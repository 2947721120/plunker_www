;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function() {
  var module;

  require("../../vendor/angular/angular");

  require("../../vendor/angular/angular-cookies");

  require("../../vendor/angular-ui/ui-bootstrap");

  require("../../vendor/angular-ui/ui-router");

  require("../services/session.coffee");

  require("../services/notifier.coffee");

  require("../services/disabler.coffee");

  require("../services/basePlunk.coffee");

  require("../services/layout.coffee");

  require("../services/updater.coffee");

  require("../services/collab.coffee");

  require("../directives/borderLayout.coffee");

  require("../directives/codeEditor.coffee");

  require("../directives/previewer.coffee");

  require("../directives/toolbar.coffee");

  module = angular.module("plunker.app.editor", ["ui.bootstrap", "ui.router", "fa.borderLayout", "plunker.service.session", "plunker.service.notifier", "plunker.service.disabler", "plunker.service.basePlunk", "plunker.service.layout", "plunker.service.updater", "plunker.service.collab", "plunker.directive.codeEditor", "plunker.directive.previewer", "plunker.directive.toolbar"]);

  module.config([
    "$stateProvider", "$urlRouterProvider", "$locationProvider", function($stateProvider, $urlRouterProvider, $locationProvider) {
      $locationProvider.html5Mode(true);
      $urlRouterProvider.when("/edit", "/edit/");
      return $urlRouterProvider.otherwise("/edit/");
    }
  ]);

  module.config([
    "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
      $stateProvider.state("editor", {
        url: "/edit",
        abstract: true,
        template: "<div ui-view=\"body\"></div>"
      });
      $stateProvider.state("editor.blank", {
        url: "/",
        views: {
          "body": {
            controller: [
              "$state", "$scope", "layout", function($state, $scope, layout) {
                return $state.go("editor.new");
              }
            ]
          }
        }
      });
      $stateProvider.state("editor.new", {
        url: "/new",
        views: {
          "body": {
            templateUrl: "/partials/editor.html",
            controller: [
              "$scope", "session", "basePlunk", "notifier", "layout", "updater", "disabler", function($scope, session, basePlunk, notifier, layout, updater, disabler) {
                var client;
                layout.current.templates.closed = false;
                client = session.createClient("edit.blank");
                return disabler.enqueue("editor", updater.update(basePlunk).then(function(json) {
                  var idx;
                  client.reset(json);
                  client.cursorSetIndex((0 <= (idx = client.getFileIndex("index.html"))) && idx || 0);
                  return notifier.success("Plunk reset");
                }));
              }
            ]
          }
        }
      });
      $stateProvider.state("editor.stream", {
        url: "/stream:{streamId:[a-z0-9]+}",
        views: {
          "body": {
            templateUrl: "/partials/editor.html",
            controller: [
              "$stateParams", "$q", "$http", "$scope", "$state", "$timeout", "collab", "notifier", "disabler", "layout", "updater", function($stateParams, $q, $http, $scope, $state, $timeout, collab, notifier, disabler, layout, updater) {
                layout.current.templates.closed = true;
                return disabler.enqueue("editor", collab.connect($stateParams.streamId).then(function(json) {
                  return notifier.success("Connected to stream");
                }, function() {
                  return notifier.error("Failed to connect to stream");
                }));
              }
            ]
          }
        }
      });
      return $stateProvider.state("editor.gist", {
        url: "/gist:{gistId:[0-9]+|[0-9a-z]{20}}",
        views: {
          "body": {
            templateUrl: "/partials/editor.html",
            controller: [
              "$stateParams", "$q", "$http", "$scope", "$state", "$timeout", "session", "notifier", "disabler", "layout", "updater", function($stateParams, $q, $http, $scope, $state, $timeout, session, notifier, disabler, layout, updater) {
                var client, parser, request;
                layout.current.templates.closed = true;
                client = session.createClient("edit.gist");
                disabler.enqueue("editor", request = $http.jsonp("https://api.github.com/gists/" + $stateParams.gistId + "?callback=JSON_CALLBACK"));
                parser = request.then(function(response) {
                  var e, file, filename, gist, json, manifest, _ref;
                  if (response.data.meta.status >= 400) {
                    return $q.reject("Gist not found");
                  }
                  gist = response.data.data;
                  json = {
                    'private': true,
                    files: []
                  };
                  if (manifest = gist.files["plunker.json"]) {
                    try {
                      angular.extend(json, angular.fromJson(manifest.content));
                    } catch (_error) {
                      e = _error;
                      notifier.warn("Unable to parse the plunker.json file");
                    }
                  }
                  json.description = gist.description || ("https://gist.github.com/" + $stateParams.gistId);
                  _ref = gist.files;
                  for (filename in _ref) {
                    file = _ref[filename];
                    if (filename !== "plunker.json") {
                      json.files.push({
                        filename: filename,
                        content: file.content
                      });
                    }
                  }
                  return updater.update(json);
                }, function(error) {
                  console.log("[ERR] Pulling gist", error);
                  return $q.reject("Unable to load gist");
                });
                return parser.then(function(json) {
                  var idx;
                  layout.current.templates.closed = true;
                  client.reset(json);
                  client.cursorSetIndex((0 <= (idx = client.getFileIndex("index.html"))) && idx || 0);
                  return notifier.success("Imported gist " + $stateParams.gistId);
                }, function(errorText) {
                  $state.go("editor.blank");
                  return notifier.error(errorText);
                });
              }
            ]
          }
        }
      });
    }
  ]);

  module.controller("SidebarController", [
    "$scope", "session", function($scope, session) {
      var client;
      $scope.session = client = session.createClient("SidebarController");
      $scope.addFile = function() {
        var filename;
        if (filename = prompt("Filename?")) {
          client.fileCreate(filename);
          return client.cursorSetFile(filename);
        }
      };
      $scope.renameFile = function(old_filename) {
        var filename;
        if (client.hasFile(old_filename) && (filename = prompt("Filename?", old_filename))) {
          return client.fileRename(old_filename, filename);
        }
      };
      $scope.removeFile = function(filename) {
        if (client.hasFile(filename) && confirm("Are you sure you would like to delete " + filename + "?")) {
          return client.fileRemove(filename);
        }
      };
      return $scope.moveTo = function(filename) {
        return client.cursorSetFile(filename);
      };
    }
  ]);

  module.controller("LayoutController", [
    "$scope", "layout", function($scope, layout) {
      $scope.layout = layout;
      return $scope.togglePreviewPane = function() {
        return $scope.showPreviewPane = !$scope.showPreviewPane;
      };
    }
  ]);

}).call(this);


},{"../../vendor/angular-ui/ui-bootstrap":19,"../../vendor/angular-ui/ui-router":20,"../../vendor/angular/angular":22,"../../vendor/angular/angular-cookies":21,"../directives/borderLayout.coffee":2,"../directives/codeEditor.coffee":3,"../directives/previewer.coffee":4,"../directives/toolbar.coffee":5,"../services/basePlunk.coffee":7,"../services/collab.coffee":8,"../services/disabler.coffee":9,"../services/layout.coffee":11,"../services/notifier.coffee":12,"../services/session.coffee":13,"../services/updater.coffee":16}],2:[function(require,module,exports){
(function() {
  var Region, module, throttle,
    __slice = [].slice;

  module = angular.module("fa.borderLayout", []);

  throttle = function(delay, fn) {
    var throttled;
    throttled = false;
    return function() {
      if (throttled) {
        return;
      }
      throttled = true;
      setTimeout(function() {
        return throttled = false;
      }, delay);
      return fn.call.apply(fn, [this].concat(__slice.call(arguments)));
    };
  };

  Region = (function() {
    function Region(width, height) {
      this.width = width != null ? width : 0;
      this.height = height != null ? height : 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
      this.left = 0;
    }

    Region.prototype.calculateSize = function(orientation, target) {
      var available, matches, terms, total;
      if (target == null) {
        target = 0;
      }
      total = this.getSize(orientation);
      available = this.getAvailableSize(orientation);
      if (angular.isNumber(target)) {
        if (target >= 1) {
          return Math.round(target);
        }
        if (target >= 0) {
          return Math.round(target * total);
        }
        return 0;
      }
      target = target.replace(/\s+/mg, "");
      if ((terms = target.split("-")).length > 1) {
        return this.calculateSize(orientation, terms.shift()) - this.calculateSize(orientation, terms.join("+"));
      }
      if ((terms = target.split("+")).length > 1) {
        return this.calculateSize(orientation, terms.shift()) + this.calculateSize(orientation, terms.join("+"));
      }
      if (matches = target.match(/^(\d+)px$/)) {
        return parseInt(matches[1], 10);
      }
      if (matches = target.match(/^(\d+(?:\.\d+)?)&$/)) {
        return Math.round(available * parseFloat(matches[1]) / 100);
      }
      if (matches = target.match(/^(\d+(?:\.\d+)?)%$/)) {
        return Math.round(total * parseFloat(matches[1]) / 100);
      }
      throw new Error("Unsupported size: " + target);
    };

    Region.prototype.consume = function(anchor, size) {
      var style;
      if (size == null) {
        size = 0;
      }
      switch (anchor) {
        case "north":
          style = {
            top: "" + this.top + "px",
            right: "" + this.right + "px",
            left: "" + this.left + "px",
            height: "" + size + "px"
          };
          this.top += size;
          break;
        case "east":
          style = {
            top: "" + this.top + "px",
            right: "" + this.right + "px",
            bottom: "" + this.bottom + "px",
            width: "" + size + "px"
          };
          this.right += size;
          break;
        case "south":
          style = {
            right: "" + this.right + "px",
            bottom: "" + this.bottom + "px",
            left: "" + this.left + "px",
            height: "" + size + "px"
          };
          this.bottom += size;
          break;
        case "west":
          style = {
            top: "" + this.top + "px",
            bottom: "" + this.bottom + "px",
            left: "" + this.left + "px",
            width: "" + size + "px"
          };
          this.left += size;
      }
      return style;
    };

    Region.prototype.getInnerRegion = function() {
      return new Region(this.width - this.right - this.left, this.height - this.top - this.bottom);
    };

    Region.prototype.getSize = function(orientation) {
      switch (orientation) {
        case "vertical":
          return this.height;
        case "horizontal":
          return this.width;
      }
    };

    Region.prototype.getAvailableSize = function(orientation) {
      switch (orientation) {
        case "vertical":
          return this.height - this.top - this.bottom;
        case "horizontal":
          return this.width - this.right - this.left;
      }
    };

    return Region;

  })();

  module.directive("pane", [
    function() {
      return {
        restrict: "E",
        replace: true,
        require: ["pane", "^borderLayout"],
        transclude: true,
        scope: true,
        template: "<div class=\"border-layout-pane\">\n  <div class=\"border-layout-pane-overlay\" ng-style=\"styleContent\"></div>\n  <div class=\"border-layout-pane-handle\" layout-handle ng-style=\"styleHandle\"></div>\n  <div class=\"border-layout-pane-scroller\" ng-style=\"styleContent\" ng-transclude></div>\n</div>",
        controller: [
          "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            var $handle, $overlay, $scroller, pane, _ref;
            pane = this;
            _ref = $element.children(), $overlay = _ref[0], $handle = _ref[1], $scroller = _ref[2];
            $scope.$watch($attrs.options, function(options, oldOptions) {
              if (options) {
                pane.anchor = options.anchor || "center";
                pane.orientation = pane.getOrientation(pane.anchor);
                pane.target = options.size;
                pane.max = options.max || Number.MAX_VALUE;
                pane.min = options.min || 0;
                pane.open = !options.closed;
                pane.order = parseInt(options.order || 0, 10);
                pane.handleSize = parseInt(options.handle || 0, 10);
                return pane.layout.reflow();
              }
            }, true);
            this.children = [];
            this.openSize = 0;
            this.attachChild = function(child) {
              return this.children.push(child);
            };
            this.getOrientation = function(anchor) {
              if (anchor == null) {
                anchor = pane.anchor;
              }
              switch (anchor) {
                case "north":
                case "south":
                  return "vertical";
                case "east":
                case "west":
                  return "horizontal";
              }
            };
            this.getContentStyle = function(anchor, handleSize) {
              var style;
              style = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              };
              switch (anchor) {
                case "north":
                  style.bottom = "" + handleSize + "px";
                  break;
                case "east":
                  style.left = "" + handleSize + "px";
                  break;
                case "south":
                  style.top = "" + handleSize + "px";
                  break;
                case "west":
                  style.right = "" + handleSize + "px";
              }
              return style;
            };
            this.getHandleStyle = function(anchor, region, handleSize) {
              switch (anchor) {
                case "north":
                  return {
                    height: "" + (region.calculateSize('vertical', handleSize)) + "px",
                    right: 0,
                    left: 0,
                    bottom: 0
                  };
                case "south":
                  return {
                    height: "" + (region.calculateSize('vertical', handleSize)) + "px",
                    right: 0,
                    left: 0,
                    top: 0
                  };
                case "east":
                  return {
                    width: "" + (region.calculateSize('horizontal', handleSize)) + "px",
                    top: 0,
                    bottom: 0,
                    left: 0
                  };
                case "west":
                  return {
                    width: "" + (region.calculateSize('horizontal', handleSize)) + "px",
                    top: 0,
                    bottom: 0,
                    right: 0
                  };
              }
            };
            this.onHandleDown = function() {
              $element.addClass("active");
              return this.layout.onHandleDown();
            };
            this.onHandleUp = function() {
              $element.removeClass("active");
              return this.layout.onHandleUp();
            };
            this.toggle = function(open) {
              if (open == null) {
                open = !pane.open;
              }
              pane.open = open;
              if (!open) {
                this.openSize = this.size;
              } else {
                this.size = this.openSize;
              }
              if (open) {
                $element.removeClass("closed");
              } else {
                $element.addClass("closed");
              }
              return this.layout.reflow();
            };
            this.reflow = function(region, target) {
              var anchor, child, handleSize, inner, orientation, size, styleContainer, styleContent, styleHandle, _i, _len, _ref1;
              if (target == null) {
                target = pane.target;
              }
              anchor = pane.anchor;
              if (open) {
                $element.removeClass("closed");
              } else {
                $element.addClass("closed");
              }
              if (anchor === "center") {
                $element.css({
                  top: "" + region.top + "px",
                  right: "" + region.right + "px",
                  bottom: "" + region.bottom + "px",
                  left: "" + region.left + "px"
                });
              } else if (anchor === "north" || anchor === "east" || anchor === "south" || anchor === "west") {
                orientation = this.getOrientation(anchor);
                handleSize = region.calculateSize(orientation, pane.handleSize || 0);
                if (!pane.open) {
                  size = handleSize;
                } else {
                  size = region.calculateSize(orientation, target);
                  size = Math.min(size, region.calculateSize(orientation, pane.max));
                  size = Math.max(size, region.calculateSize(orientation, pane.min));
                  size = Math.min(size, region.getAvailableSize(orientation));
                  size = Math.max(size, handleSize + 2);
                }
                this.size = size;
                styleContainer = region.consume(anchor, size);
                styleContent = this.getContentStyle(anchor, handleSize);
                styleHandle = this.getHandleStyle(anchor, region, handleSize);
                $element.attr("style", "").css(styleContainer);
                angular.element($overlay).attr("style", "").css(styleContent);
                angular.element($scroller).attr("style", "").css(styleContent);
                angular.element($handle).attr("style", "").css(styleHandle);
              }
              if (this.children.length) {
                inner = region.getInnerRegion();
                _ref1 = this.children;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  child = _ref1[_i];
                  inner = child.reflow(inner);
                }
              }
              return region;
            };
            return this.resize = function(target) {
              pane.target = target || 0;
              return this.layout.reflow();
            };
          }
        ],
        link: function($scope, $el, $attrs, _arg) {
          var pane, parent;
          pane = _arg[0], parent = _arg[1];
          pane.layout = parent;
          parent.attachChild(pane);
          $scope.$$nextSibling.pane = pane;
          return $scope.$watch("constrained", function(constrained) {
            if (constrained) {
              return $el.addClass("border-layout-constrained");
            } else {
              return $el.removeClass("border-layout-constrained");
            }
          });
        }
      };
    }
  ]);

  module.directive("layoutHandle", [
    "$window", function($window) {
      return {
        restrict: "A",
        require: ["?^pane", "^?borderLayout"],
        link: function($scope, $element, $attrs, _arg) {
          var clickRadius, clickTime, el, layout, pane;
          pane = _arg[0], layout = _arg[1];
          if (!pane) {
            return;
          }
          el = $element[0];
          clickRadius = 5;
          clickTime = 300;
          $scope.$watch((function() {
            return pane.getOrientation();
          }), function(orientation) {
            $element.removeClass("vertical");
            $element.removeClass("horizontal");
            switch (orientation) {
              case "vertical":
                return $element.addClass("vertical");
              case "horizontal":
                return $element.addClass("horizontal");
            }
          });
          return el.addEventListener("mousedown", function(e) {
            var anchor, coord, handleClick, handleMouseMove, handleMouseMoveThrottled, handleMouseUp, scale, startCoord, startPos, startSize, startTime;
            if (e.button !== 0) {
              return;
            }
            anchor = pane.anchor;
            if (anchor === "north" || anchor === "south") {
              coord = "screenY";
            } else if (anchor === "west" || anchor === "east") {
              coord = "screenX";
            }
            if (anchor === "north" || anchor === "west") {
              scale = 1;
            } else if (anchor === "south" || anchor === "east") {
              scale = -1;
            }
            startPos = {
              x: e.screenX,
              y: e.screenY
            };
            startCoord = e[coord];
            startSize = pane.size;
            startTime = Date.now();
            pane.onHandleDown();
            el.unselectable = "on";
            el.onselectstart = function() {
              return false;
            };
            el.style.userSelect = el.style.MozUserSelect = "none";
            e.preventDefault();
            e.defaultPrevented = true;
            e = null;
            handleClick = function(e) {
              return $scope.$apply(function() {
                return pane.toggle();
              });
            };
            handleMouseMove = function(e) {
              $element.addClass("border-layout-pane-moving");
              $scope.$apply(function() {
                var targetSize;
                return pane.resize(targetSize = startSize + scale * (e[coord] - startCoord));
              });
              e.preventDefault();
              e.defaultPrevented = true;
              return e = null;
            };
            handleMouseUp = function(e) {
              var cleanup, displacementSq, timeElapsed;
              displacementSq = Math.pow(e.screenX - startPos.x, 2) + Math.pow(e.screenY - startPos.y, 2);
              timeElapsed = Date.now() - startTime;
              $window.removeEventListener("mousemove", handleMouseMoveThrottled, true);
              $window.removeEventListener("mouseup", handleMouseUp, true);
              cleanup = function() {
                e.preventDefault();
                e.defaultPrevented = true;
                e = null;
                return pane.onHandleUp();
              };
              if (displacementSq <= Math.pow(clickRadius, 2) && timeElapsed <= clickTime) {
                handleClick(e);
                cleanup();
                return;
              }
              handleMouseMove(e);
              return cleanup();
            };
            handleMouseMoveThrottled = throttle(10, handleMouseMove);
            $window.addEventListener("mousemove", handleMouseMoveThrottled, true);
            return $window.addEventListener("mouseup", handleMouseUp, true);
          });
        }
      };
    }
  ]);

  module.directive("borderLayout", [
    "$window", "$timeout", function($window, $timeout) {
      return {
        restrict: "E",
        replace: true,
        require: ["borderLayout", "^?pane"],
        transclude: true,
        template: "<div class=\"border-layout\" ng-transclude>\n</div>",
        controller: [
          "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            var layout;
            layout = this;
            this.children = [];
            this.attachChild = function(child) {
              return this.children.push(child);
            };
            this.onHandleDown = function() {
              return $element.addClass("active");
            };
            this.onHandleUp = function() {
              $element.removeClass("active");
              return $scope.$broadcast("border-layout-reflow");
            };
            return this.reflow = function(region) {
              var child, height, width, _i, _len, _ref;
              if (layout.reflowing) {
                return;
              }
              layout.reflowing = true;
              width = $element[0].offsetWidth;
              height = $element[0].offsetHeight;
              region || (region = new Region(width, height));
              this.children.sort(function(a, b) {
                return b.order - a.order;
              });
              _ref = this.children;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                child = _ref[_i];
                region = child.reflow(region);
              }
              $scope.$broadcast("border-layout-reflow", Date.now());
              return layout.reflowing = false;
            };
          }
        ],
        link: function($scope, $el, $attrs, _arg) {
          var layout, parent;
          layout = _arg[0], parent = _arg[1];
          if (parent) {
            parent.attachChild(layout);
          }
          $scope.$on("border-layout-reflow", function() {
            if (!parent) {
              return layout.reflow();
            }
          });
          $window.addEventListener("resize", function(e) {
            e.stopPropagation();
            return $scope.$apply(function() {
              return layout.reflow();
            });
          });
          return $timeout(function() {
            if (!parent) {
              return layout.reflow();
            }
          });
        }
      };
    }
  ]);

}).call(this);


},{}],3:[function(require,module,exports){
(function() {
  var module;

  require("../services/session.coffee");

  require("../services/types.coffee");

  require("../services/settings.coffee");

  require("../services/annotations.coffee");

  module = angular.module("plunker.directive.codeEditor", ["plunker.service.session", "plunker.service.types", "plunker.service.settings", "plunker.service.annotations"]);

  module.directive("codeEditor", [
    "$rootScope", "$timeout", "session", "types", "settings", "annotations", function($rootScope, $timeout, session, types, settings, annotations) {
      var AceEditor, EditSession, Range, Renderer, UndoManager, config;
      AceEditor = ace.require("ace/editor").Editor;
      Renderer = ace.require("ace/virtual_renderer").VirtualRenderer;
      EditSession = ace.require("ace/edit_session").EditSession;
      UndoManager = ace.require("ace/undomanager").UndoManager;
      Range = ace.require("ace/range").Range;
      config = ace.require("ace/config");
      return {
        restrict: "E",
        replace: true,
        scope: {
          active: "="
        },
        template: "<div class=\"code-editor\">\n</div>",
        link: function($scope, $el, attrs) {
          var activateBuffer, addAceSession, buffers, changeSessionMode, client, editor, guessMode, moveCursor, removeAceSession, reset, snippetManager;
          editor = new AceEditor(new Renderer($el[0], "ace/theme/" + settings.editor.theme));
          client = session.createClient("code-editor");
          snippetManager = null;
          buffers = [];
          ace.config.loadModule("ace/ext/language_tools", function() {
            editor.setOptions({
              enableBasicAutocompletion: true,
              enableSnippets: true
            });
            return snippetManager = ace.require("ace/snippets").snippetManager;
          });
          $scope.$watch((function() {
            return settings.editor.theme;
          }), function(theme) {
            if (theme) {
              return editor.setTheme("ace/theme/" + theme);
            }
          });
          guessMode = function(filename) {
            return "ace/mode/" + types.getByFilename(filename).name;
          };
          activateBuffer = function(index) {
            editor.setSession(buffers[index]);
            return editor.focus();
          };
          moveCursor = function(offset) {
            var doc;
            doc = editor.session.doc;
            return editor.moveCursorToPosition(doc.indexToPosition(offset));
          };
          addAceSession = function(index, file) {
            var aceSession, doc, handleChangeAnnotationEvent, handleChangeEvent;
            aceSession = new EditSession(file.content || "");
            aceSession.setUndoManager(new UndoManager());
            aceSession.setUseWorker(true);
            aceSession.setTabSize(settings.editor.tab_size);
            aceSession.setUseWrapMode(!!settings.editor.wrap.enabled);
            aceSession.setWrapLimitRange(settings.editor.wrap.range.min, settings.editor.wrap.range.max);
            aceSession.setMode(guessMode(file.filename));
            doc = aceSession.getDocument();
            handleChangeEvent = function(e) {
              if (!$rootScope.$$phase) {
                return $scope.$apply(function() {
                  var nl;
                  nl = doc.getNewLineCharacter();
                  switch (e.data.action) {
                    case "insertText":
                      return client.textInsert(file.filename, doc.positionToIndex(e.data.range.start), e.data.text);
                    case "insertLines":
                      return client.textInsert(file.filename, doc.positionToIndex(e.data.range.start), e.data.lines.join(nl) + nl);
                    case "removeText":
                      return client.textRemove(file.filename, doc.positionToIndex(e.data.range.start), e.data.text);
                    case "removeLines":
                      return client.textRemove(file.filename, doc.positionToIndex(e.data.range.start), e.data.lines.join(nl) + nl);
                  }
                });
              }
            };
            handleChangeAnnotationEvent = function(e) {
              if (!$rootScope.$$phase) {
                return $scope.$apply(function() {
                  var idx;
                  if ((idx = client.getFileIndex(file.filename)) < 0) {
                    throw new Error("Buffers and session are out of sync for: " + file.filename);
                  }
                  annotations.update(file.filename, aceSession.getAnnotations());
                  return $rootScope.$broadcast("updateAnnotatinos", file, aceSession.getAnnotations());
                });
              }
            };
            buffers[index] = aceSession;
            annotations.update(file.filename, aceSession.getAnnotations());
            aceSession.on("change", handleChangeEvent);
            aceSession.on("changeAnnotation", handleChangeAnnotationEvent);
            return aceSession.destroy = function() {
              aceSession.off("change", handleChangeEvent);
              return aceSession.off("changeAnnotation", handleChangeAnnotationEvent);
            };
          };
          removeAceSession = function(index) {
            var file;
            if (!buffers[index]) {
              debugger;
            }
            buffers[index].destroy();
            buffers.splice(index, 1);
            if (file = client.getFileByIndex(index)) {
              return annotations.remove(file.filename);
            }
          };
          reset = function(snapshot) {
            var file, idx, _i, _j, _len, _ref, _ref1;
            for (idx = _i = _ref = buffers.length - 1; _i >= 0; idx = _i += -1) {
              removeAceSession(idx);
            }
            _ref1 = snapshot.files;
            for (idx = _j = 0, _len = _ref1.length; _j < _len; idx = ++_j) {
              file = _ref1[idx];
              addAceSession(idx, file);
            }
            return activateBuffer(snapshot.cursor.fileIndex);
          };
          changeSessionMode = function(index, filename) {
            var buffer;
            if (buffer = buffers[index]) {
              return buffer.setMode(guessMode(filename));
            }
          };
          client.on("reset", function(e, snapshot) {
            return reset(e.snapshot);
          });
          client.on("cursorSetFile", function(e, snapshot) {
            return activateBuffer(e.index);
          });
          client.on("cursorSetOffset", function(e, snapshot) {
            return moveCursor(e.offset);
          });
          client.on("fileCreate", function(e, snapshot) {
            return addAceSession(e.index, snapshot.files[e.index]);
          });
          client.on("fileRemove", function(e, snapshot) {
            removeAceSession(e.index);
            return annotations.remove(e.filename);
          });
          client.on("fileRename", function(e, snapshot) {
            changeSessionMode(e.index, e.filename);
            return annotations.rename(e.filename, e.old_filename);
          });
          client.on("textInsert", function(e, snapshot) {
            var aceSession;
            if (!(aceSession = buffers[e.index])) {
              throw new Error("Received textInsert event for a file not being tracked");
            }
            return aceSession.doc.insert(aceSession.doc.indexToPosition(e.offset), e.text);
          });
          client.on("textRemove", function(e, snapshot) {
            var aceSession;
            if (!(aceSession = buffers[e.index])) {
              throw new Error("Received textInsert event for a file not being tracked");
            }
            return aceSession.doc.remove(Range.fromPoints(aceSession.doc.indexToPosition(e.offset), aceSession.doc.indexToPosition(e.offset + e.text.length)));
          });
          reset(client.getSnapshot());
          activateBuffer(client.getCursorFileIndex());
          moveCursor(client.getCursorTextOffset());
          $scope.$on("border-layout-reflow", function() {
            return editor.resize();
          });
          return $timeout(function() {
            return editor.resize();
          }, 100);
        }
      };
    }
  ]);

}).call(this);


},{"../services/annotations.coffee":6,"../services/session.coffee":13,"../services/settings.coffee":14,"../services/types.coffee":15}],4:[function(require,module,exports){
(function() {
  var debounce, genid, module;

  genid = require("genid");

  debounce = require("lodash.debounce");

  require("../../vendor/operative.js");

  require("../services/session.coffee");

  require("../services/types.coffee");

  require("../services/url.coffee");

  require("../services/settings.coffee");

  require("../services/annotations.coffee");

  require("../services/layout.coffee");

  module = angular.module("plunker.directive.previewer", ["plunker.service.session", "plunker.service.url", "plunker.service.settings", "plunker.service.annotations", "plunker.service.layout"]);

  module.directive("previewer", [
    "$timeout", "session", "url", "settings", "annotations", "layout", function($timeout, session, url, settings, annotations, layout) {
      return {
        restrict: "E",
        replace: true,
        scope: {
          session: "="
        },
        template: "<div>\n  <div class=\"plunker-preview-container\" ng-class=\"{message: message}\">\n    <iframe id=\"plunkerPreviewTarget\" name=\"plunkerPreviewTarget\" src=\"about:blank\" width=\"100%\" height=\"100%\" frameborder=\"0\"></iframe>\n  </div>\n  <div class=\"plunker-preview-message alert alert-danger\" ng-show=\"message\">\n    <button type=\"button\" class=\"close\" ng-click=\"message=''\" aria-hidden=\"true\">&times;</button>\n    <span ng-bind=\"message\"></span>\n  </div>\n</div>",
        link: function($scope, $el, attrs) {
          var applyRefresh, client, debouncedApplyRefresh, firstOpen, iframeEl, refresh;
          $scope.previewUrl || ($scope.previewUrl = "" + url.run + "/" + (genid()) + "/");
          iframeEl = document.getElementById("plunkerPreviewTarget");
          client = session.createClient("previewer");
          firstOpen = true;
          refresh = function(snapshot) {
            var field, file, filename, form, _i, _len, _ref;
            if (layout.current.preview.closed) {
              return;
            }
            if (filename = annotations.hasError()) {
              $scope.message = "Preview has not been updated due to syntax errors in " + filename;
              return;
            } else {
              $scope.message = "";
            }
            form = document.createElement("form");
            form.style.display = "none";
            form.setAttribute("method", "post");
            form.setAttribute("action", $scope.previewUrl);
            form.setAttribute("target", "plunkerPreviewTarget");
            _ref = snapshot.files;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              file = _ref[_i];
              field = document.createElement("input");
              field.setAttribute("type", "hidden");
              field.setAttribute("name", "files[" + file.filename + "][content]");
              field.setAttribute("value", file.content);
              form.appendChild(field);
            }
            document.body.appendChild(form);
            form.submit();
            return document.body.removeChild(form);
          };
          applyRefresh = function() {
            return $scope.$apply(function() {
              return refresh(client.getSnapshot());
            });
          };
          debouncedApplyRefresh = debounce(applyRefresh, settings.previewer.delay);
          $scope.$watch((function() {
            return settings.previewer.delay;
          }), function(delay, oldDelay) {
            if (delay !== oldDelay) {
              return debouncedApplyRefresh = debounce(debouncedApplyRefresh, delay);
            }
          });
          $scope.$watch((function() {
            return layout.current.preview.closed;
          }), function(closed, wasClosed) {
            if (closed) {
              iframeEl.contentWindow.location = "about:blank";
            } else if (firstOpen || wasClosed) {
              refresh(client.getSnapshot());
            }
            return firstOpen = false;
          });
          client.on("reset", debouncedApplyRefresh);
          client.on("fileCreate", debouncedApplyRefresh);
          client.on("fileRename", debouncedApplyRefresh);
          client.on("fileRemove", debouncedApplyRefresh);
          client.on("textInsert", debouncedApplyRefresh);
          client.on("textRemove", debouncedApplyRefresh);
          return $scope.$on("$destroy", function() {
            client.off("reset", debouncedApplyRefresh);
            client.off("fileCreate", debouncedApplyRefresh);
            client.off("fileRename", debouncedApplyRefresh);
            client.off("fileRemove", debouncedApplyRefresh);
            client.off("textInsert", debouncedApplyRefresh);
            return client.off("textRemove", debouncedApplyRefresh);
          });
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/operative.js":24,"../services/annotations.coffee":6,"../services/layout.coffee":11,"../services/session.coffee":13,"../services/settings.coffee":14,"../services/types.coffee":15,"../services/url.coffee":17,"genid":27,"lodash.debounce":28}],5:[function(require,module,exports){
(function() {
  var module;

  require("../../vendor/angular-ui/ui-bootstrap");

  require("../services/notifier.coffee");

  require("../services/layout.coffee");

  module = angular.module("plunker.directive.toolbar", ["ui.bootstrap", "plunker.service.notifier", "plunker.service.layout"]);

  module.directive("plunkerToolbar", [
    "$state", "session", "notifier", "layout", function($state, session, notifier, layout) {
      return {
        restrict: "E",
        replace: true,
        scope: true,
        template: "<div class=\"plunker-editor-toolbar\">\n  <div class=\"pull-left\">\n    <button class=\"btn btn-sm btn-primary\" ng-click=\"save()\">\n      Save\n    </button>\n    \n    <button class=\"btn btn-sm btn-success\" ui-sref=\"editor.blank\">\n      New\n    </button>\n    \n    <button class=\"btn btn-sm btn-info\" ng-class=\"{active: !layout.current.preview.closed}\" ng-click=\"layout.current.preview.closed = !!!layout.current.preview.closed\">\n      Preview\n    </button>\n  </div>\n  <div class=\"pull-right\">\n    <div class=\"btn-group btn-sm\" ng-controller=\"LayoutController\">\n      <button class=\"btn btn-sm btn-default\" ng-click=\"layout.setLayout($index)\" ng-repeat=\"preset in layout.presets\" ng-bind=\"$index\" tooltip=\"{{preset.name}}\" tooltip-append-to-body=\"true\" tooltip-placement=\"bottom\"></button>\n    </div>\n  </div>\n</div>",
        link: function($scope, $element, $attrs) {
          var client;
          client = session.createClient("directive.toolbar");
          return $scope.save = function() {
            return notifier.warn("Save not implemented... yet");
          };
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/angular-ui/ui-bootstrap":19,"../services/layout.coffee":11,"../services/notifier.coffee":12}],6:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.annotations", []);

  module.factory("annotations", function() {
    return {
      annotations: {},
      update: function(filename, annotations) {
        var _base;
        if (annotations == null) {
          annotations = [];
        }
        return angular.copy(annotations, ((_base = this.annotations)[filename] || (_base[filename] = [])));
      },
      rename: function(old_filename, new_filename) {
        this.annotations[new_filename] = this.annotations[old_filename] || [];
        return delete this.annotations[old_filename];
      },
      remove: function(filename) {
        return delete this.annotations[filename];
      },
      hasError: function() {
        var annotation, annotations, filename, _i, _len, _ref;
        _ref = this.annotations;
        for (filename in _ref) {
          annotations = _ref[filename];
          for (_i = 0, _len = annotations.length; _i < _len; _i++) {
            annotation = annotations[_i];
            if (annotation.type === "error") {
              return filename;
            }
          }
        }
        return false;
      }
    };
  });

}).call(this);


},{}],7:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.basePlunk", []);

  module.value("basePlunk", {
    files: [
      {
        filename: "index.html",
        content: "<!doctype html>\n<html ng-app=\"plunker\" >\n<head>\n  <meta charset=\"utf-8\">\n  <title>AngularJS Plunker</title>\n  <script>document.write('<base href=\"' + document.location + '\" />');</script>\n  <link rel=\"stylesheet\" href=\"style.css\">\n  <script data-require=\"angular.js@1.1.x\" src=\"http://code.angularjs.org/1.1.4/angular.js\"></script>\n  <script src=\"app.js\"></script>\n</head>\n<body ng-controller=\"MainCtrl\">\n  <p>Hello {{name}}!</p>\n</body>\n</html> "
      }, {
        filename: "app.js",
        content: "var app = angular.module('plunker', []);\n \napp.controller('MainCtrl', function($scope) {\n  $scope.name = 'World';\n});"
      }, {
        filename: "style.css",
        content: "p {\n  color: red;\n}"
      }
    ]
  });

}).call(this);


},{}],8:[function(require,module,exports){
(function() {
  var browserchannel, module,
    __slice = [].slice;

  browserchannel = require("../../vendor/share/bcsocket-uncompressed.js");

  require("../../vendor/share/share.uncompressed.js");

  require("../services/session.coffee");

  module = angular.module("plunker.service.collab", ["plunker.service.session"]);

  module.factory("collab", [
    "$rootScope", "$q", "session", function($rootScope, $q, session) {
      var client, share, socket;
      console.log("Browserchannel", browserchannel);
      socket = browserchannel.BCSocket(null, {
        reconnect: true
      });
      share = new window.sharejs.Connection(socket);
      client = session.createClient("share");
      return {
        connect: function(sessionId) {
          var dfd, doc;
          dfd = $q.defer();
          doc = share.getOrCreate("json_test", sessionId);
          doc.subscribe();
          doc.whenReady(function() {
            return $rootScope.$apply(function() {
              var snapshot;
              if (!doc.type) {
                doc.create("json0", snapshot = client.getSnapshot(), function() {
                  return dfd.resolve(snapshot);
                });
              } else {
                client.reset(snapshot = doc.getSnapshot());
                dfd.resolve(snapshot);
              }
              return client.on("remoteOp", function(e) {
                return doc.submitOp(e.op);
              });
            });
          });
          doc.on("op", function(op) {
            if (!$rootScope.$$phase) {
              return $rootScope.$apply(function() {
                console.log.apply(console, ["Remoteop"].concat(__slice.call(arguments)));
                return client._applyOps(op);
              });
            }
          });
          return dfd.promise;
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/share/bcsocket-uncompressed.js":25,"../../vendor/share/share.uncompressed.js":26,"../services/session.coffee":13}],9:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.disabler", []);

  module.directive("plunkerDisabler", [
    "disabler", function(disabler) {
      return {
        link: function($scope, $element, $attrs) {
          var mask;
          mask = angular.element("<div class=\"plunker-disabler\"></div>");
          return $scope.$watch((function() {
            return disabler.state[$attrs.plunkerDisabler];
          }), function(state, prev) {
            if (state) {
              return $element.append(mask);
            } else {
              return mask.remove();
            }
          });
        }
      };
    }
  ]);

  module.service("disabler", [
    "$q", function($q) {
      var queues;
      queues = {};
      this.state = {};
      return this.enqueue = function(name, valueOrPromise) {
        var disabler;
        disabler = this;
        disabler.state[name] = true;
        return $q.when(valueOrPromise)["finally"](function() {
          return disabler.state[name] = false;
        });
      };
    }
  ]);

}).call(this);


},{}],10:[function(require,module,exports){
(function() {
  var dominatrix, module;

  dominatrix = require("../../vendor/dominatrix/dominatrix");

  module = angular.module("plunker.service.htmlFile", []);

  module.factory("htmlFile", [
    "$q", function($q) {
      var HtmlFile;
      HtmlFile = (function() {
        function HtmlFile(markup) {
          this.markup = markup;
          this.doc = window.document.implementation.createHTMLDocument("");
          this.doc.open();
          this.doc.write(this.markup);
        }

        HtmlFile.prototype.toString = function() {
          return dominatrix.domToHtml(this.doc);
        };

        return HtmlFile;

      })();
      return {
        parse: function(markup) {
          return new HtmlFile(markup);
        },
        update: function(markup) {
          var dfd;
          dfd = $q.defer();
          dfd.resolve(this.parse(markup).toString());
          return dfd.promise;
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/dominatrix/dominatrix":23}],11:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.layout", []);

  module.factory("layout", [
    "$rootScope", function($rootScope) {
      var presets, service;
      presets = [
        {
          name: "Preview on the right",
          layout: {
            toolbar: {
              anchor: "north",
              size: "41px",
              order: 9
            },
            preview: {
              anchor: "east",
              order: 0,
              size: "50& - 4px",
              handle: 4
            },
            templates: {
              anchor: "west",
              order: 2,
              size: "300px"
            }
          }
        }, {
          name: "Preview at the bottom",
          layout: {
            toolbar: {
              anchor: "north",
              size: "41px",
              order: 9
            },
            preview: {
              anchor: "south",
              order: 2,
              size: "40% - 4px",
              handle: 4
            },
            templates: {
              anchor: "west",
              order: 2,
              size: "300px"
            }
          }
        }
      ];
      service = {
        current: {},
        presets: presets,
        isOpen: function(paneId) {
          var _ref, _ref1;
          return (_ref = this.current) != null ? (_ref1 = _ref.layout) != null ? _ref1[paneId].open : void 0 : void 0;
        },
        toggle: function(paneId) {
          var _ref, _ref1;
          return (_ref = this.current) != null ? (_ref1 = _ref.layout) != null ? _ref1[paneId].open = !this.current.layout[paneId].open : void 0 : void 0;
        },
        setLayout: function(idx) {
          var config, item, preset, _ref;
          if (preset = presets[idx]) {
            _ref = preset.layout;
            for (item in _ref) {
              config = _ref[item];
              this.current[item] = angular.extend(this.current[item] || {}, config);
            }
            $rootScope.$broadcast("reflow");
          }
          return this.current;
        }
      };
      service.setLayout(0);
      return service;
    }
  ]);

}).call(this);


},{}],12:[function(require,module,exports){
(function() {
  var module,
    __slice = [].slice;

  require("../../vendor/angular-growl/angular-growl");

  module = angular.module("plunker.service.notifier", ["angular-growl"]);

  module.config([
    "growlProvider", function(growlProvider) {
      return growlProvider.globalTimeToLive(3000);
    }
  ]);

  module.factory("notifier", [
    "growl", function(growl) {
      return {
        error: function(message) {
          console.log.apply(console, ["[ERR]"].concat(__slice.call(arguments)));
          return growl.addErrorMessage(message);
        },
        warn: function(message) {
          console.log.apply(console, ["[WARN]"].concat(__slice.call(arguments)));
          return growl.addWarnMessage(message);
        },
        success: function(message) {
          console.log.apply(console, ["[OK]"].concat(__slice.call(arguments)));
          return growl.addSuccessMessage(message);
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/angular-growl/angular-growl":18}],13:[function(require,module,exports){
(function() {
  var Session, module;

  require("share/webclient/share.uncompressed.js");

  module = angular.module("plunker.service.session", []);

  module.service("session", Session = (function() {
    var SessionClient;

    SessionClient = (function() {
      function SessionClient(name, session) {
        this.name = name;
        this.session = session;
        this.listeners = {};
      }

      SessionClient.prototype.on = function(eventName, listener) {
        var _base;
        return ((_base = this.listeners)[eventName] || (_base[eventName] = [])).push(listener);
      };

      SessionClient.prototype.off = function(eventName, listener) {
        var idx;
        if (!(!this.listeners[eventName] || 0 > (idx = this.listeners[eventName].indexOf(listener)))) {
          return this.listeners[eventName].splice(idx, 1);
        }
      };

      SessionClient.prototype._applyOp = function(op) {
        return this._applyOps([op]);
      };

      SessionClient.prototype._applyOps = function(ops) {
        return this.session.applyOps(this.name, ops);
      };

      SessionClient.prototype._handleOp = function(sourceClientName, op, snapshot) {
        var filename;
        if (op.p.length === 0) {
          console.log("Reset");
          this._emit("reset", {
            snapshot: op.oi,
            old_snapshot: op.od
          });
        } else {
          switch (op.p[0]) {
            case "cursor":
              if (op.p[1] === "fileIndex") {
                this._emit("cursorSetFile", {
                  filename: snapshot.files[op.oi].filename,
                  prev_filename: snapshot.files[op.od].filename,
                  index: op.oi,
                  prev_index: op.od
                });
              } else if (op.p[1] === "textOffset") {
                this._emit("cursorSetOffset", {
                  offset: op.oi,
                  prev_offset: op.od
                });
              }
              break;
            case "description":
              if (op.p[1] !== 0) {
                return;
              }
              if (!(op.si && op.sd)) {
                return;
              }
              this._emit("setDescription", {
                description: op.si,
                old_description: op.sd
              });
              break;
            case "tags":
              if (!(op.li || op.ld)) {
                return;
              }
              if (op.p.length !== 2) {
                return;
              }
              if (op.li) {
                this._emit("tagAdd", {
                  tagName: op.li,
                  index: op.p[1]
                });
              } else if (op.ld) {
                this._emit("tagRemove", {
                  tagName: op.ld,
                  index: op.p[2]
                });
              }
              break;
            case "files":
              if (op.p.length === 2) {
                if (op.li) {
                  this._emit("fileCreate", {
                    filename: op.li.filename,
                    index: op.p[1],
                    content: op.li.content
                  });
                } else if (op.ld) {
                  this._emit("fileRemove", {
                    filename: op.ld.filename,
                    index: op.p[1],
                    content: op.ld.content
                  });
                }
              } else if (op.p[2] === "filename") {
                this._emit("fileRename", {
                  filename: op.oi,
                  index: op.p[1],
                  old_filename: op.od
                });
              } else if (op.p[2] === "content") {
                filename = snapshot.files[op.p[1]].filename;
                if (op.si) {
                  this._emit("textInsert", {
                    filename: filename,
                    index: op.p[1],
                    text: op.si,
                    offset: op.p[3]
                  });
                }
                if (op.sd) {
                  this._emit("textRemove", {
                    filename: filename,
                    index: op.p[1],
                    text: op.sd,
                    offset: op.p[3]
                  });
                }
              }
          }
        }
        return this._emit("remoteOp", {
          op: op,
          snapshot: snapshot
        });
      };

      SessionClient.prototype._emit = function(eventName, e) {
        var listener, snapshot, _i, _len, _ref, _results;
        snapshot = this.getSnapshot();
        e.eventName = eventName;
        if (this.listeners[eventName]) {
          _ref = this.listeners[eventName];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            listener = _ref[_i];
            _results.push(listener(e, snapshot));
          }
          return _results;
        }
      };

      SessionClient.prototype.getCursorFileIndex = function() {
        return this.session.snapshot.cursor.fileIndex;
      };

      SessionClient.prototype.getCursorTextOffset = function() {
        return this.session.snapshot.cursor.textOffset;
      };

      SessionClient.prototype.getDescription = function() {
        return this.session.snapshot.description;
      };

      SessionClient.prototype.getFileIndex = function(filename) {
        var file, idx, _i, _len, _ref;
        _ref = this.session.snapshot.files;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          file = _ref[idx];
          if (file.filename === filename) {
            return idx;
          }
        }
        return -1;
      };

      SessionClient.prototype.getFileByIndex = function(idx) {
        if (angular.isString(idx)) {
          idx = this.getFileIndex(idx);
        }
        return this.session.snapshot.files[idx];
      };

      SessionClient.prototype.getFile = function(filename) {
        var file, _i, _len, _ref;
        _ref = this.session.snapshot.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (file.filename === filename) {
            return file;
          }
        }
      };

      SessionClient.prototype.getNumFiles = function() {
        var _ref;
        return ((_ref = this.session.snapshot.files) != null ? _ref.length : void 0) || 0;
      };

      SessionClient.prototype.getNumTags = function() {
        var _ref;
        return ((_ref = this.session.snapshot.tags) != null ? _ref.length : void 0) || 0;
      };

      SessionClient.prototype.getSnapshot = function() {
        return this.session.snapshot;
      };

      SessionClient.prototype.getTagIndex = function(tagName) {
        var idx, tag, _i, _len, _ref;
        _ref = this.session.snapshot.tags;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          tag = _ref[idx];
          if (tag === tagName) {
            return idx;
          }
        }
        return -1;
      };

      SessionClient.prototype.hasFile = function(filename) {
        return this.getFileIndex(filename) >= 0;
      };

      SessionClient.prototype.hasFileIndex = function(idx) {
        return this.getFileByIndex(idx) != null;
      };

      SessionClient.prototype.hasTag = function(tagName) {
        return this.getTagIndex(tagName) >= 0;
      };

      SessionClient.prototype.isValidTag = function(tagName) {
        return /^[-_a-z0-9\.\[\]]+$/i.test(tagName);
      };

      SessionClient.prototype.isValidFile = function(file) {
        return this.isValidFilename(file.filename) && angular.isString(file.content);
      };

      SessionClient.prototype.isValidFilename = function(filename) {
        return /^[-_a-z0-9\.\[\]]+$/i.test(filename);
      };

      SessionClient.prototype.reset = function(json) {
        var file, tagName, _i, _j, _len, _len1, _ref, _ref1;
        if (json == null) {
          json = {};
        }
        json.description || (json.description = "");
        json.tags || (json.tags = []);
        json.cursor || (json.cursor = {
          fileIndex: 0,
          textOffset: 0
        });
        if (!angular.isString(json.description)) {
          throw new Error("Reset failed. Description must be a string.");
        }
        if (!angular.isArray(json.tags)) {
          throw new Error("Reset failed. Tags must be an array.");
        }
        _ref = json.tags;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tagName = _ref[_i];
          if (!this.isValidTag(tagName)) {
            throw new Error("Reset failed. Invalid tag: " + tagName + ".");
          }
        }
        if (!angular.isArray(json.files)) {
          throw new Error("Reset failed. Files must be an array.");
        }
        _ref1 = json.files;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          file = _ref1[_j];
          if (!this.isValidFile(file)) {
            throw new Error("Reset failed. Invalid file: " + (JSON.stringify(file)) + ".");
          }
        }
        if (!json.files.length) {
          throw new Error("Reset failed. There must be at least one file.");
        }
        return this._applyOp({
          p: [],
          od: angular.copy(this.getSnapshot()),
          oi: json
        });
      };

      SessionClient.prototype.cursorSetFile = function(filename) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable set the active file. File does not exist: " + filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["cursor", "fileIndex"],
          od: this.getCursorFileIndex(),
          oi: idx
        });
      };

      SessionClient.prototype.cursorSetIndex = function(idx) {
        if (!this.hasFileIndex(idx)) {
          throw new Error("Unable set the active file. File does not exist: " + idx);
        }
        return this._applyOp({
          p: ["cursor", "fileIndex"],
          od: this.getCursorFileIndex(),
          oi: idx
        });
      };

      SessionClient.prototype.cursorSetOffset = function(offset) {
        return this._applyOp({
          p: ["cursor", "textOffset"],
          od: this.getCursorTextOffset(),
          oi: offset
        });
      };

      SessionClient.prototype.setDescription = function(description) {
        if (description == null) {
          description = "";
        }
        return this._applyOp({
          p: ["description", 0],
          sd: this.getDescription(),
          si: description
        });
      };

      SessionClient.prototype.fileCreate = function(filename, content) {
        var idx;
        if (content == null) {
          content = "";
        }
        if (!this.isValidFilename(filename)) {
          throw new Error("Unable to create file. Invalid filename: " + filename);
        }
        if (this.hasFile(filename)) {
          throw new Error("Unable to create file. File already exists: " + filename);
        }
        idx = this.getNumFiles();
        return this._applyOp({
          p: ["files", idx],
          li: {
            filename: filename,
            content: content
          }
        });
      };

      SessionClient.prototype.fileRename = function(filename, new_filename) {
        var idx;
        if (!this.isValidFilename(new_filename)) {
          throw new Error("Unable to create file. Invalid filename: " + new_filename);
        }
        if (!this.hasFile(filename)) {
          throw new Error("Unable to rename file. File does not exist: " + filename);
        }
        if (this.hasFile(new_filename)) {
          throw new Error("Unable to rename file. A file already exists named: " + new_filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["files", idx, "filename"],
          od: filename,
          oi: new_filename
        });
      };

      SessionClient.prototype.fileRemove = function(filename) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable to remove file. File does not exist: " + filename);
        }
        if (this.getNumFiles() <= 1) {
          throw new Error("Unable to remove file. You can not remove all files.");
        }
        idx = this.getFileIndex(filename);
        this.cursorSetIndex(0);
        return this._applyOp({
          p: ["files", idx],
          ld: this.getFile(filename)
        });
      };

      SessionClient.prototype.textInsert = function(filename, offset, text) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable to insert text. File does not exist: " + filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["files", idx, "content", offset],
          si: text
        });
      };

      SessionClient.prototype.textRemove = function(filename, offset, text) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable to remove text. File does not exist: " + filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["files", idx, "content", offset],
          sd: text
        });
      };

      SessionClient.prototype.tagAdd = function(tagName) {
        var idx;
        if (!this.isValidTag(tagName)) {
          throw new Error("Unable to add tag. Invalid tag: " + tagName);
        }
        if (this.hasTag(tagName)) {
          throw new Error("Unable to add tag. Tag already exists: " + tagName);
        }
        idx = this.getNumTags();
        return this._applyOp({
          p: ["tags", idx],
          li: tagName
        });
      };

      SessionClient.prototype.tagRemove = function(tagName) {
        var idx;
        if (!this.hasTag(tagName)) {
          throw new Error("Unable to remove tag. Tag not found: " + tagName);
        }
        idx = this.getTagIndex(tagName);
        return this._applyOp({
          p: ["tags", idx],
          ld: tagName
        });
      };

      return SessionClient;

    })();

    function Session() {
      this.$clients = {};
      this.snapshot = {};
      this.iface = this.createClient("session");
      this.iface.reset({
        files: [
          {
            filename: "index.html",
            content: ""
          }
        ]
      });
    }

    Session.prototype.createClient = function(clientName) {
      var session, _base;
      session = this;
      return (_base = this.$clients)[clientName] || (_base[clientName] = new SessionClient(clientName, session));
    };

    Session.prototype.applyOps = function(sourceClientName, ops) {
      var client, clientName, op, postSnapshot, _i, _len, _ref, _results;
      postSnapshot = ottypes.json0.apply(this.snapshot, ops);
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        console.log("[OT] op", op);
      }
      console.log("[OT] snapshot", angular.copy(this.snapshot));
      if (this.snapshot !== postSnapshot) {
        angular.copy(postSnapshot, this.snapshot);
      }
      _ref = this.$clients;
      _results = [];
      for (clientName in _ref) {
        client = _ref[clientName];
        if (clientName !== sourceClientName) {
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
              op = ops[_j];
              _results1.push(client._handleOp(sourceClientName, op, this.snapshot));
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    return Session;

  })());

}).call(this);


},{"share/webclient/share.uncompressed.js":33}],14:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.settings", []);

  module.service("settings", [
    function() {
      var e, saved, settings;
      settings = {
        previewer: {
          delay: 1000,
          auto_refresh: true
        },
        editor: {
          tab_size: 2,
          soft_tabs: true,
          theme: "textmate",
          wrap: {
            range: {
              min: 0,
              max: 80
            },
            enabled: false
          }
        }
      };
      if (typeof localStorage !== "undefined" && localStorage !== null) {
        if (saved = localStorage.getItem("plnkr_settings")) {
          try {
            saved = JSON.parse(saved);
          } catch (_error) {
            e = _error;
            saved = {};
          }
        }
        setInterval(function() {
          return localStorage.setItem("plnkr_settings", JSON.stringify(settings));
        }, 2000);
      }
      return angular.extend(settings, saved);
    }
  ]);

}).call(this);


},{}],15:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.types", []);

  module.factory("types", function() {
    var name, type, types;
    types = {
      html: {
        regex: /\.html$/i,
        mime: "text/html"
      },
      javascript: {
        regex: /\.js$/i,
        mime: "text/javascript"
      },
      coffee: {
        regex: /\.coffee$/i,
        mime: "text/coffee"
      },
      css: {
        regex: /\.css$/i,
        mime: "text/css"
      },
      text: {
        regex: /\.txt$/,
        mime: "text/plain"
      }
    };
    for (name in types) {
      type = types[name];
      type.name = name;
    }
    return {
      types: types,
      getByFilename: function(filename) {
        var mode;
        for (name in types) {
          mode = types[name];
          if (mode.regex.test(filename)) {
            return mode;
          }
        }
        return types.text;
      }
    };
  });

}).call(this);


},{}],16:[function(require,module,exports){
(function() {
  var module;

  require("../services/htmlFile.coffee");

  module = angular.module("plunker.service.updater", ["plunker.service.htmlFile"]);

  module.factory("updater", [
    "$q", "htmlFile", function($q, htmlFile) {
      return {
        update: function(json) {
          var file, promises, _fn, _i, _len, _ref;
          if (!(json.files && json.files.length)) {
            throw new Error("Unable to update invalid json: missing files array");
          }
          promises = [];
          _ref = json.files;
          _fn = function(file) {
            if (file.filename.match(/\.html$/i)) {
              return promises.push(htmlFile.update(file.content).then(function(markup) {
                return file.content = markup;
              }));
            }
          };
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            _fn(file);
          }
          return $q.all(promises).then(function() {
            return json;
          });
        }
      };
    }
  ]);

}).call(this);


},{"../services/htmlFile.coffee":10}],17:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.url", []);

  module.constant("url", _plunker.url);

}).call(this);


},{}],18:[function(require,module,exports){
/**
 * angular-growl - v0.3.0 - 2013-09-26
 * https://github.com/marcorinck/angular-growl
 * Copyright (c) 2013 Marco Rinck; Licensed MIT
 */
angular.module('angular-growl', []);
angular.module('angular-growl').directive('growl', [
  '$rootScope',
  function ($rootScope) {
    'use strict';
    return {
      restrict: 'A',
      template: '<div class="growl">' + '\t<div class="growl-item alert" ng-repeat="message in messages" ng-class="computeClasses(message)">' + '\t\t<button type="button" class="close" ng-click="deleteMessage(message)">&times;</button>' + '            {{ message.text}}' + '\t</div>' + '</div>',
      replace: false,
      scope: true,
      controller: [
        '$scope',
        '$timeout',
        function ($scope, $timeout) {
          $scope.messages = [];
          $rootScope.$on('growlMessage', function (event, message) {
            $scope.messages.push(message);
            if (message.ttl && message.ttl !== -1) {
              $timeout(function () {
                $scope.deleteMessage(message);
              }, message.ttl);
            }
          });
          $scope.deleteMessage = function (message) {
            var index = $scope.messages.indexOf(message);
            if (index > -1) {
              $scope.messages.splice(index, 1);
            }
          };
          $scope.computeClasses = function (message) {
            return {
              'alert-success': message.isSuccess,
              'alert-danger': message.isError,
              'alert-warning': message.isWarn,
              'alert-info': message.isInfo
            };
          };
        }
      ]
    };
  }
]);
angular.module('angular-growl').provider('growl', function () {
  'use strict';
  var _ttl = null, _messagesKey = 'messages', _messageTextKey = 'text', _messageSeverityKey = 'severity';
  this.globalTimeToLive = function (ttl) {
    _ttl = ttl;
  };
  this.messagesKey = function (messagesKey) {
    _messagesKey = messagesKey;
  };
  this.messageTextKey = function (messageTextKey) {
    _messageTextKey = messageTextKey;
  };
  this.messageSeverityKey = function (messageSeverityKey) {
    _messageSeverityKey = messageSeverityKey;
  };
  this.serverMessagesInterceptor = [
    '$q',
    'growl',
    function ($q, growl) {
      function checkResponse(response) {
        if (response.data[_messagesKey] && response.data[_messagesKey].length > 0) {
          growl.addServerMessages(response.data[_messagesKey]);
        }
      }
      function success(response) {
        checkResponse(response);
        return response;
      }
      function error(response) {
        checkResponse(response);
        return $q.reject(response);
      }
      return function (promise) {
        return promise.then(success, error);
      };
    }
  ];
  this.$get = [
    '$rootScope',
    '$filter',
    function ($rootScope, $filter) {
      var translate;
      try {
        translate = $filter('translate');
      } catch (e) {
      }
      function broadcastMessage(message) {
        if (translate) {
          message = translate(message);
        }
        $rootScope.$broadcast('growlMessage', message);
      }
      function sendMessage(text, config, severity) {
        var _config = config || {}, message;
        message = {
          text: text,
          isWarn: severity.isWarn,
          isError: severity.isError,
          isInfo: severity.isInfo,
          isSuccess: severity.isSuccess,
          ttl: _config.ttl || _ttl
        };
        broadcastMessage(message);
      }
      function addWarnMessage(text, config) {
        sendMessage(text, config, { isWarn: true });
      }
      function addErrorMessage(text, config) {
        sendMessage(text, config, { isError: true });
      }
      function addInfoMessage(text, config) {
        sendMessage(text, config, { isInfo: true });
      }
      function addSuccessMessage(text, config) {
        sendMessage(text, config, { isSuccess: true });
      }
      function addServerMessages(messages) {
        var i, message, severity, length;
        length = messages.length;
        for (i = 0; i < length; i++) {
          message = messages[i];
          if (message[_messageTextKey] && message[_messageSeverityKey]) {
            switch (message[_messageSeverityKey]) {
            case 'warn':
              severity = { isWarn: true };
              break;
            case 'success':
              severity = { isSuccess: true };
              break;
            case 'info':
              severity = { isInfo: true };
              break;
            case 'error':
              severity = { isError: true };
              break;
            }
            sendMessage(message[_messageTextKey], undefined, severity);
          }
        }
      }
      return {
        addWarnMessage: addWarnMessage,
        addErrorMessage: addErrorMessage,
        addInfoMessage: addInfoMessage,
        addSuccessMessage: addSuccessMessage,
        addServerMessages: addServerMessages
      };
    }
  ];
});
},{}],19:[function(require,module,exports){
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdownToggle","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/popup.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset-titles.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.transition', [])

/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject('Transition cancelled');
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement('trans');
  var transitionEndEventNames = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'transition': 'transitionend'
  };
  var animationEndEventNames = {
    'WebkitTransition': 'webkitAnimationEnd',
    'MozTransition': 'animationend',
    'OTransition': 'oAnimationEnd',
    'transition': 'animationend'
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module('ui.bootstrap.collapse',['ui.bootstrap.transition'])

// The collapsible directive indicates a block of html that will expand and collapse
.directive('collapse', ['$transition', function($transition) {
  // CSS transitions don't work with height: auto, so we have to manually change the height to a
  // specific value and then once the animation completes, we can reset the height to auto.
  // Unfortunately if you do this while the CSS transitions are specified (i.e. in the CSS class
  // "collapse") then you trigger a change to height 0 in between.
  // The fix is to remove the "collapse" CSS class while changing the height back to auto - phew!
  var fixUpHeight = function(scope, element, height) {
    // We remove the collapse CSS class to prevent a transition when we change to height: auto
    element.removeClass('collapse');
    element.css({ height: height });
    // It appears that  reading offsetWidth makes the browser realise that we have changed the
    // height already :-/
    var x = element[0].offsetWidth;
    element.addClass('collapse');
  };

  return {
    link: function(scope, element, attrs) {

      var isCollapsed;
      var initialAnimSkip = true;
      scope.$watch(function (){ return element[0].scrollHeight; }, function (value) {
        //The listener is called when scollHeight changes
        //It actually does on 2 scenarios: 
        // 1. Parent is set to display none
        // 2. angular bindings inside are resolved
        //When we have a change of scrollHeight we are setting again the correct height if the group is opened
        if (element[0].scrollHeight !== 0) {
          if (!isCollapsed) {
            if (initialAnimSkip) {
              fixUpHeight(scope, element, element[0].scrollHeight + 'px');
            } else {
              fixUpHeight(scope, element, 'auto');
            }
          }
        }
      });
      
      scope.$watch(attrs.collapse, function(value) {
        if (value) {
          collapse();
        } else {
          expand();
        }
      });
      

      var currentTransition;
      var doTransition = function(change) {
        if ( currentTransition ) {
          currentTransition.cancel();
        }
        currentTransition = $transition(element,change);
        currentTransition.then(
          function() { currentTransition = undefined; },
          function() { currentTransition = undefined; }
        );
        return currentTransition;
      };

      var expand = function() {
        if (initialAnimSkip) {
          initialAnimSkip = false;
          if ( !isCollapsed ) {
            fixUpHeight(scope, element, 'auto');
          }
        } else {
          doTransition({ height : element[0].scrollHeight + 'px' })
          .then(function() {
            // This check ensures that we don't accidentally update the height if the user has closed
            // the group while the animation was still running
            if ( !isCollapsed ) {
              fixUpHeight(scope, element, 'auto');
            }
          });
        }
        isCollapsed = false;
      };
      
      var collapse = function() {
        isCollapsed = true;
        if (initialAnimSkip) {
          initialAnimSkip = false;
          fixUpHeight(scope, element, 0);
        } else {
          fixUpHeight(scope, element, element[0].scrollHeight + 'px');
          doTransition({'height':'0'});
        }
      };
    }
  };
}]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('accordionConfig', {
  closeOthers: true
})

.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {
  
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if ( closeOthers ) {
      angular.forEach(this.groups, function (group) {
        if ( group !== openGroup ) {
          group.isOpen = false;
        }
      });
    }
  };
  
  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if ( index !== -1 ) {
      this.groups.splice(this.groups.indexOf(group), 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
  return {
    restrict:'EA',
    controller:'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', ['$parse', '$transition', '$timeout', function($parse, $transition, $timeout) {
  return {
    require:'^accordion',         // We need this directive to be inside an accordion
    restrict:'EA',
    transclude:true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl:'template/accordion/accordion-group.html',
    scope:{ heading:'@' },        // Create an isolated scope and interpolate the heading attribute onto this scope
    controller: ['$scope', function($scope) {
      this.setHeading = function(element) {
        this.heading = element;
      };
    }],
    link: function(scope, element, attrs, accordionCtrl) {
      var getIsOpen, setIsOpen;

      accordionCtrl.addGroup(scope);

      scope.isOpen = false;
      
      if ( attrs.isOpen ) {
        getIsOpen = $parse(attrs.isOpen);
        setIsOpen = getIsOpen.assign;

        scope.$watch(
          function watchIsOpen() { return getIsOpen(scope.$parent); },
          function updateOpen(value) { scope.isOpen = value; }
        );
        
        scope.isOpen = getIsOpen ? getIsOpen(scope.$parent) : false;
      }

      scope.$watch('isOpen', function(value) {
        if ( value ) {
          accordionCtrl.closeOthers(scope);
        }
        if ( setIsOpen ) {
          setIsOpen(scope.$parent, value);
        }
      });
    }
  };
}])

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function() {
  return {
    restrict: 'EA',
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^accordionGroup',
    compile: function(element, attr, transclude) {
      return function link(scope, element, attr, accordionGroupCtrl) {
        // Pass the heading to the accordion-group controller
        // so that it can be transcluded into the right place in the template
        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
        accordionGroupCtrl.setHeading(transclude(scope, function() {}));
      };
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function() {
  return {
    require: '^accordionGroup',
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if ( heading ) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
});

angular.module("ui.bootstrap.alert", []).directive('alert', function () {
  return {
    restrict:'EA',
    templateUrl:'template/alert/alert.html',
    transclude:true,
    replace:true,
    scope: {
      type: '=',
      close: '&'
    },
    link: function(scope, iElement, iAttrs, controller) {
      scope.closeable = "close" in iAttrs;
    }
  };
});

angular.module('ui.bootstrap.bindHtml', [])

  .directive('bindHtmlUnsafe', function () {
    return function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || '');
      });
    };
  });
angular.module('ui.bootstrap.buttons', [])

  .constant('buttonConfig', {
    activeClass:'active',
    toggleEvent:'click'
  })

  .directive('btnRadio', ['buttonConfig', function (buttonConfig) {
  var activeClass = buttonConfig.activeClass || 'active';
  var toggleEvent = buttonConfig.toggleEvent || 'click';

  return {

    require:'ngModel',
    link:function (scope, element, attrs, ngModelCtrl) {

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui->model
      element.bind(toggleEvent, function () {
        if (!element.hasClass(activeClass)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
}])

  .directive('btnCheckbox', ['buttonConfig', function (buttonConfig) {

  var activeClass = buttonConfig.activeClass || 'active';
  var toggleEvent = buttonConfig.toggleEvent || 'click';

  return {
    require:'ngModel',
    link:function (scope, element, attrs, ngModelCtrl) {

      function getTrueValue() {
        var trueValue = scope.$eval(attrs.btnCheckboxTrue);
        return angular.isDefined(trueValue) ? trueValue : true;
      }

      function getFalseValue() {
        var falseValue = scope.$eval(attrs.btnCheckboxFalse);
        return angular.isDefined(falseValue) ? falseValue : false;
      }

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.bind(toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
}]);
/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])
.controller('CarouselController', ['$scope', '$timeout', '$transition', '$q', function ($scope, $timeout, $transition, $q) {
  var self = this,
    slides = self.slides = [],
    currentIndex = -1,
    currentTimeout, isPlaying;
  self.currentSlide = null;

  /* direction: "prev" or "next" */
  self.select = function(nextSlide, direction) {
    var nextIndex = slides.indexOf(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > currentIndex ? "next" : "prev";
    }
    if (nextSlide && nextSlide !== self.currentSlide) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition.cancel();
        //Timeout so ng-class in template has time to fix classes for finished slide
        $timeout(goNext);
      } else {
        goNext();
      }
    }
    function goNext() {
      //If we have a slide to transition from and we have a transition type and we're allowed, go
      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
        nextSlide.$element.addClass(direction);
        var reflow = nextSlide.$element[0].offsetWidth; //force reflow

        //Set all other slides to stop doing their stuff for the new transition
        angular.forEach(slides, function(slide) {
          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});
        });
        angular.extend(nextSlide, {direction: direction, active: true, entering: true});
        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});

        $scope.$currentTransition = $transition(nextSlide.$element, {});
        //We have to create new pointers inside a closure since next & current will change
        (function(next,current) {
          $scope.$currentTransition.then(
            function(){ transitionDone(next, current); },
            function(){ transitionDone(next, current); }
          );
        }(nextSlide, self.currentSlide));
      } else {
        transitionDone(nextSlide, self.currentSlide);
      }
      self.currentSlide = nextSlide;
      currentIndex = nextIndex;
      //every time you change slides, reset the timer
      restartTimer();
    }
    function transitionDone(next, current) {
      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});
      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});
      $scope.$currentTransition = null;
    }
  };

  /* Allow outside people to call indexOf on slides array */
  self.indexOfSlide = function(slide) {
    return slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (currentIndex + 1) % slides.length;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'next');
    }
  };

  $scope.prev = function() {
    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'prev');
    }
  };

  $scope.select = function(slide) {
    self.select(slide);
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.slides = function() {
    return slides;
  };

  $scope.$watch('interval', restartTimer);
  function restartTimer() {
    if (currentTimeout) {
      $timeout.cancel(currentTimeout);
    }
    function go() {
      if (isPlaying) {
        $scope.next();
        restartTimer();
      } else {
        $scope.pause();
      }
    }
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval>=0) {
      currentTimeout = $timeout(go, interval);
    }
  }
  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      if (currentTimeout) {
        $timeout.cancel(currentTimeout);
      }
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <carousel>
      <slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </slide>
      <slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </slide>
    </carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('carousel', [function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    require: 'carousel',
    templateUrl: 'template/carousel/carousel.html',
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '='
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <carousel>
    <slide ng-repeat="slide in slides" active="slide.active">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </slide>
  </carousel>
  <div class="row-fluid">
    <div class="span6">
      <ul>
        <li ng-repeat="slide in slides">
          <button class="btn btn-mini" ng-class="{'btn-info': !slide.active, 'btn-success': slide.active}" ng-disabled="slide.active" ng-click="slide.active = true">select</button>
          {{$index}}: {{slide.text}}
        </li>
      </ul>
      <a class="btn" ng-click="addSlide()">Add Slide</a>
    </div>
    <div class="span6">
      Interval, in milliseconds: <input type="number" ng-model="myInterval">
      <br />Enter a negative number to stop the interval.
    </div>
  </div>
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
  var slides = $scope.slides = [];
  $scope.addSlide = function() {
    var newWidth = 200 + ((slides.length + (25 * slides.length)) % 150);
    slides.push({
      image: 'http://placekitten.com/' + newWidth + '/200',
      text: ['More','Extra','Lots of','Surplus'][slides.length % 4] + ' '
        ['Cats', 'Kittys', 'Felines', 'Cutes'][slides.length % 4]
    });
  };
  for (var i=0; i<4; i++) $scope.addSlide();
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('slide', ['$parse', function($parse) {
  return {
    require: '^carousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: 'template/carousel/slide.html',
    scope: {
    },
    link: function (scope, element, attrs, carouselCtrl) {
      //Set up optional 'active' = binding
      if (attrs.active) {
        var getActive = $parse(attrs.active);
        var setActive = getActive.assign;
        var lastValue = scope.active = getActive(scope.$parent);
        scope.$watch(function parentActiveWatch() {
          var parentActive = getActive(scope.$parent);

          if (parentActive !== scope.active) {
            // we are out of sync and need to copy
            if (parentActive !== lastValue) {
              // parent changed and it has precedence
              lastValue = scope.active = parentActive;
            } else {
              // if the parent can be assigned then do so
              setActive(scope.$parent, parentActive = lastValue = scope.active);
            }
          }
          return parentActive;
        });
      }

      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, "position") || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        return {
          width: element.prop('offsetWidth'),
          height: element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: element.prop('offsetWidth'),
          height: element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)
        };
      }
    };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position'])

.constant('datepickerConfig', {
  dayFormat: 'dd',
  monthFormat: 'MMMM',
  yearFormat: 'yyyy',
  dayHeaderFormat: 'EEE',
  dayTitleFormat: 'MMMM yyyy',
  monthTitleFormat: 'yyyy',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null
})

.controller('DatepickerController', ['$scope', '$attrs', 'dateFilter', 'datepickerConfig', function($scope, $attrs, dateFilter, dtConfig) {
  var format = {
    day:        getValue($attrs.dayFormat,        dtConfig.dayFormat),
    month:      getValue($attrs.monthFormat,      dtConfig.monthFormat),
    year:       getValue($attrs.yearFormat,       dtConfig.yearFormat),
    dayHeader:  getValue($attrs.dayHeaderFormat,  dtConfig.dayHeaderFormat),
    dayTitle:   getValue($attrs.dayTitleFormat,   dtConfig.dayTitleFormat),
    monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
  },
  startingDay = getValue($attrs.startingDay,      dtConfig.startingDay),
  yearRange =   getValue($attrs.yearRange,        dtConfig.yearRange);

  this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
  this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;

  function getValue(value, defaultValue) {
    return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
  }

  function getDaysInMonth( year, month ) {
    return new Date(year, month, 0).getDate();
  }

  function getDates(startDate, n) {
    var dates = new Array(n);
    var current = startDate, i = 0;
    while (i < n) {
      dates[i++] = new Date(current);
      current.setDate( current.getDate() + 1 );
    }
    return dates;
  }

  function makeDate(date, format, isSelected, isSecondary) {
    return { date: date, label: dateFilter(date, format), selected: !!isSelected, secondary: !!isSecondary };
  }

  this.modes = [
    {
      name: 'day',
      getVisibleDates: function(date, selected) {
        var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
        var difference = startingDay - firstDayOfMonth.getDay(),
        numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
        firstDate = new Date(firstDayOfMonth), numDates = 0;

        if ( numDisplayedFromPreviousMonth > 0 ) {
          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
          numDates += numDisplayedFromPreviousMonth; // Previous
        }
        numDates += getDaysInMonth(year, month + 1); // Current
        numDates += (7 - numDates % 7) % 7; // Next

        var days = getDates(firstDate, numDates), labels = new Array(7);
        for (var i = 0; i < numDates; i ++) {
          var dt = new Date(days[i]);
          days[i] = makeDate(dt, format.day, (selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear()), dt.getMonth() !== month);
        }
        for (var j = 0; j < 7; j++) {
          labels[j] = dateFilter(days[j].date, format.dayHeader);
        }
        return { objects: days, title: dateFilter(date, format.dayTitle), labels: labels };
      },
      compare: function(date1, date2) {
        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
      },
      split: 7,
      step: { months: 1 }
    },
    {
      name: 'month',
      getVisibleDates: function(date, selected) {
        var months = new Array(12), year = date.getFullYear();
        for ( var i = 0; i < 12; i++ ) {
          var dt = new Date(year, i, 1);
          months[i] = makeDate(dt, format.month, (selected && selected.getMonth() === i && selected.getFullYear() === year));
        }
        return { objects: months, title: dateFilter(date, format.monthTitle) };
      },
      compare: function(date1, date2) {
        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
      },
      split: 3,
      step: { years: 1 }
    },
    {
      name: 'year',
      getVisibleDates: function(date, selected) {
        var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
        for ( var i = 0; i < yearRange; i++ ) {
          var dt = new Date(startYear + i, 0, 1);
          years[i] = makeDate(dt, format.year, (selected && selected.getFullYear() === dt.getFullYear()));
        }
        return { objects: years, title: [years[0].label, years[yearRange - 1].label].join(' - ') };
      },
      compare: function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      },
      split: 5,
      step: { years: yearRange }
    }
  ];

  this.isDisabled = function(date, mode) {
    var currentMode = this.modes[mode || 0];
    return ((this.minDate && currentMode.compare(date, this.minDate) < 0) || (this.maxDate && currentMode.compare(date, this.maxDate) > 0) || ($scope.dateDisabled && $scope.dateDisabled({date: date, mode: currentMode.name})));
  };
}])

.directive( 'datepicker', ['dateFilter', '$parse', 'datepickerConfig', '$log', function (dateFilter, $parse, datepickerConfig, $log) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/datepicker.html',
    scope: {
      dateDisabled: '&'
    },
    require: ['datepicker', '?^ngModel'],
    controller: 'DatepickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModel = ctrls[1];

      if (!ngModel) {
        return; // do nothing if no ng-model
      }

      // Configuration parameters
      var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;

      if (attrs.showWeeks) {
        scope.$parent.$watch($parse(attrs.showWeeks), function(value) {
          showWeeks = !! value;
          updateShowWeekNumbers();
        });
      } else {
        updateShowWeekNumbers();
      }

      if (attrs.min) {
        scope.$parent.$watch($parse(attrs.min), function(value) {
          datepickerCtrl.minDate = value ? new Date(value) : null;
          refill();
        });
      }
      if (attrs.max) {
        scope.$parent.$watch($parse(attrs.max), function(value) {
          datepickerCtrl.maxDate = value ? new Date(value) : null;
          refill();
        });
      }

      function updateShowWeekNumbers() {
        scope.showWeekNumbers = mode === 0 && showWeeks;
      }

      // Split array into smaller arrays
      function split(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      }

      function refill( updateSelected ) {
        var date = null, valid = true;

        if ( ngModel.$modelValue ) {
          date = new Date( ngModel.$modelValue );

          if ( isNaN(date) ) {
            valid = false;
            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          } else if ( updateSelected ) {
            selected = date;
          }
        }
        ngModel.$setValidity('date', valid);

        var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
        angular.forEach(data.objects, function(obj) {
          obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
        });

        ngModel.$setValidity('date-disabled', (!date || !datepickerCtrl.isDisabled(date)));

        scope.rows = split(data.objects, currentMode.split);
        scope.labels = data.labels || [];
        scope.title = data.title;
      }

      function setMode(value) {
        mode = value;
        updateShowWeekNumbers();
        refill();
      }

      ngModel.$render = function() {
        refill( true );
      };

      scope.select = function( date ) {
        if ( mode === 0 ) {
          var dt = new Date( ngModel.$modelValue );
          dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
          ngModel.$setViewValue( dt );
          refill( true );
        } else {
          selected = date;
          setMode( mode - 1 );
        }
      };
      scope.move = function(direction) {
        var step = datepickerCtrl.modes[mode].step;
        selected.setMonth( selected.getMonth() + direction * (step.months || 0) );
        selected.setFullYear( selected.getFullYear() + direction * (step.years || 0) );
        refill();
      };
      scope.toggleMode = function() {
        setMode( (mode + 1) % datepickerCtrl.modes.length );
      };
      scope.getWeekNumber = function(row) {
        return ( mode === 0 && scope.showWeekNumbers && row.length === 7 ) ? getISO8601WeekNumber(row[0].date) : null;
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }
    }
  };
}])

.constant('datepickerPopupConfig', {
  dateFormat: 'yyyy-MM-dd',
  closeOnDateSelection: true
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'datepickerPopupConfig',
function ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    link: function(originalScope, element, attrs, ngModel) {

      var closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
      var dateFormat = attrs.datepickerPopup || datepickerPopupConfig.dateFormat;

     // create a child scope for the datepicker directive so we are not polluting original scope
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function() {
        scope.$destroy();
      });

      var getIsOpen, setIsOpen;
      if ( attrs.isOpen ) {
        getIsOpen = $parse(attrs.isOpen);
        setIsOpen = getIsOpen.assign;

        originalScope.$watch(getIsOpen, function updateOpen(value) {
          scope.isOpen = !! value;
        });
      }
      scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false; // Initial state

      function setOpen( value ) {
        if (setIsOpen) {
          setIsOpen(originalScope, !!value);
        } else {
          scope.isOpen = !!value;
        }
      }

      var documentClickBind = function(event) {
        if (scope.isOpen && event.target !== element[0]) {
          scope.$apply(function() {
            setOpen(false);
          });
        }
      };

      var elementFocusBind = function() {
        scope.$apply(function() {
          setOpen( true );
        });
      };

      // popup element used to display calendar
      var popupEl = angular.element('<datepicker-popup-wrap><datepicker></datepicker></datepicker-popup-wrap>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection()'
      });
      var datepickerEl = popupEl.find('datepicker');
      if (attrs.datepickerOptions) {
        datepickerEl.attr(angular.extend({}, originalScope.$eval(attrs.datepickerOptions)));
      }

      // TODO: reverse from dateFilter string to Date object
      function parseDate(viewValue) {
        if (!viewValue) {
          ngModel.$setValidity('date', true);
          return null;
        } else if (angular.isDate(viewValue)) {
          ngModel.$setValidity('date', true);
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = new Date(viewValue);
          if (isNaN(date)) {
            ngModel.$setValidity('date', false);
            return undefined;
          } else {
            ngModel.$setValidity('date', true);
            return date;
          }
        } else {
          ngModel.$setValidity('date', false);
          return undefined;
        }
      }
      ngModel.$parsers.unshift(parseDate);

      // Inner change
      scope.dateSelection = function() {
        ngModel.$setViewValue(scope.date);
        ngModel.$render();

        if (closeOnDateSelection) {
          setOpen( false );
        }
      };

      element.bind('input change keyup', function() {
        scope.$apply(function() {
          updateCalendar();
        });
      });

      // Outter change
      ngModel.$render = function() {
        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
        element.val(date);

        updateCalendar();
      };

      function updateCalendar() {
        scope.date = ngModel.$modelValue;
        updatePosition();
      }

      function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
        if (attribute) {
          originalScope.$watch($parse(attribute), function(value){
            scope[scopeProperty] = value;
          });
          datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
        }
      }
      addWatchableAttribute(attrs.min, 'min');
      addWatchableAttribute(attrs.max, 'max');
      if (attrs.showWeeks) {
        addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');
      } else {
        scope.showWeeks = true;
        datepickerEl.attr('show-weeks', 'showWeeks');
      }
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', attrs.dateDisabled);
      }

      function updatePosition() {
        scope.position = $position.position(element);
        scope.position.top = scope.position.top + element.prop('offsetHeight');
      }

      var documentBindingInitialized = false, elementFocusInitialized = false;
      scope.$watch('isOpen', function(value) {
        if (value) {
          updatePosition();
          $document.bind('click', documentClickBind);
          if(elementFocusInitialized) {
            element.unbind('focus', elementFocusBind);
          }
          element[0].focus();
          documentBindingInitialized = true;
        } else {
          if(documentBindingInitialized) {
            $document.unbind('click', documentClickBind);
          }
          element.bind('focus', elementFocusBind);
          elementFocusInitialized = true;
        }

        if ( setIsOpen ) {
          setIsOpen(originalScope, value);
        }
      });

      var $setModelValue = $parse(attrs.ngModel).assign;

      scope.today = function() {
        $setModelValue(originalScope, new Date());
      };
      scope.clear = function() {
        $setModelValue(originalScope, null);
      };

      element.after($compile(popupEl)(scope));
    }
  };
}])

.directive('datepickerPopupWrap', [function() {
  return {
    restrict:'E',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link:function (scope, element, attrs) {
      element.bind('click', function(event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
}]);

/*
 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
 * @restrict class or attribute
 * @example:
   <li class="dropdown">
     <a class="dropdown-toggle">My Dropdown Menu</a>
     <ul class="dropdown-menu">
       <li ng-repeat="choice in dropChoices">
         <a ng-href="{{choice.href}}">{{choice.text}}</a>
       </li>
     </ul>
   </li>
 */

angular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', ['$document', '$location', function ($document, $location) {
  var openElement = null,
      closeMenu   = angular.noop;
  return {
    restrict: 'CA',
    link: function(scope, element, attrs) {
      scope.$watch('$location.path', function() { closeMenu(); });
      element.parent().bind('click', function() { closeMenu(); });
      element.bind('click', function (event) {

        var elementWasOpen = (element === openElement);

        event.preventDefault();
        event.stopPropagation();

        if (!!openElement) {
          closeMenu();
        }

        if (!elementWasOpen) {
          element.parent().addClass('open');
          openElement = element;
          closeMenu = function (event) {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            $document.unbind('click', closeMenu);
            element.parent().removeClass('open');
            closeMenu = angular.noop;
            openElement = null;
          };
          $document.bind('click', closeMenu);
        }
      });
    }
  };
}]);
angular.module('ui.bootstrap.modal', [])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function () {
    return {
      createNew: function () {
        var stack = [];

        return {
          add: function (key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function (key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function () {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('modalBackdrop', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      link: function (scope, element, attrs) {

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });

        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop != 'static') {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };
      }
    };
  }])

  .directive('modalWindow', ['$timeout', function ($timeout) {
    return {
      restrict: 'EA',
      scope: {
        index: '@'
      },
      replace: true,
      transclude: true,
      templateUrl: 'template/modal/window.html',
      link: function (scope, element, attrs) {
        scope.windowClass = attrs.windowClass || '';

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });
      }
    };
  }])

  .factory('$modalStack', ['$document', '$compile', '$rootScope', '$$stackedMap',
    function ($document, $compile, $rootScope, $$stackedMap) {

      var backdropjqLiteEl, backdropDomEl;
      var backdropScope = $rootScope.$new(true);
      var body = $document.find('body').eq(0);
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
        backdropScope.index = newBackdropIndex;
      });

      function removeModalWindow(modalInstance) {

        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        //remove window DOM element
        modalWindow.modalDomEl.remove();

        //remove backdrop if no longer needed
        if (backdropIndex() == -1) {
          backdropDomEl.remove();
          backdropDomEl = undefined;
        }

        //destroy scope
        modalWindow.modalScope.$destroy();
      }

      $document.bind('keydown', function (evt) {
        var modal;

        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            $rootScope.$apply(function () {
              $modalStack.dismiss(modal.key);
            });
          }
        }
      });

      $modalStack.open = function (modalInstance, modal) {

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });

        var angularDomEl = angular.element('<div modal-window></div>');
        angularDomEl.attr('window-class', modal.windowClass);
        angularDomEl.attr('index', openedWindows.length() - 1);
        angularDomEl.html(modal.content);

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        body.append(modalDomEl);

        if (backdropIndex() >= 0 && !backdropDomEl) {
            backdropjqLiteEl = angular.element('<div modal-backdrop></div>');
            backdropDomEl = $compile(backdropjqLiteEl)(backdropScope);
            body.append(backdropDomEl);
        }
      };

      $modalStack.close = function (modalInstance, result) {
        var modal = openedWindows.get(modalInstance);
        if (modal) {
          modal.value.deferred.resolve(result);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
          modalWindow.deferred.reject(reason);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      return $modalStack;
    }])

  .provider('$modal', function () {

    var $modalProvider = {
      options: {
        backdrop: true, //can be also false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',
        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {

          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $http.get(options.templateUrl, {cache: $templateCache}).then(function (result) {
                return result.data;
              });
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value, key) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              close: function (result) {
                $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;

              //controllers
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });

                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
              }

              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                content: tplAndVars[0],
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                windowClass: modalOptions.windowClass
              });

            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });

            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function () {
              modalOpenedDeferred.reject(false);
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });
angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {
  var self = this;

  this.init = function(defaultItemsPerPage) {
    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = defaultItemsPerPage;
    }
  };

  this.noPrevious = function() {
    return this.page === 1;
  };
  this.noNext = function() {
    return this.page === $scope.totalPages;
  };

  this.isActive = function(page) {
    return this.page === page;
  };

  this.calculateTotalPages = function() {
    return this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
  };

  this.getAttributeValue = function(attribute, defaultValue, interpolate) {
    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
  };

  this.render = function() {
    this.page = parseInt($scope.page, 10) || 1;
    $scope.pages = this.getPages(this.page, $scope.totalPages);
  };

  $scope.selectPage = function(page) {
    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {
      $scope.page = page;
      $scope.onSelectPage({ page: page });
    }
  };

  $scope.$watch('totalItems', function() {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function(value) {
    if ( $attrs.numPages ) {
      $scope.numPages = value; // Readonly variable
    }

    if ( self.page > value ) {
      $scope.selectPage(value);
    } else {
      self.render();
    }
  });

  $scope.$watch('page', function() {
    self.render();
  });
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &',
      numPages: '='
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var maxSize,
      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),
      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),
      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),
      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),
      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),
      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),
      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);

      paginationCtrl.init(config.itemsPerPage);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive, isDisabled) {
        return {
          number: number,
          text: text,
          active: isActive,
          disabled: isDisabled
        };
      }

      paginationCtrl.getPages = function(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, paginationCtrl.isActive(number), false);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false, false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false, false);
            pages.push(nextPageSet);
          }
        }

        // Add previous & next links
        if (directionLinks) {
          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
          pages.unshift(previousPage);

          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
          pages.push(nextPage);
        }

        // Add first & last links
        if (boundaryLinks) {
          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
          pages.unshift(firstPage);

          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
          pages.push(lastPage);
        }

        return pages;
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: 'Â« Previous',
  nextText: 'Next Â»',
  align: true
})

.directive('pager', ['pagerConfig', function(config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &',
      numPages: '='
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),
      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);

      paginationCtrl.init(config.itemsPerPage);

      // Create page object used in template
      function makePage(number, text, isDisabled, isPrevious, isNext) {
        return {
          number: number,
          text: text,
          disabled: isDisabled,
          previous: ( align && isPrevious ),
          next: ( align && isNext )
        };
      }

      paginationCtrl.getPages = function(currentPage) {
        return [
          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),
          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)
        ];
      };
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider( '$tooltip', function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur'
  };

  // The options specified to the provider globally.
  var globalOptions = {};
  
  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function( value ) {
		angular.extend( globalOptions, value );
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers ( triggers ) {
    angular.extend( triggerMap, triggers );
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name){
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {
    return function $tooltip ( type, prefix, defaultTriggerShow ) {
      var options = angular.extend( {}, defaultOptions, globalOptions );

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers ( trigger ) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case( type );

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template = 
        '<'+ directiveName +'-popup '+
          'title="'+startSym+'tt_title'+endSym+'" '+
          'content="'+startSym+'tt_content'+endSym+'" '+
          'placement="'+startSym+'tt_placement'+endSym+'" '+
          'animation="tt_animation()" '+
          'is-open="tt_isOpen"'+
          '>'+
        '</'+ directiveName +'-popup>';

      return {
        restrict: 'EA',
        scope: true,
        link: function link ( scope, element, attrs ) {
          var tooltip = $compile( template )( scope );
          var transitionTimeout;
          var popupTimeout;
          var $body;
          var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
          var triggers = getTriggers( undefined );
          var hasRegisteredTriggers = false;

          // By default, the tooltip is not open.
          // TODO add ability to start tooltip opened
          scope.tt_isOpen = false;

          function toggleTooltipBind () {
            if ( ! scope.tt_isOpen ) {
              showTooltipBind();
            } else {
              hideTooltipBind();
            }
          }
          
          // Show the tooltip with delay if specified, otherwise show it immediately
          function showTooltipBind() {
            if ( scope.tt_popupDelay ) {
              popupTimeout = $timeout( show, scope.tt_popupDelay );
            } else {
              scope.$apply( show );
            }
          }

          function hideTooltipBind () {
            scope.$apply(function () {
              hide();
            });
          }
          
          // Show the tooltip popup element.
          function show() {
            var position,
                ttWidth,
                ttHeight,
                ttPosition;

            // Don't show empty tooltips.
            if ( ! scope.tt_content ) {
              return;
            }

            // If there is a pending remove transition, we must cancel it, lest the
            // tooltip be mysteriously removed.
            if ( transitionTimeout ) {
              $timeout.cancel( transitionTimeout );
            }
            
            // Set the initial positioning.
            tooltip.css({ top: 0, left: 0, display: 'block' });
            
            // Now we add it to the DOM because need some info about it. But it's not 
            // visible yet anyway.
            if ( appendToBody ) {
                $body = $body || $document.find( 'body' );
                $body.append( tooltip );
            } else {
              element.after( tooltip );
            }

            // Get the position of the directive element.
            position = appendToBody ? $position.offset( element ) : $position.position( element );

            // Get the height and width of the tooltip so we can center it.
            ttWidth = tooltip.prop( 'offsetWidth' );
            ttHeight = tooltip.prop( 'offsetHeight' );
            
            // Calculate the tooltip's top and left coordinates to center it with
            // this directive.
            switch ( scope.tt_placement ) {
              case 'right':
                ttPosition = {
                  top: position.top + position.height / 2 - ttHeight / 2,
                  left: position.left + position.width
                };
                break;
              case 'bottom':
                ttPosition = {
                  top: position.top + position.height,
                  left: position.left + position.width / 2 - ttWidth / 2
                };
                break;
              case 'left':
                ttPosition = {
                  top: position.top + position.height / 2 - ttHeight / 2,
                  left: position.left - ttWidth
                };
                break;
              default:
                ttPosition = {
                  top: position.top - ttHeight,
                  left: position.left + position.width / 2 - ttWidth / 2
                };
                break;
            }

            ttPosition.top += 'px';
            ttPosition.left += 'px';

            // Now set the calculated positioning.
            tooltip.css( ttPosition );
              
            // And show the tooltip.
            scope.tt_isOpen = true;
          }
          
          // Hide the tooltip popup element.
          function hide() {
            // First things first: we don't show it anymore.
            scope.tt_isOpen = false;

            //if tooltip is going to be shown after delay, we must cancel this
            $timeout.cancel( popupTimeout );
            
            // And now we remove it from the DOM. However, if we have animation, we 
            // need to wait for it to expire beforehand.
            // FIXME: this is a placeholder for a port of the transitions library.
            if ( angular.isDefined( scope.tt_animation ) && scope.tt_animation() ) {
              transitionTimeout = $timeout( function () { tooltip.remove(); }, 500 );
            } else {
              tooltip.remove();
            }
          }

          /**
           * Observe the relevant attributes.
           */
          attrs.$observe( type, function ( val ) {
            scope.tt_content = val;
          });

          attrs.$observe( prefix+'Title', function ( val ) {
            scope.tt_title = val;
          });

          attrs.$observe( prefix+'Placement', function ( val ) {
            scope.tt_placement = angular.isDefined( val ) ? val : options.placement;
          });

          attrs.$observe( prefix+'Animation', function ( val ) {
            scope.tt_animation = angular.isDefined( val ) ? $parse( val ) : function(){ return options.animation; };
          });

          attrs.$observe( prefix+'PopupDelay', function ( val ) {
            var delay = parseInt( val, 10 );
            scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
          });

          attrs.$observe( prefix+'Trigger', function ( val ) {

            if (hasRegisteredTriggers) {
              element.unbind( triggers.show, showTooltipBind );
              element.unbind( triggers.hide, hideTooltipBind );
            }

            triggers = getTriggers( val );

            if ( triggers.show === triggers.hide ) {
              element.bind( triggers.show, toggleTooltipBind );
            } else {
              element.bind( triggers.show, showTooltipBind );
              element.bind( triggers.hide, hideTooltipBind );
            }

            hasRegisteredTriggers = true;
          });

          attrs.$observe( prefix+'AppendToBody', function ( val ) {
            appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;
          });

          // if a tooltip is attached to <body> we need to remove it on
          // location change as its parent scope will probably not be destroyed
          // by the change.
          if ( appendToBody ) {
            scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {
            if ( scope.tt_isOpen ) {
              hide();
            }
          });
          }

          // Make sure tooltip is destroyed and removed.
          scope.$on('$destroy', function onDestroyTooltip() {
            if ( scope.tt_isOpen ) {
              hide();
            } else {
              tooltip.remove();
            }
          });
        }
      };
    };
  }];
})

.directive( 'tooltipPopup', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
})

.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );
}])

.directive( 'tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
})

.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )
.directive( 'popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html'
  };
})
.directive( 'popover', [ '$compile', '$timeout', '$parse', '$window', '$tooltip', function ( $compile, $timeout, $parse, $window, $tooltip ) {
  return $tooltip( 'popover', 'popover', 'click' );
}]);


angular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition'])

.constant('progressConfig', {
  animate: true,
  autoType: false,
  stackedTypes: ['success', 'info', 'warning', 'danger']
})

.controller('ProgressBarController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {

    // Whether bar transitions should be animated
    var animate = angular.isDefined($attrs.animate) ? $scope.$eval($attrs.animate) : progressConfig.animate;
    var autoType = angular.isDefined($attrs.autoType) ? $scope.$eval($attrs.autoType) : progressConfig.autoType;
    var stackedTypes = angular.isDefined($attrs.stackedTypes) ? $scope.$eval('[' + $attrs.stackedTypes + ']') : progressConfig.stackedTypes;

    // Create bar object
    this.makeBar = function(newBar, oldBar, index) {
        var newValue = (angular.isObject(newBar)) ? newBar.value : (newBar || 0);
        var oldValue =  (angular.isObject(oldBar)) ? oldBar.value : (oldBar || 0);
        var type = (angular.isObject(newBar) && angular.isDefined(newBar.type)) ? newBar.type : (autoType) ? getStackedType(index || 0) : null;

        return {
            from: oldValue,
            to: newValue,
            type: type,
            animate: animate
        };
    };

    function getStackedType(index) {
        return stackedTypes[index];
    }

    this.addBar = function(bar) {
        $scope.bars.push(bar);
        $scope.totalPercent += bar.to;
    };

    this.clearBars = function() {
        $scope.bars = [];
        $scope.totalPercent = 0;
    };
    this.clearBars();
}])

.directive('progress', function() {
    return {
        restrict: 'EA',
        replace: true,
        controller: 'ProgressBarController',
        scope: {
            value: '=percent',
            onFull: '&',
            onEmpty: '&'
        },
        templateUrl: 'template/progressbar/progress.html',
        link: function(scope, element, attrs, controller) {
            scope.$watch('value', function(newValue, oldValue) {
                controller.clearBars();

                if (angular.isArray(newValue)) {
                    // Stacked progress bar
                    for (var i=0, n=newValue.length; i < n; i++) {
                        controller.addBar(controller.makeBar(newValue[i], oldValue[i], i));
                    }
                } else {
                    // Simple bar
                    controller.addBar(controller.makeBar(newValue, oldValue));
                }
            }, true);

            // Total percent listeners
            scope.$watch('totalPercent', function(value) {
              if (value >= 100) {
                scope.onFull();
              } else if (value <= 0) {
                scope.onEmpty();
              }
            }, true);
        }
    };
})

.directive('progressbar', ['$transition', function($transition) {
    return {
        restrict: 'EA',
        replace: true,
        scope: {
            width: '=',
            old: '=',
            type: '=',
            animate: '='
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element) {
            scope.$watch('width', function(value) {
                if (scope.animate) {
                    element.css('width', scope.old + '%');
                    $transition(element, {width: value + '%'});
                } else {
                    element.css('width', value + '%');
                }
            });
        }
    };
}]);
angular.module('ui.bootstrap.rating', [])

.constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
})

.controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {

  this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
  this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
  this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

  this.createDefaultRange = function(len) {
    var defaultStateObject = {
      stateOn: this.stateOn,
      stateOff: this.stateOff
    };

    var states = new Array(len);
    for (var i = 0; i < len; i++) {
      states[i] = defaultStateObject;
    }
    return states;
  };

  this.normalizeRange = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i].stateOn = states[i].stateOn || this.stateOn;
      states[i].stateOff = states[i].stateOff || this.stateOff;
    }
    return states;
  };

  // Get objects used in template
  $scope.range = angular.isDefined($attrs.ratingStates) ?  this.normalizeRange(angular.copy($scope.$parent.$eval($attrs.ratingStates))): this.createDefaultRange(this.maxRange);

  $scope.rate = function(value) {
    if ( $scope.readonly || $scope.value === value) {
      return;
    }

    $scope.value = value;
  };

  $scope.enter = function(value) {
    if ( ! $scope.readonly ) {
      $scope.val = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.val = angular.copy($scope.value);
    $scope.onLeave();
  };

  $scope.$watch('value', function(value) {
    $scope.val = value;
  });

  $scope.readonly = false;
  if ($attrs.readonly) {
    $scope.$parent.$watch($parse($attrs.readonly), function(value) {
      $scope.readonly = !!value;
    });
  }
}])

.directive('rating', function() {
  return {
    restrict: 'EA',
    scope: {
      value: '=',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true
  };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.directive('tabs', function() {
  return function() {
    throw new Error("The `tabs` directive is deprecated, please migrate to `tabset`. Instructions can be found at http://github.com/angular-ui/bootstrap/tree/master/CHANGELOG.md");
  };
})

.controller('TabsetController', ['$scope', '$element',
function TabsetCtrl($scope, $element) {

  var ctrl = this,
    tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(tab) {
    angular.forEach(tabs, function(tab) {
      tab.active = false;
    });
    tab.active = true;
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    if (tabs.length === 1 || tab.active) {
      ctrl.select(tab);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected
    if (tab.active && tabs.length > 1) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {string=} direction  What direction the tabs should be rendered. Available:
 * 'right', 'left', 'below'.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Vertical Tab 1"><b>First</b> Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    require: '^tabset',
    scope: {},
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    compile: function(elm, attrs, transclude) {
      return function(scope, element, attrs, tabsetCtrl) {
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
        scope.direction = angular.isDefined(attrs.direction) ? scope.$parent.$eval(attrs.direction) : 'top';
        scope.tabsAbove = (scope.direction != 'below');
        tabsetCtrl.$scope = scope;
        tabsetCtrl.$transcludeFn = transclude;
      };
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', '$http', '$templateCache', '$compile',
function($parse, $http, $templateCache, $compile) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    compile: function(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {
        var getActive, setActive;
        if (attrs.active) {
          getActive = $parse(attrs.active);
          setActive = getActive.assign;
          scope.$parent.$watch(getActive, function updateActive(value) {
            scope.active = !!value;
          });
          scope.active = getActive(scope.$parent);
        } else {
          setActive = getActive = angular.noop;
        }

        scope.$watch('active', function(active) {
          setActive(scope.$parent, active);
          if (active) {
            tabsetCtrl.select(scope);
            scope.onSelect();
          } else {
            scope.onDeselect();
          }
        });

        scope.disabled = false;
        if ( attrs.disabled ) {
          scope.$parent.$watch($parse(attrs.disabled), function(value) {
            scope.disabled = !! value;
          });
        }

        scope.select = function() {
          if ( ! scope.disabled ) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });
        if (scope.active) {
          setActive(scope.$parent, true);
        }


        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}])

.directive('tabHeadingTransclude', [function() {
  return {
    restrict: 'A',
    require: '^tab',
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
}])

.directive('tabContentTransclude', ['$compile', '$parse', function($compile, $parse) {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName &&  (
      node.hasAttribute('tab-heading') ||
      node.hasAttribute('data-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' ||
      node.tagName.toLowerCase() === 'data-tab-heading'
    );
  }
}])

.directive('tabsetTitles', ['$http', function($http) {
  return {
    restrict: 'A',
    require: '^tabset',
    templateUrl: 'template/tabs/tabset-titles.html',
    replace: true,
    link: function(scope, elm, attrs, tabsetCtrl) {
      if (!scope.$eval(attrs.tabsetTitles)) {
        elm.remove();
      } else {
        //now that tabs location has been decided, transclude the tab titles in
        tabsetCtrl.$transcludeFn(tabsetCtrl.$scope.$parent, function(node) {
          elm.append(node);
        });
      }
    }
  };
}])

;


angular.module('ui.bootstrap.timepicker', [])

.constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: ['AM', 'PM'],
  readonlyInput: false,
  mousewheel: true
})

.directive('timepicker', ['$parse', '$log', 'timepickerConfig', function ($parse, $log, timepickerConfig) {
  return {
    restrict: 'EA',
    require:'?^ngModel',
    replace: true,
    scope: {},
    templateUrl: 'template/timepicker/timepicker.html',
    link: function(scope, element, attrs, ngModel) {
      if ( !ngModel ) {
        return; // do nothing if no ng-model
      }

      var selected = new Date(), meridians = timepickerConfig.meridians;

      var hourStep = timepickerConfig.hourStep;
      if (attrs.hourStep) {
        scope.$parent.$watch($parse(attrs.hourStep), function(value) {
          hourStep = parseInt(value, 10);
        });
      }

      var minuteStep = timepickerConfig.minuteStep;
      if (attrs.minuteStep) {
        scope.$parent.$watch($parse(attrs.minuteStep), function(value) {
          minuteStep = parseInt(value, 10);
        });
      }

      // 12H / 24H mode
      scope.showMeridian = timepickerConfig.showMeridian;
      if (attrs.showMeridian) {
        scope.$parent.$watch($parse(attrs.showMeridian), function(value) {
          scope.showMeridian = !!value;

          if ( ngModel.$error.time ) {
            // Evaluate from template
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            if (angular.isDefined( hours ) && angular.isDefined( minutes )) {
              selected.setHours( hours );
              refresh();
            }
          } else {
            updateTemplate();
          }
        });
      }

      // Get scope.hours in 24H mode if valid
      function getHoursFromTemplate ( ) {
        var hours = parseInt( scope.hours, 10 );
        var valid = ( scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
        if ( !valid ) {
          return undefined;
        }

        if ( scope.showMeridian ) {
          if ( hours === 12 ) {
            hours = 0;
          }
          if ( scope.meridian === meridians[1] ) {
            hours = hours + 12;
          }
        }
        return hours;
      }

      function getMinutesFromTemplate() {
        var minutes = parseInt(scope.minutes, 10);
        return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;
      }

      function pad( value ) {
        return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;
      }

      // Input elements
      var inputs = element.find('input'), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);

      // Respond on mousewheel spin
      var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
      if ( mousewheel ) {

        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          //pick correct delta variable depending on event
          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
          return (e.detail || delta > 0);
        };

        hoursInputEl.bind('mousewheel wheel', function(e) {
          scope.$apply( (isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours() );
          e.preventDefault();
        });

        minutesInputEl.bind('mousewheel wheel', function(e) {
          scope.$apply( (isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes() );
          e.preventDefault();
        });
      }

      scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
      if ( ! scope.readonlyInput ) {

        var invalidate = function(invalidHours, invalidMinutes) {
          ngModel.$setViewValue( null );
          ngModel.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            scope.invalidMinutes = invalidMinutes;
          }
        };

        scope.updateHours = function() {
          var hours = getHoursFromTemplate();

          if ( angular.isDefined(hours) ) {
            selected.setHours( hours );
            refresh( 'h' );
          } else {
            invalidate(true);
          }
        };

        hoursInputEl.bind('blur', function(e) {
          if ( !scope.validHours && scope.hours < 10) {
            scope.$apply( function() {
              scope.hours = pad( scope.hours );
            });
          }
        });

        scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate();

          if ( angular.isDefined(minutes) ) {
            selected.setMinutes( minutes );
            refresh( 'm' );
          } else {
            invalidate(undefined, true);
          }
        };

        minutesInputEl.bind('blur', function(e) {
          if ( !scope.invalidMinutes && scope.minutes < 10 ) {
            scope.$apply( function() {
              scope.minutes = pad( scope.minutes );
            });
          }
        });
      } else {
        scope.updateHours = angular.noop;
        scope.updateMinutes = angular.noop;
      }

      ngModel.$render = function() {
        var date = ngModel.$modelValue ? new Date( ngModel.$modelValue ) : null;

        if ( isNaN(date) ) {
          ngModel.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if ( date ) {
            selected = date;
          }
          makeValid();
          updateTemplate();
        }
      };

      // Call internally when we know that model is valid.
      function refresh( keyboardChange ) {
        makeValid();
        ngModel.$setViewValue( new Date(selected) );
        updateTemplate( keyboardChange );
      }

      function makeValid() {
        ngModel.$setValidity('time', true);
        scope.invalidHours = false;
        scope.invalidMinutes = false;
      }

      function updateTemplate( keyboardChange ) {
        var hours = selected.getHours(), minutes = selected.getMinutes();

        if ( scope.showMeridian ) {
          hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
        }
        scope.hours =  keyboardChange === 'h' ? hours : pad(hours);
        scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
        scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }

      function addMinutes( minutes ) {
        var dt = new Date( selected.getTime() + minutes * 60000 );
        selected.setHours( dt.getHours(), dt.getMinutes() );
        refresh();
      }

      scope.incrementHours = function() {
        addMinutes( hourStep * 60 );
      };
      scope.decrementHours = function() {
        addMinutes( - hourStep * 60 );
      };
      scope.incrementMinutes = function() {
        addMinutes( minuteStep );
      };
      scope.decrementMinutes = function() {
        addMinutes( - minuteStep );
      };
      scope.toggleMeridian = function() {
        addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );
      };
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('typeaheadParser', ['$parse', function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

  return {
    parse:function (input) {

      var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
      if (!match) {
        throw new Error(
          "Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" +
            " but got '" + input + "'.");
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',
    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require:'ngModel',
    link:function (originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typehead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);


      //pop-up element used to display matches
      var popUpEl = angular.element('<typeahead-popup></typeahead-popup>');
      popUpEl.attr({
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        query: 'query',
        position: 'position'
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function(){
        scope.$destroy();
      });

      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
      };

      var getMatchesAsync = function(inputValue) {

        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(scope, locals)).then(function(matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          if (inputValue === modelCtrl.$viewValue) {
            if (matches.length > 0) {

              scope.activeIdx = 0;
              scope.matches.length = 0;

              //transform labels
              for(var i=0; i<matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');

            } else {
              resetMatches();
            }
            isLoadingSetter(originalScope, false);
          }
        }, function(){
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
      var timeoutPromise;

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        resetMatches();
        if (inputValue && inputValue.length >= minSearch) {
          if (waitTime > 0) {
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);//cancel previous timeout
            }
            timeoutPromise = $timeout(function () {
              getMatchesAsync(inputValue);
            }, waitTime);
          } else {
            getMatchesAsync(inputValue);
          }
        }

        if (isEditable) {
          return inputValue;
        } else {
          modelCtrl.$setValidity('editable', false);
          return undefined;
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        if (inputFormatter) {

          locals['$model'] = modelValue;
          return inputFormatter(originalScope, locals);

        } else {

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a mach was selected via a mouse click event
        element[0].focus();
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind('keydown', function (evt) {

        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();

        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();

        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });

        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function (evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind('click', dismissClickHandler);

      originalScope.$on('$destroy', function(){
        $document.unbind('click', dismissClickHandler);
      });

      element.after($compile(popUpEl)(scope));
    }
  };

}])

  .directive('typeaheadPopup', function () {
    return {
      restrict:'E',
      scope:{
        matches:'=',
        query:'=',
        active:'=',
        position:'=',
        select:'&'
      },
      replace:true,
      templateUrl:'template/typeahead/typeahead-popup.html',
      link:function (scope, element, attrs) {

        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function () {
          return scope.matches.length > 0;
        };

        scope.isActive = function (matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function (matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function (activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
    return {
      restrict:'E',
      scope:{
        index:'=',
        match:'=',
        query:'='
      },
      link:function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){
           element.replaceWith($compile(tplContent.trim())(scope));
        });
      }
    };
  }])

  .filter('typeaheadHighlight', function() {

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }

    return function(matchItem, query) {
      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
    };
  });
angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion-group.html",
    "<div class=\"accordion-group\">\n" +
    "  <div class=\"accordion-heading\" ><a class=\"accordion-toggle\" ng-click=\"isOpen = !isOpen\" accordion-transclude=\"heading\">{{heading}}</a></div>\n" +
    "  <div class=\"accordion-body\" collapse=\"!isOpen\">\n" +
    "    <div class=\"accordion-inner\" ng-transclude></div>  </div>\n" +
    "</div>");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion.html",
    "<div class=\"accordion\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/alert/alert.html",
    "<div class='alert' ng-class='type && \"alert-\" + type'>\n" +
    "    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\">\n" +
    "    <ol class=\"carousel-indicators\" ng-show=\"slides().length > 1\">\n" +
    "        <li ng-repeat=\"slide in slides()\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
    "    </ol>\n" +
    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "    <a ng-click=\"prev()\" class=\"carousel-control left\" ng-show=\"slides().length > 1\">&lsaquo;</a>\n" +
    "    <a ng-click=\"next()\" class=\"carousel-control right\" ng-show=\"slides().length > 1\">&rsaquo;</a>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': leaving || (active && !entering),\n" +
    "    'prev': (next || active) && direction=='prev',\n" +
    "    'next': (next || active) && direction=='next',\n" +
    "    'right': direction=='prev',\n" +
    "    'left': direction=='next'\n" +
    "  }\" class=\"item\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<table>\n" +
    "  <thead>\n" +
    "    <tr class=\"text-center\">\n" +
    "      <th><button type=\"button\" class=\"btn pull-left\" ng-click=\"move(-1)\"><i class=\"icon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{rows[0].length - 2 + showWeekNumbers}}\"><button type=\"button\" class=\"btn btn-block\" ng-click=\"toggleMode()\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn pull-right\" ng-click=\"move(1)\"><i class=\"icon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"labels.length > 0\">\n" +
    "      <th ng-show=\"showWeekNumbers\">#</th>\n" +
    "      <th ng-repeat=\"label in labels\">{{label}}</th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows\">\n" +
    "      <td ng-show=\"showWeekNumbers\" class=\"text-center\"><em>{{ getWeekNumber(row) }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"text-center\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn\" ng-class=\"{'btn-info': dt.selected}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\"><span ng-class=\"{muted: dt.secondary}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" class=\"dropdown-menu\">\n" +
    "	<li ng-transclude></li>\n" +
    "	<li class=\"divider\"></li>\n" +
    "	<li style=\"padding: 9px;\">\n" +
    "		<span class=\"btn-group\">\n" +
    "			<button class=\"btn btn-small btn-inverse\" ng-click=\"today()\">Today</button>\n" +
    "			<button class=\"btn btn-small btn-info\" ng-click=\"showWeeks = ! showWeeks\" ng-class=\"{active: showWeeks}\">Weeks</button>\n" +
    "			<button class=\"btn btn-small btn-danger\" ng-click=\"clear()\">Clear</button>\n" +
    "		</span>\n" +
    "		<button class=\"btn btn-small btn-success pull-right\" ng-click=\"isOpen = false\">Close</button>\n" +
    "	</li>\n" +
    "</ul>");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/backdrop.html",
    "<div class=\"modal-backdrop fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1040 + index*10}\" ng-click=\"close($event)\"></div>");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/window.html",
    "<div class=\"modal fade {{ windowClass }}\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10}\" ng-transclude></div>");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<div class=\"pager\">\n" +
    "  <ul>\n" +
    "    <li ng-repeat=\"page in pages\" ng-class=\"{disabled: page.disabled, previous: page.previous, next: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<div class=\"pagination\"><ul>\n" +
    "  <li ng-repeat=\"page in pages\" ng-class=\"{active: page.active, disabled: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind-html-unsafe=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover.html",
    "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/bar.html",
    "<div class=\"bar\" ng-class='type && \"bar-\" + type'></div>");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progress.html",
    "<div class=\"progress\"><progressbar ng-repeat=\"bar in bars\" width=\"bar.to\" old=\"bar.from\" animate=\"bar.animate\" type=\"bar.type\"></progressbar></div>");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\">\n" +
    "	<i ng-repeat=\"r in range\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" ng-class=\"$index < val && (r.stateOn || 'icon-star') || (r.stateOff || 'icon-star-empty')\"></i>\n" +
    "</span>");
}]);

angular.module("template/tabs/pane.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/pane.html",
    "<div class=\"tab-pane\" ng-class=\"{active: selected}\" ng-show=\"selected\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
    "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabs.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabs.html",
    "<div class=\"tabbable\">\n" +
    "  <ul class=\"nav nav-tabs\">\n" +
    "    <li ng-repeat=\"pane in panes\" ng-class=\"{active:pane.selected}\">\n" +
    "      <a ng-click=\"select(pane)\">{{pane.heading}}</a>\n" +
    "    </li>\n" +
    "  </ul>\n" +
    "  <div class=\"tab-content\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tabs/tabset-titles.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset-titles.html",
    "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "\n" +
    "<div class=\"tabbable\" ng-class=\"{'tabs-right': direction == 'right', 'tabs-left': direction == 'left', 'tabs-below': direction == 'below'}\">\n" +
    "  <div tabset-titles=\"tabsAbove\"></div>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div tabset-titles=\"!tabsAbove\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/timepicker/timepicker.html",
    "<table class=\"form-inline\">\n" +
    "	<tr class=\"text-center\">\n" +
    "		<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
    "		<td>&nbsp;</td>\n" +
    "		<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
    "		<td ng-show=\"showMeridian\"></td>\n" +
    "	</tr>\n" +
    "	<tr>\n" +
    "		<td class=\"control-group\" ng-class=\"{'error': invalidHours}\"><input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"span1 text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\" /></td>\n" +
    "		<td>:</td>\n" +
    "		<td class=\"control-group\" ng-class=\"{'error': invalidMinutes}\"><input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"span1 text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\"></td>\n" +
    "		<td ng-show=\"showMeridian\"><button type=\"button\" ng-click=\"toggleMeridian()\" class=\"btn text-center\">{{meridian}}</button></td>\n" +
    "	</tr>\n" +
    "	<tr class=\"text-center\">\n" +
    "		<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
    "		<td>&nbsp;</td>\n" +
    "		<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
    "		<td ng-show=\"showMeridian\"></td>\n" +
    "	</tr>\n" +
    "</table>");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-match.html",
    "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-popup.html",
    "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
    "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\">\n" +
    "        <typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></typeahead-match>\n" +
    "    </li>\n" +
    "</ul>");
}]);

angular.module("template/typeahead/typeahead.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead.html",
    "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
    "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\">\n" +
    "        <a tabindex=\"-1\" ng-click=\"selectMatch($index)\" ng-bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>\n" +
    "    </li>\n" +
    "</ul>");
}]);
},{}],20:[function(require,module,exports){
/**
 * State-based routing for AngularJS
 * @version v0.2.0
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] === "") continue;
    if (!second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i].params || !parents[i].params.length) continue;
    parentParams = parents[i].params;

    for (var j in parentParams) {
      if (inheritList.indexOf(parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

angular.module('ui.router.util', ['ng']);
angular.module('ui.router.router', ['ui.router.util']);
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
angular.module('ui.router', ['ui.router.state']);
angular.module('ui.router.compat', ['ui.router']);


/**
 * Service (`ui-util`). Manages resolution of (acyclic) graphs of promises.
 * @module $resolve
 * @requires $q
 * @requires $injector
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {
  
  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
  

  /**
   * Studies a set of invocables that are likely to be used multiple times.
   *      $resolve.study(invocables)(locals, parent, self)
   * is equivalent to
   *      $resolve.resolve(invocables, locals, parent, self)
   * but the former is more efficient (in fact `resolve` just calls `study` internally).
   * See {@link module:$resolve/resolve} for details.
   * @function
   * @param {Object} invocables
   * @return {Function}
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
    
    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;
      
      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, cycle.indexOf(key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;
      
      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(key); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }
      
      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required
    
    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }
    
    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }       
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }
      
      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = resolution.promise,
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;
          
      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values); 
          result.$$values = values;
          result.$$promises = true; // keep for isResolve()
          resolution.resolve(values);
        }
      }
      
      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }
      
      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }
      
      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      if (parent.$$values) {
        merged = merge(values, parent.$$values);
        done();
      } else {
        extend(promises, parent.$$promises);
        parent.then(done, fail);
      }
      
      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }
      
      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        params.forEach(function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = invocation.promise;
      }
      
      return result;
    };
  };
  
  /**
   * Resolves a set of invocables. An invocable is a function to be invoked via `$injector.invoke()`,
   * and can have an arbitrary number of dependencies. An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the resulting value will be
   * used instead. Dependencies of invocables are resolved (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve` (or recursively
   *   from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises returned by injectables
   * have been resolved. If any invocable (or `$injector.invoke`) throws an exception, or if a promise
   * returned by an invocable is rejected, the `$resolve` promise is immediately rejected with the same error.
   * A rejection of a `parent` promise (if specified) will likewise be propagated immediately. Once the
   * `$resolve` promise has been rejected, no further invocables will be called.
   * 
   * Cyclic dependencies between invocables are not permitted and will caues `$resolve` to throw an
   * error. As a special case, an injectable can depend on a parameter with the same name as the injectable,
   * which will be fulfilled from the `parent` injectable of the same name. This allows inherited values
   * to be decorated. Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an (asynchronous) rejection
   * of the `$resolve` promise rather than a (synchronous) exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available. This is true even for
   * dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to be a service name
   * to be passed to `$injector.get()`. This is supported primarily for backwards-compatibility with the
   * `resolve` property of `$routeProvider` routes.
   *
   * @function
   * @param {Object.<string, Function|string>} invocables  functions to invoke or `$injector` services to fetch.
   * @param {Object.<string, *>} [locals]  values to make available to the injectables
   * @param {Promise.<Object>} [parent]  a promise returned by another call to `$resolve`.
   * @param {Object} [self]  the `this` for the invoked methods
   * @return {Promise.<Object>}  Promise for an object that contains the resolved return value
   *    of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);


/**
 * Service. Manages loading of templates.
 * @constructor
 * @name $templateFactory
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 */
$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
function $TemplateFactory(  $http,   $templateCache,   $injector) {

  /**
   * Creates a template from a configuration object. 
   * @function
   * @name $templateFactory#fromConfig
   * @methodOf $templateFactory
   * @param {Object} config  Configuration object for which to load a template. The following
   *    properties are search in the specified order, and the first one that is defined is
   *    used to create the template:
   * @param {string|Function} config.template  html string template or function to load via
   *    {@link $templateFactory#fromString fromString}.
   * @param {string|Function} config.templateUrl  url to load or a function returning the url
   *    to load via {@link $templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider  function to invoke via
   *    {@link $templateFactory#fromProvider fromProvider}.
   * @param {Object} params  Parameters to pass to the template function.
   * @param {Object} [locals] Locals to pass to `invoke` if the template is loaded via a
   *      `templateProvider`. Defaults to `{ params: params }`.
   * @return {string|Promise.<string>}  The template html as a string, or a promise for that string,
   *      or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * Creates a template from a string or a function returning a string.
   * @function
   * @name $templateFactory#fromString
   * @methodOf $templateFactory
   * @param {string|Function} template  html template as a string or function that returns an html
   *      template as a string.
   * @param {Object} params  Parameters to pass to the template function.
   * @return {string|Promise.<string>}  The template html as a string, or a promise for that string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * Loads a template from the a URL via `$http` and `$templateCache`.
   * @function
   * @name $templateFactory#fromUrl
   * @methodOf $templateFactory
   * @param {string|Function} url  url of the template to load, or a function that returns a url.
   * @param {Object} params  Parameters to pass to the url function.
   * @return {string|Promise.<string>}  The template html as a string, or a promise for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else return $http
        .get(url, { cache: $templateCache })
        .then(function(response) { return response.data; });
  };

  /**
   * Creates a template by invoking an injectable provider function.
   * @function
   * @name $templateFactory#fromUrl
   * @methodOf $templateFactory
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} [locals] Locals to pass to `invoke`. Defaults to `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

/**
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link UrlMatcher#exec exec}.
 * 
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * ':' name - colon placeholder
 * * '*' name - catch-all placeholder
 * * '{' name '}' - curly placeholder
 * * '{' name ':' regexp '}' - curly placeholder with regexp. Should the regexp itself contain
 *   curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon 
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 * 
 * ### Examples
 * 
 * * '/hello/' - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * '/user/:id' - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * '/user/{id}' - Same as the previous example, but using curly brace syntax.
 * * '/user/{id:[^/]*}' - Same as the previous example.
 * * '/user/{id:[0-9a-fA-F]{1,8}}' - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * '/files/{path:.*}' - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * '/files/*path' - ditto.
 *
 * @constructor
 * @param {string} pattern  the pattern to compile into a matcher.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link UrlMatcher#exec exec()} returns
 *   non-null) will start with this prefix.
 */
function UrlMatcher(pattern) {

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])(\w+)               classic placeholder ($1 / $2)
  //    \{(\w+)(?:\:( ... ))?\}   curly brace placeholder ($3) with optional regexp ... ($4)
  //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                  - anything other than curly braces or backslash
  //    \\.                       - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}     - a matched set of curly braces containing other atoms
  var placeholder = /([:*])(\w+)|\{(\w+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      names = {}, compiled = '^', last = 0, m,
      segments = this.segments = [],
      params = this.params = [];

  function addParameter(id) {
    if (!/^\w+(-+\w+)*$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (names[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    names[id] = true;
    params.push(id);
  }

  function quoteRegExp(string) {
    return string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  var id, regexp, segment;
  while ((m = placeholder.exec(pattern))) {
    id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    regexp = m[4] || (m[1] == '*' ? '.*' : '[^/]*');
    segment = pattern.substring(last, m.index);
    if (segment.indexOf('?') >= 0) break; // we're into the search part
    compiled += quoteRegExp(segment) + '(' + regexp + ')';
    addParameter(id);
    segments.push(segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');
  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last+i);

    // Allow parameters to be separated by '?' as well as '&' to make concat() easier
    forEach(search.substring(1).split(/[&?]/), addParameter);
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + '$';
  segments.push(segment);
  this.regexp = new RegExp(compiled);
  this.prefix = segments[0];
}

/**
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * ### Example
 * The following two matchers are equivalent:
 * ```
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * ```
 *
 * @param {string} pattern  The pattern to append.
 * @return {UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * ### Example
 * ```
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', { x:'1', q:'hello' });
 * // returns { id:'bob', q:'hello', r:null }
 * ```
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @return {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;

  var params = this.params, nTotal = params.length,
    nPath = this.segments.length-1,
    values = {}, i;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  for (i=0; i<nPath; i++) values[params[i]] = m[i+1];
  for (/**/; i<nTotal; i++) values[params[i]] = searchParams[params[i]];

  return values;
};

/**
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 * @return {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function () {
  return this.params;
};

/**
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * ### Example
 * ```
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * ```
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @return {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  var segments = this.segments, params = this.params;
  if (!values) return segments.join('');

  var nPath = segments.length-1, nTotal = params.length,
    result = segments[0], i, search, value;

  for (i=0; i<nPath; i++) {
    value = values[params[i]];
    // TODO: Maybe we should throw on null here? It's not really good style to use '' and null interchangeabley
    if (value != null) result += encodeURIComponent(value);
    result += segments[i+1];
  }
  for (/**/; i<nTotal; i++) {
    value = values[params[i]];
    if (value != null) {
      result += (search ? '&' : '?') + params[i] + '=' + encodeURIComponent(value);
      search = true;
    }
  }

  return result;
};

/**
 * Service. Factory for {@link UrlMatcher} instances. The factory is also available to providers
 * under the name `$urlMatcherFactoryProvider`.
 * @constructor
 * @name $urlMatcherFactory
 */
function $UrlMatcherFactory() {
  /**
   * Creates a {@link UrlMatcher} for the specified pattern.
   * @function
   * @name $urlMatcherFactory#compile
   * @methodOf $urlMatcherFactory
   * @param {string} pattern  The URL pattern.
   * @return {UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern) {
    return new UrlMatcher(pattern);
  };

  /**
   * Returns true if the specified object is a UrlMatcher, or false otherwise.
   * @function
   * @name $urlMatcherFactory#isMatcher
   * @methodOf $urlMatcherFactory
   * @param {Object} o
   * @return {boolean}
   */
  this.isMatcher = function (o) {
    return isObject(o) && isFunction(o.exec) && isFunction(o.format) && isFunction(o.concat);
  };

  this.$get = function () {
    return this;
  };
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);


$UrlRouterProvider.$inject = ['$urlMatcherFactoryProvider'];
function $UrlRouterProvider(  $urlMatcherFactory) {
  var rules = [], 
      otherwise = null;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  this.rule =
    function (rule) {
      if (!isFunction(rule)) throw new Error("'rule' must be a function");
      rules.push(rule);
      return this;
    };

  this.otherwise =
    function (rule) {
      if (isString(rule)) {
        var redirect = rule;
        rule = function () { return redirect; };
      }
      else if (!isFunction(rule)) throw new Error("'rule' must be a function");
      otherwise = rule;
      return this;
    };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  this.when =
    function (what, handler) {
      var redirect, handlerIsString = isString(handler);
      if (isString(what)) what = $urlMatcherFactory.compile(what);

      if (!handlerIsString && !isFunction(handler) && !isArray(handler))
        throw new Error("invalid 'handler' in when()");

      var strategies = {
        matcher: function (what, handler) {
          if (handlerIsString) {
            redirect = $urlMatcherFactory.compile(handler);
            handler = ['$match', function ($match) { return redirect.format($match); }];
          }
          return extend(function ($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
          }, {
            prefix: isString(what.prefix) ? what.prefix : ''
          });
        },
        regex: function (what, handler) {
          if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

          if (handlerIsString) {
            redirect = handler;
            handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
          }
          return extend(function ($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path()));
          }, {
            prefix: regExpPrefix(what)
          });
        }
      };

      var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

      for (var n in check) {
        if (check[n]) {
          return this.rule(strategies[n](what, handler));
        }
      }

      throw new Error("invalid 'what' in when()");
    };

  this.$get =
    [        '$location', '$rootScope', '$injector',
    function ($location,   $rootScope,   $injector) {
      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
      function update() {
        function check(rule) {
          var handled = rule($injector, $location);
          if (handled) {
            if (isString(handled)) $location.replace().url(handled);
            return true;
          }
          return false;
        }
        var n=rules.length, i;
        for (i=0; i<n; i++) {
          if (check(rules[i])) return;
        }
        // always check otherwise last to allow dynamic updates to the set of rules
        if (otherwise) check(otherwise);
      }

      $rootScope.$on('$locationChangeSuccess', update);
      return {};
    }];
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider', '$locationProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory,           $locationProvider) {

  var root, states = {}, $state;

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = angular.extend({}, state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url;

      if (isString(url)) {
        if (url.charAt(0) == '^') {
          return $urlMatcherFactory.compile(url.substring(1));
        }
        return (state.parent.navigable || root).url.concat(url);
      }

      if ($urlMatcherFactory.isMatcher(url) || url == null) {
        return url;
      }
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      if (!state.params) {
        return state.url ? state.url.parameters() : state.parent.params;
      }
      if (!isArray(state.params)) throw new Error("Invalid params in state '" + state + "'");
      if (state.url) throw new Error("Both params and url specicified in state '" + state + "'");
      return state.params;
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    ownParams: function(state) {
      if (!state.parent) {
        return state.params;
      }
      var paramNames = {}; forEach(state.params, function (p) { paramNames[p] = true; });

      forEach(state.parent.params, function (p) {
        if (!paramNames[p]) {
          throw new Error("Missing required parameter '" + p + "' in state '" + state.name + "'");
        }
        paramNames[p] = false;
      });
      var ownParams = [];

      forEach(paramNames, function (own, p) {
        if (own) ownParams.push(p);
      });
      return ownParams;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    }
  };


  function findState(stateOrName, base) {
    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = name.indexOf(".") === 0 || name.indexOf("^") === 0;

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }


  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states[name]) throw new Error("State '" + name + "'' is already defined");

    for (var key in stateBuilder) {
      state[key] = stateBuilder[key](state);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state['abstract'] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, false);
        }
      }]);
    }
    return state;
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  // .state(state)
  // .state(name, state)
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  // $urlRouter is injected just to ensure it gets instantiated
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$location', '$urlRouter'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $location,   $urlRouter) {

    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
    var TransitionPrevented = $q.reject(new Error('transition prevented'));

    root.locals = { resolve: null, globals: { $stateParams: {} } };
    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    $state.go = function go(to, params, options) {
      return this.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    $state.transitionTo = function transitionTo(to, toParams, options) {
      if (!isDefined(options)) options = (options === true || options === false) ? { location: options } : {};
      toParams = toParams || {};
      options = extend({ location: true, inherit: false, relative: null }, options);

      var toState = findState(to, options.relative);
      if (!isDefined(toState)) throw new Error("No such state " + toState);
      if (toState['abstract']) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      to = toState;

      var toPath = to.path,
          from = $state.$current, fromParams = $state.params, fromPath = from.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep, state, locals = root.locals, toLocals = [];
      for (keep = 0, state = toPath[keep];
           state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams);
           keep++, state = toPath[keep]) {
        locals = toLocals[keep] = state.locals;
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change that we've initiated ourselves,
      // because we might accidentally abort a legitimate transition initiated from code?
      if (to === from && locals === from.locals) {
        $state.transition = null;
        return $q.when($state.current);
      }

      // Normalize/filter parameters before we pass them to event handlers etc.
      toParams = normalize(to.params, toParams || {});

      // Broadcast start event and cancel the transition if requested
      var evt = $rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams);
      if (evt.defaultPrevented) return TransitionPrevented;

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);
      for (var l=keep; l<toPath.length; l++, state=toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state===to, resolved, locals);
      }

      // Once everything is resolved, wer are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit 'from' states not kept
        for (l=fromPath.length-1; l>=keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l=keep; l<toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        // Update $location
        var toNav = to.navigable;
        if (options.location && toNav) {
          $location.url(toNav.url.format(toNav.locals.globals.$stateParams));
        }

        $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

        return $q.reject(error);
      });

      return transition;
    };

    $state.is = function is(stateOrName) {
      var state = findState(stateOrName);
      return (isDefined(state)) ? $state.$current === state : undefined;
    };

    $state.includes = function includes(stateOrName) {
      var state = findState(stateOrName);
      return (isDefined(state)) ? isDefined($state.$current.includes[state.name]) : undefined;
    };

    $state.href = function href(stateOrName, params, options) {
      options = extend({ lossy: true, inherit: false, relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) return null;

      params = inheritParams($stateParams, params || {}, $state.$current, state);
      var nav = (state && options.lossy) ? state.navigable : state;
      var url = (nav && nav.url) ? nav.url.format(normalize(state.params, params || {})) : null;
      return !$locationProvider.html5Mode() && url ? "#" + url : url;
    };

    $state.get = function (stateOrName) {
      var state = findState(stateOrName);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params, params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [ dst.resolve.then(function (globals) {
        dst.globals = globals;
      }) ];
      if (inherited) promises.push(inherited);

      // Resolve template and dependencies for all views.
      forEach(state.views, function (view, name) {
        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
        injectables.$template = [ function () {
          return $view.load(name, { view: view, locals: locals, params: $stateParams, notify: false }) || '';
        }];

        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {
          // References to the controller (only instantiated at link time)
          result.$$controller = view.controller;
          // Provide access to the state itself for internal use
          result.$$state = state;
          dst[name] = result;
        }));
      });

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function normalize(keys, values) {
    var normalized = {};

    forEach(keys, function (name) {
      var value = values[name];
      normalized[name] = (value != null) ? String(value) : null;
    });
    return normalized;
  }

  function equalForKeys(a, b, keys) {
    // If keys not provided, assume keys from object 'a'
    if (!keys) {
      keys = [];
      for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
    }

    for (var i=0; i<keys.length; i++) {
      var k = keys[i];
      if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
    }
    return true;
  }

  function filterByKeys(keys, values) {
    var filtered = {};

    forEach(keys, function (name) {
      filtered[name] = values[name];
    });
    return filtered;
  }
}

angular.module('ui.router.state')
  .value('$stateParams', {})
  .provider('$state', $StateProvider);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        if (result && options.notify) {
          $rootScope.$broadcast('$viewContentLoading', options);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);


$ViewDirective.$inject = ['$state', '$compile', '$controller', '$injector', '$anchorScroll'];
function $ViewDirective(   $state,   $compile,   $controller,   $injector,   $anchorScroll) {
  // TODO: Change to $injector.has() when we version bump to Angular 1.1.5.
  // See: https://github.com/angular/angular.js/blob/master/CHANGELOG.md#115-triangle-squarification-2013-05-22
  var $animator; try { $animator = $injector.get('$animator'); } catch (e) { /* do nothing */ }
  var viewIsUpdating = false;

  var directive = {
    restrict: 'ECA',
    terminal: true,
    transclude: true,
    compile: function (element, attr, transclude) {
      return function(scope, element, attr) {
        var viewScope, viewLocals,
            name = attr[directive.name] || attr.name || '',
            onloadExp = attr.onload || '',
            animate = isDefined($animator) && $animator(scope, attr);

        // Returns a set of DOM manipulation functions based on whether animation
        // should be performed
        var renderer = function(doAnimate) {
          return ({
            "true": {
              remove: function(element) { animate.leave(element.contents(), element); },
              restore: function(compiled, element) { animate.enter(compiled, element); },
              populate: function(template, element) {
                var contents = angular.element('<div></div>').html(template).contents();
                animate.enter(contents, element);
                return contents;
              }
            },
            "false": {
              remove: function(element) { element.html(''); },
              restore: function(compiled, element) { element.append(compiled); },
              populate: function(template, element) {
                element.html(template);
                return element.contents();
              }
            }
          })[doAnimate.toString()];
        };

        // Put back the compiled initial view
        element.append(transclude(scope));

        // Find the details of the parent view directive (if any) and use it
        // to derive our own qualified view name, then hang our own details
        // off the DOM so child directives can find it.
        var parent = element.parent().inheritedData('$uiView');
        if (name.indexOf('@') < 0) name  = name + '@' + (parent ? parent.state.name : '');
        var view = { name: name, state: null };
        element.data('$uiView', view);

        var eventHook = function() {
          if (viewIsUpdating) return;
          viewIsUpdating = true;

          try { updateView(true); } catch (e) {
            viewIsUpdating = false;
            throw e;
          }
          viewIsUpdating = false;
        };

        scope.$on('$stateChangeSuccess', eventHook);
        scope.$on('$viewContentLoading', eventHook);
        updateView(false);

        function updateView(doAnimate) {
          var locals = $state.$current && $state.$current.locals[name];
          if (locals === viewLocals) return; // nothing to do
          var render = renderer(animate && doAnimate);

          // Remove existing content
          render.remove(element);

          // Destroy previous view scope
          if (viewScope) {
            viewScope.$destroy();
            viewScope = null;
          }

          if (!locals) {
            viewLocals = null;
            view.state = null;

            // Restore the initial view
            return render.restore(transclude(scope), element);
          }

          viewLocals = locals;
          view.state = locals.$$state;

          var link = $compile(render.populate(locals.$template, element));
          viewScope = scope.$new();

          if (locals.$$controller) {
            locals.$scope = viewScope;
            var controller = $controller(locals.$$controller, locals);
            element.children().data('$ngControllerController', controller);
          }
          link(viewScope);
          viewScope.$emit('$viewContentLoaded');
          if (onloadExp) viewScope.$eval(onloadExp);

          // TODO: This seems strange, shouldn't $anchorScroll listen for $viewContentLoaded if necessary?
          // $anchorScroll might listen on event...
          $anchorScroll();
        }
      };
    }
  };
  return directive;
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);

function parseStateRef(ref) {
  var parsed = ref.match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

$StateRefDirective.$inject = ['$state'];
function $StateRefDirective($state) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      var ref = parseStateRef(attrs.uiSref);
      var params = null, url = null, base = $state.$current;
      var isForm = element[0].nodeName === "FORM";
      var attr = isForm ? "action" : "href", nav = true;

      var stateData = element.parent().inheritedData('$uiView');

      if (stateData && stateData.state && stateData.state.name) {
        base = stateData.state;
      }

      var update = function(newVal) {
        if (newVal) params = newVal;
        if (!nav) return;

        var newHref = $state.href(ref.state, params, { relative: base });

        if (!newHref) {
          nav = false;
          return false;
        }
        element[0][attr] = newHref;
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(newVal, oldVal) {
          if (newVal !== oldVal) update(newVal);
        }, true);
        params = scope.$eval(ref.paramExpr);
      }
      update();

      if (isForm) return;

      element.bind("click", function(e) {
        if ((e.which == 1) && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
          $state.go(ref.state, params, { relative: base });
          scope.$apply();
          e.preventDefault();
        }
      });
    }
  };
}

angular.module('ui.router.state').directive('uiSref', $StateRefDirective);

$RouteProvider.$inject = ['$stateProvider', '$urlRouterProvider'];
function $RouteProvider(  $stateProvider,    $urlRouterProvider) {

  var routes = [];

  onEnterRoute.$inject = ['$$state'];
  function onEnterRoute(   $$state) {
    /*jshint validthis: true */
    this.locals = $$state.locals.globals;
    this.params = this.locals.$stateParams;
  }

  function onExitRoute() {
    /*jshint validthis: true */
    this.locals = null;
    this.params = null;
  }

  this.when = when;
  function when(url, route) {
    /*jshint validthis: true */
    if (route.redirectTo != null) {
      // Redirect, configure directly on $urlRouterProvider
      var redirect = route.redirectTo, handler;
      if (isString(redirect)) {
        handler = redirect; // leave $urlRouterProvider to handle
      } else if (isFunction(redirect)) {
        // Adapt to $urlRouterProvider API
        handler = function (params, $location) {
          return redirect(params, $location.path(), $location.search());
        };
      } else {
        throw new Error("Invalid 'redirectTo' in when()");
      }
      $urlRouterProvider.when(url, handler);
    } else {
      // Regular route, configure as state
      $stateProvider.state(inherit(route, {
        parent: null,
        name: 'route:' + encodeURIComponent(url),
        url: url,
        onEnter: onEnterRoute,
        onExit: onExitRoute
      }));
    }
    routes.push(route);
    return this;
  }

  this.$get = $get;
  $get.$inject = ['$state', '$rootScope', '$routeParams'];
  function $get(   $state,   $rootScope,   $routeParams) {

    var $route = {
      routes: routes,
      params: $routeParams,
      current: undefined
    };

    function stateAsRoute(state) {
      return (state.name !== '') ? state : undefined;
    }

    $rootScope.$on('$stateChangeStart', function (ev, to, toParams, from, fromParams) {
      $rootScope.$broadcast('$routeChangeStart', stateAsRoute(to), stateAsRoute(from));
    });

    $rootScope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
      $route.current = stateAsRoute(to);
      $rootScope.$broadcast('$routeChangeSuccess', stateAsRoute(to), stateAsRoute(from));
      copy(toParams, $route.params);
    });

    $rootScope.$on('$stateChangeError', function (ev, to, toParams, from, fromParams, error) {
      $rootScope.$broadcast('$routeChangeError', stateAsRoute(to), stateAsRoute(from), error);
    });

    return $route;
  }
}

angular.module('ui.router.compat')
  .provider('$route', $RouteProvider)
  .directive('ngView', $ViewDirective);
})(window, window.angular);
},{}],21:[function(require,module,exports){
/**
 * @license AngularJS v1.2.0-rc.2
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/**
 * @ngdoc overview
 * @name ngCookies
 * @description
 *
 * # ngCookies
 *
 * Provides the {@link ngCookies.$cookies `$cookies`} and
 * {@link ngCookies.$cookieStore `$cookieStore`} services.
 *
 * {@installModule cookies}
 *
 * See {@link ngCookies.$cookies `$cookies`} and
 * {@link ngCookies.$cookieStore `$cookieStore`} for usage.
 */


angular.module('ngCookies', ['ng']).
  /**
   * @ngdoc object
   * @name ngCookies.$cookies
   * @requires $browser
   *
   * @description
   * Provides read/write access to browser's cookies.
   *
   * Only a simple Object is exposed and by adding or removing properties to/from
   * this object, new cookies are created/deleted at the end of current $eval.
   *
   * Requires the {@link ngCookies `ngCookies`} module to be installed.
   *
   * @example
   <doc:example>
     <doc:source>
       <script>
         function ExampleController($cookies) {
           // Retrieving a cookie
           var favoriteCookie = $cookies.myFavorite;
           // Setting a cookie
           $cookies.myFavorite = 'oatmeal';
         }
       </script>
     </doc:source>
   </doc:example>
   */
   factory('$cookies', ['$rootScope', '$browser', function ($rootScope, $browser) {
      var cookies = {},
          lastCookies = {},
          lastBrowserCookies,
          runEval = false,
          copy = angular.copy,
          isUndefined = angular.isUndefined;

      //creates a poller fn that copies all cookies from the $browser to service & inits the service
      $browser.addPollFn(function() {
        var currentCookies = $browser.cookies();
        if (lastBrowserCookies != currentCookies) { //relies on browser.cookies() impl
          lastBrowserCookies = currentCookies;
          copy(currentCookies, lastCookies);
          copy(currentCookies, cookies);
          if (runEval) $rootScope.$apply();
        }
      })();

      runEval = true;

      //at the end of each eval, push cookies
      //TODO: this should happen before the "delayed" watches fire, because if some cookies are not
      //      strings or browser refuses to store some cookies, we update the model in the push fn.
      $rootScope.$watch(push);

      return cookies;


      /**
       * Pushes all the cookies from the service to the browser and verifies if all cookies were stored.
       */
      function push() {
        var name,
            value,
            browserCookies,
            updated;

        //delete any cookies deleted in $cookies
        for (name in lastCookies) {
          if (isUndefined(cookies[name])) {
            $browser.cookies(name, undefined);
          }
        }

        //update all cookies updated in $cookies
        for(name in cookies) {
          value = cookies[name];
          if (!angular.isString(value)) {
            if (angular.isDefined(lastCookies[name])) {
              cookies[name] = lastCookies[name];
            } else {
              delete cookies[name];
            }
          } else if (value !== lastCookies[name]) {
            $browser.cookies(name, value);
            updated = true;
          }
        }

        //verify what was actually stored
        if (updated){
          updated = false;
          browserCookies = $browser.cookies();

          for (name in cookies) {
            if (cookies[name] !== browserCookies[name]) {
              //delete or reset all cookies that the browser dropped from $cookies
              if (isUndefined(browserCookies[name])) {
                delete cookies[name];
              } else {
                cookies[name] = browserCookies[name];
              }
              updated = true;
            }
          }
        }
      }
    }]).


  /**
   * @ngdoc object
   * @name ngCookies.$cookieStore
   * @requires $cookies
   *
   * @description
   * Provides a key-value (string-object) storage, that is backed by session cookies.
   * Objects put or retrieved from this storage are automatically serialized or
   * deserialized by angular's toJson/fromJson.
   *
   * Requires the {@link ngCookies `ngCookies`} module to be installed.
   *
   * @example
   */
   factory('$cookieStore', ['$cookies', function($cookies) {

      return {
        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#get
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Returns the value of given cookie key
         *
         * @param {string} key Id to use for lookup.
         * @returns {Object} Deserialized cookie value.
         */
        get: function(key) {
          var value = $cookies[key];
          return value ? angular.fromJson(value) : value;
        },

        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#put
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Sets a value for given cookie key
         *
         * @param {string} key Id for the `value`.
         * @param {Object} value Value to be stored.
         */
        put: function(key, value) {
          $cookies[key] = angular.toJson(value);
        },

        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#remove
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Remove given cookie
         *
         * @param {string} key Id of the key-value pair to delete.
         */
        remove: function(key) {
          delete $cookies[key];
        }
      };

    }]);


})(window, window.angular);
},{}],22:[function(require,module,exports){
/**
 * @license AngularJS v1.2.0-rc.2
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, document, undefined) {'use strict';

/**
 * @description
 *
 * This object provides a utility for producing rich Error messages within
 * Angular. It can be called as follows:
 *
 * var exampleMinErr = minErr('example');
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
 *
 * The above creates an instance of minErr in the example namespace. The
 * resulting error will have a namespaced error code of example.one.  The
 * resulting error will replace {0} with the value of foo, and {1} with the
 * value of bar. The object is not restricted in the number of arguments it can
 * take.
 *
 * If fewer arguments are specified than necessary for interpolation, the extra
 * interpolation markers will be preserved in the final string.
 *
 * Since data will be parsed statically during a build step, some restrictions
 * are applied with respect to how minErr instances are created and called.
 * Instances should have names of the form namespaceMinErr for a minErr created
 * using minErr('namespace') . Error codes, namespaces and template strings
 * should all be static strings, not variables or general expressions.
 *
 * @param {string} module The namespace to use for the new minErr instance.
 * @returns {function(string, string, ...): Error} instance
 */

function minErr(module) {
  return function () {
    var code = arguments[0],
      prefix = '[' + (module ? module + ':' : '') + code + '] ',
      template = arguments[1],
      templateArgs = arguments,
      stringify = function (obj) {
        if (isFunction(obj)) {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (!isString(obj)) {
          return JSON.stringify(obj);
        }
        return obj;
      },
      message, i;

    message = prefix + template.replace(/\{\d+\}/g, function (match) {
      var index = +match.slice(1, -1), arg;

      if (index + 2 < templateArgs.length) {
        arg = templateArgs[index + 2];
        if (isFunction(arg)) {
          return arg.toString().replace(/ ?\{[\s\S]*$/, '');
        } else if (isUndefined(arg)) {
          return 'undefined';
        } else if (!isString(arg)) {
          return toJson(arg);
        }
        return arg;
      }
      return match;
    });

    message = message + '\nhttp://errors.angularjs.org/' + version.full + '/' +
      (module ? module + '/' : '') + code;
    for (i = 2; i < arguments.length; i++) {
      message = message + (i == 2 ? '?' : '&') + 'p' + (i-2) + '=' +
        encodeURIComponent(stringify(arguments[i]));
    }

    return new Error(message);
  };
}

////////////////////////////////////

/**
 * hasOwnProperty may be overwritten by a property of the same name, or entirely
 * absent from an object that does not inherit Object.prototype; this copy is
 * used instead
 */
var hasOwnPropertyFn = Object.prototype.hasOwnProperty;
var hasOwnPropertyLocal = function(obj, key) {
  return hasOwnPropertyFn.call(obj, key);
};

/**
 * @ngdoc function
 * @name angular.lowercase
 * @function
 *
 * @description Converts the specified string to lowercase.
 * @param {string} string String to be converted to lowercase.
 * @returns {string} Lowercased string.
 */
var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};


/**
 * @ngdoc function
 * @name angular.uppercase
 * @function
 *
 * @description Converts the specified string to uppercase.
 * @param {string} string String to be converted to uppercase.
 * @returns {string} Uppercased string.
 */
var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


var manualLowercase = function(s) {
  return isString(s)
      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
      : s;
};
var manualUppercase = function(s) {
  return isString(s)
      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
      : s;
};


// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
if ('i' !== 'I'.toLowerCase()) {
  lowercase = manualLowercase;
  uppercase = manualUppercase;
}


var /** holds major version number for IE or NaN for real browsers */
    msie,
    jqLite,           // delay binding since jQuery could be loaded after us.
    jQuery,           // delay binding
    slice             = [].slice,
    push              = [].push,
    toString          = Object.prototype.toString,
    ngMinErr          = minErr('ng'),


    _angular          = window.angular,
    /** @name angular */
    angular           = window.angular || (window.angular = {}),
    angularModule,
    nodeName_,
    uid               = ['0', '0', '0'];

/**
 * IE 11 changed the format of the UserAgent string.
 * See http://msdn.microsoft.com/en-us/library/ms537503.aspx
 */
msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
if (isNaN(msie)) {
  msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
}


/**
 * @private
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)
 */
function isArrayLike(obj) {
  if (obj == null || isWindow(obj)) {
    return false;
  }
  
  var length = obj.length;

  if (obj.nodeType === 1 && length) {
    return true;
  }

  return isArray(obj) || !isFunction(obj) && (
    length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj
  );
}

/**
 * @ngdoc function
 * @name angular.forEach
 * @function
 *
 * @description
 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
 * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`
 * is the value of an object property or an array element and `key` is the object property key or
 * array element index. Specifying a `context` for the function is optional.
 *
 * Note: this function was previously known as `angular.foreach`.
 *
   <pre>
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key){
       this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender:male']);
   </pre>
 *
 * @param {Object|Array} obj Object to iterate over.
 * @param {Function} iterator Iterator function.
 * @param {Object=} context Object to become context (`this`) for the iterator function.
 * @returns {Object|Array} Reference to `obj`.
 */
function forEach(obj, iterator, context) {
  var key;
  if (obj) {
    if (isFunction(obj)){
      for (key in obj) {
        if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    } else if (obj.forEach && obj.forEach !== forEach) {
      obj.forEach(iterator, context);
    } else if (isArrayLike(obj)) {
      for (key = 0; key < obj.length; key++)
        iterator.call(context, obj[key], key);
    } else {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    }
  }
  return obj;
}

function sortedKeys(obj) {
  var keys = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keys.push(key);
    }
  }
  return keys.sort();
}

function forEachSorted(obj, iterator, context) {
  var keys = sortedKeys(obj);
  for ( var i = 0; i < keys.length; i++) {
    iterator.call(context, obj[keys[i]], keys[i]);
  }
  return keys;
}


/**
 * when using forEach the params are value, key, but it is often useful to have key, value.
 * @param {function(string, *)} iteratorFn
 * @returns {function(*, string)}
 */
function reverseParams(iteratorFn) {
  return function(value, key) { iteratorFn(key, value) };
}

/**
 * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
 * characters such as '012ABC'. The reason why we are not using simply a number counter is that
 * the number string gets longer over time, and it can also overflow, where as the nextId
 * will grow much slower, it is a string, and it will never overflow.
 *
 * @returns an unique alpha-numeric string
 */
function nextUid() {
  var index = uid.length;
  var digit;

  while(index) {
    index--;
    digit = uid[index].charCodeAt(0);
    if (digit == 57 /*'9'*/) {
      uid[index] = 'A';
      return uid.join('');
    }
    if (digit == 90  /*'Z'*/) {
      uid[index] = '0';
    } else {
      uid[index] = String.fromCharCode(digit + 1);
      return uid.join('');
    }
  }
  uid.unshift('0');
  return uid.join('');
}


/**
 * Set or clear the hashkey for an object.
 * @param obj object
 * @param h the hashkey (!truthy to delete the hashkey)
 */
function setHashKey(obj, h) {
  if (h) {
    obj.$$hashKey = h;
  }
  else {
    delete obj.$$hashKey;
  }
}

/**
 * @ngdoc function
 * @name angular.extend
 * @function
 *
 * @description
 * Extends the destination object `dst` by copying all of the properties from the `src` object(s)
 * to `dst`. You can specify multiple `src` objects.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
function extend(dst) {
  var h = dst.$$hashKey;
  forEach(arguments, function(obj){
    if (obj !== dst) {
      forEach(obj, function(value, key){
        dst[key] = value;
      });
    }
  });

  setHashKey(dst,h);
  return dst;
}

function int(str) {
  return parseInt(str, 10);
}


function inherit(parent, extra) {
  return extend(new (extend(function() {}, {prototype:parent}))(), extra);
}

/**
 * @ngdoc function
 * @name angular.noop
 * @function
 *
 * @description
 * A function that performs no operations. This function can be useful when writing code in the
 * functional style.
   <pre>
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
   </pre>
 */
function noop() {}
noop.$inject = [];


/**
 * @ngdoc function
 * @name angular.identity
 * @function
 *
 * @description
 * A function that returns its first argument. This function is useful when writing code in the
 * functional style.
 *
   <pre>
     function transformer(transformationFn, value) {
       return (transformationFn || angular.identity)(value);
     };
   </pre>
 */
function identity($) {return $;}
identity.$inject = [];


function valueFn(value) {return function() {return value;};}

/**
 * @ngdoc function
 * @name angular.isUndefined
 * @function
 *
 * @description
 * Determines if a reference is undefined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is undefined.
 */
function isUndefined(value){return typeof value == 'undefined';}


/**
 * @ngdoc function
 * @name angular.isDefined
 * @function
 *
 * @description
 * Determines if a reference is defined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is defined.
 */
function isDefined(value){return typeof value != 'undefined';}


/**
 * @ngdoc function
 * @name angular.isObject
 * @function
 *
 * @description
 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
 * considered to be objects.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Object` but not `null`.
 */
function isObject(value){return value != null && typeof value == 'object';}


/**
 * @ngdoc function
 * @name angular.isString
 * @function
 *
 * @description
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value){return typeof value == 'string';}


/**
 * @ngdoc function
 * @name angular.isNumber
 * @function
 *
 * @description
 * Determines if a reference is a `Number`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Number`.
 */
function isNumber(value){return typeof value == 'number';}


/**
 * @ngdoc function
 * @name angular.isDate
 * @function
 *
 * @description
 * Determines if a value is a date.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Date`.
 */
function isDate(value){
  return toString.apply(value) == '[object Date]';
}


/**
 * @ngdoc function
 * @name angular.isArray
 * @function
 *
 * @description
 * Determines if a reference is an `Array`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Array`.
 */
function isArray(value) {
  return toString.apply(value) == '[object Array]';
}


/**
 * @ngdoc function
 * @name angular.isFunction
 * @function
 *
 * @description
 * Determines if a reference is a `Function`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Function`.
 */
function isFunction(value){return typeof value == 'function';}


/**
 * Determines if a value is a regular expression object.
 *
 * @private
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `RegExp`.
 */
function isRegExp(value) {
  return toString.apply(value) == '[object RegExp]';
}


/**
 * Checks if `obj` is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
  return obj && obj.document && obj.location && obj.alert && obj.setInterval;
}


function isScope(obj) {
  return obj && obj.$evalAsync && obj.$watch;
}


function isFile(obj) {
  return toString.apply(obj) === '[object File]';
}


function isBoolean(value) {
  return typeof value == 'boolean';
}


var trim = (function() {
  // native trim is way faster: http://jsperf.com/angular-trim-test
  // but IE doesn't have it... :-(
  // TODO: we should move this into IE/ES5 polyfill
  if (!String.prototype.trim) {
    return function(value) {
      return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
    };
  }
  return function(value) {
    return isString(value) ? value.trim() : value;
  };
})();


/**
 * @ngdoc function
 * @name angular.isElement
 * @function
 *
 * @description
 * Determines if a reference is a DOM element (or wrapped jQuery element).
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
 */
function isElement(node) {
  return node &&
    (node.nodeName  // we are a direct element
    || (node.on && node.find));  // we have an on and find method part of jQuery API
}

/**
 * @param str 'key1,key2,...'
 * @returns {object} in the form of {key1:true, key2:true, ...}
 */
function makeMap(str){
  var obj = {}, items = str.split(","), i;
  for ( i = 0; i < items.length; i++ )
    obj[ items[i] ] = true;
  return obj;
}


if (msie < 9) {
  nodeName_ = function(element) {
    element = element.nodeName ? element : element[0];
    return (element.scopeName && element.scopeName != 'HTML')
      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
  };
} else {
  nodeName_ = function(element) {
    return element.nodeName ? element.nodeName : element[0].nodeName;
  };
}


function map(obj, iterator, context) {
  var results = [];
  forEach(obj, function(value, index, list) {
    results.push(iterator.call(context, value, index, list));
  });
  return results;
}


/**
 * @description
 * Determines the number of elements in an array, the number of properties an object has, or
 * the length of a string.
 *
 * Note: This function is used to augment the Object type in Angular expressions. See
 * {@link angular.Object} for more information about Angular arrays.
 *
 * @param {Object|Array|string} obj Object, array, or string to inspect.
 * @param {boolean} [ownPropsOnly=false] Count only "own" properties in an object
 * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.
 */
function size(obj, ownPropsOnly) {
  var size = 0, key;

  if (isArray(obj) || isString(obj)) {
    return obj.length;
  } else if (isObject(obj)){
    for (key in obj)
      if (!ownPropsOnly || obj.hasOwnProperty(key))
        size++;
  }

  return size;
}


function includes(array, obj) {
  return indexOf(array, obj) != -1;
}

function indexOf(array, obj) {
  if (array.indexOf) return array.indexOf(obj);

  for ( var i = 0; i < array.length; i++) {
    if (obj === array[i]) return i;
  }
  return -1;
}

function arrayRemove(array, value) {
  var index = indexOf(array, value);
  if (index >=0)
    array.splice(index, 1);
  return value;
}

function isLeafNode (node) {
  if (node) {
    switch (node.nodeName) {
    case "OPTION":
    case "PRE":
    case "TITLE":
      return true;
    }
  }
  return false;
}

/**
 * @ngdoc function
 * @name angular.copy
 * @function
 *
 * @description
 * Creates a deep copy of `source`, which should be an object or an array.
 *
 * * If no destination is supplied, a copy of the object or array is created.
 * * If a destination is provided, all of its elements (for array) or properties (for objects)
 *   are deleted and then all elements/properties from the source are copied to it.
 * * If  `source` is not an object or array, `source` is returned.
 *
 * Note: this function is used to augment the Object type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {*} source The source that will be used to make a copy.
 *                   Can be any type, including primitives, `null`, and `undefined`.
 * @param {(Object|Array)=} destination Destination into which the source is copied. If
 *     provided, must be of the same type as `source`.
 * @returns {*} The copy or updated `destination`, if `destination` was specified.
 */
function copy(source, destination){
  if (isWindow(source) || isScope(source)) {
    throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
  }

  if (!destination) {
    destination = source;
    if (source) {
      if (isArray(source)) {
        destination = copy(source, []);
      } else if (isDate(source)) {
        destination = new Date(source.getTime());
      } else if (isRegExp(source)) {
        destination = new RegExp(source.source);
      } else if (isObject(source)) {
        destination = copy(source, {});
      }
    }
  } else {
    if (source === destination) throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
    if (isArray(source)) {
      destination.length = 0;
      for ( var i = 0; i < source.length; i++) {
        destination.push(copy(source[i]));
      }
    } else {
      var h = destination.$$hashKey;
      forEach(destination, function(value, key){
        delete destination[key];
      });
      for ( var key in source) {
        destination[key] = copy(source[key]);
      }
      setHashKey(destination,h);
    }
  }
  return destination;
}

/**
 * Create a shallow copy of an object
 */
function shallowCopy(src, dst) {
  dst = dst || {};

  for(var key in src) {
    if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
      dst[key] = src[key];
    }
  }

  return dst;
}


/**
 * @ngdoc function
 * @name angular.equals
 * @function
 *
 * @description
 * Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and
 * objects.
 *
 * Two objects or values are considered equivalent if at least one of the following is true:
 *
 * * Both objects or values pass `===` comparison.
 * * Both objects or values are of the same type and all of their properties pass `===` comparison.
 * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)
 * * Both values represent the same regular expression (In JavasScript,
 *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
 *   representation matches).
 *
 * During a property comparison, properties of `function` type and properties with names
 * that begin with `$` are ignored.
 *
 * Scope and DOMWindow objects are being compared only by identify (`===`).
 *
 * @param {*} o1 Object or value to compare.
 * @param {*} o2 Object or value to compare.
 * @returns {boolean} True if arguments are equal.
 */
function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
  if (t1 == t2) {
    if (t1 == 'object') {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;
        if ((length = o1.length) == o2.length) {
          for(key=0; key<length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        return isDate(o2) && o1.getTime() == o2.getTime();
      } else if (isRegExp(o1) && isRegExp(o2)) {
        return o1.toString() == o2.toString();
      } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
        keySet = {};
        for(key in o1) {
          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for(key in o2) {
          if (!keySet.hasOwnProperty(key) &&
              key.charAt(0) !== '$' &&
              o2[key] !== undefined &&
              !isFunction(o2[key])) return false;
        }
        return true;
      }
    }
  }
  return false;
}


function concat(array1, array2, index) {
  return array1.concat(slice.call(array2, index));
}

function sliceArgs(args, startIndex) {
  return slice.call(args, startIndex || 0);
}


/**
 * @ngdoc function
 * @name angular.bind
 * @function
 *
 * @description
 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
 * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
 * known as [function currying](http://en.wikipedia.org/wiki/Currying).
 *
 * @param {Object} self Context which `fn` should be evaluated in.
 * @param {function()} fn Function to be bound.
 * @param {...*} args Optional arguments to be prebound to the `fn` function call.
 * @returns {function()} Function that wraps the `fn` with all the specified bindings.
 */
function bind(self, fn) {
  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
  if (isFunction(fn) && !(fn instanceof RegExp)) {
    return curryArgs.length
      ? function() {
          return arguments.length
            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))
            : fn.apply(self, curryArgs);
        }
      : function() {
          return arguments.length
            ? fn.apply(self, arguments)
            : fn.call(self);
        };
  } else {
    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
    return fn;
  }
}


function toJsonReplacer(key, value) {
  var val = value;

  if (/^\$+/.test(key)) {
    val = undefined;
  } else if (isWindow(value)) {
    val = '$WINDOW';
  } else if (value &&  document === value) {
    val = '$DOCUMENT';
  } else if (isScope(value)) {
    val = '$SCOPE';
  }

  return val;
}


/**
 * @ngdoc function
 * @name angular.toJson
 * @function
 *
 * @description
 * Serializes input into a JSON-formatted string. Properties with leading $ characters will be
 * stripped since angular uses this notation internally.
 *
 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
 * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
 * @returns {string|undefined} JSON-ified string representing `obj`.
 */
function toJson(obj, pretty) {
  if (typeof obj === 'undefined') return undefined;
  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
}


/**
 * @ngdoc function
 * @name angular.fromJson
 * @function
 *
 * @description
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|Date|string|number} Deserialized thingy.
 */
function fromJson(json) {
  return isString(json)
      ? JSON.parse(json)
      : json;
}


function toBoolean(value) {
  if (value && value.length !== 0) {
    var v = lowercase("" + value);
    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
  } else {
    value = false;
  }
  return value;
}

/**
 * @returns {string} Returns the string representation of the element.
 */
function startingTag(element) {
  element = jqLite(element).clone();
  try {
    // turns out IE does not let you set .html() on elements which
    // are not allowed to have children. So we just ignore it.
    element.html('');
  } catch(e) {}
  // As Per DOM Standards
  var TEXT_NODE = 3;
  var elemHtml = jqLite('<div>').append(element).html();
  try {
    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :
        elemHtml.
          match(/^(<[^>]+>)/)[1].
          replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
  } catch(e) {
    return lowercase(elemHtml);
  }

}


/////////////////////////////////////////////////

/**
 * Tries to decode the URI component without throwing an exception.
 *
 * @private
 * @param str value potential URI component to check.
 * @returns {boolean} True if `value` can be decoded
 * with the decodeURIComponent function.
 */
function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  } catch(e) {
    // Ignore any invalid uri component
  }
}


/**
 * Parses an escaped url query string into key-value pairs.
 * @returns Object.<(string|boolean)>
 */
function parseKeyValue(/**string*/keyValue) {
  var obj = {}, key_value, key;
  forEach((keyValue || "").split('&'), function(keyValue){
    if ( keyValue ) {
      key_value = keyValue.split('=');
      key = tryDecodeURIComponent(key_value[0]);
      if ( isDefined(key) ) {
        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
        if (!obj[key]) {
          obj[key] = val;
        } else if(isArray(obj[key])) {
          obj[key].push(val);
        } else {
          obj[key] = [obj[key],val];
        }
      }
    }
  });
  return obj;
}

function toKeyValue(obj) {
  var parts = [];
  forEach(obj, function(value, key) {
    if (isArray(value)) {
      forEach(value, function(arrayValue) {
        parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
      });
    } else {
    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    }
  });
  return parts.length ? parts.join('&') : '';
}


/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
 * segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriSegment(val) {
  return encodeUriQuery(val, true).
             replace(/%26/gi, '&').
             replace(/%3D/gi, '=').
             replace(/%2B/gi, '+');
}


/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query       = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriQuery(val, pctEncodeSpaces) {
  return encodeURIComponent(val).
             replace(/%40/gi, '@').
             replace(/%3A/gi, ':').
             replace(/%24/g, '$').
             replace(/%2C/gi, ',').
             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
}


/**
 * @ngdoc directive
 * @name ng.directive:ngApp
 *
 * @element ANY
 * @param {angular.Module} ngApp an optional application
 *   {@link angular.module module} name to load.
 *
 * @description
 *
 * Use this directive to auto-bootstrap an application. Only
 * one ngApp directive can be used per HTML document. The directive
 * designates the root of the application and is typically placed
 * at the root of the page.
 *
 * The first ngApp found in the document will be auto-bootstrapped. To use multiple applications in an
 * HTML document you must manually bootstrap them using {@link angular.bootstrap}.
 * Applications cannot be nested.
 *
 * In the example below if the `ngApp` directive would not be placed
 * on the `html` element then the document would not be compiled
 * and the `{{ 1+2 }}` would not be resolved to `3`.
 *
 * `ngApp` is the easiest way to bootstrap an application.
 *
 <doc:example>
   <doc:source>
    I can add: 1 + 2 =  {{ 1+2 }}
   </doc:source>
 </doc:example>
 *
 */
function angularInit(element, bootstrap) {
  var elements = [element],
      appElement,
      module,
      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
      NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

  function append(element) {
    element && elements.push(element);
  }

  forEach(names, function(name) {
    names[name] = true;
    append(document.getElementById(name));
    name = name.replace(':', '\\:');
    if (element.querySelectorAll) {
      forEach(element.querySelectorAll('.' + name), append);
      forEach(element.querySelectorAll('.' + name + '\\:'), append);
      forEach(element.querySelectorAll('[' + name + ']'), append);
    }
  });

  forEach(elements, function(element) {
    if (!appElement) {
      var className = ' ' + element.className + ' ';
      var match = NG_APP_CLASS_REGEXP.exec(className);
      if (match) {
        appElement = element;
        module = (match[2] || '').replace(/\s+/g, ',');
      } else {
        forEach(element.attributes, function(attr) {
          if (!appElement && names[attr.name]) {
            appElement = element;
            module = attr.value;
          }
        });
      }
    }
  });
  if (appElement) {
    bootstrap(appElement, module ? [module] : []);
  }
}

/**
 * @ngdoc function
 * @name angular.bootstrap
 * @description
 * Use this function to manually start up angular application.
 *
 * See: {@link guide/bootstrap Bootstrap}
 *
 * Note that ngScenario-based end-to-end tests cannot use this function to bootstrap manually.
 * They must use {@link api/ng.directive:ngApp ngApp}.
 *
 * @param {Element} element DOM element which is the root of angular application.
 * @param {Array<String|Function>=} modules an array of module declarations. See: {@link angular.module modules}
 * @returns {AUTO.$injector} Returns the newly created injector for this app.
 */
function bootstrap(element, modules) {
  var doBootstrap = function() {
    element = jqLite(element);

    if (element.injector()) {
      var tag = (element[0] === document) ? 'document' : startingTag(element);
      throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag);
    }

    modules = modules || [];
    modules.unshift(['$provide', function($provide) {
      $provide.value('$rootElement', element);
    }]);
    modules.unshift('ng');
    var injector = createInjector(modules);
    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate',
       function(scope, element, compile, injector, animate) {
        scope.$apply(function() {
          element.data('$injector', injector);
          compile(element)(scope);
        });
        animate.enabled(true);
      }]
    );
    return injector;
  };

  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return doBootstrap();
  }

  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
  angular.resumeBootstrap = function(extraModules) {
    forEach(extraModules, function(module) {
      modules.push(module);
    });
    doBootstrap();
  };
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator){
  separator = separator || '_';
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
  });
}

function bindJQuery() {
  // bind to jQuery if present;
  jQuery = window.jQuery;
  // reset to jQuery or default to us.
  if (jQuery) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });
    // Method signature: JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)
    JQLitePatchJQueryRemove('remove', true, true, false);
    JQLitePatchJQueryRemove('empty', false, false, false);
    JQLitePatchJQueryRemove('html', false, false, true);
  } else {
    jqLite = JQLite;
  }
  angular.element = jqLite;
}

/**
 * throw error if the argument is falsy.
 */
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
  }

  assertArg(isFunction(arg), name, 'not a function, got ' +
      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
  return arg;
}

/**
 * Return the value accessible from the object by path. Any undefined traversals are ignored
 * @param {Object} obj starting object
 * @param {string} path path to traverse
 * @param {boolean=true} bindFnToScope
 * @returns value as accessible by path
 */
//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
  if (!path) return obj;
  var keys = path.split('.');
  var key;
  var lastInstance = obj;
  var len = keys.length;

  for (var i = 0; i < len; i++) {
    key = keys[i];
    if (obj) {
      obj = (lastInstance = obj)[key];
    }
  }
  if (!bindFnToScope && isFunction(obj)) {
    return bind(lastInstance, obj);
  }
  return obj;
}

/**
 * @ngdoc interface
 * @name angular.Module
 * @description
 *
 * Interface for configuring angular {@link angular.module modules}.
 */

function setupModuleLoader(window) {

  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  return ensure(ensure(window, 'angular', Object), 'module', function() {
    /** @type {Object.<string, angular.Module>} */
    var modules = {};

    /**
     * @ngdoc function
     * @name angular.module
     * @description
     *
     * The `angular.module` is a global place for creating, registering and retrieving Angular modules.
     * All modules (angular core or 3rd party) that should be available to an application must be
     * registered using this mechanism.
     *
     * When passed two or more arguments, a new module is created.  If passed only one argument, an
     * existing module (the name passed as the first argument to `module`) is retrieved.
     *
     *
     * # Module
     *
     * A module is a collection of services, directives, filters, and configuration information.
     * `angular.module` is used to configure the {@link AUTO.$injector $injector}.
     *
     * <pre>
     * // Create a new module
     * var myModule = angular.module('myModule', []);
     *
     * // register a new service
     * myModule.value('appName', 'MyCoolApp');
     *
     * // configure existing services inside initialization blocks.
     * myModule.config(function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix('!');
     * });
     * </pre>
     *
     * Then you can create an injector and load your modules like this:
     *
     * <pre>
     * var injector = angular.injector(['ng', 'MyModule'])
     * </pre>
     *
     * However it's more likely that you'll just use
     * {@link ng.directive:ngApp ngApp} or
     * {@link angular.bootstrap} to simplify this process for you.
     *
     * @param {!string} name The name of the module to create or retrieve.
     * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the
     *        the module is being retrieved for further configuration.
     * @param {Function} configFn Optional configuration function for the module. Same as
     *        {@link angular.Module#config Module#config()}.
     * @returns {module} new module with the {@link angular.Module} api.
     */
    return function module(name, requires, configFn) {
      if (requires && modules.hasOwnProperty(name)) {
        modules[name] = null;
      }
      return ensure(modules, name, function() {
        if (!requires) {
          throw minErr('$injector')('nomod', "Module '{0}' is not available! You either misspelled the module name " +
              "or forgot to load it. If registering a module ensure that you specify the dependencies as the second " +
              "argument.", name);
        }

        /** @type {!Array.<Array.<*>>} */
        var invokeQueue = [];

        /** @type {!Array.<Function>} */
        var runBlocks = [];

        var config = invokeLater('$injector', 'invoke');

        /** @type {angular.Module} */
        var moduleInstance = {
          // Private state
          _invokeQueue: invokeQueue,
          _runBlocks: runBlocks,

          /**
           * @ngdoc property
           * @name angular.Module#requires
           * @propertyOf angular.Module
           * @returns {Array.<string>} List of module names which must be loaded before this module.
           * @description
           * Holds the list of modules which the injector will load before the current module is loaded.
           */
          requires: requires,

          /**
           * @ngdoc property
           * @name angular.Module#name
           * @propertyOf angular.Module
           * @returns {string} Name of the module.
           * @description
           */
          name: name,


          /**
           * @ngdoc method
           * @name angular.Module#provider
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerType Construction function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#provider $provide.provider()}.
           */
          provider: invokeLater('$provide', 'provider'),

          /**
           * @ngdoc method
           * @name angular.Module#factory
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerFunction Function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#factory $provide.factory()}.
           */
          factory: invokeLater('$provide', 'factory'),

          /**
           * @ngdoc method
           * @name angular.Module#service
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} constructor A constructor function that will be instantiated.
           * @description
           * See {@link AUTO.$provide#service $provide.service()}.
           */
          service: invokeLater('$provide', 'service'),

          /**
           * @ngdoc method
           * @name angular.Module#value
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {*} object Service instance object.
           * @description
           * See {@link AUTO.$provide#value $provide.value()}.
           */
          value: invokeLater('$provide', 'value'),

          /**
           * @ngdoc method
           * @name angular.Module#constant
           * @methodOf angular.Module
           * @param {string} name constant name
           * @param {*} object Constant value.
           * @description
           * Because the constant are fixed, they get applied before other provide methods.
           * See {@link AUTO.$provide#constant $provide.constant()}.
           */
          constant: invokeLater('$provide', 'constant', 'unshift'),

          /**
           * @ngdoc method
           * @name angular.Module#animation
           * @methodOf angular.Module
           * @param {string} name animation name
           * @param {Function} animationFactory Factory function for creating new instance of an animation.
           * @description
           *
           * **NOTE**: animations are take effect only if the **ngAnimate** module is loaded.
           *
           *
           * Defines an animation hook that can be later used with {@link ngAnimate.$animate $animate} service and
           * directives that use this service.
           *
           * <pre>
           * module.animation('.animation-name', function($inject1, $inject2) {
           *   return {
           *     eventName : function(element, done) {
           *       //code to run the animation
           *       //once complete, then run done()
           *       return function cancellationFunction(element) {
           *         //code to cancel the animation
           *       }
           *     }
           *   }
           * })
           * </pre>
           *
           * See {@link ngAnimate.$animateProvider#register $animateProvider.register()} and
           * {@link ngAnimate ngAnimate module} for more information.
           */
          animation: invokeLater('$animateProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#filter
           * @methodOf angular.Module
           * @param {string} name Filter name.
           * @param {Function} filterFactory Factory function for creating new instance of filter.
           * @description
           * See {@link ng.$filterProvider#register $filterProvider.register()}.
           */
          filter: invokeLater('$filterProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#controller
           * @methodOf angular.Module
           * @param {string} name Controller name.
           * @param {Function} constructor Controller constructor function.
           * @description
           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
           */
          controller: invokeLater('$controllerProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#directive
           * @methodOf angular.Module
           * @param {string} name directive name
           * @param {Function} directiveFactory Factory function for creating new instance of
           * directives.
           * @description
           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
           */
          directive: invokeLater('$compileProvider', 'directive'),

          /**
           * @ngdoc method
           * @name angular.Module#config
           * @methodOf angular.Module
           * @param {Function} configFn Execute this function on module load. Useful for service
           *    configuration.
           * @description
           * Use this method to register work which needs to be performed on module loading.
           */
          config: config,

          /**
           * @ngdoc method
           * @name angular.Module#run
           * @methodOf angular.Module
           * @param {Function} initializationFn Execute this function after injector creation.
           *    Useful for application initialization.
           * @description
           * Use this method to register work which should be performed when the injector is done
           * loading all modules.
           */
          run: function(block) {
            runBlocks.push(block);
            return this;
          }
        };

        if (configFn) {
          config(configFn);
        }

        return  moduleInstance;

        /**
         * @param {string} provider
         * @param {string} method
         * @param {String=} insertMethod
         * @returns {angular.Module}
         */
        function invokeLater(provider, method, insertMethod) {
          return function() {
            invokeQueue[insertMethod || 'push']([provider, method, arguments]);
            return moduleInstance;
          }
        }
      });
    };
  });

}

/**
 * @ngdoc property
 * @name angular.version
 * @description
 * An object that contains information about the current AngularJS version. This object has the
 * following properties:
 *
 * - `full` â€“ `{string}` â€“ Full version string, such as "0.9.18".
 * - `major` â€“ `{number}` â€“ Major version number, such as "0".
 * - `minor` â€“ `{number}` â€“ Minor version number, such as "9".
 * - `dot` â€“ `{number}` â€“ Dot version number, such as "18".
 * - `codeName` â€“ `{string}` â€“ Code name of the release, such as "jiggling-armfat".
 */
var version = {
  full: '1.2.0-rc.2',    // all of these placeholder strings will be replaced by grunt's
  major: 1,    // package task
  minor: 2,
  dot: 0,
  codeName: 'barehand-atomsplitting'
};


function publishExternalAPI(angular){
  extend(angular, {
    'bootstrap': bootstrap,
    'copy': copy,
    'extend': extend,
    'equals': equals,
    'element': jqLite,
    'forEach': forEach,
    'injector': createInjector,
    'noop':noop,
    'bind':bind,
    'toJson': toJson,
    'fromJson': fromJson,
    'identity':identity,
    'isUndefined': isUndefined,
    'isDefined': isDefined,
    'isString': isString,
    'isFunction': isFunction,
    'isObject': isObject,
    'isNumber': isNumber,
    'isElement': isElement,
    'isArray': isArray,
    '$$minErr': minErr,
    'version': version,
    'isDate': isDate,
    'lowercase': lowercase,
    'uppercase': uppercase,
    'callbacks': {counter: 0}
  });

  angularModule = setupModuleLoader(window);
  try {
    angularModule('ngLocale');
  } catch (e) {
    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
  }

  angularModule('ng', ['ngLocale'], ['$provide',
    function ngModule($provide) {
      $provide.provider('$compile', $CompileProvider).
        directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCsp: ngCspDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            ngValue: ngValueDirective
        }).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider({
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $interpolate: $InterpolateProvider,
        $http: $HttpProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider,
        $$urlUtils: $$UrlUtilsProvider
      });
    }
  ]);
}

//////////////////////////////////
//JQLite
//////////////////////////////////

/**
 * @ngdoc function
 * @name angular.element
 * @function
 *
 * @description
 * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
 * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if
 * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite
 * implementation (commonly referred to as jqLite).
 *
 * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`
 * event fired.
 *
 * jqLite is a tiny, API-compatible subset of jQuery that allows
 * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality
 * within a very small footprint, so only a subset of the jQuery API - methods, arguments and
 * invocation styles - are supported.
 *
 * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never
 * raw DOM references.
 *
 * ## Angular's jqLite
 * Angular's lite version of jQuery provides only the following jQuery methods:
 *
 * - [addClass()](http://api.jquery.com/addClass/)
 * - [after()](http://api.jquery.com/after/)
 * - [append()](http://api.jquery.com/append/)
 * - [attr()](http://api.jquery.com/attr/)
 * - [bind()](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
 * - [children()](http://api.jquery.com/children/) - Does not support selectors
 * - [clone()](http://api.jquery.com/clone/)
 * - [contents()](http://api.jquery.com/contents/)
 * - [css()](http://api.jquery.com/css/)
 * - [data()](http://api.jquery.com/data/)
 * - [eq()](http://api.jquery.com/eq/)
 * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name
 * - [hasClass()](http://api.jquery.com/hasClass/)
 * - [html()](http://api.jquery.com/html/)
 * - [next()](http://api.jquery.com/next/) - Does not support selectors
 * - [on()](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
 * - [off()](http://api.jquery.com/off/) - Does not support namespaces or selectors
 * - [parent()](http://api.jquery.com/parent/) - Does not support selectors
 * - [prepend()](http://api.jquery.com/prepend/)
 * - [prop()](http://api.jquery.com/prop/)
 * - [ready()](http://api.jquery.com/ready/)
 * - [remove()](http://api.jquery.com/remove/)
 * - [removeAttr()](http://api.jquery.com/removeAttr/)
 * - [removeClass()](http://api.jquery.com/removeClass/)
 * - [removeData()](http://api.jquery.com/removeData/)
 * - [replaceWith()](http://api.jquery.com/replaceWith/)
 * - [text()](http://api.jquery.com/text/)
 * - [toggleClass()](http://api.jquery.com/toggleClass/)
 * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
 * - [unbind()](http://api.jquery.com/off/) - Does not support namespaces
 * - [val()](http://api.jquery.com/val/)
 * - [wrap()](http://api.jquery.com/wrap/)
 *
 * ## jQuery/jqLite Extras
 * Angular also provides the following additional methods and events to both jQuery and jqLite:
 *
 * ### Events
 * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
 *    on all DOM nodes being removed.  This can be used to clean up and 3rd party bindings to the DOM
 *    element before it is removed.
 * ### Methods
 * - `controller(name)` - retrieves the controller of the current element or its parent. By default
 *   retrieves controller associated with the `ngController` directive. If `name` is provided as
 *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
 *   `'ngModel'`).
 * - `injector()` - retrieves the injector of the current element or its parent.
 * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current
 *   element or its parent.
 * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
 *   parent element is reached.
 *
 * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
 * @returns {Object} jQuery object.
 */

var jqCache = JQLite.cache = {},
    jqName = JQLite.expando = 'ng-' + new Date().getTime(),
    jqId = 1,
    addEventListenerFn = (window.document.addEventListener
      ? function(element, type, fn) {element.addEventListener(type, fn, false);}
      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),
    removeEventListenerFn = (window.document.removeEventListener
      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }
      : function(element, type, fn) {element.detachEvent('on' + type, fn); });

function jqNextId() { return ++jqId; }


var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var jqLiteMinErr = minErr('jqLite');

/**
 * Converts snake_case to camelCase.
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function camelCase(name) {
  return name.
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).
    replace(MOZ_HACK_REGEXP, 'Moz$1');
}

/////////////////////////////////////////////
// jQuery mutation patch
//
// In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a
// $destroy event on all DOM nodes being removed.
//
/////////////////////////////////////////////

function JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
  var originalJqFn = jQuery.fn[name];
  originalJqFn = originalJqFn.$original || originalJqFn;
  removePatch.$original = originalJqFn;
  jQuery.fn[name] = removePatch;

  function removePatch(param) {
    var list = filterElems && param ? [this.filter(param)] : [this],
        fireEvent = dispatchThis,
        set, setIndex, setLength,
        element, childIndex, childLength, children;

    if (!getterIfNoArguments || param != null) {
      while(list.length) {
        set = list.shift();
        for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for(childIndex = 0, childLength = (children = element.children()).length;
              childIndex < childLength;
              childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
    }
    return originalJqFn.apply(this, arguments);
  }
}

/////////////////////////////////////////////
function JQLite(element) {
  if (element instanceof JQLite) {
    return element;
  }
  if (!(this instanceof JQLite)) {
    if (isString(element) && element.charAt(0) != '<') {
      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
    }
    return new JQLite(element);
  }

  if (isString(element)) {
    var div = document.createElement('div');
    // Read about the NoScope elements here:
    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx
    div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!
    div.removeChild(div.firstChild); // remove the superfluous div
    JQLiteAddNodes(this, div.childNodes);
    var fragment = jqLite(document.createDocumentFragment());
    fragment.append(this); // detach the elements from the temporary DOM div.
  } else {
    JQLiteAddNodes(this, element);
  }
}

function JQLiteClone(element) {
  return element.cloneNode(true);
}

function JQLiteDealoc(element){
  JQLiteRemoveData(element);
  for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {
    JQLiteDealoc(children[i]);
  }
}

function JQLiteOff(element, type, fn, unsupported) {
  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');

  var events = JQLiteExpandoStore(element, 'events'),
      handle = JQLiteExpandoStore(element, 'handle');

  if (!handle) return; //no listeners registered

  if (isUndefined(type)) {
    forEach(events, function(eventHandler, type) {
      removeEventListenerFn(element, type, eventHandler);
      delete events[type];
    });
  } else {
    forEach(type.split(' '), function(type) {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type] || [], fn);
      }
    });
  }
}

function JQLiteRemoveData(element, name) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId];

  if (expandoStore) {
    if (name) {
      delete jqCache[expandoId].data[name];
      return;
    }

    if (expandoStore.handle) {
      expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
      JQLiteOff(element);
    }
    delete jqCache[expandoId];
    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.
  }
}

function JQLiteExpandoStore(element, key, value) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId || -1];

  if (isDefined(value)) {
    if (!expandoStore) {
      element[jqName] = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {};
    }
    expandoStore[key] = value;
  } else {
    return expandoStore && expandoStore[key];
  }
}

function JQLiteData(element, key, value) {
  var data = JQLiteExpandoStore(element, 'data'),
      isSetter = isDefined(value),
      keyDefined = !isSetter && isDefined(key),
      isSimpleGetter = keyDefined && !isObject(key);

  if (!data && !isSimpleGetter) {
    JQLiteExpandoStore(element, 'data', data = {});
  }

  if (isSetter) {
    data[key] = value;
  } else {
    if (keyDefined) {
      if (isSimpleGetter) {
        // don't create data in this case.
        return data && data[key];
      } else {
        extend(data, key);
      }
    } else {
      return data;
    }
  }
}

function JQLiteHasClass(element, selector) {
  return ((" " + element.className + " ").replace(/[\n\t]/g, " ").
      indexOf( " " + selector + " " ) > -1);
}

function JQLiteRemoveClass(element, cssClasses) {
  if (cssClasses) {
    forEach(cssClasses.split(' '), function(cssClass) {
      element.className = trim(
          (" " + element.className + " ")
          .replace(/[\n\t]/g, " ")
          .replace(" " + trim(cssClass) + " ", " ")
      );
    });
  }
}

function JQLiteAddClass(element, cssClasses) {
  if (cssClasses) {
    forEach(cssClasses.split(' '), function(cssClass) {
      if (!JQLiteHasClass(element, cssClass)) {
        element.className = trim(element.className + ' ' + trim(cssClass));
      }
    });
  }
}

function JQLiteAddNodes(root, elements) {
  if (elements) {
    elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))
      ? elements
      : [ elements ];
    for(var i=0; i < elements.length; i++) {
      root.push(elements[i]);
    }
  }
}

function JQLiteController(element, name) {
  return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');
}

function JQLiteInheritedData(element, name, value) {
  element = jqLite(element);

  // if element is the document object work with the html element instead
  // this makes $(document).scope() possible
  if(element[0].nodeType == 9) {
    element = element.find('html');
  }

  while (element.length) {
    if ((value = element.data(name)) !== undefined) return value;
    element = element.parent();
  }
}

//////////////////////////////////////////
// Functions which are declared directly.
//////////////////////////////////////////
var JQLitePrototype = JQLite.prototype = {
  ready: function(fn) {
    var fired = false;

    function trigger() {
      if (fired) return;
      fired = true;
      fn();
    }

    // check if document already is loaded
    if (document.readyState === 'complete'){
      setTimeout(trigger);
    } else {
      this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9
      // we can not use jqLite since we are not done loading and jQuery could be loaded later.
      JQLite(window).on('load', trigger); // fallback to window.onload for others
    }
  },
  toString: function() {
    var value = [];
    forEach(this, function(e){ value.push('' + e);});
    return '[' + value.join(', ') + ']';
  },

  eq: function(index) {
      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
  },

  length: 0,
  push: push,
  sort: [].sort,
  splice: [].splice
};

//////////////////////////////////////////
// Functions iterating getter/setters.
// these functions return self on setter and
// value on get.
//////////////////////////////////////////
var BOOLEAN_ATTR = {};
forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
  BOOLEAN_ATTR[lowercase(value)] = value;
});
var BOOLEAN_ELEMENTS = {};
forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
  BOOLEAN_ELEMENTS[uppercase(value)] = true;
});

function getBooleanAttrName(element, name) {
  // check dom last since we will most likely fail on name
  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];

  // booleanAttr is here twice to minimize DOM access
  return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
}

forEach({
  data: JQLiteData,
  inheritedData: JQLiteInheritedData,

  scope: function(element) {
    return JQLiteInheritedData(element, '$scope');
  },

  controller: JQLiteController ,

  injector: function(element) {
    return JQLiteInheritedData(element, '$injector');
  },

  removeAttr: function(element,name) {
    element.removeAttribute(name);
  },

  hasClass: JQLiteHasClass,

  css: function(element, name, value) {
    name = camelCase(name);

    if (isDefined(value)) {
      element.style[name] = value;
    } else {
      var val;

      if (msie <= 8) {
        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
        val = element.currentStyle && element.currentStyle[name];
        if (val === '') val = 'auto';
      }

      val = val || element.style[name];

      if (msie <= 8) {
        // jquery weirdness :-/
        val = (val === '') ? undefined : val;
      }

      return  val;
    }
  },

  attr: function(element, name, value){
    var lowercasedName = lowercase(name);
    if (BOOLEAN_ATTR[lowercasedName]) {
      if (isDefined(value)) {
        if (!!value) {
          element[name] = true;
          element.setAttribute(name, lowercasedName);
        } else {
          element[name] = false;
          element.removeAttribute(lowercasedName);
        }
      } else {
        return (element[name] ||
                 (element.attributes.getNamedItem(name)|| noop).specified)
               ? lowercasedName
               : undefined;
      }
    } else if (isDefined(value)) {
      element.setAttribute(name, value);
    } else if (element.getAttribute) {
      // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
      // some elements (e.g. Document) don't have get attribute, so return undefined
      var ret = element.getAttribute(name, 2);
      // normalize non-existing attributes to undefined (as jQuery)
      return ret === null ? undefined : ret;
    }
  },

  prop: function(element, name, value) {
    if (isDefined(value)) {
      element[name] = value;
    } else {
      return element[name];
    }
  },

  text: (function() {
    var NODE_TYPE_TEXT_PROPERTY = [];
    if (msie < 9) {
      NODE_TYPE_TEXT_PROPERTY[1] = 'innerText';    /** Element **/
      NODE_TYPE_TEXT_PROPERTY[3] = 'nodeValue';    /** Text **/
    } else {
      NODE_TYPE_TEXT_PROPERTY[1] =                 /** Element **/
      NODE_TYPE_TEXT_PROPERTY[3] = 'textContent';  /** Text **/
    }
    getText.$dv = '';
    return getText;

    function getText(element, value) {
      var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType]
      if (isUndefined(value)) {
        return textProp ? element[textProp] : '';
      }
      element[textProp] = value;
    }
  })(),

  val: function(element, value) {
    if (isUndefined(value)) {
      if (nodeName_(element) === 'SELECT' && element.multiple) {
        var result = [];
        forEach(element.options, function (option) {
          if (option.selected) {
            result.push(option.value || option.text);
          }
        });
        return result.length === 0 ? null : result;
      }
      return element.value;
    }
    element.value = value;
  },

  html: function(element, value) {
    if (isUndefined(value)) {
      return element.innerHTML;
    }
    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
      JQLiteDealoc(childNodes[i]);
    }
    element.innerHTML = value;
  }
}, function(fn, name){
  /**
   * Properties: writes return selection, reads return first value
   */
  JQLite.prototype[name] = function(arg1, arg2) {
    var i, key;

    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
    // in a way that survives minification.
    if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {
      if (isObject(arg1)) {

        // we are a write, but the object properties are the key/values
        for(i=0; i < this.length; i++) {
          if (fn === JQLiteData) {
            // data() takes the whole object in jQuery
            fn(this[i], arg1);
          } else {
            for (key in arg1) {
              fn(this[i], key, arg1[key]);
            }
          }
        }
        // return self for chaining
        return this;
      } else {
        // we are a read, so read the first child.
        var value = fn.$dv;
        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
        var jj = value == undefined ? Math.min(this.length, 1) : this.length;
        for (var j = 0; j < jj; j++) {
          var nodeValue = fn(this[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        }
        return value;
      }
    } else {
      // we are a write, so apply to all children
      for(i=0; i < this.length; i++) {
        fn(this[i], arg1, arg2);
      }
      // return self for chaining
      return this;
    }
  };
});

function createEventHandler(element, events) {
  var eventHandler = function (event, type) {
    if (!event.preventDefault) {
      event.preventDefault = function() {
        event.returnValue = false; //ie
      };
    }

    if (!event.stopPropagation) {
      event.stopPropagation = function() {
        event.cancelBubble = true; //ie
      };
    }

    if (!event.target) {
      event.target = event.srcElement || document;
    }

    if (isUndefined(event.defaultPrevented)) {
      var prevent = event.preventDefault;
      event.preventDefault = function() {
        event.defaultPrevented = true;
        prevent.call(event);
      };
      event.defaultPrevented = false;
    }

    event.isDefaultPrevented = function() {
      return event.defaultPrevented || event.returnValue == false;
    };

    forEach(events[type || event.type], function(fn) {
      fn.call(element, event);
    });

    // Remove monkey-patched methods (IE),
    // as they would cause memory leaks in IE8.
    if (msie <= 8) {
      // IE7/8 does not allow to delete property on native object
      event.preventDefault = null;
      event.stopPropagation = null;
      event.isDefaultPrevented = null;
    } else {
      // It shouldn't affect normal browsers (native methods are defined on prototype).
      delete event.preventDefault;
      delete event.stopPropagation;
      delete event.isDefaultPrevented;
    }
  };
  eventHandler.elem = element;
  return eventHandler;
}

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
forEach({
  removeData: JQLiteRemoveData,

  dealoc: JQLiteDealoc,

  on: function onFn(element, type, fn, unsupported){
    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');

    var events = JQLiteExpandoStore(element, 'events'),
        handle = JQLiteExpandoStore(element, 'handle');

    if (!events) JQLiteExpandoStore(element, 'events', events = {});
    if (!handle) JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));

    forEach(type.split(' '), function(type){
      var eventFns = events[type];

      if (!eventFns) {
        if (type == 'mouseenter' || type == 'mouseleave') {
          var contains = document.body.contains || document.body.compareDocumentPosition ?
          function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
              adown.contains ?
              adown.contains( bup ) :
              a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
              ));
            } :
            function( a, b ) {
              if ( b ) {
                while ( (b = b.parentNode) ) {
                  if ( b === a ) {
                    return true;
                  }
                }
              }
              return false;
            };

          events[type] = [];

          // Refer to jQuery's implementation of mouseenter & mouseleave
          // Read about mouseenter and mouseleave:
          // http://www.quirksmode.org/js/events_mouse.html#link8
          var eventmap = { mouseleave : "mouseout", mouseenter : "mouseover"};

          onFn(element, eventmap[type], function(event) {
            var target = this, related = event.relatedTarget;
            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !contains(target, related)) ){
              handle(event, type);
            }
          });

        } else {
          addEventListenerFn(element, type, handle);
          events[type] = [];
        }
        eventFns = events[type]
      }
      eventFns.push(fn);
    });
  },

  off: JQLiteOff,

  replaceWith: function(element, replaceNode) {
    var index, parent = element.parentNode;
    JQLiteDealoc(element);
    forEach(new JQLite(replaceNode), function(node){
      if (index) {
        parent.insertBefore(node, index.nextSibling);
      } else {
        parent.replaceChild(node, element);
      }
      index = node;
    });
  },

  children: function(element) {
    var children = [];
    forEach(element.childNodes, function(element){
      if (element.nodeType === 1)
        children.push(element);
    });
    return children;
  },

  contents: function(element) {
    return element.childNodes || [];
  },

  append: function(element, node) {
    forEach(new JQLite(node), function(child){
      if (element.nodeType === 1 || element.nodeType === 11) {
        element.appendChild(child);
      }
    });
  },

  prepend: function(element, node) {
    if (element.nodeType === 1) {
      var index = element.firstChild;
      forEach(new JQLite(node), function(child){
        element.insertBefore(child, index);
      });
    }
  },

  wrap: function(element, wrapNode) {
    wrapNode = jqLite(wrapNode)[0];
    var parent = element.parentNode;
    if (parent) {
      parent.replaceChild(wrapNode, element);
    }
    wrapNode.appendChild(element);
  },

  remove: function(element) {
    JQLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  },

  after: function(element, newElement) {
    var index = element, parent = element.parentNode;
    forEach(new JQLite(newElement), function(node){
      parent.insertBefore(node, index.nextSibling);
      index = node;
    });
  },

  addClass: JQLiteAddClass,
  removeClass: JQLiteRemoveClass,

  toggleClass: function(element, selector, condition) {
    if (isUndefined(condition)) {
      condition = !JQLiteHasClass(element, selector);
    }
    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
  },

  parent: function(element) {
    var parent = element.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },

  next: function(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }

    // IE8 doesn't have nextElementSibling
    var elm = element.nextSibling;
    while (elm != null && elm.nodeType !== 1) {
      elm = elm.nextSibling;
    }
    return elm;
  },

  find: function(element, selector) {
    return element.getElementsByTagName(selector);
  },

  clone: JQLiteClone,

  triggerHandler: function(element, eventName, eventData) {
    var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
    eventData = eventData || {
      preventDefault: noop,
      stopPropagation: noop
    };

    forEach(eventFns, function(fn) {
      fn.call(element, eventData);
    });
  }
}, function(fn, name){
  /**
   * chaining functions
   */
  JQLite.prototype[name] = function(arg1, arg2, arg3) {
    var value;
    for(var i=0; i < this.length; i++) {
      if (value == undefined) {
        value = fn(this[i], arg1, arg2, arg3);
        if (value !== undefined) {
          // any function which returns a value needs to be wrapped
          value = jqLite(value);
        }
      } else {
        JQLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
      }
    }
    return value == undefined ? this : value;
  };

  // bind legacy bind/unbind to on/off
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
});

/**
 * Computes a hash of an 'obj'.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in 'type:hashKey' format.
 */
function hashKey(obj) {
  var objType = typeof obj,
      key;

  if (objType == 'object' && obj !== null) {
    if (typeof (key = obj.$$hashKey) == 'function') {
      // must invoke on object to keep the right this
      key = obj.$$hashKey();
    } else if (key === undefined) {
      key = obj.$$hashKey = nextUid();
    }
  } else {
    key = obj;
  }

  return objType + ':' + key;
}

/**
 * HashMap which can use objects as keys
 */
function HashMap(array){
  forEach(array, this.put, this);
}
HashMap.prototype = {
  /**
   * Store key value pair
   * @param key key to store can be any type
   * @param value value to store can be any type
   */
  put: function(key, value) {
    this[hashKey(key)] = value;
  },

  /**
   * @param key
   * @returns the value for the key
   */
  get: function(key) {
    return this[hashKey(key)];
  },

  /**
   * Remove the key/value pair
   * @param key
   */
  remove: function(key) {
    var value = this[key = hashKey(key)];
    delete this[key];
    return value;
  }
};

/**
 * @ngdoc function
 * @name angular.injector
 * @function
 *
 * @description
 * Creates an injector function that can be used for retrieving services as well as for
 * dependency injection (see {@link guide/di dependency injection}).
 *

 * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
 *        {@link angular.module}. The `ng` module must be explicitly added.
 * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.
 *
 * @example
 * Typical usage
 * <pre>
 *   // create an injector
 *   var $injector = angular.injector(['ng']);
 *
 *   // use the injector to kick off your application
 *   // use the type inference to auto inject arguments, or use implicit injection
 *   $injector.invoke(function($rootScope, $compile, $document){
 *     $compile($document)($rootScope);
 *     $rootScope.$digest();
 *   });
 * </pre>
 */


/**
 * @ngdoc overview
 * @name AUTO
 * @description
 *
 * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.
 */

var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var $injectorMinErr = minErr('$injector');
function annotate(fn) {
  var $inject,
      fnText,
      argDecl,
      last;

  if (typeof fn == 'function') {
    if (!($inject = fn.$inject)) {
      $inject = [];
      if (fn.length) {
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
          arg.replace(FN_ARG, function(all, underscore, name){
            $inject.push(name);
          });
        });
      }
      fn.$inject = $inject;
    }
  } else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], 'fn');
    $inject = fn.slice(0, last);
  } else {
    assertArgFn(fn, 'fn', true);
  }
  return $inject;
}

///////////////////////////////////////

/**
 * @ngdoc object
 * @name AUTO.$injector
 * @function
 *
 * @description
 *
 * `$injector` is used to retrieve object instances as defined by
 * {@link AUTO.$provide provider}, instantiate types, invoke methods,
 * and load modules.
 *
 * The following always holds true:
 *
 * <pre>
 *   var $injector = angular.injector();
 *   expect($injector.get('$injector')).toBe($injector);
 *   expect($injector.invoke(function($injector){
 *     return $injector;
 *   }).toBe($injector);
 * </pre>
 *
 * # Injection Function Annotation
 *
 * JavaScript does not have annotations, and annotations are needed for dependency injection. The
 * following are all valid ways of annotating function with injection arguments and are equivalent.
 *
 * <pre>
 *   // inferred (only works if code not minified/obfuscated)
 *   $injector.invoke(function(serviceA){});
 *
 *   // annotated
 *   function explicit(serviceA) {};
 *   explicit.$inject = ['serviceA'];
 *   $injector.invoke(explicit);
 *
 *   // inline
 *   $injector.invoke(['serviceA', function(serviceA){}]);
 * </pre>
 *
 * ## Inference
 *
 * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be
 * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation
 * tools since these tools change the argument names.
 *
 * ## `$inject` Annotation
 * By adding a `$inject` property onto a function the injection parameters can be specified.
 *
 * ## Inline
 * As an array of injection names, where the last item in the array is the function to call.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#get
 * @methodOf AUTO.$injector
 *
 * @description
 * Return an instance of the service.
 *
 * @param {string} name The name of the instance to retrieve.
 * @return {*} The instance.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#invoke
 * @methodOf AUTO.$injector
 *
 * @description
 * Invoke the method and supply the method arguments from the `$injector`.
 *
 * @param {!function} fn The function to invoke. The function arguments come form the function annotation.
 * @param {Object=} self The `this` for the invoked method.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
 *   the `$injector` is consulted.
 * @returns {*} the value returned by the invoked `fn` function.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#has
 * @methodOf AUTO.$injector
 *
 * @description
 * Allows the user to query if the particular service exist.
 *
 * @param {string} Name of the service to query.
 * @returns {boolean} returns true if injector has given service.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#instantiate
 * @methodOf AUTO.$injector
 * @description
 * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies
 * all of the arguments to the constructor function as specified by the constructor annotation.
 *
 * @param {function} Type Annotated constructor function.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
 *   the `$injector` is consulted.
 * @returns {Object} new instance of `Type`.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#annotate
 * @methodOf AUTO.$injector
 *
 * @description
 * Returns an array of service names which the function is requesting for injection. This API is used by the injector
 * to determine which services need to be injected into the function when the function is invoked. There are three
 * ways in which the function can be annotated with the needed dependencies.
 *
 * # Argument names
 *
 * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting
 * the function into a string using `toString()` method and extracting the argument names.
 * <pre>
 *   // Given
 *   function MyController($scope, $route) {
 *     // ...
 *   }
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
 * </pre>
 *
 * This method does not work with code minification / obfuscation. For this reason the following annotation strategies
 * are supported.
 *
 * # The `$inject` property
 *
 * If a function has an `$inject` property and its value is an array of strings, then the strings represent names of
 * services to be injected into the function.
 * <pre>
 *   // Given
 *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
 *     // ...
 *   }
 *   // Define function dependencies
 *   MyController.$inject = ['$scope', '$route'];
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
 * </pre>
 *
 * # The array notation
 *
 * It is often desirable to inline Injected functions and that's when setting the `$inject` property is very
 * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives
 * minification is a better choice:
 *
 * <pre>
 *   // We wish to write this (not minification / obfuscation safe)
 *   injector.invoke(function($compile, $rootScope) {
 *     // ...
 *   });
 *
 *   // We are forced to write break inlining
 *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
 *     // ...
 *   };
 *   tmpFn.$inject = ['$compile', '$rootScope'];
 *   injector.invoke(tmpFn);
 *
 *   // To better support inline function the inline annotation is supported
 *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
 *     // ...
 *   }]);
 *
 *   // Therefore
 *   expect(injector.annotate(
 *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
 *    ).toEqual(['$compile', '$rootScope']);
 * </pre>
 *
 * @param {function|Array.<string|Function>} fn Function for which dependent service names need to be retrieved as described
 *   above.
 *
 * @returns {Array.<string>} The names of the services which the function requires.
 */




/**
 * @ngdoc object
 * @name AUTO.$provide
 *
 * @description
 *
 * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.
 * The providers share the same name as the instance they create with `Provider` suffixed to them.
 *
 * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of
 * a service. The Provider can have additional methods which would allow for configuration of the provider.
 *
 * <pre>
 *   function GreetProvider() {
 *     var salutation = 'Hello';
 *
 *     this.salutation = function(text) {
 *       salutation = text;
 *     };
 *
 *     this.$get = function() {
 *       return function (name) {
 *         return salutation + ' ' + name + '!';
 *       };
 *     };
 *   }
 *
 *   describe('Greeter', function(){
 *
 *     beforeEach(module(function($provide) {
 *       $provide.provider('greet', GreetProvider);
 *     }));
 *
 *     it('should greet', inject(function(greet) {
 *       expect(greet('angular')).toEqual('Hello angular!');
 *     }));
 *
 *     it('should allow configuration of salutation', function() {
 *       module(function(greetProvider) {
 *         greetProvider.salutation('Ahoj');
 *       });
 *       inject(function(greet) {
 *         expect(greet('angular')).toEqual('Ahoj angular!');
 *       });
 *     });
 * </pre>
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#provider
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.
 *
 * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.
 * @param {(Object|function())} provider If the provider is:
 *
 *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
 *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.
 *   - `Constructor`: a new instance of the provider will be created using
 *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.
 *
 * @returns {Object} registered provider instance
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#factory
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for configuring services if only `$get` method is required.
 *
 * @param {string} name The name of the instance.
 * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for
 * `$provide.provider(name, {$get: $getFn})`.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#service
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for registering service of given class.
 *
 * @param {string} name The name of the instance.
 * @param {Function} constructor A class (constructor function) that will be instantiated.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#value
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for configuring services if the `$get` method is a constant.
 *
 * @param {string} name The name of the instance.
 * @param {*} value The value.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#constant
 * @methodOf AUTO.$provide
 * @description
 *
 * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected
 * into configuration function (other modules) and it is not interceptable by
 * {@link AUTO.$provide#decorator decorator}.
 *
 * @param {string} name The name of the constant.
 * @param {*} value The constant value.
 * @returns {Object} registered instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#decorator
 * @methodOf AUTO.$provide
 * @description
 *
 * Decoration of service, allows the decorator to intercept the service instance creation. The
 * returned instance may be the original instance, or a new instance which delegates to the
 * original instance.
 *
 * @param {string} name The name of the service to decorate.
 * @param {function()} decorator This function will be invoked when the service needs to be
 *    instantiated. The function is called using the {@link AUTO.$injector#invoke
 *    injector.invoke} method and is therefore fully injectable. Local injection arguments:
 *
 *    * `$delegate` - The original service instance, which can be monkey patched, configured,
 *      decorated or delegated to.
 */


function createInjector(modulesToLoad) {
  var INSTANTIATING = {},
      providerSuffix = 'Provider',
      path = [],
      loadedModules = new HashMap(),
      providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          }
      },
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, function() {
            throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
          })),
      instanceCache = {},
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
          }));


  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });

  return instanceInjector;

  ////////////////////////////////////
  // $provider
  ////////////////////////////////////

  function supportObject(delegate) {
    return function(key, value) {
      if (isObject(key)) {
        forEach(key, reverseParams(delegate));
      } else {
        return delegate(key, value);
      }
    }
  }

  function provider(name, provider_) {
    if (isFunction(provider_) || isArray(provider_)) {
      provider_ = providerInjector.instantiate(provider_);
    }
    if (!provider_.$get) {
      throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
    }
    return providerCache[name + providerSuffix] = provider_;
  }

  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }

  function service(name, constructor) {
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
  }

  function value(name, value) { return factory(name, valueFn(value)); }

  function constant(name, value) {
    providerCache[name] = value;
    instanceCache[name] = value;
  }

  function decorator(serviceName, decorFn) {
    var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = function() {
      var origInstance = instanceInjector.invoke(orig$get, origProvider);
      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
    };
  }

  ////////////////////////////////////
  // Module Loading
  ////////////////////////////////////
  function loadModules(modulesToLoad){
    var runBlocks = [];
    forEach(modulesToLoad, function(module) {
      if (loadedModules.get(module)) return;
      loadedModules.put(module, true);

      try {
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
            var invokeArgs = invokeQueue[i],
                provider = providerInjector.get(invokeArgs[0]);

            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else {
          assertArgFn(module, 'module');
        }
      } catch (e) {
        if (isArray(module)) {
          module = module[module.length - 1];
        }
        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
          // Safari & FF's stack traces don't contain error.message content unlike those of Chrome and IE
          // So if stack doesn't contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
          e = e.message + '\n' + e.stack;
        }
        throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
      }
    });
    return runBlocks;
  }

  ////////////////////////////////////
  // internal Injector
  ////////////////////////////////////

  function createInternalInjector(cache, factory) {

    function getService(serviceName) {
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr('cdep', 'Circular dependency found: {0}', path.join(' <- '));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          return cache[serviceName] = factory(serviceName);
        } finally {
          path.shift();
        }
      }
    }

    function invoke(fn, self, locals){
      var args = [],
          $inject = annotate(fn),
          length, i,
          key;

      for(i = 0, length = $inject.length; i < length; i++) {
        key = $inject[i];
        if (typeof key !== 'string') {
          throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
        }
        args.push(
          locals && locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key)
        );
      }
      if (!fn.$inject) {
        // this means that we must be an array.
        fn = fn[length];
      }


      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke
      switch (self ? -1 : args.length) {
        case  0: return fn();
        case  1: return fn(args[0]);
        case  2: return fn(args[0], args[1]);
        case  3: return fn(args[0], args[1], args[2]);
        case  4: return fn(args[0], args[1], args[2], args[3]);
        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);
        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default: return fn.apply(self, args);
      }
    }

    function instantiate(Type, locals) {
      var Constructor = function() {},
          instance, returnedValue;

      // Check if Type is annotated and use just the given function at n-1 as parameter
      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
      instance = new Constructor();
      returnedValue = invoke(Type, instance, locals);

      return isObject(returnedValue) ? returnedValue : instance;
    }

    return {
      invoke: invoke,
      instantiate: instantiate,
      get: getService,
      annotate: annotate,
      has: function(name) {
        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      }
    };
  }
}

/**
 * @ngdoc function
 * @name ng.$anchorScroll
 * @requires $window
 * @requires $location
 * @requires $rootScope
 *
 * @description
 * When called, it checks current value of `$location.hash()` and scroll to related element,
 * according to rules specified in
 * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.
 *
 * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.
 * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.
 */
function $AnchorScrollProvider() {

  var autoScrollingEnabled = true;

  this.disableAutoScrolling = function() {
    autoScrollingEnabled = false;
  };

  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
    var document = $window.document;

    // helper function to get first anchor from a NodeList
    // can't use filter.filter, as it accepts only instances of Array
    // and IE can't convert NodeList to an array using [].slice
    // TODO(vojta): use filter if we change it to accept lists as well
    function getFirstAnchor(list) {
      var result = null;
      forEach(list, function(element) {
        if (!result && lowercase(element.nodeName) === 'a') result = element;
      });
      return result;
    }

    function scroll() {
      var hash = $location.hash(), elm;

      // empty hash, scroll to the top of the page
      if (!hash) $window.scrollTo(0, 0);

      // element with given id
      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();

      // first anchor with given name :-D
      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();

      // no element and hash == 'top', scroll to the top of the page
      else if (hash === 'top') $window.scrollTo(0, 0);
    }

    // does not scroll when user clicks on anchor link that is currently on
    // (no url change, no $location.hash() change), browser native does scroll
    if (autoScrollingEnabled) {
      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
        function autoScrollWatchAction() {
          $rootScope.$evalAsync(scroll);
        });
    }

    return scroll;
  }];
}

var $animateMinErr = minErr('$animate');

/**
 * @ngdoc object
 * @name ng.$animateProvider
 *
 * @description
 * Default implementation of $animate that doesn't perform any animations, instead just synchronously performs DOM
 * updates and calls done() callbacks.
 *
 * In order to enable animations the ngAnimate module has to be loaded.
 *
 * To see the functional implementation check out src/ngAnimate/animate.js
 */
var $AnimateProvider = ['$provide', function($provide) {

  this.$$selectors = {};


  /**
   * @ngdoc function
   * @name ng.$animateProvider#register
   * @methodOf ng.$animateProvider
   *
   * @description
   * Registers a new injectable animation factory function. The factory function produces the animation object which
   * contains callback functions for each event that is expected to be animated.
   *
   *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction` must be called once the
   *   element animation is complete. If a function is returned then the animation service will use this function to
   *   cancel the animation whenever a cancel event is triggered.
   *
   *
   *<pre>
   *   return {
     *     eventFn : function(element, done) {
     *       //code to run the animation
     *       //once complete, then run done()
     *       return function cancellationFunction() {
     *         //code to cancel the animation
     *       }
     *     }
     *   }
   *</pre>
   *
   * @param {string} name The name of the animation.
   * @param {function} factory The factory function that will be executed to return the animation object.
   */
  this.register = function(name, factory) {
    var key = name + '-animation';
    if (name && name.charAt(0) != '.') throw $animateMinErr('notcsel',
        "Expecting class selector starting with '.' got '{0}'.", name);
    this.$$selectors[name.substr(1)] = key;
    $provide.factory(key, factory);
  };

  this.$get = ['$timeout', function($timeout) {

    /**
     * @ngdoc object
     * @name ng.$animate
     *
     * @description
     * The $animate service provides rudimentary DOM manipulation functions to insert, remove, move elements within
     * the DOM as well as adding and removing classes. This service is the core service used by the ngAnimate $animator
     * service which provides high-level animation hooks for CSS and JavaScript. 
     *
     * $animate is available in the AngularJS core, however, the ngAnimate module must be included to enable full out
     * animation support. Otherwise, $animate will only perform simple DOM manipulation operations.
     *
     * To learn more about enabling animation support, click here to visit the {@link ngAnimate ngAnimate module page}
     * as well as the {@link ngAnimate.$animate ngAnimate $animate service page}.
     */
    return {

      /**
       * @ngdoc function
       * @name ng.$animate#enter
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Inserts the element into the DOM either after the `after` element or within the `parent` element. Once complete,
       * the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will be inserted into the DOM
       * @param {jQuery/jqLite element} parent the parent element which will append the element as a child (if the after element is not present)
       * @param {jQuery/jqLite element} after the sibling element which will append the element after itself
       * @param {function=} done callback function that will be called after the element has been inserted into the DOM
       */
      enter : function(element, parent, after, done) {
        var afterNode = after && after[after.length - 1];
        var parentNode = parent && parent[0] || afterNode && afterNode.parentNode;
        // IE does not like undefined so we have to pass null.
        var afterNextSibling = (afterNode && afterNode.nextSibling) || null;
        forEach(element, function(node) {
          parentNode.insertBefore(node, afterNextSibling);
        });
        done && $timeout(done, 0, false);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#leave
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Removes the element from the DOM. Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will be removed from the DOM
       * @param {function=} done callback function that will be called after the element has been removed from the DOM
       */
      leave : function(element, done) {
        element.remove();
        done && $timeout(done, 0, false);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#move
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Moves the position of the provided element within the DOM to be placed either after the `after` element or inside of the `parent` element.
       * Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will be moved around within the DOM
       * @param {jQuery/jqLite element} parent the parent element where the element will be inserted into (if the after element is not present)
       * @param {jQuery/jqLite element} after the sibling element where the element will be positioned next to
       * @param {function=} done the callback function (if provided) that will be fired after the element has been moved to it's new position
       */
      move : function(element, parent, after, done) {
        // Do not remove element before insert. Removing will cause data associated with the
        // element to be dropped. Insert will implicitly do the remove.
        this.enter(element, parent, after, done);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#addClass
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Adds the provided className CSS class value to the provided element. Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will have the className value added to it
       * @param {string} className the CSS class which will be added to the element
       * @param {function=} done the callback function (if provided) that will be fired after the className value has been added to the element
       */
      addClass : function(element, className, done) {
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(' ') : '';
        element.addClass(className);
        done && $timeout(done, 0, false);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#removeClass
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Removes the provided className CSS class value from the provided element. Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will have the className value removed from it
       * @param {string} className the CSS class which will be removed from the element
       * @param {function=} done the callback function (if provided) that will be fired after the className value has been removed from the element
       */
      removeClass : function(element, className, done) {
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(' ') : '';
        element.removeClass(className);
        done && $timeout(done, 0, false);
      },

      enabled : noop
    };
  }];
}];

/**
 * ! This is a private undocumented service !
 *
 * @name ng.$browser
 * @requires $log
 * @description
 * This object has two goals:
 *
 * - hide all the global state in the browser caused by the window object
 * - abstract away all the browser specific features and inconsistencies
 *
 * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
 * service, which can be used for convenient testing of the application without the interaction with
 * the real browser apis.
 */
/**
 * @param {object} window The global window object.
 * @param {object} document jQuery wrapped document.
 * @param {function()} XHR XMLHttpRequest constructor.
 * @param {object} $log console.log or an object with the same interface.
 * @param {object} $sniffer $sniffer service
 */
function Browser(window, document, $log, $sniffer) {
  var self = this,
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};

  self.isMock = false;

  var outstandingRequestCount = 0;
  var outstandingRequestCallbacks = [];

  // TODO(vojta): remove this temporary api
  self.$$completeOutstandingRequest = completeOutstandingRequest;
  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };

  /**
   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
   */
  function completeOutstandingRequest(fn) {
    try {
      fn.apply(null, sliceArgs(arguments, 1));
    } finally {
      outstandingRequestCount--;
      if (outstandingRequestCount === 0) {
        while(outstandingRequestCallbacks.length) {
          try {
            outstandingRequestCallbacks.pop()();
          } catch (e) {
            $log.error(e);
          }
        }
      }
    }
  }

  /**
   * @private
   * Note: this method is used only by scenario runner
   * TODO(vojta): prefix this method with $$ ?
   * @param {function()} callback Function that will be called when no outstanding request
   */
  self.notifyWhenNoOutstandingRequests = function(callback) {
    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
    // at some deterministic time in respect to the test runner's actions. Leaving things up to the
    // regular poller would result in flaky tests.
    forEach(pollFns, function(pollFn){ pollFn(); });

    if (outstandingRequestCount === 0) {
      callback();
    } else {
      outstandingRequestCallbacks.push(callback);
    }
  };

  //////////////////////////////////////////////////////////////
  // Poll Watcher API
  //////////////////////////////////////////////////////////////
  var pollFns = [],
      pollTimeout;

  /**
   * @name ng.$browser#addPollFn
   * @methodOf ng.$browser
   *
   * @param {function()} fn Poll function to add
   *
   * @description
   * Adds a function to the list of functions that poller periodically executes,
   * and starts polling if not started yet.
   *
   * @returns {function()} the added function
   */
  self.addPollFn = function(fn) {
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
    pollFns.push(fn);
    return fn;
  };

  /**
   * @param {number} interval How often should browser call poll functions (ms)
   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
   *
   * @description
   * Configures the poller to run in the specified intervals, using the specified
   * setTimeout fn and kicks it off.
   */
  function startPoller(interval, setTimeout) {
    (function check() {
      forEach(pollFns, function(pollFn){ pollFn(); });
      pollTimeout = setTimeout(check, interval);
    })();
  }

  //////////////////////////////////////////////////////////////
  // URL API
  //////////////////////////////////////////////////////////////

  var lastBrowserUrl = location.href,
      baseElement = document.find('base'),
      replacedUrl = null;

  /**
   * @name ng.$browser#url
   * @methodOf ng.$browser
   *
   * @description
   * GETTER:
   * Without any argument, this method just returns current value of location.href.
   *
   * SETTER:
   * With at least one argument, this method sets url to new value.
   * If html5 history api supported, pushState/replaceState is used, otherwise
   * location.href/location.replace is used.
   * Returns its own instance to allow chaining
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to change url.
   *
   * @param {string} url New url (when used as setter)
   * @param {boolean=} replace Should new url replace current history record ?
   */
  self.url = function(url, replace) {
    // setter
    if (url) {
      if (lastBrowserUrl == url) return;
      lastBrowserUrl = url;
      if ($sniffer.history) {
        if (replace) history.replaceState(null, '', url);
        else {
          history.pushState(null, '', url);
          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462
          baseElement.attr('href', baseElement.attr('href'));
        }
      } else {
        if (replace) {
          location.replace(url);
          replacedUrl = url;
        } else {
          location.href = url;
          replacedUrl = null;
        }
      }
      return self;
    // getter
    } else {
      // - the replacedUrl is a workaround for an IE8-9 issue with location.replace method that doesn't update
      //   location.href synchronously
      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
      return replacedUrl || location.href.replace(/%27/g,"'");
    }
  };

  var urlChangeListeners = [],
      urlChangeInit = false;

  function fireUrlChange() {
    if (lastBrowserUrl == self.url()) return;

    lastBrowserUrl = self.url();
    forEach(urlChangeListeners, function(listener) {
      listener(self.url());
    });
  }

  /**
   * @name ng.$browser#onUrlChange
   * @methodOf ng.$browser
   * @TODO(vojta): refactor to use node's syntax for events
   *
   * @description
   * Register callback function that will be called, when url changes.
   *
   * It's only called when the url is changed by outside of angular:
   * - user types different url into address bar
   * - user clicks on history (forward/back) button
   * - user clicks on a link
   *
   * It's not called when url is changed by $browser.url() method
   *
   * The listener gets called with new url as parameter.
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to monitor url changes in angular apps.
   *
   * @param {function(string)} listener Listener function to be called when url changes.
   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
   */
  self.onUrlChange = function(callback) {
    if (!urlChangeInit) {
      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
      // don't fire popstate when user change the address bar and don't fire hashchange when url
      // changed by push/replaceState

      // html5 history api - popstate event
      if ($sniffer.history) jqLite(window).on('popstate', fireUrlChange);
      // hashchange event
      if ($sniffer.hashchange) jqLite(window).on('hashchange', fireUrlChange);
      // polling
      else self.addPollFn(fireUrlChange);

      urlChangeInit = true;
    }

    urlChangeListeners.push(callback);
    return callback;
  };

  //////////////////////////////////////////////////////////////
  // Misc API
  //////////////////////////////////////////////////////////////

  /**
   * Returns current <base href>
   * (always relative - without domain)
   *
   * @returns {string=}
   */
  self.baseHref = function() {
    var href = baseElement.attr('href');
    return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
  };

  //////////////////////////////////////////////////////////////
  // Cookies API
  //////////////////////////////////////////////////////////////
  var lastCookies = {};
  var lastCookieString = '';
  var cookiePath = self.baseHref();

  /**
   * @name ng.$browser#cookies
   * @methodOf ng.$browser
   *
   * @param {string=} name Cookie name
   * @param {string=} value Cookie value
   *
   * @description
   * The cookies method provides a 'private' low level access to browser cookies.
   * It is not meant to be used directly, use the $cookie service instead.
   *
   * The return values vary depending on the arguments that the method was called with as follows:
   * <ul>
   *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>
   *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>
   *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>
   * </ul>
   *
   * @returns {Object} Hash of all cookies (if called without any parameter)
   */
  self.cookies = function(name, value) {
    var cookieLength, cookieArray, cookie, i, index;

    if (name) {
      if (value === undefined) {
        rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
      } else {
        if (isString(value)) {
          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;

          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
          // - 300 cookies
          // - 20 cookies per unique domain
          // - 4096 bytes per cookie
          if (cookieLength > 4096) {
            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because it was too large ("+
              cookieLength + " > 4096 bytes)!");
          }
        }
      }
    } else {
      if (rawDocument.cookie !== lastCookieString) {
        lastCookieString = rawDocument.cookie;
        cookieArray = lastCookieString.split("; ");
        lastCookies = {};

        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf('=');
          if (index > 0) { //ignore nameless cookies
            var name = unescape(cookie.substring(0, index));
            // the first value that is seen for a cookie is the most
            // specific one.  values for the same cookie name that
            // follow are for less specific paths.
            if (lastCookies[name] === undefined) {
              lastCookies[name] = unescape(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    }
  };


  /**
   * @name ng.$browser#defer
   * @methodOf ng.$browser
   * @param {function()} fn A function, who's execution should be deferred.
   * @param {number=} [delay=0] of milliseconds to defer the function execution.
   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
   *
   * @description
   * Executes a fn asynchronously via `setTimeout(fn, delay)`.
   *
   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
   * via `$browser.defer.flush()`.
   *
   */
  self.defer = function(fn, delay) {
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(function() {
      delete pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    }, delay || 0);
    pendingDeferIds[timeoutId] = true;
    return timeoutId;
  };


  /**
   * @name ng.$browser#defer.cancel
   * @methodOf ng.$browser.defer
   *
   * @description
   * Cancels a deferred task identified with `deferId`.
   *
   * @param {*} deferId Token returned by the `$browser.defer` function.
   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully canceled.
   */
  self.defer.cancel = function(deferId) {
    if (pendingDeferIds[deferId]) {
      delete pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      return true;
    }
    return false;
  };

}

function $BrowserProvider(){
  this.$get = ['$window', '$log', '$sniffer', '$document',
      function( $window,   $log,   $sniffer,   $document){
        return new Browser($window, $document, $log, $sniffer);
      }];
}

/**
 * @ngdoc object
 * @name ng.$cacheFactory
 *
 * @description
 * Factory that constructs cache objects and gives access to them.
 * 
 * <pre>
 * 
 *  var cache = $cacheFactory('cacheId');
 *  expect($cacheFactory.get('cacheId')).toBe(cache);
 *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();
 *
 *  cache.put("key", "value");
 *  cache.put("another key", "another value");
 * 
 *  expect(cache.info()).toEqual({id: 'cacheId', size: 2}); // Since we've specified no options on creation
 * 
 * </pre>
 *
 *
 * @param {string} cacheId Name or id of the newly created cache.
 * @param {object=} options Options object that specifies the cache behavior. Properties:
 *
 *   - `{number=}` `capacity` â€” turns the cache into LRU cache.
 *
 * @returns {object} Newly created cache object with the following set of methods:
 *
 * - `{object}` `info()` â€” Returns id, size, and options of cache.
 * - `{{*}}` `put({string} key, {*} value)` â€” Puts a new key-value pair into the cache and returns it.
 * - `{{*}}` `get({string} key)` â€” Returns cached value for `key` or undefined for cache miss.
 * - `{void}` `remove({string} key)` â€” Removes a key-value pair from the cache.
 * - `{void}` `removeAll()` â€” Removes all cached values.
 * - `{void}` `destroy()` â€” Removes references to this cache from $cacheFactory.
 *
 */
function $CacheFactoryProvider() {

  this.$get = function() {
    var caches = {};

    function cacheFactory(cacheId, options) {
      if (cacheId in caches) {
        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
      }

      var size = 0,
          stats = extend({}, options, {id: cacheId}),
          data = {},
          capacity = (options && options.capacity) || Number.MAX_VALUE,
          lruHash = {},
          freshEnd = null,
          staleEnd = null;

      return caches[cacheId] = {

        put: function(key, value) {
          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

          refresh(lruEntry);

          if (isUndefined(value)) return;
          if (!(key in data)) size++;
          data[key] = value;

          if (size > capacity) {
            this.remove(staleEnd.key);
          }

          return value;
        },


        get: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          refresh(lruEntry);

          return data[key];
        },


        remove: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          if (lruEntry == freshEnd) freshEnd = lruEntry.p;
          if (lruEntry == staleEnd) staleEnd = lruEntry.n;
          link(lruEntry.n,lruEntry.p);

          delete lruHash[key];
          delete data[key];
          size--;
        },


        removeAll: function() {
          data = {};
          size = 0;
          lruHash = {};
          freshEnd = staleEnd = null;
        },


        destroy: function() {
          data = null;
          stats = null;
          lruHash = null;
          delete caches[cacheId];
        },


        info: function() {
          return extend({}, stats, {size: size});
        }
      };


      /**
       * makes the `entry` the freshEnd of the LRU linked list
       */
      function refresh(entry) {
        if (entry != freshEnd) {
          if (!staleEnd) {
            staleEnd = entry;
          } else if (staleEnd == entry) {
            staleEnd = entry.n;
          }

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        }
      }


      /**
       * bidirectionally links two entries of the LRU linked list
       */
      function link(nextEntry, prevEntry) {
        if (nextEntry != prevEntry) {
          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
        }
      }
    }


  /**
   * @ngdoc method
   * @name ng.$cacheFactory#info
   * @methodOf ng.$cacheFactory
   *
   * @description
   * Get information about all the of the caches that have been created
   *
   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`
   */
    cacheFactory.info = function() {
      var info = {};
      forEach(caches, function(cache, cacheId) {
        info[cacheId] = cache.info();
      });
      return info;
    };


  /**
   * @ngdoc method
   * @name ng.$cacheFactory#get
   * @methodOf ng.$cacheFactory
   *
   * @description
   * Get access to a cache object by the `cacheId` used when it was created.
   *
   * @param {string} cacheId Name or id of a cache to access.
   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.
   */
    cacheFactory.get = function(cacheId) {
      return caches[cacheId];
    };


    return cacheFactory;
  };
}

/**
 * @ngdoc object
 * @name ng.$templateCache
 *
 * @description
 * The first time a template is used, it is loaded in the template cache for quick retrieval. You can
 * load templates directly into the cache in a `script` tag, or by consuming the `$templateCache`
 * service directly.
 * 
 * Adding via the `script` tag:
 * <pre>
 * <html ng-app>
 * <head>
 * <script type="text/ng-template" id="templateId.html">
 *   This is the content of the template
 * </script>
 * </head>
 *   ...
 * </html>
 * </pre>
 * 
 * **Note:** the `script` tag containing the template does not need to be included in the `head` of the document, but 
 * it must be below the `ng-app` definition.
 * 
 * Adding via the $templateCache service:
 * 
 * <pre>
 * var myApp = angular.module('myApp', []);
 * myApp.run(function($templateCache) {
 *   $templateCache.put('templateId.html', 'This is the content of the template');
 * });
 * </pre>
 * 
 * To retrieve the template later, simply use it in your HTML:
 * <pre>
 * <div ng-include=" 'templateId.html' "></div>
 * </pre>
 * 
 * or get it via Javascript:
 * <pre>
 * $templateCache.get('templateId.html')
 * </pre>
 * 
 * See {@link ng.$cacheFactory $cacheFactory}.
 *
 */
function $TemplateCacheProvider() {
  this.$get = ['$cacheFactory', function($cacheFactory) {
    return $cacheFactory('templates');
  }];
}

/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
 *
 * DOM-related variables:
 *
 * - "node" - DOM Node
 * - "element" - DOM Element or Node
 * - "$node" or "$element" - jqLite-wrapped node or element
 *
 *
 * Compiler related stuff:
 *
 * - "linkFn" - linking fn of a single directive
 * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
 * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
 * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
 */


/**
 * @ngdoc function
 * @name ng.$compile
 * @function
 *
 * @description
 * Compiles a piece of HTML string or DOM into a template and produces a template function, which
 * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.
 *
 * The compilation is a process of walking the DOM tree and trying to match DOM elements to
 * {@link ng.$compileProvider#directive directives}. For each match it
 * executes corresponding template function and collects the
 * instance functions into a single template function which is then returned.
 *
 * The template function can then be used once to produce the view or as it is the case with
 * {@link ng.directive:ngRepeat repeater} many-times, in which
 * case each call results in a view that is a DOM clone of the original template.
 *
 <doc:example module="compile">
   <doc:source>
    <script>
      // declare a new module, and inject the $compileProvider
      angular.module('compile', [], function($compileProvider) {
        // configure new 'compile' directive by passing a directive
        // factory function. The factory function injects the '$compile'
        $compileProvider.directive('compile', function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        })
      });

      function Ctrl($scope) {
        $scope.name = 'Angular';
        $scope.html = 'Hello {{name}}';
      }
    </script>
    <div ng-controller="Ctrl">
      <input ng-model="name"> <br>
      <textarea ng-model="html"></textarea> <br>
      <div compile="html"></div>
    </div>
   </doc:source>
   <doc:scenario>
     it('should auto compile', function() {
       expect(element('div[compile]').text()).toBe('Hello Angular');
       input('html').enter('{{name}}!');
       expect(element('div[compile]').text()).toBe('Angular!');
     });
   </doc:scenario>
 </doc:example>

 *
 *
 * @param {string|DOMElement} element Element or HTML string to compile into a template function.
 * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.
 * @param {number} maxPriority only apply directives lower then given priority (Only effects the
 *                 root element(s), not their children)
 * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template
 * (a DOM element/tree) to a scope. Where:
 *
 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
 *               `template` and call the `cloneAttachFn` function allowing the caller to attach the
 *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
 *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:
 *
 *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
 *      * `scope` - is the current scope with which the linking function is working with.
 *
 * Calling the linking function returns the element of the template. It is either the original element
 * passed in, or the clone of the element if the `cloneAttachFn` is provided.
 *
 * After linking the view is not updated until after a call to $digest which typically is done by
 * Angular automatically.
 *
 * If you need access to the bound view, there are two ways to do it:
 *
 * - If you are not asking the linking function to clone the template, create the DOM element(s)
 *   before you send them to the compiler and keep this reference around.
 *   <pre>
 *     var element = $compile('<p>{{total}}</p>')(scope);
 *   </pre>
 *
 * - if on the other hand, you need the element to be cloned, the view reference from the original
 *   example would not point to the clone, but rather to the original template that was cloned. In
 *   this case, you can access the clone via the cloneAttachFn:
 *   <pre>
 *     var templateHTML = angular.element('<p>{{total}}</p>'),
 *         scope = ....;
 *
 *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {
 *       //attach the clone to DOM document at the right place
 *     });
 *
 *     //now we have reference to the cloned DOM via `clone`
 *   </pre>
 *
 *
 * For information on how the compiler works, see the
 * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
 */

var $compileMinErr = minErr('$compile');

/**
 * @ngdoc service
 * @name ng.$compileProvider
 * @function
 *
 * @description
 */
$CompileProvider.$inject = ['$provide'];
function $CompileProvider($provide) {
  var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
      aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/,
      imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]*|formaction)$/;

  /**
   * @ngdoc function
   * @name ng.$compileProvider#directive
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Register a new directive with the compiler.
   *
   * @param {string} name Name of the directive in camel-case. (ie <code>ngBind</code> which will match as
   *                <code>ng-bind</code>).
   * @param {function|Array} directiveFactory An injectable directive factory function. See {@link guide/directive} for more
   *                info.
   * @returns {ng.$compileProvider} Self for chaining.
   */
   this.directive = function registerDirective(name, directiveFactory) {
    if (isString(name)) {
      assertArg(directiveFactory, 'directiveFactory');
      if (!hasDirectives.hasOwnProperty(name)) {
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
          function($injector, $exceptionHandler) {
            var directives = [];
            forEach(hasDirectives[name], function(directiveFactory) {
              try {
                var directive = $injector.invoke(directiveFactory);
                if (isFunction(directive)) {
                  directive = { compile: valueFn(directive) };
                } else if (!directive.compile && directive.link) {
                  directive.compile = valueFn(directive.link);
                }
                directive.priority = directive.priority || 0;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller && directive.name);
                directive.restrict = directive.restrict || 'A';
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          }]);
      }
      hasDirectives[name].push(directiveFactory);
    } else {
      forEach(name, reverseParams(registerDirective));
    }
    return this;
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#aHrefSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.aHrefSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      aHrefSanitizationWhitelist = regexp;
      return this;
    }
    return aHrefSanitizationWhitelist;
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#imgSrcSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during img[src] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into an
   * absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist` regular
   * expression. If a match is found, the original url is written into the dom. Otherwise, the
   * absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.imgSrcSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      imgSrcSanitizationWhitelist = regexp;
      return this;
    }
    return imgSrcSanitizationWhitelist;
  };


  this.$get = [
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',
            '$controller', '$rootScope', '$document', '$sce', '$$urlUtils', '$animate',
    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
             $controller,   $rootScope,   $document,   $sce,   $$urlUtils, $animate) {

    var Attributes = function(element, attr) {
      this.$$element = element;
      this.$attr = attr || {};
    };

    Attributes.prototype = {
      $normalize: directiveNormalize,


      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$addClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Adds the CSS class value specified by the classVal parameter to the element. If animations
       * are enabled then an animation will be triggered for the class addition.
       *
       * @param {string} classVal The className value that will be added to the element
       */
      $addClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.addClass(this.$$element, classVal);
        }
      },

      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$removeClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Removes the CSS class value specified by the classVal parameter from the element. If animations
       * are enabled then an animation will be triggered for the class removal.
       *
       * @param {string} classVal The className value that will be removed from the element
       */
      $removeClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.removeClass(this.$$element, classVal);
        }
      },

      /**
       * Set a normalized attribute on the element in a way such that all directives
       * can share the attribute. This function properly handles boolean attributes.
       * @param {string} key Normalized key. (ie ngAttribute)
       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
       *     Defaults to true.
       * @param {string=} attrName Optional none normalized name. Defaults to key.
       */
      $set: function(key, value, writeAttr, attrName) {
        //special case for class attribute addition + removal
        //so that class changes can tap into the animation
        //hooks provided by the $animate service
        if(key == 'class') {
          value = value || '';
          var current = this.$$element.attr('class') || '';
          this.$removeClass(tokenDifference(current, value).join(' '));
          this.$addClass(tokenDifference(value, current).join(' '));
        } else {
          var booleanKey = getBooleanAttrName(this.$$element[0], key),
              normalizedVal,
              nodeName;

          if (booleanKey) {
            this.$$element.prop(key, value);
            attrName = booleanKey;
          }

          this[key] = value;

          // translate normalized key to actual key
          if (attrName) {
            this.$attr[key] = attrName;
          } else {
            attrName = this.$attr[key];
            if (!attrName) {
              this.$attr[key] = attrName = snake_case(key, '-');
            }
          }

          nodeName = nodeName_(this.$$element);

          // sanitize a[href] and img[src] values
          if ((nodeName === 'A' && key === 'href') ||
              (nodeName === 'IMG' && key === 'src')) {
            // NOTE: $$urlUtils.resolve() doesn't support IE < 8 so we don't sanitize for that case.
            if (!msie || msie >= 8 ) {
              normalizedVal = $$urlUtils.resolve(value);
              if (normalizedVal !== '') {
                if ((key === 'href' && !normalizedVal.match(aHrefSanitizationWhitelist)) ||
                    (key === 'src' && !normalizedVal.match(imgSrcSanitizationWhitelist))) {
                  this[key] = value = 'unsafe:' + normalizedVal;
                }
              }
            }
          }

          if (writeAttr !== false) {
            if (value === null || value === undefined) {
              this.$$element.removeAttr(attrName);
            } else {
              this.$$element.attr(attrName, value);
            }
          }
        }

        // fire observers
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[key], function(fn) {
          try {
            fn(value);
          } catch (e) {
            $exceptionHandler(e);
          }
        });

        function tokenDifference(str1, str2) {
          var values = [],
              tokens1 = str1.split(/\s+/),
              tokens2 = str2.split(/\s+/);

          outer:
          for(var i=0;i<tokens1.length;i++) {
            var token = tokens1[i];
            for(var j=0;j<tokens2.length;j++) {
              if(token == tokens2[j]) continue outer;
            }
            values.push(token);
          }
          return values;
        };
      },


      /**
       * Observe an interpolated attribute.
       * The observer will never be called, if given attribute is not interpolated.
       *
       * @param {string} key Normalized key. (ie ngAttribute) .
       * @param {function(*)} fn Function that will be called whenever the attribute value changes.
       * @returns {function(*)} the `fn` Function passed in.
       */
      $observe: function(key, fn) {
        var attrs = this,
            $$observers = (attrs.$$observers || (attrs.$$observers = {})),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(function() {
          if (!listeners.$$inter) {
            // no one registered attribute interpolation function, so lets call it manually
            fn(attrs[key]);
          }
        });
        return fn;
      }
    };

    var urlSanitizationNode = $document[0].createElement('a'),
        startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
            ? identity
            : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
        },
        NG_ATTR_BINDING = /^ngAttr[A-Z]/;


    return compile;

    //================================

    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective) {
      if (!($compileNodes instanceof jqLite)) {
        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.
        $compileNodes = jqLite($compileNodes);
      }
      // We can not compile top level text elements since text nodes can be merged and we will
      // not be able to attach scope data to them, so we will wrap them in <span>
      forEach($compileNodes, function(node, index){
        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\S+/) /* non-empty */ ) {
          $compileNodes[index] = node = jqLite(node).wrap('<span></span>').parent()[0];
        }
      });
      var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective);
      return function publicLinkFn(scope, cloneConnectFn){
        assertArg(scope, 'scope');
        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
        // and sometimes changes the structure of the DOM.
        var $linkNode = cloneConnectFn
          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!
          : $compileNodes;

        // Attach scope only to non-text nodes.
        for(var i = 0, ii = $linkNode.length; i<ii; i++) {
          var node = $linkNode[i];
          if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {
            $linkNode.eq(i).data('$scope', scope);
          }
        }
        safeAddClass($linkNode, 'ng-scope');
        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
        return $linkNode;
      };
    }

    function safeAddClass($element, className) {
      try {
        $element.addClass(className);
      } catch(e) {
        // ignore, since it means that we are trying to set class on
        // SVG element, where class name is read-only.
      }
    }

    /**
     * Compile function matches each node in nodeList against the directives. Once all directives
     * for a particular node are collected their compile functions are executed. The compile
     * functions return values - the linking functions - are combined into a composite linking
     * function, which is the a linking function for the node.
     *
     * @param {NodeList} nodeList an array of nodes or NodeList to compile
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the
     *        rootElement must be set the jqLite collection of the compile root. This is
     *        needed so that the jqLite collection items can be replaced with widgets.
     * @param {number=} max directive priority
     * @returns {?function} A composite linking function of all of the matched directives or null.
     */
    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective) {
      var linkFns = [],
          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;

      for(var i = 0; i < nodeList.length; i++) {
        attrs = new Attributes();

        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
        directives = collectDirectives(nodeList[i], [], attrs, i == 0 ? maxPriority : undefined, ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)
            : null;

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)
            ? null
            : compileNodes(nodeList[i].childNodes,
                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

        linkFns.push(nodeLinkFn);
        linkFns.push(childLinkFn);
        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);
      }

      // return a linking function if we have found anything, null otherwise
      return linkFnFound ? compositeLinkFn : null;

      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;

        // copy nodeList so that linking doesn't break due to live list updates.
        var stableNodeList = [];
        for (i = 0, ii = nodeList.length; i < ii; i++) {
          stableNodeList.push(nodeList[i]);
        }

        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
          node = stableNodeList[n];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];

          if (nodeLinkFn) {
            if (nodeLinkFn.scope) {
              childScope = scope.$new(isObject(nodeLinkFn.scope));
              jqLite(node).data('$scope', childScope);
            } else {
              childScope = scope;
            }
            childTranscludeFn = nodeLinkFn.transclude;
            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                  (function(transcludeFn) {
                    return function(cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;

                      return transcludeFn(transcludeScope, cloneFn).
                          on('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  })(childTranscludeFn || transcludeFn)
              );
            } else {
              nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
            }
          } else if (childLinkFn) {
            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
          }
        }
      }
    }


    /**
     * Looks for directives on the given node and adds them to the directive collection which is
     * sorted.
     *
     * @param node Node to search.
     * @param directives An array to which the directives are added to. This array is sorted before
     *        the function returns.
     * @param attrs The shared attrs object which is used to populate the normalized attributes.
     * @param {number=} maxPriority Max directive priority.
     */
    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      switch(nodeType) {
        case 1: /* Element */
          // use the node name: <directive>
          addDirective(directives,
              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority, ignoreDirective);

          // iterate over the attributes
          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
            var attrStartName;
            var attrEndName;
            var index;

            attr = nAttrs[j];
            if (!msie || msie >= 8 || attr.specified) {
              name = attr.name;
              // support ngAttr attribute binding
              ngAttrName = directiveNormalize(name);
              if (NG_ATTR_BINDING.test(ngAttrName)) {
                name = ngAttrName.substr(6).toLowerCase();
              }
              if ((index = ngAttrName.lastIndexOf('Start')) != -1 && index == ngAttrName.length - 5) {
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + 'end';
                name = name.substr(0, name.length - 6);
              }
              nName = directiveNormalize(name.toLowerCase());
              attrsMap[nName] = name;
              attrs[nName] = value = trim((msie && name == 'href')
                ? decodeURIComponent(node.getAttribute(name, 2))
                : attr.value);
              if (getBooleanAttrName(node, nName)) {
                attrs[nName] = true; // presence means true
              }
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
            }
          }

          // use class as directive
          className = node.className;
          if (isString(className) && className !== '') {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;
        case 3: /* Text Node */
          addTextInterpolateDirective(directives, node.nodeValue);
          break;
        case 8: /* Comment */
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {
            // turns out that under some circumstances IE9 throws errors when one attempts to read comment's node value.
            // Just ignore it and continue. (Can't seem to reproduce in test case.)
          }
          break;
      }

      directives.sort(byPriority);
      return directives;
    }

    /**
     * Given a node with an directive-start it collects all of the siblings until it find directive-end.
     * @param node
     * @param attrStart
     * @param attrEnd
     * @returns {*}
     */
    function groupScan(node, attrStart, attrEnd) {
      var nodes = [];
      var depth = 0;
      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
        var startNode = node;
        do {
          if (!node) {
            throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
          }
          if (node.nodeType == 1 /** Element **/) {
            if (node.hasAttribute(attrStart)) depth++;
            if (node.hasAttribute(attrEnd)) depth--;
          }
          nodes.push(node);
          node = node.nextSibling;
        } while (depth > 0);
      } else {
        nodes.push(node);
      }
      return jqLite(nodes);
    }

    /**
     * Wrapper for linking function which converts normal linking function into a grouped
     * linking function.
     * @param linkFn
     * @param attrStart
     * @param attrEnd
     * @returns {Function}
     */
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
      return function(scope, element, attrs, controllers) {
        element = groupScan(element[0], attrStart, attrEnd);
        return linkFn(scope, element, attrs, controllers);
      }
    }

    /**
     * Once the directives have been collected, their compile functions are executed. This method
     * is responsible for inlining directive templates as well as terminating the application
     * of the directives if the terminal directive has been reached.
     *
     * @param {Array} directives Array of collected directives to execute their compile function.
     *        this needs to be pre-sorted by priority order.
     * @param {Node} compileNode The raw DOM node to apply the compile functions to
     * @param {Object} templateAttrs The shared attribute function
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
     *        argument has the root jqLite array so that we can replace nodes on it.
     * @returns linkFn
     */
    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective) {
      var terminalPriority = -Number.MAX_VALUE,
          preLinkFns = [],
          postLinkFns = [],
          newScopeDirective = null,
          newIsolateScopeDirective = null,
          templateDirective = null,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          transcludeDirective,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          controllerDirectives,
          linkFn,
          directiveValue;

      // executes all directives on the current element
      for(var i = 0, ii = directives.length; i < ii; i++) {
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        // collect multiblock sections
        if (attrStart) {
          $compileNode = groupScan(compileNode, attrStart, attrEnd)
        }
        $template = undefined;

        if (terminalPriority > directive.priority) {
          break; // prevent further processing of directives
        }

        if (directiveValue = directive.scope) {
          assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
          if (isObject(directiveValue)) {
            safeAddClass($compileNode, 'ng-isolate-scope');
            newIsolateScopeDirective = directive;
          }
          safeAddClass($compileNode, 'ng-scope');
          newScopeDirective = newScopeDirective || directive;
        }

        directiveName = directive.name;

        if (directiveValue = directive.controller) {
          controllerDirectives = controllerDirectives || {};
          assertNoDuplicate("'" + directiveName + "' controller",
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        }

        if (directiveValue = directive.transclude) {
          assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
          transcludeDirective = directive;
          terminalPriority = directive.priority;
          if (directiveValue == 'element') {
            $template = groupScan(compileNode, attrStart, attrEnd)
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name);
          } else {
            $template = jqLite(JQLiteClone(compileNode)).contents();
            $compileNode.html(''); // clear contents
            childTranscludeFn = compile($template, transcludeFn);
          }
        }

        if (directive.template) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          if (directive.replace) {
            replaceDirective = directive;
            $template = jqLite('<div>' +
                                 trim(directiveValue) +
                               '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
            }

            replaceWith(jqCollection, $compileNode, compileNode);

            var newTemplateAttrs = {$attr: {}};

            // combine directives from the original node and from the template:
            // - take the array of directives for this element
            // - split it into two parts, those that were already applied and those that weren't
            // - collect directives from the template, add them to the second group and sort them
            // - append the second group with new directives to the first group
            directives = directives.concat(
                collectDirectives(
                    compileNode,
                    directives.splice(i + 1, directives.length - (i + 1)),
                    newTemplateAttrs
                )
            );
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          } else {
            $compileNode.html(directiveValue);
          }
        }

        if (directive.templateUrl) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          if (directive.replace) {
            replaceDirective = directive;
          }
          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),
              nodeLinkFn, $compileNode, templateAttrs, jqCollection, childTranscludeFn);
          ii = directives.length;
        } else if (directive.compile) {
          try {
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            if (isFunction(linkFn)) {
              addLinkFns(null, linkFn, attrStart, attrEnd);
            } else if (linkFn) {
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            }
          } catch (e) {
            $exceptionHandler(e, startingTag($compileNode));
          }
        }

        if (directive.terminal) {
          nodeLinkFn.terminal = true;
          terminalPriority = Math.max(terminalPriority, directive.priority);
        }

      }

      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
      nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;

      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
      return nodeLinkFn;

      ////////////////////

      function addLinkFns(pre, post, attrStart, attrEnd) {
        if (pre) {
          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          preLinkFns.push(pre);
        }
        if (post) {
          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          postLinkFns.push(post);
        }
      }


      function getControllers(require, $element) {
        var value, retrievalMethod = 'data', optional = false;
        if (isString(require)) {
          while((value = require.charAt(0)) == '^' || value == '?') {
            require = require.substr(1);
            if (value == '^') {
              retrievalMethod = 'inheritedData';
            }
            optional = optional || value == '?';
          }
          value = $element[retrievalMethod]('$' + require + 'Controller');
          if (!value && !optional) {
            throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
          }
          return value;
        } else if (isArray(require)) {
          value = [];
          forEach(require, function(require) {
            value.push(getControllers(require, $element));
          });
        }
        return value;
      }


      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
        var attrs, $element, i, ii, linkFn, controller;

        if (compileNode === linkNode) {
          attrs = templateAttrs;
        } else {
          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
        }
        $element = attrs.$$element;

        if (newIsolateScopeDirective) {
          var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;

          var parentScope = scope.$parent || scope;

          forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                optional = (match[2] == '?'),
                mode = match[1], // @, =, or &
                lastValue,
                parentGet, parentSet;

            scope.$$isolateBindings[scopeName] = mode + attrName;

            switch (mode) {

              case '@': {
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = parentScope;
                if( attrs[attrName] ) {
                  // If the attribute has been provided then we trigger an interpolation to ensure the value is there for use in the link fn
                  scope[scopeName] = $interpolate(attrs[attrName])(parentScope);
                }
                break;
              }

              case '=': {
                if (optional && !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                parentSet = parentGet.assign || function() {
                  // reset the change, or we will throw this exception on every $digest
                  lastValue = scope[scopeName] = parentGet(parentScope);
                  throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!",
                      attrs[attrName], newIsolateScopeDirective.name);
                };
                lastValue = scope[scopeName] = parentGet(parentScope);
                scope.$watch(function parentValueWatch() {
                  var parentValue = parentGet(parentScope);

                  if (parentValue !== scope[scopeName]) {
                    // we are out of sync and need to copy
                    if (parentValue !== lastValue) {
                      // parent changed and it has precedence
                      lastValue = scope[scopeName] = parentValue;
                    } else {
                      // if the parent can be assigned then do so
                      parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                    }
                  }
                  return parentValue;
                });
                break;
              }

              case '&': {
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(parentScope, locals);
                };
                break;
              }

              default: {
                throw $compileMinErr('iscp', "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}",
                    newIsolateScopeDirective.name, scopeName, definition);
              }
            }
          });
        }

        if (controllerDirectives) {
          forEach(controllerDirectives, function(directive) {
            var locals = {
              $scope: scope,
              $element: $element,
              $attrs: attrs,
              $transclude: boundTranscludeFn
            }, controllerInstance;

            controller = directive.controller;
            if (controller == '@') {
              controller = attrs[directive.name];
            }

            controllerInstance = $controller(controller, locals);
            $element.data(
                '$' + directive.name + 'Controller',
                controllerInstance);
            if (directive.controllerAs) {
              locals.$scope[directive.controllerAs] = controllerInstance;
            }
          });
        }

        // PRELINKING
        for(i = 0, ii = preLinkFns.length; i < ii; i++) {
          try {
            linkFn = preLinkFns[i];
            linkFn(scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element));
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // RECURSION
        childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);

        // POSTLINKING
        for(i = 0, ii = postLinkFns.length; i < ii; i++) {
          try {
            linkFn = postLinkFns[i];
            linkFn(scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element));
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }
      }
    }


    /**
     * looks up the directive and decorates it with exception handling and proper parameters. We
     * call this the boundDirective.
     *
     * @param {string} name name of the directive to look up.
     * @param {string} location The directive must be found in specific format.
     *   String containing any of theses characters:
     *
     *   * `E`: element name
     *   * `A': attribute
     *   * `C`: class
     *   * `M`: comment
     * @returns true if directive was added.
     */
    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
      if (name === ignoreDirective) return null;
      var match = null;
      if (hasDirectives.hasOwnProperty(name)) {
        for(var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i<ii; i++) {
          try {
            directive = directives[i];
            if ( (maxPriority === undefined || maxPriority > directive.priority) &&
                 directive.restrict.indexOf(location) != -1) {
              if (startAttrName) {
                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});
              }
              tDirectives.push(directive);
              match = directive;
            }
          } catch(e) { $exceptionHandler(e); }
        }
      }
      return match;
    }


    /**
     * When the element is replaced with HTML template then the new attributes
     * on the template need to be merged with the existing attributes in the DOM.
     * The desired effect is to have both of the attributes present.
     *
     * @param {object} dst destination attributes (original DOM)
     * @param {object} src source attributes (from the directive template)
     */
    function mergeTemplateAttributes(dst, src) {
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      // reapply the old attributes to the new element
      forEach(dst, function(value, key) {
        if (key.charAt(0) != '$') {
          if (src[key]) {
            value += (key === 'style' ? ';' : ' ') + src[key];
          }
          dst.$set(key, value, true, srcAttr[key]);
        }
      });

      // copy the new attributes on the old attrs object
      forEach(src, function(value, key) {
        if (key == 'class') {
          safeAddClass($element, value);
          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
        } else if (key == 'style') {
          $element.attr('style', $element.attr('style') + ';' + value);
        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        }
      });
    }


    function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,
        $rootElement, childTranscludeFn) {
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          // The fact that we have to copy and patch the directive seems wrong!
          derivedSyncDirective = extend({}, origAsyncDirective, {
            controller: null, templateUrl: null, transclude: null, scope: null, replace: null
          }),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl;

      $compileNode.html('');

      $http.get($sce.getTrustedResourceUrl(templateUrl), {cache: $templateCache}).
        success(function(content) {
          var compileNode, tempTemplateAttrs, $template;

          content = denormalizeTemplate(content);

          if (origAsyncDirective.replace) {
            $template = jqLite('<div>' + trim(content) + '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}",
                  origAsyncDirective.name, templateUrl);
            }

            tempTemplateAttrs = {$attr: {}};
            replaceWith($rootElement, $compileNode, compileNode);
            collectDirectives(compileNode, directives, tempTemplateAttrs);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          } else {
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          }

          directives.unshift(derivedSyncDirective);

          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective);
          forEach($rootElement, function(node, i) {
            if (node == compileNode) {
              $rootElement[i] = $compileNode[0];
            }
          });
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);


          while(linkQueue.length) {
            var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                controller = linkQueue.shift(),
                linkNode = $compileNode[0];

            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
              // it was cloned therefore we have to clone as well.
              linkNode = JQLiteClone(compileNode);
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
            }

            afterTemplateNodeLinkFn(
              beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller),
              scope, linkNode, $rootElement, controller
            );
          }
          linkQueue = null;
        }).
        error(function(response, code, headers, config) {
          throw $compileMinErr('tpload', 'Failed to load template: {0}', config.url);
        });

      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
        if (linkQueue) {
          linkQueue.push(scope);
          linkQueue.push(node);
          linkQueue.push(rootElement);
          linkQueue.push(controller);
        } else {
          afterTemplateNodeLinkFn(function() {
            beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
          }, scope, node, rootElement, controller);
        }
      };
    }


    /**
     * Sorting function for bound directives.
     */
    function byPriority(a, b) {
      return b.priority - a.priority;
    }


    function assertNoDuplicate(what, previousDirective, directive, element) {
      if (previousDirective) {
        throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] asking for {2} on: {3}',
            previousDirective.name, directive.name, what, startingTag(element));
      }
    }


    function addTextInterpolateDirective(directives, text) {
      var interpolateFn = $interpolate(text, true);
      if (interpolateFn) {
        directives.push({
          priority: 0,
          compile: valueFn(function textInterpolateLinkFn(scope, node) {
            var parent = node.parent(),
                bindings = parent.data('$binding') || [];
            bindings.push(interpolateFn);
            safeAddClass(parent.data('$binding', bindings), 'ng-binding');
            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
              node[0].nodeValue = value;
            });
          })
        });
      }
    }


    function getTrustedContext(node, attrNormalizedName) {
      // maction[xlink:href] can source SVG.  It's not limited to <maction>.
      if (attrNormalizedName == "xlinkHref" ||
          (nodeName_(node) != "IMG" && (attrNormalizedName == "src" ||
                                        attrNormalizedName == "ngSrc"))) {
        return $sce.RESOURCE_URL;
      }
    }


    function addAttrInterpolateDirective(node, directives, value, name) {
      var interpolateFn = $interpolate(value, true);

      // no interpolation found -> ignore
      if (!interpolateFn) return;


      if (name === "multiple" && nodeName_(node) === "SELECT") {
        throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}",
            startingTag(node));
      }

      directives.push({
        priority: 100,
        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
          var $$observers = (attr.$$observers || (attr.$$observers = {}));

          if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
            throw $compileMinErr('nodomevents',
                "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- " +
                "versions (such as ng-click instead of onclick) instead.");
          }

          // we need to interpolate again, in case the attribute value has been updated
          // (e.g. by another directive's compile function)
          interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name));

          // if attribute was updated so that there is no interpolation going on we don't want to
          // register any observers
          if (!interpolateFn) return;

          attr[name] = interpolateFn(scope);
          ($$observers[name] || ($$observers[name] = [])).$$inter = true;
          (attr.$$observers && attr.$$observers[name].$$scope || scope).
            $watch(interpolateFn, function interpolateFnWatchAction(value) {
              attr.$set(name, value);
            });
        })
      });
    }


    /**
     * This is a special jqLite.replaceWith, which can replace items which
     * have no parents, provided that the containing jqLite collection is provided.
     *
     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
     *    in the root of the tree.
     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep the shell,
     *    but replace its DOM node reference.
     * @param {Node} newNode The new DOM node.
     */
    function replaceWith($rootElement, elementsToRemove, newNode) {
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      if ($rootElement) {
        for(i = 0, ii = $rootElement.length; i < ii; i++) {
          if ($rootElement[i] == firstElementToRemove) {
            $rootElement[i++] = newNode;
            for (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) {
              if (j2 < jj) {
                $rootElement[j] = $rootElement[j2];
              } else {
                delete $rootElement[j];
              }
            }
            $rootElement.length -= removeCount - 1;
            break;
          }
        }
      }

      if (parent) {
        parent.replaceChild(newNode, firstElementToRemove);
      }
      var fragment = document.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);
      newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
        var element = elementsToRemove[k];
        jqLite(element).remove(); // must do this way to clean up expando
        fragment.appendChild(element);
        delete elementsToRemove[k];
      }

      elementsToRemove[0] = newNode;
      elementsToRemove.length = 1
    }
  }];
}

var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
/**
 * Converts all accepted directives format into proper directive name.
 * All of these will become 'myDirective':
 *   my:Directive
 *   my-directive
 *   x-my-directive
 *   data-my:directive
 *
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function directiveNormalize(name) {
  return camelCase(name.replace(PREFIX_REGEXP, ''));
}

/**
 * @ngdoc object
 * @name ng.$compile.directive.Attributes
 * @description
 *
 * A shared object between directive compile / linking functions which contains normalized DOM element
 * attributes. The the values reflect current binding state `{{ }}`. The normalization is needed
 * since all of these are treated as equivalent in Angular:
 *
 *          <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
 */

/**
 * @ngdoc property
 * @name ng.$compile.directive.Attributes#$attr
 * @propertyOf ng.$compile.directive.Attributes
 * @returns {object} A map of DOM element attribute names to the normalized name. This is
 *          needed to do reverse lookup from normalized name back to actual name.
 */


/**
 * @ngdoc function
 * @name ng.$compile.directive.Attributes#$set
 * @methodOf ng.$compile.directive.Attributes
 * @function
 *
 * @description
 * Set DOM element attribute value.
 *
 *
 * @param {string} name Normalized element attribute name of the property to modify. The name is
 *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
 *          property to the original name.
 * @param {string} value Value to set the attribute to. The value can be an interpolated string.
 */



/**
 * Closure compiler type information
 */

function nodesetLinkingFn(
  /* angular.Scope */ scope,
  /* NodeList */ nodeList,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

function directiveLinkingFn(
  /* nodesetLinkingFn */ nodesetLinkingFn,
  /* angular.Scope */ scope,
  /* Node */ node,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

/**
 * @ngdoc object
 * @name ng.$controllerProvider
 * @description
 * The {@link ng.$controller $controller service} is used by Angular to create new
 * controllers.
 *
 * This provider allows controller registration via the
 * {@link ng.$controllerProvider#register register} method.
 */
function $ControllerProvider() {
  var controllers = {},
      CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;


  /**
   * @ngdoc function
   * @name ng.$controllerProvider#register
   * @methodOf ng.$controllerProvider
   * @param {string} name Controller name
   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
   *    annotations in the array notation).
   */
  this.register = function(name, constructor) {
    if (isObject(name)) {
      extend(controllers, name)
    } else {
      controllers[name] = constructor;
    }
  };


  this.$get = ['$injector', '$window', function($injector, $window) {

    /**
     * @ngdoc function
     * @name ng.$controller
     * @requires $injector
     *
     * @param {Function|string} constructor If called with a function then it's considered to be the
     *    controller constructor function. Otherwise it's considered to be a string which is used
     *    to retrieve the controller constructor using the following steps:
     *
     *    * check if a controller with given name is registered via `$controllerProvider`
     *    * check if evaluating the string on the current scope returns a constructor
     *    * check `window[constructor]` on the global `window` object
     *
     * @param {Object} locals Injection locals for Controller.
     * @return {Object} Instance of given controller.
     *
     * @description
     * `$controller` service is responsible for instantiating controllers.
     *
     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into
     * a service, so that one can override this service with {@link https://gist.github.com/1649788
     * BC version}.
     */
    return function(expression, locals) {
      var instance, match, constructor, identifier;

      if(isString(expression)) {
        match = expression.match(CNTRL_REG),
        constructor = match[1],
        identifier = match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);

        assertArgFn(expression, constructor, true);
      }

      instance = $injector.instantiate(expression, locals);

      if (identifier) {
        if (!(locals && typeof locals.$scope == 'object')) {
          throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
        }

        locals.$scope[identifier] = instance;
      }

      return instance;
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$document
 * @requires $window
 *
 * @description
 * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`
 * element.
 */
function $DocumentProvider(){
  this.$get = ['$window', function(window){
    return jqLite(window.document);
  }];
}

/**
 * @ngdoc function
 * @name ng.$exceptionHandler
 * @requires $log
 *
 * @description
 * Any uncaught exception in angular expressions is delegated to this service.
 * The default implementation simply delegates to `$log.error` which logs it into
 * the browser console.
 *
 * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
 *
 * @param {Error} exception Exception associated with the error.
 * @param {string=} cause optional information about the context in which
 *       the error was thrown.
 *
 */
function $ExceptionHandlerProvider() {
  this.$get = ['$log', function($log) {
    return function(exception, cause) {
      $log.error.apply($log, arguments);
    };
  }];
}

/**
 * Parse headers into key value object
 *
 * @param {string} headers Raw headers as a string
 * @returns {Object} Parsed headers as key value object
 */
function parseHeaders(headers) {
  var parsed = {}, key, val, i;

  if (!headers) return parsed;

  forEach(headers.split('\n'), function(line) {
    i = line.indexOf(':');
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    if (key) {
      if (parsed[key]) {
        parsed[key] += ', ' + val;
      } else {
        parsed[key] = val;
      }
    }
  });

  return parsed;
}


/**
 * Returns a function that provides access to parsed headers.
 *
 * Headers are lazy parsed when first requested.
 * @see parseHeaders
 *
 * @param {(string|Object)} headers Headers to provide access to.
 * @returns {function(string=)} Returns a getter function which if called with:
 *
 *   - if called with single an argument returns a single header value or null
 *   - if called with no arguments returns an object containing all headers.
 */
function headersGetter(headers) {
  var headersObj = isObject(headers) ? headers : undefined;

  return function(name) {
    if (!headersObj) headersObj =  parseHeaders(headers);

    if (name) {
      return headersObj[lowercase(name)] || null;
    }

    return headersObj;
  };
}


/**
 * Chain all given functions
 *
 * This function is used for both request and response transforming
 *
 * @param {*} data Data to transform.
 * @param {function(string=)} headers Http headers getter fn.
 * @param {(function|Array.<function>)} fns Function or an array of functions.
 * @returns {*} Transformed data.
 */
function transformData(data, headers, fns) {
  if (isFunction(fns))
    return fns(data, headers);

  forEach(fns, function(fn) {
    data = fn(data, headers);
  });

  return data;
}


function isSuccess(status) {
  return 200 <= status && status < 300;
}


function $HttpProvider() {
  var JSON_START = /^\s*(\[|\{[^\{])/,
      JSON_END = /[\}\]]\s*$/,
      PROTECTION_PREFIX = /^\)\]\}',?\n/,
      CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': 'application/json;charset=utf-8'};

  var defaults = this.defaults = {
    // transform incoming response data
    transformResponse: [function(data) {
      if (isString(data)) {
        // strip json vulnerability protection prefix
        data = data.replace(PROTECTION_PREFIX, '');
        if (JSON_START.test(data) && JSON_END.test(data))
          data = fromJson(data);
      }
      return data;
    }],

    // transform outgoing request data
    transformRequest: [function(d) {
      return isObject(d) && !isFile(d) ? toJson(d) : d;
    }],

    // default headers
    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*'
      },
      post:   CONTENT_TYPE_APPLICATION_JSON,
      put:    CONTENT_TYPE_APPLICATION_JSON,
      patch:  CONTENT_TYPE_APPLICATION_JSON
    },

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN'
  };

  /**
   * Are order by request. I.E. they are applied in the same order as
   * array on request, but revers order on response.
   */
  var interceptorFactories = this.interceptors = [];
  /**
   * For historical reasons, response interceptors ordered by the order in which
   * they are applied to response. (This is in revers to interceptorFactories)
   */
  var responseInterceptorFactories = this.responseInterceptors = [];

  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector', '$$urlUtils',
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector, $$urlUtils) {

    var defaultCache = $cacheFactory('$http');

    /**
     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
     * The reversal is needed so that we can build up the interception chain around the
     * server request.
     */
    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory)
          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory)
          ? $injector.get(interceptorFactory)
          : $injector.invoke(interceptorFactory);

      /**
       * Response interceptors go before "around" interceptors (no real reason, just
       * had to pick one.) But they are already reversed, so we can't use unshift, hence
       * the splice.
       */
      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });


    /**
     * @ngdoc function
     * @name ng.$http
     * @requires $httpBackend
     * @requires $browser
     * @requires $cacheFactory
     * @requires $rootScope
     * @requires $q
     * @requires $injector
     *
     * @description
     * The `$http` service is a core Angular service that facilitates communication with the remote
     * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest
     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.
     *
     * For unit testing applications that use `$http` service, see
     * {@link ngMock.$httpBackend $httpBackend mock}.
     *
     * For a higher level of abstraction, please check out the {@link ngResource.$resource
     * $resource} service.
     *
     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
     * it is important to familiarize yourself with these APIs and the guarantees they provide.
     *
     *
     * # General usage
     * The `$http` service is a function which takes a single argument â€” a configuration object â€”
     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
     * with two $http specific methods: `success` and `error`.
     *
     * <pre>
     *   $http({method: 'GET', url: '/someUrl'}).
     *     success(function(data, status, headers, config) {
     *       // this callback will be called asynchronously
     *       // when the response is available
     *     }).
     *     error(function(data, status, headers, config) {
     *       // called asynchronously if an error occurs
     *       // or server returns response with an error status.
     *     });
     * </pre>
     *
     * Since the returned value of calling the $http function is a `promise`, you can also use
     * the `then` method to register callbacks, and these callbacks will receive a single argument â€“
     * an object representing the response. See the API signature and type info below for more
     * details.
     *
     * A response status code between 200 and 299 is considered a success status and
     * will result in the success callback being called. Note that if the response is a redirect,
     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
     * called for such responses.
     *
     * # Shortcut methods
     *
     * Since all invocations of the $http service require passing in an HTTP method and URL, and
     * POST/PUT requests require request data to be provided as well, shortcut methods
     * were created:
     *
     * <pre>
     *   $http.get('/someUrl').success(successCallback);
     *   $http.post('/someUrl', data).success(successCallback);
     * </pre>
     *
     * Complete list of shortcut methods:
     *
     * - {@link ng.$http#get $http.get}
     * - {@link ng.$http#head $http.head}
     * - {@link ng.$http#post $http.post}
     * - {@link ng.$http#put $http.put}
     * - {@link ng.$http#delete $http.delete}
     * - {@link ng.$http#jsonp $http.jsonp}
     *
     *
     * # Setting HTTP Headers
     *
     * The $http service will automatically add certain HTTP headers to all requests. These defaults
     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
     * object, which currently contains this default configuration:
     *
     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
     *   - `Accept: application/json, text/plain, * / *`
     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
     *   - `Content-Type: application/json`
     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
     *   - `Content-Type: application/json`
     *
     * To add or overwrite these defaults, simply add or remove a property from these configuration
     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
     * with the lowercased HTTP method name as the key, e.g.
     * `$httpProvider.defaults.headers.get['My-Header']='value'`.
     *
     * Additionally, the defaults can be set at runtime via the `$http.defaults` object in the same
     * fashion.
     *
     *
     * # Transforming Requests and Responses
     *
     * Both requests and responses can be transformed using transform functions. By default, Angular
     * applies these transformations:
     *
     * Request transformations:
     *
     * - If the `data` property of the request configuration object contains an object, serialize it into
     *   JSON format.
     *
     * Response transformations:
     *
     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
     *  - If JSON response is detected, deserialize it using a JSON parser.
     *
     * To globally augment or override the default transforms, modify the `$httpProvider.defaults.transformRequest` and
     * `$httpProvider.defaults.transformResponse` properties. These properties are by default an
     * array of transform functions, which allows you to `push` or `unshift` a new transformation function into the
     * transformation chain. You can also decide to completely override any default transformations by assigning your
     * transformation functions to these properties directly without the array wrapper.
     *
     * Similarly, to locally override the request/response transforms, augment the `transformRequest` and/or
     * `transformResponse` properties of the configuration object passed into `$http`.
     *
     *
     * # Caching
     *
     * To enable caching, set the configuration property `cache` to `true`. When the cache is
     * enabled, `$http` stores the response from the server in local cache. Next time the
     * response is served from the cache without sending a request to the server.
     *
     * Note that even if the response is served from cache, delivery of the data is asynchronous in
     * the same way that real requests are.
     *
     * If there are multiple GET requests for the same URL that should be cached using the same
     * cache, but the cache is not populated yet, only one request to the server will be made and
     * the remaining requests will be fulfilled using the response from the first request.
     *
     * A custom default cache built with $cacheFactory can be provided in $http.defaults.cache.
     * To skip it, set configuration property `cache` to `false`.
     *
     *
     * # Interceptors
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication, or any kind of synchronous or
     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
     * able to intercept requests before they are handed to the server and
     * responses before they are handed over to the application code that
     * initiated these requests. The interceptors leverage the {@link ng.$q
     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
     *
     * The interceptors are service factories that are registered with the `$httpProvider` by
     * adding them to the `$httpProvider.interceptors` array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor.
     *
     * There are two kinds of interceptors (and two kinds of rejection interceptors):
     *
     *   * `request`: interceptors get called with http `config` object. The function is free to modify
     *     the `config` or create a new one. The function needs to return the `config` directly or as a
     *     promise.
     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or resolved
     *      with a rejection.
     *   * `response`: interceptors get called with http `response` object. The function is free to modify
     *     the `response` or create a new one. The function needs to return the `response` directly or as a
     *     promise.
     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or resolved
     *      with a rejection.
     *
     *
     * <pre>
     *   // register the interceptor as a service
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return {
     *       // optional method
     *       'request': function(config) {
     *         // do something on success
     *         return config || $q.when(config);
     *       },
     *
     *       // optional method
     *      'requestError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       },
     *
     *
     *
     *       // optional method
     *       'response': function(response) {
     *         // do something on success
     *         return response || $q.when(response);
     *       },
     *
     *       // optional method
     *      'responseError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       };
     *     }
     *   });
     *
     *   $httpProvider.interceptors.push('myHttpInterceptor');
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
     *     return {
     *      'request': function(config) {
     *          // same as above
     *       },
     *       'response': function(response) {
     *          // same as above
     *       }
     *   });
     * </pre>
     *
     * # Response interceptors (DEPRECATED)
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication or any kind of synchronous or
     * asynchronous preprocessing of received responses, it is desirable to be able to intercept
     * responses for http requests before they are handed over to the application code that
     * initiated these requests. The response interceptors leverage the {@link ng.$q
     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.
     *
     * The interceptors are service factories that are registered with the $httpProvider by
     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor  â€” a function that
     * takes a {@link ng.$q promise} and returns the original or a new promise.
     *
     * <pre>
     *   // register the interceptor as a service
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       return promise.then(function(response) {
     *         // do something on success
     *         return response;
     *       }, function(response) {
     *         // do something on error
     *         if (canRecover(response)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(response);
     *       });
     *     }
     *   });
     *
     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       // same as above
     *     }
     *   });
     * </pre>
     *
     *
     * # Security Considerations
     *
     * When designing web applications, consider security threats from:
     *
     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     *   JSON vulnerability}
     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}
     *
     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
     * pre-configured with strategies that address these issues, but for this to work backend server
     * cooperation is required.
     *
     * ## JSON Vulnerability Protection
     *
     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     * JSON vulnerability} allows third party website to turn your JSON resource URL into
     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To
     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
     * Angular will automatically strip the prefix before processing it as JSON.
     *
     * For example if your server needs to return:
     * <pre>
     * ['one','two']
     * </pre>
     *
     * which is vulnerable to attack, your server can return:
     * <pre>
     * )]}',
     * ['one','two']
     * </pre>
     *
     * Angular will strip the prefix, before processing the JSON.
     *
     *
     * ## Cross Site Request Forgery (XSRF) Protection
     *
     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which
     * an unauthorized site can gain your user's private data. Angular provides a mechanism
     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
     * JavaScript that runs on your domain could read the cookie, your server can be assured that
     * the XHR came from JavaScript running on your domain. The header will not be set for
     * cross-domain requests.
     *
     * To take advantage of this, your server needs to set a token in a JavaScript readable session
     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
     * that only JavaScript running on your domain could have sent the request. The token must be
     * unique for each user and must be verifiable by the server (to prevent the JavaScript from making
     * up its own tokens). We recommend that the token is a digest of your site's authentication
     * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.
     *
     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
     * properties of either $httpProvider.defaults, or the per-request config object.
     *
     *
     * @param {object} config Object describing the request to be made and how it should be
     *    processed. The object has following properties:
     *
     *    - **method** â€“ `{string}` â€“ HTTP method (e.g. 'GET', 'POST', etc)
     *    - **url** â€“ `{string}` â€“ Absolute or relative URL of the resource that is being requested.
     *    - **params** â€“ `{Object.<string|Object>}` â€“ Map of strings or objects which will be turned to
     *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.
     *    - **data** â€“ `{string|Object}` â€“ Data to be sent as the request message data.
     *    - **headers** â€“ `{Object}` â€“ Map of strings or functions which return strings representing
     *      HTTP headers to send to the server. If the return value of a function is null, the header will
     *      not be sent.
     *    - **xsrfHeaderName** â€“ `{string}` â€“ Name of HTTP header to populate with the XSRF token.
     *    - **xsrfCookieName** â€“ `{string}` â€“ Name of cookie containing the XSRF token.
     *    - **transformRequest** â€“ `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` â€“
     *      transform function or an array of such functions. The transform function takes the http
     *      request body and headers and returns its transformed (typically serialized) version.
     *    - **transformResponse** â€“ `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` â€“
     *      transform function or an array of such functions. The transform function takes the http
     *      response body and headers and returns its transformed (typically deserialized) version.
     *    - **cache** â€“ `{boolean|Cache}` â€“ If true, a default $http cache will be used to cache the
     *      GET request, otherwise if a cache instance built with
     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
     *      caching.
     *    - **timeout** â€“ `{number|Promise}` â€“ timeout in milliseconds, or {@link ng.$q promise}
     *      that should abort the request when resolved.
     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the
     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
     *      requests with credentials} for more information.
     *    - **responseType** - `{string}` - see {@link
     *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
     *
     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
     *   standard `then` method and two http specific methods: `success` and `error`. The `then`
     *   method takes two arguments a success and an error callback which will be called with a
     *   response object. The `success` and `error` methods take a single argument - a function that
     *   will be called when the request succeeds or fails respectively. The arguments passed into
     *   these functions are destructured representation of the response object passed into the
     *   `then` method. The response object has these properties:
     *
     *   - **data** â€“ `{string|Object}` â€“ The response body transformed with the transform functions.
     *   - **status** â€“ `{number}` â€“ HTTP status code of the response.
     *   - **headers** â€“ `{function([headerName])}` â€“ Header getter function.
     *   - **config** â€“ `{Object}` â€“ The configuration object that was used to generate the request.
     *
     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
     *   requests. This is primarily meant to be used for debugging purposes.
     *
     *
     * @example
      <example>
        <file name="index.html">
          <div ng-controller="FetchCtrl">
            <select ng-model="method">
              <option>GET</option>
              <option>JSONP</option>
            </select>
            <input type="text" ng-model="url" size="80"/>
            <button ng-click="fetch()">fetch</button><br>
            <button ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
            <button ng-click="updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">Sample JSONP</button>
            <button ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')">Invalid JSONP</button>
            <pre>http status code: {{status}}</pre>
            <pre>http response data: {{data}}</pre>
          </div>
        </file>
        <file name="script.js">
          function FetchCtrl($scope, $http, $templateCache) {
            $scope.method = 'GET';
            $scope.url = 'http-hello.html';

            $scope.fetch = function() {
              $scope.code = null;
              $scope.response = null;

              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
                success(function(data, status) {
                  $scope.status = status;
                  $scope.data = data;
                }).
                error(function(data, status) {
                  $scope.data = data || "Request failed";
                  $scope.status = status;
              });
            };

            $scope.updateModel = function(method, url) {
              $scope.method = method;
              $scope.url = url;
            };
          }
        </file>
        <file name="http-hello.html">
          Hello, $http!
        </file>
        <file name="scenario.js">
          it('should make an xhr GET request', function() {
            element(':button:contains("Sample GET")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('200');
            expect(binding('data')).toMatch(/Hello, \$http!/);
          });

          it('should make a JSONP request to angularjs.org', function() {
            element(':button:contains("Sample JSONP")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('200');
            expect(binding('data')).toMatch(/Super Hero!/);
          });

          it('should make JSONP request to invalid URL and invoke the error handler',
              function() {
            element(':button:contains("Invalid JSONP")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('0');
            expect(binding('data')).toBe('Request failed');
          });
        </file>
      </example>
     */
    function $http(requestConfig) {
      var config = {
        transformRequest: defaults.transformRequest,
        transformResponse: defaults.transformResponse
      };
      var headers = mergeHeaders(requestConfig);

      extend(config, requestConfig);
      config.headers = headers;
      config.method = uppercase(config.method);

      var xsrfValue = $$urlUtils.isSameOrigin(config.url)
          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
          : undefined;
      if (xsrfValue) {
        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
      }


      var serverRequest = function(config) {
        headers = config.headers;
        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

        // strip content-type if data is undefined
        if (isUndefined(config.data)) {
          forEach(headers, function(value, header) {
            if (lowercase(header) === 'content-type') {
                delete headers[header];
            }
          });
        }

        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
          config.withCredentials = defaults.withCredentials;
        }

        // send request
        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
      };

      var chain = [serverRequest, undefined];
      var promise = $q.when(config);

      // apply interceptors
      forEach(reversedInterceptors, function(interceptor) {
        if (interceptor.request || interceptor.requestError) {
          chain.unshift(interceptor.request, interceptor.requestError);
        }
        if (interceptor.response || interceptor.responseError) {
          chain.push(interceptor.response, interceptor.responseError);
        }
      });

      while(chain.length) {
        var thenFn = chain.shift();
        var rejectFn = chain.shift();

        promise = promise.then(thenFn, rejectFn);
      }

      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      return promise;

      function transformResponse(response) {
        // make a copy since the response must be cacheable
        var resp = extend({}, response, {
          data: transformData(response.data, response.headers, config.transformResponse)
        });
        return (isSuccess(response.status))
          ? resp
          : $q.reject(resp);
      }

      function mergeHeaders(config) {
        var defHeaders = defaults.headers,
            reqHeaders = extend({}, config.headers),
            defHeaderName, lowercaseDefHeaderName, reqHeaderName;

        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);

        // execute if header value is function
        execHeaders(defHeaders);
        execHeaders(reqHeaders);

        // using for-in instead of forEach to avoid unecessary iteration after header has been found
        defaultHeadersIteration:
        for (defHeaderName in defHeaders) {
          lowercaseDefHeaderName = lowercase(defHeaderName);

          for (reqHeaderName in reqHeaders) {
            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
              continue defaultHeadersIteration;
            }
          }

          reqHeaders[defHeaderName] = defHeaders[defHeaderName];
        }

        return reqHeaders;

        function execHeaders(headers) {
          var headerContent;

          forEach(headers, function(headerFn, header) {
            if (isFunction(headerFn)) {
              headerContent = headerFn();
              if (headerContent != null) {
                headers[header] = headerContent;
              } else {
                delete headers[header];
              }
            }
          });
        }
      }
    }

    $http.pendingRequests = [];

    /**
     * @ngdoc method
     * @name ng.$http#get
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `GET` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#delete
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `DELETE` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#head
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `HEAD` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#jsonp
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `JSONP` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request.
     *                     Should contain `JSON_CALLBACK` string.
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethods('get', 'delete', 'head', 'jsonp');

    /**
     * @ngdoc method
     * @name ng.$http#post
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `POST` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#put
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `PUT` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethodsWithData('post', 'put');

        /**
         * @ngdoc property
         * @name ng.$http#defaults
         * @propertyOf ng.$http
         *
         * @description
         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
         * default headers, withCredentials as well as request and response transformations.
         *
         * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
         */
    $http.defaults = defaults;


    return $http;


    function createShortMethods(names) {
      forEach(arguments, function(name) {
        $http[name] = function(url, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url
          }));
        };
      });
    }


    function createShortMethodsWithData(name) {
      forEach(arguments, function(name) {
        $http[name] = function(url, data, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url,
            data: data
          }));
        };
      });
    }


    /**
     * Makes the request.
     *
     * !!! ACCESSES CLOSURE VARS:
     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
     */
    function sendReq(config, reqData, reqHeaders) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          cache,
          cachedResp,
          url = buildUrl(config.url, config.params);

      $http.pendingRequests.push(config);
      promise.then(removePendingReq, removePendingReq);


      if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {
        cache = isObject(config.cache) ? config.cache
              : isObject(defaults.cache) ? defaults.cache
              : defaultCache;
      }

      if (cache) {
        cachedResp = cache.get(url);
        if (isDefined(cachedResp)) {
          if (cachedResp.then) {
            // cached request has already been sent, but there is no response yet
            cachedResp.then(removePendingReq, removePendingReq);
            return cachedResp;
          } else {
            // serving from cache
            if (isArray(cachedResp)) {
              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
            } else {
              resolvePromise(cachedResp, 200, {});
            }
          }
        } else {
          // put the promise for the non-transformed response into cache as a placeholder
          cache.put(url, promise);
        }
      }

      // if we won't have the response in cache, send the request to the backend
      if (isUndefined(cachedResp)) {
        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
            config.withCredentials, config.responseType);
      }

      return promise;


      /**
       * Callback registered to $httpBackend():
       *  - caches the response if desired
       *  - resolves the raw $http promise
       *  - calls $apply
       */
      function done(status, response, headersString) {
        if (cache) {
          if (isSuccess(status)) {
            cache.put(url, [status, response, parseHeaders(headersString)]);
          } else {
            // remove promise from the cache
            cache.remove(url);
          }
        }

        resolvePromise(response, status, headersString);
        if (!$rootScope.$$phase) $rootScope.$apply();
      }


      /**
       * Resolves the raw $http promise.
       */
      function resolvePromise(response, status, headers) {
        // normalize internal statuses to 0
        status = Math.max(status, 0);

        (isSuccess(status) ? deferred.resolve : deferred.reject)({
          data: response,
          status: status,
          headers: headersGetter(headers),
          config: config
        });
      }


      function removePendingReq() {
        var idx = indexOf($http.pendingRequests, config);
        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
      }
    }


    function buildUrl(url, params) {
          if (!params) return url;
          var parts = [];
          forEachSorted(params, function(value, key) {
            if (value == null || value == undefined) return;
            if (!isArray(value)) value = [value];

            forEach(value, function(v) {
              if (isObject(v)) {
                v = toJson(v);
              }
              parts.push(encodeUriQuery(key) + '=' +
                         encodeUriQuery(v));
            });
          });
          return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
        }


  }];
}

var XHR = window.XMLHttpRequest || function() {
  try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch (e2) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP"); } catch (e3) {}
  throw minErr('$httpBackend')('noxhr', "This browser does not support XMLHttpRequest.");
};


/**
 * @ngdoc object
 * @name ng.$httpBackend
 * @requires $browser
 * @requires $window
 * @requires $document
 *
 * @description
 * HTTP backend used by the {@link ng.$http service} that delegates to
 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
 *
 * You should never need to use this service directly, instead use the higher-level abstractions:
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
 *
 * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
 * $httpBackend} which can be trained with responses.
 */
function $HttpBackendProvider() {
  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,
        $document[0], $window.location.protocol.replace(':', ''));
  }];
}

function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
  // TODO(vojta): fix the signature
  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
    var status;
    $browser.$$incOutstandingRequestCount();
    url = url || $browser.url();

    if (lowercase(method) == 'jsonp') {
      var callbackId = '_' + (callbacks.counter++).toString(36);
      callbacks[callbackId] = function(data) {
        callbacks[callbackId].data = data;
      };

      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
          function() {
        if (callbacks[callbackId].data) {
          completeRequest(callback, 200, callbacks[callbackId].data);
        } else {
          completeRequest(callback, status || -2);
        }
        delete callbacks[callbackId];
      });
    } else {
      var xhr = new XHR();
      xhr.open(method, url, true);
      forEach(headers, function(value, key) {
        if (value) xhr.setRequestHeader(key, value);
      });

      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the
      // response is in the cache. the promise api will ensure that to the app code the api is
      // always async
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          var responseHeaders = xhr.getAllResponseHeaders();

          // TODO(vojta): remove once Firefox 21 gets released.
          // begin: workaround to overcome Firefox CORS http response headers bug
          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735
          // Firefox already patched in nightly. Should land in Firefox 21.

          // CORS "simple response headers" http://www.w3.org/TR/cors/
          var value,
              simpleHeaders = ["Cache-Control", "Content-Language", "Content-Type",
                                  "Expires", "Last-Modified", "Pragma"];
          if (!responseHeaders) {
            responseHeaders = "";
            forEach(simpleHeaders, function (header) {
              var value = xhr.getResponseHeader(header);
              if (value) {
                  responseHeaders += header + ": " + value + "\n";
              }
            });
          }
          // end of the workaround.

          // responseText is the old-school way of retrieving response (supported by IE8 & 9)
          // response and responseType properties were introduced in XHR Level2 spec (supported by IE10)
          completeRequest(callback,
              status || xhr.status,
              (xhr.responseType ? xhr.response : xhr.responseText),
              responseHeaders);
        }
      };

      if (withCredentials) {
        xhr.withCredentials = true;
      }

      if (responseType) {
        xhr.responseType = responseType;
      }

      xhr.send(post || '');
    }

    if (timeout > 0) {
      var timeoutId = $browserDefer(timeoutRequest, timeout);
    } else if (timeout && timeout.then) {
      timeout.then(timeoutRequest);
    }


    function timeoutRequest() {
      status = -1;
      jsonpDone && jsonpDone();
      xhr && xhr.abort();
    }

    function completeRequest(callback, status, response, headersString) {
      // URL_MATCH is defined in src/service/location.js
      var protocol = (url.match(SERVER_MATCH) || ['', locationProtocol])[1];

      // cancel timeout and subsequent timeout promise resolution
      timeoutId && $browserDefer.cancel(timeoutId);
      jsonpDone = xhr = null;

      // fix status code for file protocol (it's always 0)
      status = (protocol == 'file') ? (response ? 200 : 404) : status;

      // normalize IE bug (http://bugs.jquery.com/ticket/1450)
      status = status == 1223 ? 204 : status;

      callback(status, response, headersString);
      $browser.$$completeOutstandingRequest(noop);
    }
  };

  function jsonpReq(url, done) {
    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
    // - fetches local scripts via XHR and evals them
    // - adds and immediately removes script elements from the document
    var script = rawDocument.createElement('script'),
        doneWrapper = function() {
          rawDocument.body.removeChild(script);
          if (done) done();
        };

    script.type = 'text/javascript';
    script.src = url;

    if (msie) {
      script.onreadystatechange = function() {
        if (/loaded|complete/.test(script.readyState)) doneWrapper();
      };
    } else {
      script.onload = script.onerror = doneWrapper;
    }

    rawDocument.body.appendChild(script);
    return doneWrapper;
  }
}

var $interpolateMinErr = minErr('$interpolate');

/**
 * @ngdoc object
 * @name ng.$interpolateProvider
 * @function
 *
 * @description
 *
 * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
 *
 * @example
   <doc:example module="customInterpolationApp">
     <doc:source>
      <script>
        var customInterpolationApp = angular.module('customInterpolationApp', []);

        customInterpolationApp.config(function($interpolateProvider) {
          $interpolateProvider.startSymbol('//');
          $interpolateProvider.endSymbol('//');
        });


        customInterpolationApp.controller('DemoController', function DemoController() {
            this.label = "This bindings is brought you you by // interpolation symbols.";
        });
      </script>
      <div ng-app="App" ng-controller="DemoController as demo">
          //demo.label//
      </div>
     </doc:source>
     <doc:scenario>
       it('should interpolate binding with custom symbols', function() {
         expect(binding('demo.label')).toBe('This bindings is brought you you by // interpolation symbols.');
       });
 </doc:scenario>
   </doc:example>
 */
function $InterpolateProvider() {
  var startSymbol = '{{';
  var endSymbol = '}}';

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#startSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
   *
   * @param {string=} value new value to set the starting symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.startSymbol = function(value){
    if (value) {
      startSymbol = value;
      return this;
    } else {
      return startSymbol;
    }
  };

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#endSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
   *
   * @param {string=} value new value to set the ending symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.endSymbol = function(value){
    if (value) {
      endSymbol = value;
      return this;
    } else {
      return endSymbol;
    }
  };


  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
    var startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length;

    /**
     * @ngdoc function
     * @name ng.$interpolate
     * @function
     *
     * @requires $parse
     * @requires $sce
     *
     * @description
     *
     * Compiles a string with markup into an interpolation function. This service is used by the
     * HTML {@link ng.$compile $compile} service for data binding. See
     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
     * interpolation markup.
     *
     *
       <pre>
         var $interpolate = ...; // injected
         var exp = $interpolate('Hello {{name}}!');
         expect(exp({name:'Angular'}).toEqual('Hello Angular!');
       </pre>
     *
     *
     * @param {string} text The text with markup to interpolate.
     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
     *    embedded expression in order to return an interpolation function. Strings with no
     *    embedded expression will return null for the interpolation function.
     * @param {string=} trustedContext when provided, the returned function passes the interpolated
     *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
     *    provides Strict Contextual Escaping for details.
     * @returns {function(context)} an interpolation function which is used to compute the interpolated
     *    string. The function has these parameters:
     *
     *    * `context`: an object against which any expressions embedded in the strings are evaluated
     *      against.
     *
     */
    function $interpolate(text, mustHaveExpression, trustedContext) {
      var startIndex,
          endIndex,
          index = 0,
          parts = [],
          length = text.length,
          hasInterpolation = false,
          fn,
          exp,
          concat = [];

      while(index < length) {
        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&
             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {
          (index != startIndex) && parts.push(text.substring(index, startIndex));
          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
          fn.exp = exp;
          index = endIndex + endSymbolLength;
          hasInterpolation = true;
        } else {
          // we did not find anything, so we have to add the remainder to the parts array
          (index != length) && parts.push(text.substring(index));
          index = length;
        }
      }

      if (!(length = parts.length)) {
        // we added, nothing, must have been an empty string.
        parts.push('');
        length = 1;
      }

      // Concatenating expressions makes it hard to reason about whether some combination of concatenated
      // values are unsafe to use and could easily lead to XSS.  By requiring that a single
      // expression be used for iframe[src], object[src], etc., we ensure that the value that's used
      // is assigned or constructed by some JS code somewhere that is more testable or make it
      // obvious that you bound the value to some user controlled value.  This helps reduce the load
      // when auditing for XSS issues.
      if (trustedContext && parts.length > 1) {
          throw $interpolateMinErr('noconcat',
              "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
              "interpolations that concatenate multiple expressions when a trusted value is " +
              "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      }

      if (!mustHaveExpression  || hasInterpolation) {
        concat.length = length;
        fn = function(context) {
          try {
            for(var i = 0, ii = length, part; i<ii; i++) {
              if (typeof (part = parts[i]) == 'function') {
                part = part(context);
                if (trustedContext) {
                  part = $sce.getTrusted(trustedContext, part);
                } else {
                  part = $sce.valueOf(part);
                }
                if (part == null || part == undefined) {
                  part = '';
                } else if (typeof part != 'string') {
                  part = toJson(part);
                }
              }
              concat[i] = part;
            }
            return concat.join('');
          }
          catch(err) {
            var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
            $exceptionHandler(newErr);
          }
        };
        fn.exp = text;
        fn.parts = parts;
        return fn;
      }
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#startSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
     *
     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.startSymbol = function() {
      return startSymbol;
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#endSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
     *
     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.endSymbol = function() {
      return endSymbol;
    }

    return $interpolate;
  }];
}

/**
 * @ngdoc object
 * @name ng.$locale
 *
 * @description
 * $locale service provides localization rules for various Angular components. As of right now the
 * only public api is:
 *
 * * `id` â€“ `{string}` â€“ locale id formatted as `languageId-countryId` (e.g. `en-us`)
 */
function $LocaleProvider(){
  this.$get = function() {
    return {
      id: 'en-us',

      NUMBER_FORMATS: {
        DECIMAL_SEP: '.',
        GROUP_SEP: ',',
        PATTERNS: [
          { // Decimal Pattern
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: '',
            posSuf: '',
            negPre: '-',
            negSuf: '',
            gSize: 3,
            lgSize: 3
          },{ //Currency Pattern
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: '\u00A4',
            posSuf: '',
            negPre: '(\u00A4',
            negSuf: ')',
            gSize: 3,
            lgSize: 3
          }
        ],
        CURRENCY_SYM: '$'
      },

      DATETIME_FORMATS: {
        MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'
                .split(','),
        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
        AMPMS: ['AM','PM'],
        medium: 'MMM d, y h:mm:ss a',
        short: 'M/d/yy h:mm a',
        fullDate: 'EEEE, MMMM d, y',
        longDate: 'MMMM d, y',
        mediumDate: 'MMM d, y',
        shortDate: 'M/d/yy',
        mediumTime: 'h:mm:ss a',
        shortTime: 'h:mm a'
      },

      pluralCat: function(num) {
        if (num === 1) {
          return 'one';
        }
        return 'other';
      }
    };
  };
}

var SERVER_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/,
    PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
var $locationMinErr = minErr('$location');


/**
 * Encode path using encodeUriSegment, ignoring forward slashes
 *
 * @param {string} path Path to encode
 * @returns {string}
 */
function encodePath(path) {
  var segments = path.split('/'),
      i = segments.length;

  while (i--) {
    segments[i] = encodeUriSegment(segments[i]);
  }

  return segments.join('/');
}

function matchUrl(url, obj) {
  var match = SERVER_MATCH.exec(url);

  obj.$$protocol = match[1];
  obj.$$host = match[3];
  obj.$$port = int(match[5]) || DEFAULT_PORTS[match[1]] || null;
}

function matchAppUrl(url, obj) {
  var match = PATH_MATCH.exec(url);

  obj.$$path = decodeURIComponent(match[1]);
  obj.$$search = parseKeyValue(match[3]);
  obj.$$hash = decodeURIComponent(match[5] || '');

  // make sure path starts with '/';
  if (obj.$$path && obj.$$path.charAt(0) != '/') obj.$$path = '/' + obj.$$path;
}


function composeProtocolHostPort(protocol, host, port) {
  return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
}

/**
 *
 * @param {string} begin
 * @param {string} whole
 * @param {string} otherwise
 * @returns {string} returns text from whole after begin or otherwise if it does not begin with expected string.
 */
function beginsWith(begin, whole, otherwise) {
  return whole.indexOf(begin) == 0 ? whole.substr(begin.length) : otherwise;
}


function stripHash(url) {
  var index = url.indexOf('#');
  return index == -1 ? url : url.substr(0, index);
}


function stripFile(url) {
  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
}

/* return the server only (scheme://host:port) */
function serverBase(url) {
  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
}


/**
 * LocationHtml5Url represents an url
 * This object is exposed as $location service when HTML5 mode is enabled and supported
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} basePrefix url path prefix
 */
function LocationHtml5Url(appBase, basePrefix) {
  this.$$html5 = true;
  basePrefix = basePrefix || '';
  var appBaseNoFile = stripFile(appBase);
  /**
   * Parse given html5 (regular) url string into properties
   * @param {string} newAbsoluteUrl HTML5 url
   * @private
   */
  this.$$parse = function(url) {
    var parsed = {}
    matchUrl(url, parsed);
    var pathUrl = beginsWith(appBaseNoFile, url);
    if (!isString(pathUrl)) {
      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
    }
    matchAppUrl(pathUrl, parsed);
    extend(this, parsed);
    if (!this.$$path) {
      this.$$path = '/';
    }

    this.$$compose();
  };

  /**
   * Compose url and update `absUrl` property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
  };

  this.$$rewrite = function(url) {
    var appUrl, prevAppUrl;

    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {
      prevAppUrl = appUrl;
      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {
        return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
      } else {
        return appBase + prevAppUrl;
      }
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {
      return appBaseNoFile + appUrl;
    } else if (appBaseNoFile == url + '/') {
      return appBaseNoFile;
    }
  }
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when developer doesn't opt into html5 mode.
 * It also serves as the base class for html5 mode fallback on legacy browsers.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangUrl(appBase, hashPrefix) {
  var appBaseNoFile = stripFile(appBase);

  matchUrl(appBase, this);


  /**
   * Parse given hashbang url into properties
   * @param {string} url Hashbang url
   * @private
   */
  this.$$parse = function(url) {
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'
        ? beginsWith(hashPrefix, withoutBaseUrl)
        : (this.$$html5)
          ? withoutBaseUrl
          : '';

    if (!isString(withoutHashUrl)) {
      throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
    }
    matchAppUrl(withoutHashUrl, this);
    this.$$compose();
  };

  /**
   * Compose hashbang url and update `absUrl` property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
  };

  this.$$rewrite = function(url) {
    if(stripHash(appBase) == stripHash(url)) {
      return url;
    }
  }
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when html5 history api is enabled but the browser
 * does not support it.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangInHtml5Url(appBase, hashPrefix) {
  this.$$html5 = true;
  LocationHashbangUrl.apply(this, arguments);

  var appBaseNoFile = stripFile(appBase);

  this.$$rewrite = function(url) {
    var appUrl;

    if ( appBase == stripHash(url) ) {
      return url;
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {
      return appBase + hashPrefix + appUrl;
    } else if ( appBaseNoFile === url + '/') {
      return appBaseNoFile;
    }
  }
}


LocationHashbangInHtml5Url.prototype =
  LocationHashbangUrl.prototype =
  LocationHtml5Url.prototype = {

  /**
   * Are we in html5 mode?
   * @private
   */
  $$html5: false,

  /**
   * Has any change been replacing ?
   * @private
   */
  $$replace: false,

  /**
   * @ngdoc method
   * @name ng.$location#absUrl
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return full url representation with all segments encoded according to rules specified in
   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.
   *
   * @return {string} full url
   */
  absUrl: locationGetter('$$absUrl'),

  /**
   * @ngdoc method
   * @name ng.$location#url
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
   *
   * Change path, search and hash, when called with parameter and return `$location`.
   *
   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
   * @param {string=} replace The path that will be changed
   * @return {string} url
   */
  url: function(url, replace) {
    if (isUndefined(url))
      return this.$$url;

    var match = PATH_MATCH.exec(url);
    if (match[1]) this.path(decodeURIComponent(match[1]));
    if (match[2] || match[1]) this.search(match[3] || '');
    this.hash(match[5] || '', replace);

    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#protocol
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return protocol of current url.
   *
   * @return {string} protocol of current url
   */
  protocol: locationGetter('$$protocol'),

  /**
   * @ngdoc method
   * @name ng.$location#host
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return host of current url.
   *
   * @return {string} host of current url.
   */
  host: locationGetter('$$host'),

  /**
   * @ngdoc method
   * @name ng.$location#port
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return port of current url.
   *
   * @return {Number} port
   */
  port: locationGetter('$$port'),

  /**
   * @ngdoc method
   * @name ng.$location#path
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return path of current url when called without any parameter.
   *
   * Change path when called with parameter and return `$location`.
   *
   * Note: Path should always begin with forward slash (/), this method will add the forward slash
   * if it is missing.
   *
   * @param {string=} path New path
   * @return {string} path
   */
  path: locationGetterSetter('$$path', function(path) {
    return path.charAt(0) == '/' ? path : '/' + path;
  }),

  /**
   * @ngdoc method
   * @name ng.$location#search
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return search part (as object) of current url when called without any parameter.
   *
   * Change search part when called with parameter and return `$location`.
   *
   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or hash object. Hash object
   *    may contain an array of values, which will be decoded as duplicates in the url.
   * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a
   *    single search parameter. If the value is `null`, the parameter will be deleted.
   *
   * @return {string} search
   */
  search: function(search, paramValue) {
    switch (arguments.length) {
      case 0:
        return this.$$search;
      case 1:
        if (isString(search)) {
          this.$$search = parseKeyValue(search);
        } else if (isObject(search)) {
          this.$$search = search;
        } else {
          throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
        }
        break;
      default:
        if (paramValue == undefined || paramValue == null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
    }

    this.$$compose();
    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#hash
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return hash fragment when called without any parameter.
   *
   * Change hash fragment when called with parameter and return `$location`.
   *
   * @param {string=} hash New hash fragment
   * @return {string} hash
   */
  hash: locationGetterSetter('$$hash', identity),

  /**
   * @ngdoc method
   * @name ng.$location#replace
   * @methodOf ng.$location
   *
   * @description
   * If called, all changes to $location during current `$digest` will be replacing current history
   * record, instead of adding new one.
   */
  replace: function() {
    this.$$replace = true;
    return this;
  }
};

function locationGetter(property) {
  return function() {
    return this[property];
  };
}


function locationGetterSetter(property, preprocess) {
  return function(value) {
    if (isUndefined(value))
      return this[property];

    this[property] = preprocess(value);
    this.$$compose();

    return this;
  };
}


/**
 * @ngdoc object
 * @name ng.$location
 *
 * @requires $browser
 * @requires $sniffer
 * @requires $rootElement
 *
 * @description
 * The $location service parses the URL in the browser address bar (based on the
 * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL
 * available to your application. Changes to the URL in the address bar are reflected into
 * $location service and changes to $location are reflected into the browser address bar.
 *
 * **The $location service:**
 *
 * - Exposes the current URL in the browser address bar, so you can
 *   - Watch and observe the URL.
 *   - Change the URL.
 * - Synchronizes the URL with the browser when the user
 *   - Changes the address bar.
 *   - Clicks the back or forward button (or clicks a History link).
 *   - Clicks on a link.
 * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
 *
 * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular
 * Services: Using $location}
 */

/**
 * @ngdoc object
 * @name ng.$locationProvider
 * @description
 * Use the `$locationProvider` to configure how the application deep linking paths are stored.
 */
function $LocationProvider(){
  var hashPrefix = '',
      html5Mode = false;

  /**
   * @ngdoc property
   * @name ng.$locationProvider#hashPrefix
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} prefix Prefix for hash part (containing path and search)
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.hashPrefix = function(prefix) {
    if (isDefined(prefix)) {
      hashPrefix = prefix;
      return this;
    } else {
      return hashPrefix;
    }
  };

  /**
   * @ngdoc property
   * @name ng.$locationProvider#html5Mode
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} mode Use HTML5 strategy if available.
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.html5Mode = function(mode) {
    if (isDefined(mode)) {
      html5Mode = mode;
      return this;
    } else {
      return html5Mode;
    }
  };

  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
      function( $rootScope,   $browser,   $sniffer,   $rootElement) {
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
        initialUrl = $browser.url(),
        appBase;

    if (html5Mode) {
      appBase = serverBase(initialUrl) + (baseHref || '/');
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    } else {
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    }
    $location = new LocationMode(appBase, '#' + hashPrefix);
    $location.$$parse($location.$$rewrite(initialUrl));

    $rootElement.on('click', function(event) {
      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
      // currently we open nice url link and redirect then

      if (event.ctrlKey || event.metaKey || event.which == 2) return;

      var elm = jqLite(event.target);

      // traverse the DOM up to find first A tag
      while (lowercase(elm[0].nodeName) !== 'a') {
        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
      }

      var absHref = elm.prop('href');
      var rewrittenUrl = $location.$$rewrite(absHref);

      if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {
        event.preventDefault();
        if (rewrittenUrl != $browser.url()) {
          // update location manually
          $location.$$parse(rewrittenUrl);
          $rootScope.$apply();
          // hack to work around FF6 bug 684208 when scenario runner clicks on links
          window.angular['ff-684208-preventDefault'] = true;
        }
      }
    });


    // rewrite hashbang url <> html5 url
    if ($location.absUrl() != initialUrl) {
      $browser.url($location.absUrl(), true);
    }

    // update $location when $browser url changes
    $browser.onUrlChange(function(newUrl) {
      if ($location.absUrl() != newUrl) {
        if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
          $browser.url($location.absUrl());
          return;
        }
        $rootScope.$evalAsync(function() {
          var oldUrl = $location.absUrl();

          $location.$$parse(newUrl);
          afterLocationChange(oldUrl);
        });
        if (!$rootScope.$$phase) $rootScope.$digest();
      }
    });

    // update browser
    var changeCounter = 0;
    $rootScope.$watch(function $locationWatch() {
      var oldUrl = $browser.url();
      var currentReplace = $location.$$replace;

      if (!changeCounter || oldUrl != $location.absUrl()) {
        changeCounter++;
        $rootScope.$evalAsync(function() {
          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).
              defaultPrevented) {
            $location.$$parse(oldUrl);
          } else {
            $browser.url($location.absUrl(), currentReplace);
            afterLocationChange(oldUrl);
          }
        });
      }
      $location.$$replace = false;

      return changeCounter;
    });

    return $location;

    function afterLocationChange(oldUrl) {
      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
    }
}];
}

/**
 * @ngdoc object
 * @name ng.$log
 * @requires $window
 *
 * @description
 * Simple service for logging. Default implementation writes the message
 * into the browser's console (if present).
 *
 * The main purpose of this service is to simplify debugging and troubleshooting.
 *
 * @example
   <example>
     <file name="script.js">
       function LogCtrl($scope, $log) {
         $scope.$log = $log;
         $scope.message = 'Hello World!';
       }
     </file>
     <file name="index.html">
       <div ng-controller="LogCtrl">
         <p>Reload this page with open console, enter text and hit the log button...</p>
         Message:
         <input type="text" ng-model="message"/>
         <button ng-click="$log.log(message)">log</button>
         <button ng-click="$log.warn(message)">warn</button>
         <button ng-click="$log.info(message)">info</button>
         <button ng-click="$log.error(message)">error</button>
       </div>
     </file>
   </example>
 */

/**
 * @ngdoc object
 * @name ng.$logProvider
 * @description
 * Use the `$logProvider` to configure how the application logs messages
 */
function $LogProvider(){
  var debug = true,
      self = this;
  
  /**
   * @ngdoc property
   * @name ng.$logProvider#debugEnabled
   * @methodOf ng.$logProvider
   * @description
   * @param {string=} flag enable or disable debug level messages
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.debugEnabled = function(flag) {
	  if (isDefined(flag)) {
		  debug = flag;
		  return this;
	  } else {
		  return debug;
	  }
  };
  
  this.$get = ['$window', function($window){
    return {
      /**
       * @ngdoc method
       * @name ng.$log#log
       * @methodOf ng.$log
       *
       * @description
       * Write a log message
       */
      log: consoleLog('log'),

      /**
       * @ngdoc method
       * @name ng.$log#info
       * @methodOf ng.$log
       *
       * @description
       * Write an information message
       */
      info: consoleLog('info'),

      /**
       * @ngdoc method
       * @name ng.$log#warn
       * @methodOf ng.$log
       *
       * @description
       * Write a warning message
       */
      warn: consoleLog('warn'),

      /**
       * @ngdoc method
       * @name ng.$log#error
       * @methodOf ng.$log
       *
       * @description
       * Write an error message
       */
      error: consoleLog('error'),
      
      /**
       * @ngdoc method
       * @name ng.$log#debug
       * @methodOf ng.$log
       * 
       * @description
       * Write a debug message
       */
      debug: (function () {
    	var fn = consoleLog('debug');
    	
    	return function() {
    		if (debug) {
    			fn.apply(self, arguments);
    		}
    	}
      }())
    };

    function formatError(arg) {
      if (arg instanceof Error) {
        if (arg.stack) {
          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
              ? 'Error: ' + arg.message + '\n' + arg.stack
              : arg.stack;
        } else if (arg.sourceURL) {
          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
        }
      }
      return arg;
    }

    function consoleLog(type) {
      var console = $window.console || {},
          logFn = console[type] || console.log || noop;

      if (logFn.apply) {
        return function() {
          var args = [];
          forEach(arguments, function(arg) {
            args.push(formatError(arg));
          });
          return logFn.apply(console, args);
        };
      }

      // we are IE which either doesn't have window.console => this is noop and we do nothing,
      // or we are IE where console.log doesn't have apply so we log at least first 2 args
      return function(arg1, arg2) {
        logFn(arg1, arg2);
      }
    }
  }];
}

var $parseMinErr = minErr('$parse');

// Sandboxing Angular Expressions
// ------------------------------
// Angular expressions are generally considered safe because these expressions only have direct access to $scope and
// locals. However, one can obtain the ability to execute arbitrary JS code by obtaining a reference to native JS
// functions such as the Function constructor.
//
// As an example, consider the following Angular expression:
//
//   {}.toString.constructor(alert("evil JS code"))
//
// We want to prevent this type of access. For the sake of performance, during the lexing phase we disallow any "dotted"
// access to any member named "constructor".
//
// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor while evaluating
// the expression, which is a stronger but more expensive test. Since reflective calls are expensive anyway, this is not
// such a big deal compared to static dereferencing.
//
// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits against the
// expression language, but not to prevent exploits that were enabled by exposing sensitive JavaScript or browser apis
// on Scope. Exposing such objects on a Scope is never a good practice and therefore we are not even trying to protect
// against interaction with an object explicitly exposed in this way.
//
// A developer could foil the name check by aliasing the Function constructor under a different name on the scope.
//
// In general, it is not possible to access a Window object from an angular expression unless a window or some DOM
// object that has a reference to window is published onto a Scope.

function ensureSafeMemberName(name, fullExpression) {
  if (name === "constructor") {
    throw $parseMinErr('isecfld',
        'Referencing "constructor" field in Angular expressions is disallowed! Expression: {0}', fullExpression);
  }
  return name;
};

function ensureSafeObject(obj, fullExpression) {
  // nifty check if obj is Function that is fast and works across iframes and other contexts
  if (obj && obj.constructor === obj) {
    throw $parseMinErr('isecfn',
        'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
  } else {
    return obj;
  }
}


var OPERATORS = {
    'null':function(){return null;},
    'true':function(){return true;},
    'false':function(){return false;},
    undefined:noop,
    '+':function(self, locals, a,b){
      a=a(self, locals); b=b(self, locals);
      if (isDefined(a)) {
        if (isDefined(b)) {
          return a + b;
        }
        return a;
      }
      return isDefined(b)?b:undefined;},
    '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},
    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},
    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},
    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},
    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},
    '=':noop,
    '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},
    '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},
    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},
    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},
    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},
    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},
    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},
    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},
    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},
    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},
//    '|':function(self, locals, a,b){return a|b;},
    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
    '!':function(self, locals, a){return !a(self, locals);}
};
var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};

function lex(text, csp){
  var tokens = [],
      token,
      index = 0,
      json = [],
      ch,
      lastCh = ':'; // can start regexp

  while (index < text.length) {
    ch = text.charAt(index);
    if (is('"\'')) {
      readString(ch);
    } else if (isNumber(ch) || is('.') && isNumber(peek())) {
      readNumber();
    } else if (isIdent(ch)) {
      readIdent();
      // identifiers can only be if the preceding char was a { or ,
      if (was('{,') && json[0]=='{' &&
         (token=tokens[tokens.length-1])) {
        token.json = token.text.indexOf('.') == -1;
      }
    } else if (is('(){}[].,;:?')) {
      tokens.push({
        index:index,
        text:ch,
        json:(was(':[,') && is('{[')) || is('}]:,')
      });
      if (is('{[')) json.unshift(ch);
      if (is('}]')) json.shift();
      index++;
    } else if (isWhitespace(ch)) {
      index++;
      continue;
    } else {
      var ch2 = ch + peek(),
          ch3 = ch2 + peek(2),
          fn = OPERATORS[ch],
          fn2 = OPERATORS[ch2],
          fn3 = OPERATORS[ch3];
      if (fn3) {
        tokens.push({index:index, text:ch3, fn:fn3});
        index += 3;
      } else if (fn2) {
        tokens.push({index:index, text:ch2, fn:fn2});
        index += 2;
      } else if (fn) {
        tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});
        index += 1;
      } else {
        throwError("Unexpected next character ", index, index+1);
      }
    }
    lastCh = ch;
  }
  return tokens;

  function is(chars) {
    return chars.indexOf(ch) != -1;
  }

  function was(chars) {
    return chars.indexOf(lastCh) != -1;
  }

  function peek(i) {
    var num = i || 1;
    return index + num < text.length ? text.charAt(index + num) : false;
  }
  function isNumber(ch) {
    return '0' <= ch && ch <= '9';
  }
  function isWhitespace(ch) {
    return ch == ' ' || ch == '\r' || ch == '\t' ||
           ch == '\n' || ch == '\v' || ch == '\u00A0'; // IE treats non-breaking space as \u00A0
  }
  function isIdent(ch) {
    return 'a' <= ch && ch <= 'z' ||
           'A' <= ch && ch <= 'Z' ||
           '_' == ch || ch == '$';
  }
  function isExpOperator(ch) {
    return ch == '-' || ch == '+' || isNumber(ch);
  }

  function throwError(error, start, end) {
    end = end || index;
    var colStr = (isDefined(start) ?
        "s " + start +  "-" + index + " [" + text.substring(start, end) + "]"
        : " " + end);
    throw $parseMinErr('lexerr', "Lexer Error: {0} at column{1} in expression [{2}].",
        error, colStr, text);
  }

  function readNumber() {
    var number = "";
    var start = index;
    while (index < text.length) {
      var ch = lowercase(text.charAt(index));
      if (ch == '.' || isNumber(ch)) {
        number += ch;
      } else {
        var peekCh = peek();
        if (ch == 'e' && isExpOperator(peekCh)) {
          number += ch;
        } else if (isExpOperator(ch) &&
            peekCh && isNumber(peekCh) &&
            number.charAt(number.length - 1) == 'e') {
          number += ch;
        } else if (isExpOperator(ch) &&
            (!peekCh || !isNumber(peekCh)) &&
            number.charAt(number.length - 1) == 'e') {
          throwError('Invalid exponent');
        } else {
          break;
        }
      }
      index++;
    }
    number = 1 * number;
    tokens.push({index:start, text:number, json:true,
      fn:function() {return number;}});
  }
  function readIdent() {
    var ident = "",
        start = index,
        lastDot, peekIndex, methodName, ch;

    while (index < text.length) {
      ch = text.charAt(index);
      if (ch == '.' || isIdent(ch) || isNumber(ch)) {
        if (ch == '.') lastDot = index;
        ident += ch;
      } else {
        break;
      }
      index++;
    }

    //check if this is not a method invocation and if it is back out to last dot
    if (lastDot) {
      peekIndex = index;
      while(peekIndex < text.length) {
        ch = text.charAt(peekIndex);
        if (ch == '(') {
          methodName = ident.substr(lastDot - start + 1);
          ident = ident.substr(0, lastDot - start);
          index = peekIndex;
          break;
        }
        if(isWhitespace(ch)) {
          peekIndex++;
        } else {
          break;
        }
      }
    }


    var token = {
      index:start,
      text:ident
    };

    if (OPERATORS.hasOwnProperty(ident)) {
      token.fn = token.json = OPERATORS[ident];
    } else {
      var getter = getterFn(ident, csp, text);
      token.fn = extend(function(self, locals) {
        return (getter(self, locals));
      }, {
        assign: function(self, value) {
          return setter(self, ident, value, text);
        }
      });
    }

    tokens.push(token);

    if (methodName) {
      tokens.push({
        index:lastDot,
        text: '.',
        json: false
      });
      tokens.push({
        index: lastDot + 1,
        text: methodName,
        json: false
      });
    }
  }

  function readString(quote) {
    var start = index;
    index++;
    var string = "";
    var rawString = quote;
    var escape = false;
    while (index < text.length) {
      var ch = text.charAt(index);
      rawString += ch;
      if (escape) {
        if (ch == 'u') {
          var hex = text.substring(index + 1, index + 5);
          if (!hex.match(/[\da-f]{4}/i))
            throwError( "Invalid unicode escape [\\u" + hex + "]");
          index += 4;
          string += String.fromCharCode(parseInt(hex, 16));
        } else {
          var rep = ESCAPE[ch];
          if (rep) {
            string += rep;
          } else {
            string += ch;
          }
        }
        escape = false;
      } else if (ch == '\\') {
        escape = true;
      } else if (ch == quote) {
        index++;
        tokens.push({
          index:start,
          text:rawString,
          string:string,
          json:true,
          fn:function() { return string; }
        });
        return;
      } else {
        string += ch;
      }
      index++;
    }
    throwError("Unterminated quote", start);
  }
}

/////////////////////////////////////////

function parser(text, json, $filter, csp){
  var ZERO = valueFn(0),
      value,
      tokens = lex(text, csp),
      assignment = _assignment,
      functionCall = _functionCall,
      fieldAccess = _fieldAccess,
      objectIndex = _objectIndex,
      filterChain = _filterChain;

  if(json){
    // The extra level of aliasing is here, just in case the lexer misses something, so that
    // we prevent any accidental execution in JSON.
    assignment = logicalOR;
    functionCall =
      fieldAccess =
      objectIndex =
      filterChain =
        function() { throwError("is not valid json", {text:text, index:0}); };
    value = primary();
  } else {
    value = statements();
  }
  if (tokens.length !== 0) {
    throwError("is an unexpected token", tokens[0]);
  }
  value.literal = !!value.literal;
  value.constant = !!value.constant;
  return value;

  ///////////////////////////////////
  function throwError(msg, token) {
    throw $parseMinErr('syntax',
        "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
        token.text, msg, (token.index + 1), text, text.substring(token.index));
  }

  function peekToken() {
    if (tokens.length === 0)
      throw $parseMinErr('ueoe', "Unexpected end of expression: {0}", text);
    return tokens[0];
  }

  function peek(e1, e2, e3, e4) {
    if (tokens.length > 0) {
      var token = tokens[0];
      var t = token.text;
      if (t==e1 || t==e2 || t==e3 || t==e4 ||
          (!e1 && !e2 && !e3 && !e4)) {
        return token;
      }
    }
    return false;
  }

  function expect(e1, e2, e3, e4){
    var token = peek(e1, e2, e3, e4);
    if (token) {
      if (json && !token.json) {
        throwError("is not valid json", token);
      }
      tokens.shift();
      return token;
    }
    return false;
  }

  function consume(e1){
    if (!expect(e1)) {
      throwError("is unexpected, expecting [" + e1 + "]", peek());
    }
  }

  function unaryFn(fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, right);
    }, {
      constant:right.constant
    });
  }

  function ternaryFn(left, middle, right){
    return extend(function(self, locals){
      return left(self, locals) ? middle(self, locals) : right(self, locals);
    }, {
      constant: left.constant && middle.constant && right.constant
    });
  }

  function binaryFn(left, fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, left, right);
    }, {
      constant:left.constant && right.constant
    });
  }

  function statements() {
    var statements = [];
    while(true) {
      if (tokens.length > 0 && !peek('}', ')', ';', ']'))
        statements.push(filterChain());
      if (!expect(';')) {
        // optimize for the common case where there is only one statement.
        // TODO(size): maybe we should not support multiple statements?
        return statements.length == 1
          ? statements[0]
          : function(self, locals){
            var value;
            for ( var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
      }
    }
  }

  function _filterChain() {
    var left = expression();
    var token;
    while(true) {
      if ((token = expect('|'))) {
        left = binaryFn(left, token.fn, filter());
      } else {
        return left;
      }
    }
  }

  function filter() {
    var token = expect();
    var fn = $filter(token.text);
    var argsFn = [];
    while(true) {
      if ((token = expect(':'))) {
        argsFn.push(expression());
      } else {
        var fnInvoke = function(self, locals, input){
          var args = [input];
          for ( var i = 0; i < argsFn.length; i++) {
            args.push(argsFn[i](self, locals));
          }
          return fn.apply(self, args);
        };
        return function() {
          return fnInvoke;
        };
      }
    }
  }

  function expression() {
    return assignment();
  }

  function _assignment() {
    var left = ternary();
    var right;
    var token;
    if ((token = expect('='))) {
      if (!left.assign) {
        throwError("implies assignment but [" +
          text.substring(0, token.index) + "] can not be assigned to", token);
      }
      right = ternary();
      return function(scope, locals){
        return left.assign(scope, right(scope, locals), locals);
      };
    } else {
      return left;
    }
  }

  function ternary() {
    var left = logicalOR();
    var middle;
    var token;
    if((token = expect('?'))){
      middle = ternary();
      if((token = expect(':'))){
        return ternaryFn(left, middle, ternary());
      }
      else {
        throwError('expected :', token);
      }
    }
    else {
      return left;
    }
  }

  function logicalOR() {
    var left = logicalAND();
    var token;
    while(true) {
      if ((token = expect('||'))) {
        left = binaryFn(left, token.fn, logicalAND());
      } else {
        return left;
      }
    }
  }

  function logicalAND() {
    var left = equality();
    var token;
    if ((token = expect('&&'))) {
      left = binaryFn(left, token.fn, logicalAND());
    }
    return left;
  }

  function equality() {
    var left = relational();
    var token;
    if ((token = expect('==','!=','===','!=='))) {
      left = binaryFn(left, token.fn, equality());
    }
    return left;
  }

  function relational() {
    var left = additive();
    var token;
    if ((token = expect('<', '>', '<=', '>='))) {
      left = binaryFn(left, token.fn, relational());
    }
    return left;
  }

  function additive() {
    var left = multiplicative();
    var token;
    while ((token = expect('+','-'))) {
      left = binaryFn(left, token.fn, multiplicative());
    }
    return left;
  }

  function multiplicative() {
    var left = unary();
    var token;
    while ((token = expect('*','/','%'))) {
      left = binaryFn(left, token.fn, unary());
    }
    return left;
  }

  function unary() {
    var token;
    if (expect('+')) {
      return primary();
    } else if ((token = expect('-'))) {
      return binaryFn(ZERO, token.fn, unary());
    } else if ((token = expect('!'))) {
      return unaryFn(token.fn, unary());
    } else {
      return primary();
    }
  }


  function primary() {
    var primary;
    if (expect('(')) {
      primary = filterChain();
      consume(')');
    } else if (expect('[')) {
      primary = arrayDeclaration();
    } else if (expect('{')) {
      primary = object();
    } else {
      var token = expect();
      primary = token.fn;
      if (!primary) {
        throwError("not a primary expression", token);
      }
      if (token.json) {
        primary.constant = primary.literal = true;
      }
    }

    var next, context;
    while ((next = expect('(', '[', '.'))) {
      if (next.text === '(') {
        primary = functionCall(primary, context);
        context = null;
      } else if (next.text === '[') {
        context = primary;
        primary = objectIndex(primary);
      } else if (next.text === '.') {
        context = primary;
        primary = fieldAccess(primary);
      } else {
        throwError("IMPOSSIBLE");
      }
    }
    return primary;
  }

  function _fieldAccess(object) {
    var field = expect().text;
    var getter = getterFn(field, csp, text);
    return extend(
        function(scope, locals, self) {
          return getter(self || object(scope, locals), locals);
        },
        {
          assign:function(scope, value, locals) {
            return setter(object(scope, locals), field, value, text);
          }
        }
    );
  }

  function _objectIndex(obj) {
    var indexFn = expression();
    consume(']');
    return extend(
      function(self, locals){
        var o = obj(self, locals),
            i = indexFn(self, locals),
            v, p;

        if (!o) return undefined;
        v = ensureSafeObject(o[i], text);
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function(val) { p.$$v = val; });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign:function(self, value, locals){
          var key = indexFn(self, locals);
          // prevent overwriting of Function.constructor which would break ensureSafeObject check
          return ensureSafeObject(obj(self, locals), text)[key] = value;
        }
      });
  }

  function _functionCall(fn, contextGetter) {
    var argsFn = [];
    if (peekToken().text != ')') {
      do {
        argsFn.push(expression());
      } while (expect(','));
    }
    consume(')');
    return function(scope, locals){
      var args = [],
          context = contextGetter ? contextGetter(scope, locals) : scope;

      for ( var i = 0; i < argsFn.length; i++) {
        args.push(argsFn[i](scope, locals));
      }
      var fnPtr = fn(scope, locals, context) || noop;
      // IE stupidity!
      var v = fnPtr.apply
          ? fnPtr.apply(context, args)
          : fnPtr(args[0], args[1], args[2], args[3], args[4]);

      // Check for promise
      if (v && v.then) {
        var p = v;
        if (!('$$v' in v)) {
          p.$$v = undefined;
          p.then(function(val) { p.$$v = val; });
        }
        v = v.$$v;
      }

      return v;
    };
  }

  // This is used with json array declaration
  function arrayDeclaration () {
    var elementFns = [];
    var allConstant = true;
    if (peekToken().text != ']') {
      do {
        var elementFn = expression();
        elementFns.push(elementFn);
        if (!elementFn.constant) {
          allConstant = false;
        }
      } while (expect(','));
    }
    consume(']');
    return extend(function(self, locals){
      var array = [];
      for ( var i = 0; i < elementFns.length; i++) {
        array.push(elementFns[i](self, locals));
      }
      return array;
    }, {
      literal:true,
      constant:allConstant
    });
  }

  function object () {
    var keyValues = [];
    var allConstant = true;
    if (peekToken().text != '}') {
      do {
        var token = expect(),
        key = token.string || token.text;
        consume(":");
        var value = expression();
        keyValues.push({key:key, value:value});
        if (!value.constant) {
          allConstant = false;
        }
      } while (expect(','));
    }
    consume('}');
    return extend(function(self, locals){
      var object = {};
      for ( var i = 0; i < keyValues.length; i++) {
        var keyValue = keyValues[i];
        object[keyValue.key] = keyValue.value(self, locals);
      }
      return object;
    }, {
      literal:true,
      constant:allConstant
    });
  }
}

//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

function setter(obj, path, setValue, fullExp) {
  var element = path.split('.'), key;
  for (var i = 0; element.length > 1; i++) {
    key = ensureSafeMemberName(element.shift(), fullExp);
    var propertyObj = obj[key];
    if (!propertyObj) {
      propertyObj = {};
      obj[key] = propertyObj;
    }
    obj = propertyObj;
    if (obj.then) {
      if (!("$$v" in obj)) {
        (function(promise) {
          promise.then(function(val) { promise.$$v = val; }); }
        )(obj);
      }
      if (obj.$$v === undefined) {
        obj.$$v = {};
      }
      obj = obj.$$v;
    }
  }
  key = ensureSafeMemberName(element.shift(), fullExp);
  obj[key] = setValue;
  return setValue;
}

var getterFnCache = {};

/**
 * Implementation of the "Black Hole" variant from:
 * - http://jsperf.com/angularjs-parse-getter/4
 * - http://jsperf.com/path-evaluation-simplified/7
 */
function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);
  ensureSafeMemberName(key2, fullExp);
  ensureSafeMemberName(key3, fullExp);
  ensureSafeMemberName(key4, fullExp);
  return function(scope, locals) {
    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
        promise;

    if (pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key0];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key1];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key2];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key3];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key4];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    return pathVal;
  };
}

function getterFn(path, csp, fullExp) {
  if (getterFnCache.hasOwnProperty(path)) {
    return getterFnCache[path];
  }

  var pathKeys = path.split('.'),
      pathKeysLength = pathKeys.length,
      fn;

  if (csp) {
    fn = (pathKeysLength < 6)
        ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp)
        : function(scope, locals) {
          var i = 0, val;
          do {
            val = cspSafeGetterFn(
                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp
                  )(scope, locals);

            locals = undefined; // clear after first iteration
            scope = val;
          } while (i < pathKeysLength);
          return val;
        }
  } else {
    var code = 'var l, fn, p;\n';
    forEach(pathKeys, function(key, index) {
      ensureSafeMemberName(key, fullExp);
      code += 'if(s === null || s === undefined) return s;\n' +
              'l=s;\n' +
              's='+ (index
                      // we simply dereference 's' on any .dot notation
                      ? 's'
                      // but if we are first then we check locals first, and if so read it first
                      : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +
              'if (s && s.then) {\n' +
                ' if (!("$$v" in s)) {\n' +
                  ' p=s;\n' +
                  ' p.$$v = undefined;\n' +
                  ' p.then(function(v) {p.$$v=v;});\n' +
                  '}\n' +
                ' s=s.$$v\n' +
              '}\n';
    });
    code += 'return s;';
    fn = Function('s', 'k', code); // s=scope, k=locals
    fn.toString = function() { return code; };
  }

  return getterFnCache[path] = fn;
}

///////////////////////////////////

/**
 * @ngdoc function
 * @name ng.$parse
 * @function
 *
 * @description
 *
 * Converts Angular {@link guide/expression expression} into a function.
 *
 * <pre>
 *   var getter = $parse('user.name');
 *   var setter = getter.assign;
 *   var context = {user:{name:'angular'}};
 *   var locals = {user:{name:'local'}};
 *
 *   expect(getter(context)).toEqual('angular');
 *   setter(context, 'newValue');
 *   expect(context.user.name).toEqual('newValue');
 *   expect(getter(context, locals)).toEqual('local');
 * </pre>
 *
 *
 * @param {string} expression String expression to compile.
 * @returns {function(context, locals)} a function which represents the compiled expression:
 *
 *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
 *      are evaluated against (typically a scope object).
 *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
 *      `context`.
 *
 *    The returned function also has the following properties:
 *      * `literal` â€“ `{boolean}` â€“ whether the expression's top-level node is a JavaScript
 *        literal.
 *      * `constant` â€“ `{boolean}` â€“ whether the expression is made entirely of JavaScript
 *        constant literals.
 *      * `assign` â€“ `{?function(context, value)}` â€“ if the expression is assignable, this will be
 *        set to a function to change its value on the given context.
 *
 */
function $ParseProvider() {
  var cache = {};
  this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {
    return function(exp) {
      switch(typeof exp) {
        case 'string':
          return cache.hasOwnProperty(exp)
            ? cache[exp]
            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);
        case 'function':
          return exp;
        default:
          return noop;
      }
    };
  }];
}

/**
 * @ngdoc service
 * @name ng.$q
 * @requires $rootScope
 *
 * @description
 * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).
 *
 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
 * interface for interacting with an object that represents the result of an action that is
 * performed asynchronously, and may or may not be finished at any given point in time.
 *
 * From the perspective of dealing with error handling, deferred and promise APIs are to
 * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
 *
 * <pre>
 *   // for the purpose of this example let's assume that variables `$q` and `scope` are
 *   // available in the current lexical scope (they could have been injected or passed in).
 *
 *   function asyncGreet(name) {
 *     var deferred = $q.defer();
 *
 *     setTimeout(function() {
 *       // since this fn executes async in a future turn of the event loop, we need to wrap
 *       // our code into an $apply call so that the model changes are properly observed.
 *       scope.$apply(function() {
 *         deferred.notify('About to greet ' + name + '.');
 *
 *         if (okToGreet(name)) {
 *           deferred.resolve('Hello, ' + name + '!');
 *         } else {
 *           deferred.reject('Greeting ' + name + ' is not allowed.');
 *         }
 *       });
 *     }, 1000);
 *
 *     return deferred.promise;
 *   }
 *
 *   var promise = asyncGreet('Robin Hood');
 *   promise.then(function(greeting) {
 *     alert('Success: ' + greeting);
 *   }, function(reason) {
 *     alert('Failed: ' + reason);
 *   }, function(update) {
 *     alert('Got notification: ' + update);
 *   });
 * </pre>
 *
 * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
 * comes in the way of
 * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).
 *
 * Additionally the promise api allows for composition that is very hard to do with the
 * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
 * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
 * section on serial or parallel joining of promises.
 *
 *
 * # The Deferred API
 *
 * A new instance of deferred is constructed by calling `$q.defer()`.
 *
 * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
 * that can be used for signaling the successful or unsuccessful completion, as well as the status
 * of the task.
 *
 * **Methods**
 *
 * - `resolve(value)` â€“ resolves the derived promise with the `value`. If the value is a rejection
 *   constructed via `$q.reject`, the promise will be rejected instead.
 * - `reject(reason)` â€“ rejects the derived promise with the `reason`. This is equivalent to
 *   resolving it with a rejection constructed via `$q.reject`.
 * - `notify(value)` - provides updates on the status of the promises execution. This may be called
 *   multiple times before the promise is either resolved or rejected.
 *
 * **Properties**
 *
 * - promise â€“ `{Promise}` â€“ promise object associated with this deferred.
 *
 *
 * # The Promise API
 *
 * A new promise instance is created when a deferred instance is created and can be retrieved by
 * calling `deferred.promise`.
 *
 * The purpose of the promise object is to allow for interested parties to get access to the result
 * of the deferred task when it completes.
 *
 * **Methods**
 *
 * - `then(successCallback, errorCallback, notifyCallback)` â€“ regardless of when the promise was or
 *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
 *   as soon as the result is available. The callbacks are called with a single argument: the result
 *   or rejection reason. Additionally, the notify callback may be called zero or more times to
 *   provide a progress indication, before the promise is resolved or rejected.
 *
 *   This method *returns a new promise* which is resolved or rejected via the return value of the
 *   `successCallback`, `errorCallback`. It also notifies via the return value of the `notifyCallback`
 *   method. The promise can not be resolved or rejected from the notifyCallback method.
 *
 * - `catch(errorCallback)` â€“ shorthand for `promise.then(null, errorCallback)`
 *
 * - `finally(callback)` â€“ allows you to observe either the fulfillment or rejection of a promise,
 *   but to do so without modifying the final value. This is useful to release resources or do some
 *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
 *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
 *   more information.
 *
 *   Because `finally` is a reserved word in JavaScript and reserved keywords are not supported as
 *   property names by ES3, you'll need to invoke the method like `promise['finally'](callback)` to
 *   make your code IE8 compatible.
 *
 * # Chaining promises
 *
 * Because calling the `then` method of a promise returns a new derived promise, it is easily possible
 * to create a chain of promises:
 *
 * <pre>
 *   promiseB = promiseA.then(function(result) {
 *     return result + 1;
 *   });
 *
 *   // promiseB will be resolved immediately after promiseA is resolved and its value
 *   // will be the result of promiseA incremented by 1
 * </pre>
 *
 * It is possible to create chains of any length and since a promise can be resolved with another
 * promise (which will defer its resolution further), it is possible to pause/defer resolution of
 * the promises at any point in the chain. This makes it possible to implement powerful APIs like
 * $http's response interceptors.
 *
 *
 * # Differences between Kris Kowal's Q and $q
 *
 *  There are three main differences:
 *
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
 *   mechanism in angular, which means faster propagation of resolution or rejection into your
 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
 * - $q promises are recognized by the templating engine in angular, which means that in templates
 *   you can treat promises attached to a scope as if they were the resulting values.
 * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
 *   all the important functionality needed for common async tasks.
 *
 *  # Testing
 *
 *  <pre>
 *    it('should simulate promise', inject(function($q, $rootScope) {
 *      var deferred = $q.defer();
 *      var promise = deferred.promise;
 *      var resolvedValue;
 *
 *      promise.then(function(value) { resolvedValue = value; });
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Simulate resolving of promise
 *      deferred.resolve(123);
 *      // Note that the 'then' function does not get called synchronously.
 *      // This is because we want the promise API to always be async, whether or not
 *      // it got called synchronously or asynchronously.
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Propagate promise resolution to 'then' functions using $apply().
 *      $rootScope.$apply();
 *      expect(resolvedValue).toEqual(123);
 *    });
 *  </pre>
 */
function $QProvider() {

  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
    return qFactory(function(callback) {
      $rootScope.$evalAsync(callback);
    }, $exceptionHandler);
  }];
}


/**
 * Constructs a promise manager.
 *
 * @param {function(function)} nextTick Function for executing functions in the next turn.
 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
 *     debugging purposes.
 * @returns {object} Promise manager.
 */
function qFactory(nextTick, exceptionHandler) {

  /**
   * @ngdoc
   * @name ng.$q#defer
   * @methodOf ng.$q
   * @description
   * Creates a `Deferred` object which represents a task which will finish in the future.
   *
   * @returns {Deferred} Returns a new instance of deferred.
   */
  var defer = function() {
    var pending = [],
        value, deferred;

    deferred = {

      resolve: function(val) {
        if (pending) {
          var callbacks = pending;
          pending = undefined;
          value = ref(val);

          if (callbacks.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i < ii; i++) {
                callback = callbacks[i];
                value.then(callback[0], callback[1], callback[2]);
              }
            });
          }
        }
      },


      reject: function(reason) {
        deferred.resolve(reject(reason));
      },


      notify: function(progress) {
        if (pending) {
          var callbacks = pending;

          if (pending.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i < ii; i++) {
                callback = callbacks[i];
                callback[2](progress);
              }
            });
          }
        }
      },


      promise: {
        then: function(callback, errback, progressback) {
          var result = defer();

          var wrappedCallback = function(value) {
            try {
              result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
            } catch(e) {
              result.reject(e);
              exceptionHandler(e);
            }
          };

          var wrappedErrback = function(reason) {
            try {
              result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
            } catch(e) {
              result.reject(e);
              exceptionHandler(e);
            }
          };

          var wrappedProgressback = function(progress) {
            try {
              result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
            } catch(e) {
              exceptionHandler(e);
            }
          };

          if (pending) {
            pending.push([wrappedCallback, wrappedErrback, wrappedProgressback]);
          } else {
            value.then(wrappedCallback, wrappedErrback, wrappedProgressback);
          }

          return result.promise;
        },

        "catch": function(callback) {
          return this.then(null, callback);
        },

        "finally": function(callback) {

          function makePromise(value, resolved) {
            var result = defer();
            if (resolved) {
              result.resolve(value);
            } else {
              result.reject(value);
            }
            return result.promise;
          }

          function handleCallback(value, isResolved) {
            var callbackOutput = null;
            try {
              callbackOutput = (callback ||defaultCallback)();
            } catch(e) {
              return makePromise(e, false);
            }
            if (callbackOutput && isFunction(callbackOutput.then)) {
              return callbackOutput.then(function() {
                return makePromise(value, isResolved);
              }, function(error) {
                return makePromise(error, false);
              });
            } else {
              return makePromise(value, isResolved);
            }
          }

          return this.then(function(value) {
            return handleCallback(value, true);
          }, function(error) {
            return handleCallback(error, false);
          });
        }
      }
    };

    return deferred;
  };


  var ref = function(value) {
    if (value && isFunction(value.then)) return value;
    return {
      then: function(callback) {
        var result = defer();
        nextTick(function() {
          result.resolve(callback(value));
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#reject
   * @methodOf ng.$q
   * @description
   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
   * used to forward rejection in a chain of promises. If you are dealing with the last promise in
   * a promise chain, you don't need to worry about it.
   *
   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
   * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
   * a promise error callback and you want to forward the error to the promise derived from the
   * current promise, you have to "rethrow" the error by returning a rejection constructed via
   * `reject`.
   *
   * <pre>
   *   promiseB = promiseA.then(function(result) {
   *     // success: do something and resolve promiseB
   *     //          with the old or a new result
   *     return result;
   *   }, function(reason) {
   *     // error: handle the error if possible and
   *     //        resolve promiseB with newPromiseOrValue,
   *     //        otherwise forward the rejection to promiseB
   *     if (canHandle(reason)) {
   *      // handle the error and recover
   *      return newPromiseOrValue;
   *     }
   *     return $q.reject(reason);
   *   });
   * </pre>
   *
   * @param {*} reason Constant, message, exception or an object representing the rejection reason.
   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
   */
  var reject = function(reason) {
    return {
      then: function(callback, errback) {
        var result = defer();
        nextTick(function() {
          try {
            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
          } catch(e) {
            result.reject(e);
            exceptionHandler(e);
          }
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#when
   * @methodOf ng.$q
   * @description
   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
   * This is useful when you are dealing with an object that might or might not be a promise, or if
   * the promise comes from a source that can't be trusted.
   *
   * @param {*} value Value or a promise
   * @returns {Promise} Returns a promise of the passed value or promise
   */
  var when = function(value, callback, errback, progressback) {
    var result = defer(),
        done;

    var wrappedCallback = function(value) {
      try {
        return (isFunction(callback) ? callback : defaultCallback)(value);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedErrback = function(reason) {
      try {
        return (isFunction(errback) ? errback : defaultErrback)(reason);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedProgressback = function(progress) {
      try {
        return (isFunction(progressback) ? progressback : defaultCallback)(progress);
      } catch (e) {
        exceptionHandler(e);
      }
    };

    nextTick(function() {
      ref(value).then(function(value) {
        if (done) return;
        done = true;
        result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));
      }, function(reason) {
        if (done) return;
        done = true;
        result.resolve(wrappedErrback(reason));
      }, function(progress) {
        if (done) return;
        result.notify(wrappedProgressback(progress));
      });
    });

    return result.promise;
  };


  function defaultCallback(value) {
    return value;
  }


  function defaultErrback(reason) {
    return reject(reason);
  }


  /**
   * @ngdoc
   * @name ng.$q#all
   * @methodOf ng.$q
   * @description
   * Combines multiple promises into a single promise that is resolved when all of the input
   * promises are resolved.
   *
   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
   *   each value corresponding to the promise at the same index/key in the `promises` array/hash. If any of
   *   the promises is resolved with a rejection, this resulting promise will be resolved with the
   *   same rejection.
   */
  function all(promises) {
    var deferred = defer(),
        counter = 0,
        results = isArray(promises) ? [] : {};

    forEach(promises, function(promise, key) {
      counter++;
      ref(promise).then(function(value) {
        if (results.hasOwnProperty(key)) return;
        results[key] = value;
        if (!(--counter)) deferred.resolve(results);
      }, function(reason) {
        if (results.hasOwnProperty(key)) return;
        deferred.reject(reason);
      });
    });

    if (counter === 0) {
      deferred.resolve(results);
    }

    return deferred.promise;
  }

  return {
    defer: defer,
    reject: reject,
    when: when,
    all: all
  };
}

/**
 * DESIGN NOTES
 *
 * The design decisions behind the scope are heavily favored for speed and memory consumption.
 *
 * The typical use of scope is to watch the expressions, which most of the time return the same
 * value as last time so we optimize the operation.
 *
 * Closures construction is expensive in terms of speed as well as memory:
 *   - No closures, instead use prototypical inheritance for API
 *   - Internal state needs to be stored on scope directly, which means that private state is
 *     exposed as $$____ properties
 *
 * Loop operations are optimized by using while(count--) { ... }
 *   - this means that in order to keep the same order of execution as addition we have to add
 *     items to the array at the beginning (shift) instead of at the end (push)
 *
 * Child scopes are created and removed often
 *   - Using an array would be slow since inserts in middle are expensive so we use linked list
 *
 * There are few watches then a lot of observers. This is why you don't want the observer to be
 * implemented in the same way as watch. Watch requires return of initialization function which
 * are expensive to construct.
 */


/**
 * @ngdoc object
 * @name ng.$rootScopeProvider
 * @description
 *
 * Provider for the $rootScope service.
 */

/**
 * @ngdoc function
 * @name ng.$rootScopeProvider#digestTtl
 * @methodOf ng.$rootScopeProvider
 * @description
 *
 * Sets the number of digest iterations the scope should attempt to execute before giving up and
 * assuming that the model is unstable.
 *
 * The current default is 10 iterations.
 *
 * @param {number} limit The number of digest iterations.
 */


/**
 * @ngdoc object
 * @name ng.$rootScope
 * @description
 *
 * Every application has a single root {@link ng.$rootScope.Scope scope}.
 * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide
 * event processing life-cycle. See {@link guide/scope developer guide on scopes}.
 */
function $RootScopeProvider(){
  var TTL = 10;
  var $rootScopeMinErr = minErr('$rootScope');

  this.digestTtl = function(value) {
    if (arguments.length) {
      TTL = value;
    }
    return TTL;
  };

  this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',
      function( $injector,   $exceptionHandler,   $parse,   $browser) {

    /**
     * @ngdoc function
     * @name ng.$rootScope.Scope
     *
     * @description
     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
     * {@link AUTO.$injector $injector}. Child scopes are created using the
     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
     * compiled HTML template is executed.)
     *
     * Here is a simple scope snippet to show how you can interact with the scope.
     * <pre>
     * <file src="./test/ng/rootScopeSpec.js" tag="docs1" />
     * </pre>
     *
     * # Inheritance
     * A scope can inherit from a parent scope, as in this example:
     * <pre>
         var parent = $rootScope;
         var child = parent.$new();

         parent.salutation = "Hello";
         child.name = "World";
         expect(child.salutation).toEqual('Hello');

         child.salutation = "Welcome";
         expect(child.salutation).toEqual('Welcome');
         expect(parent.salutation).toEqual('Hello');
     * </pre>
     *
     *
     * @param {Object.<string, function()>=} providers Map of service factory which need to be provided
     *     for the current scope. Defaults to {@link ng}.
     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
     *     append/override services provided by `providers`. This is handy when unit-testing and having
     *     the need to override a default service.
     * @returns {Object} Newly created scope.
     *
     */
    function Scope() {
      this.$id = nextUid();
      this.$$phase = this.$parent = this.$$watchers =
                     this.$$nextSibling = this.$$prevSibling =
                     this.$$childHead = this.$$childTail = null;
      this['this'] = this.$root =  this;
      this.$$destroyed = false;
      this.$$asyncQueue = [];
      this.$$postDigestQueue = [];
      this.$$listeners = {};
      this.$$isolateBindings = {};
    }

    /**
     * @ngdoc property
     * @name ng.$rootScope.Scope#$id
     * @propertyOf ng.$rootScope.Scope
     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for
     *   debugging.
     */


    Scope.prototype = {
      constructor: Scope,
      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$new
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Creates a new child {@link ng.$rootScope.Scope scope}.
       *
       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and
       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope
       * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
       *
       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for
       * the scope and its child scopes to be permanently detached from the parent and thus stop
       * participating in model change detection and listener notification by invoking.
       *
       * @param {boolean} isolate if true then the scope does not prototypically inherit from the
       *         parent scope. The scope is isolated, as it can not see parent scope properties.
       *         When creating widgets it is useful for the widget to not accidentally read parent
       *         state.
       *
       * @returns {Object} The newly created child scope.
       *
       */
      $new: function(isolate) {
        var Child,
            child;

        if (isolate) {
          child = new Scope();
          child.$root = this.$root;
          // ensure that there is just one async queue per $rootScope and it's children
          child.$$asyncQueue = this.$$asyncQueue;
          child.$$postDigestQueue = this.$$postDigestQueue;
        } else {
          Child = function() {}; // should be anonymous; This is so that when the minifier munges
            // the name it does not become random set of chars. These will then show up as class
            // name in the debugger.
          Child.prototype = this;
          child = new Child();
          child.$id = nextUid();
        }
        child['this'] = child;
        child.$$listeners = {};
        child.$parent = this;
        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
        child.$$prevSibling = this.$$childTail;
        if (this.$$childHead) {
          this.$$childTail.$$nextSibling = child;
          this.$$childTail = child;
        } else {
          this.$$childHead = this.$$childTail = child;
        }
        return child;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watch
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
       *
       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and
       *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}
       *   reruns when it detects changes the `watchExpression` can execute multiple times per
       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
       * - The `listener` is called only when the value from the current `watchExpression` and the
       *   previous call to `watchExpression` are not equal (with the exception of the initial run,
       *   see below). The inequality is determined according to
       *   {@link angular.equals} function. To save the value of the object for later comparison, the
       *   {@link angular.copy} function is used. It also means that watching complex options will
       *   have adverse memory and performance implications.
       * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This
       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration
       *   limit is 10 to prevent an infinite loop deadlock.
       *
       *
       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`
       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is
       * detected, be prepared for multiple calls to your listener.)
       *
       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
       * watcher. In rare cases, this is undesirable because the listener is called when the result
       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
       * listener was called due to initialization.
       *
       *
       * # Example
       * <pre>
           // let's assume that scope was dependency injected as the $rootScope
           var scope = $rootScope;
           scope.name = 'misko';
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = 'adam';
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * </pre>
       *
       *
       *
       * @param {(function()|string)} watchExpression Expression that is evaluated on each
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a
       *    call to the `listener`.
       *
       *    - `string`: Evaluated as {@link guide/expression expression}
       *    - `function(scope)`: called with current `scope` as a parameter.
       * @param {(function()|string)=} listener Callback called whenever the return value of
       *   the `watchExpression` changes.
       *
       *    - `string`: Evaluated as {@link guide/expression expression}
       *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.
       *
       * @param {boolean=} objectEquality Compare object for equality rather than for reference.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $watch: function(watchExp, listener, objectEquality) {
        var scope = this,
            get = compileToFn(watchExp, 'watch'),
            array = scope.$$watchers,
            watcher = {
              fn: listener,
              last: initWatchVal,
              get: get,
              exp: watchExp,
              eq: !!objectEquality
            };

        // in the case user pass string, we need to compile it, do we really need this ?
        if (!isFunction(listener)) {
          var listenFn = compileToFn(listener || noop, 'listener');
          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};
        }

        if (typeof watchExp == 'string' && get.constant) {
          var originalFn = watcher.fn;
          watcher.fn = function(newVal, oldVal, scope) {
            originalFn.call(this, newVal, oldVal, scope);
            arrayRemove(array, watcher);
          };
        }

        if (!array) {
          array = scope.$$watchers = [];
        }
        // we use unshift since we use a while loop in $digest for speed.
        // the while loop reads in reverse order.
        array.unshift(watcher);

        return function() {
          arrayRemove(array, watcher);
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watchCollection
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Shallow watches the properties of an object and fires whenever any of the properties change
       * (for arrays this implies watching the array items, for object maps this implies watching the properties).
       * If a change is detected the `listener` callback is fired.
       *
       * - The `obj` collection is observed via standard $watch operation and is examined on every call to $digest() to
       *   see if any items have been added, removed, or moved.
       * - The `listener` is called whenever anything within the `obj` has changed. Examples include adding new items
       *   into the object or array, removing and moving items around.
       *
       *
       * # Example
       * <pre>
          $scope.names = ['igor', 'matias', 'misko', 'james'];
          $scope.dataCount = 4;

          $scope.$watchCollection('names', function(newNames, oldNames) {
            $scope.dataCount = newNames.length;
          });

          expect($scope.dataCount).toEqual(4);
          $scope.$digest();

          //still at 4 ... no changes
          expect($scope.dataCount).toEqual(4);

          $scope.names.pop();
          $scope.$digest();

          //now there's been a change
          expect($scope.dataCount).toEqual(3);
       * </pre>
       *
       *
       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The expression value
       *    should evaluate to an object or an array which is observed on each
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the collection will trigger
       *    a call to the `listener`.
       *
       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is fired with both
       *    the `newCollection` and `oldCollection` as parameters.
       *    The `newCollection` object is the newly modified data obtained from the `obj` expression and the
       *    `oldCollection` object is a copy of the former collection data.
       *    The `scope` refers to the current scope.
       *
       * @returns {function()} Returns a de-registration function for this listener. When the de-registration function is executed
       * then the internal watch operation is terminated.
       */
      $watchCollection: function(obj, listener) {
        var self = this;
        var oldValue;
        var newValue;
        var changeDetected = 0;
        var objGetter = $parse(obj);
        var internalArray = [];
        var internalObject = {};
        var oldLength = 0;

        function $watchCollectionWatch() {
          newValue = objGetter(self);
          var newLength, key;

          if (!isObject(newValue)) {
            if (oldValue !== newValue) {
              oldValue = newValue;
              changeDetected++;
            }
          } else if (isArrayLike(newValue)) {
            if (oldValue !== internalArray) {
              // we are transitioning from something which was not an array into array.
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            }

            newLength = newValue.length;

            if (oldLength !== newLength) {
              // if lengths do not match we need to trigger change notification
              changeDetected++;
              oldValue.length = oldLength = newLength;
            }
            // copy the items to oldValue and look for changes.
            for (var i = 0; i < newLength; i++) {
              if (oldValue[i] !== newValue[i]) {
                changeDetected++;
                oldValue[i] = newValue[i];
              }
            }
          } else {
            if (oldValue !== internalObject) {
              // we are transitioning from something which was not an object into object.
              oldValue = internalObject = {};
              oldLength = 0;
              changeDetected++;
            }
            // copy the items to oldValue and look for changes.
            newLength = 0;
            for (key in newValue) {
              if (newValue.hasOwnProperty(key)) {
                newLength++;
                if (oldValue.hasOwnProperty(key)) {
                  if (oldValue[key] !== newValue[key]) {
                    changeDetected++;
                    oldValue[key] = newValue[key];
                  }
                } else {
                  oldLength++;
                  oldValue[key] = newValue[key];
                  changeDetected++;
                }
              }
            }
            if (oldLength > newLength) {
              // we used to have more keys, need to find them and destroy them.
              changeDetected++;
              for(key in oldValue) {
                if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                  oldLength--;
                  delete oldValue[key];
                }
              }
            }
          }
          return changeDetected;
        }

        function $watchCollectionAction() {
          listener(newValue, oldValue, self);
        }

        return this.$watch($watchCollectionWatch, $watchCollectionAction);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$digest
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.
       * Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the
       * `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are
       * firing. This means that it is possible to get into an infinite loop. This function will throw
       * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.
       *
       * Usually you don't call `$digest()` directly in
       * {@link ng.directive:ngController controllers} or in
       * {@link ng.$compileProvider#directive directives}.
       * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a
       * {@link ng.$compileProvider#directive directives}) will force a `$digest()`.
       *
       * If you want to be notified whenever `$digest()` is called,
       * you can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}
       * with no `listener`.
       *
       * You may have a need to call `$digest()` from within unit-tests, to simulate the scope
       * life-cycle.
       *
       * # Example
       * <pre>
           var scope = ...;
           scope.name = 'misko';
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch('name', function(newValue, oldValue) {
             scope.counter = scope.counter + 1;
           });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = 'adam';
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * </pre>
       *
       */
      $digest: function() {
        var watch, value, last,
            watchers,
            asyncQueue = this.$$asyncQueue,
            postDigestQueue = this.$$postDigestQueue,
            length,
            dirty, ttl = TTL,
            next, current, target = this,
            watchLog = [],
            logIdx, logMsg;

        beginPhase('$digest');

        do { // "while dirty" loop
          dirty = false;
          current = target;

          while(asyncQueue.length) {
            try {
              current.$eval(asyncQueue.shift());
            } catch (e) {
              $exceptionHandler(e);
            }
          }

          do { // "traverse the scopes" loop
            if ((watchers = current.$$watchers)) {
              // process our watches
              length = watchers.length;
              while (length--) {
                try {
                  watch = watchers[length];
                  // Most common watches are on primitives, in which case we can short
                  // circuit it with === operator, only when === fails do we use .equals
                  if (watch && (value = watch.get(current)) !== (last = watch.last) &&
                      !(watch.eq
                          ? equals(value, last)
                          : (typeof value == 'number' && typeof last == 'number'
                             && isNaN(value) && isNaN(last)))) {
                    dirty = true;
                    watch.last = watch.eq ? copy(value) : value;
                    watch.fn(value, ((last === initWatchVal) ? value : last), current);
                    if (ttl < 5) {
                      logIdx = 4 - ttl;
                      if (!watchLog[logIdx]) watchLog[logIdx] = [];
                      logMsg = (isFunction(watch.exp))
                          ? 'fn: ' + (watch.exp.name || watch.exp.toString())
                          : watch.exp;
                      logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                      watchLog[logIdx].push(logMsg);
                    }
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }

            // Insanity Warning: scope depth-first traversal
            // yes, this code is a bit crazy, but it works and we have tests to prove it!
            // this piece should be kept in sync with the traversal in $broadcast
            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
              while(current !== target && !(next = current.$$nextSibling)) {
                current = current.$parent;
              }
            }
          } while ((current = next));

          if(dirty && !(ttl--)) {
            clearPhase();
            throw $rootScopeMinErr('infdig',
                '{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}',
                TTL, toJson(watchLog));
          }
        } while (dirty || asyncQueue.length);

        clearPhase();

        while(postDigestQueue.length) {
          try {
            postDigestQueue.shift()();
          } catch (e) {
            $exceptionHandler(e);
          }
        }
      },


      /**
       * @ngdoc event
       * @name ng.$rootScope.Scope#$destroy
       * @eventOf ng.$rootScope.Scope
       * @eventType broadcast on scope being destroyed
       *
       * @description
       * Broadcasted when a scope and its children are being destroyed.
       *
       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
       * clean up DOM bindings before an element is removed from the DOM.
       */

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$destroy
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Removes the current scope (and all of its children) from the parent scope. Removal implies
       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
       * propagate to the current scope and its children. Removal also implies that the current
       * scope is eligible for garbage collection.
       *
       * The `$destroy()` is usually used by directives such as
       * {@link ng.directive:ngRepeat ngRepeat} for managing the
       * unrolling of the loop.
       *
       * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.
       * Application code can register a `$destroy` event handler that will give it chance to
       * perform any necessary cleanup.
       *
       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
       * clean up DOM bindings before an element is removed from the DOM.
       */
      $destroy: function() {
        // we can't destroy the root scope or a scope that has been already destroyed
        if ($rootScope == this || this.$$destroyed) return;
        var parent = this.$parent;

        this.$broadcast('$destroy');
        this.$$destroyed = true;

        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        // This is bogus code that works around Chrome's GC leak
        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
            this.$$childTail = null;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$eval
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the `expression` on the current scope returning the result. Any exceptions in the
       * expression are propagated (uncaught). This is useful when evaluating Angular expressions.
       *
       * # Example
       * <pre>
           var scope = ng.$rootScope.Scope();
           scope.a = 1;
           scope.b = 2;

           expect(scope.$eval('a+b')).toEqual(3);
           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
       * </pre>
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with the current `scope` parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $eval: function(expr, locals) {
        return $parse(expr)(this, locals);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$evalAsync
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the expression on the current scope at a later point in time.
       *
       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:
       *
       *   - it will execute after the function that schedule the evaluation is done running (preferably before DOM rendering).
       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after `expression` execution.
       *
       * Any exceptions from the execution of the expression are forwarded to the
       * {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * __Note:__ if this function is called outside of `$digest` cycle, a new $digest cycle will be scheduled.
       * It is however encouraged to always call code that changes the model from withing an `$apply` call.
       * That includes code evaluated via `$evalAsync`.
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with the current `scope` parameter.
       *
       */
      $evalAsync: function(expr) {
        // if we are outside of an $digest loop and this is the first time we are scheduling async task also schedule
        // async auto-flush
        if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {
          $browser.defer(function() {
            if ($rootScope.$$asyncQueue.length) {
              $rootScope.$digest();
            }
          });
        }

        this.$$asyncQueue.push(expr);
      },

      $$postDigest : function(expr) {
        this.$$postDigestQueue.push(expr);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$apply
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * `$apply()` is used to execute an expression in angular from outside of the angular framework.
       * (For example from browser DOM events, setTimeout, XHR or third party libraries).
       * Because we are calling into the angular framework we need to perform proper scope life-cycle
       * of {@link ng.$exceptionHandler exception handling},
       * {@link ng.$rootScope.Scope#$digest executing watches}.
       *
       * ## Life cycle
       *
       * # Pseudo-Code of `$apply()`
       * <pre>
           function $apply(expr) {
             try {
               return $eval(expr);
             } catch (e) {
               $exceptionHandler(e);
             } finally {
               $root.$digest();
             }
           }
       * </pre>
       *
       *
       * Scope's `$apply()` method transitions through the following stages:
       *
       * 1. The {@link guide/expression expression} is executed using the
       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
       * 2. Any exceptions from the execution of the expression are forwarded to the
       *    {@link ng.$exceptionHandler $exceptionHandler} service.
       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression
       *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
       *
       *
       * @param {(string|function())=} exp An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with current `scope` parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $apply: function(expr) {
        try {
          beginPhase('$apply');
          return this.$eval(expr);
        } catch (e) {
          $exceptionHandler(e);
        } finally {
          clearPhase();
          try {
            $rootScope.$digest();
          } catch (e) {
            $exceptionHandler(e);
            throw e;
          }
        }
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$on
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of
       * event life cycle.
       *
       * The event listener function format is: `function(event, args...)`. The `event` object
       * passed into the listener has the following attributes:
       *
       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.
       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.
       *   - `name` - `{string}`: Name of the event.
       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event
       *     propagation (available only for events that were `$emit`-ed).
       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.
       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
       *
       * @param {string} name Event name to listen on.
       * @param {function(event, args...)} listener Function to call when the event is emitted.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $on: function(name, listener) {
        var namedListeners = this.$$listeners[name];
        if (!namedListeners) {
          this.$$listeners[name] = namedListeners = [];
        }
        namedListeners.push(listener);

        return function() {
          namedListeners[indexOf(namedListeners, listener)] = null;
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$emit
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event `name` upwards through the scope hierarchy notifying the
       * registered {@link ng.$rootScope.Scope#$on} listeners.
       *
       * The event life cycle starts at the scope on which `$emit` was called. All
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
       * Afterwards, the event traverses upwards toward the root scope and calls all registered
       * listeners along the way. The event will stop propagating if one of the listeners cancels it.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to emit.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
       */
      $emit: function(name, args) {
        var empty = [],
            namedListeners,
            scope = this,
            stopPropagation = false,
            event = {
              name: name,
              targetScope: scope,
              stopPropagation: function() {stopPropagation = true;},
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            i, length;

        do {
          namedListeners = scope.$$listeners[name] || empty;
          event.currentScope = scope;
          for (i=0, length=namedListeners.length; i<length; i++) {

            // if listeners were deregistered, defragment the array
            if (!namedListeners[i]) {
              namedListeners.splice(i, 1);
              i--;
              length--;
              continue;
            }
            try {
              namedListeners[i].apply(null, listenerArgs);
              if (stopPropagation) return event;
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          //traverse upwards
          scope = scope.$parent;
        } while (scope);

        return event;
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$broadcast
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
       * registered {@link ng.$rootScope.Scope#$on} listeners.
       *
       * The event life cycle starts at the scope on which `$broadcast` was called. All
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and
       * calls all registered listeners along the way. The event cannot be canceled.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to broadcast.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
       */
      $broadcast: function(name, args) {
        var target = this,
            current = target,
            next = target,
            event = {
              name: name,
              targetScope: target,
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            listeners, i, length;

        //down while you can, then up and next sibling or up and next sibling until back at root
        do {
          current = next;
          event.currentScope = current;
          listeners = current.$$listeners[name] || [];
          for (i=0, length = listeners.length; i<length; i++) {
            // if listeners were deregistered, defragment the array
            if (!listeners[i]) {
              listeners.splice(i, 1);
              i--;
              length--;
              continue;
            }

            try {
              listeners[i].apply(null, listenerArgs);
            } catch(e) {
              $exceptionHandler(e);
            }
          }

          // Insanity Warning: scope depth-first traversal
          // yes, this code is a bit crazy, but it works and we have tests to prove it!
          // this piece should be kept in sync with the traversal in $digest
          if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
            while(current !== target && !(next = current.$$nextSibling)) {
              current = current.$parent;
            }
          }
        } while ((current = next));

        return event;
      }
    };

    var $rootScope = new Scope();

    return $rootScope;


    function beginPhase(phase) {
      if ($rootScope.$$phase) {
        throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
      }

      $rootScope.$$phase = phase;
    }

    function clearPhase() {
      $rootScope.$$phase = null;
    }

    function compileToFn(exp, name) {
      var fn = $parse(exp);
      assertArgFn(fn, name);
      return fn;
    }

    /**
     * function used as an initial value for watchers.
     * because it's unique we can easily tell it apart from other values
     */
    function initWatchVal() {}
  }];
}

var $sceMinErr = minErr('$sce');

var SCE_CONTEXTS = {
  HTML: 'html',
  CSS: 'css',
  URL: 'url',
  // RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a
  // url.  (e.g. ng-include, script src, templateUrl)
  RESOURCE_URL: 'resourceUrl',
  JS: 'js'
};


/**
 * @ngdoc service
 * @name ng.$sceDelegate
 * @function
 *
 * @description
 *
 * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
 * Contextual Escaping (SCE)} services to AngularJS.
 *
 * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
 * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
 * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
 * work because `$sce` delegates to `$sceDelegate` for these operations.
 *
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
 *
 * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
 * can override it completely to change the behavior of `$sce`, the common case would
 * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
 * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
 * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist
 * $sceDelegateProvider.resourceUrlWhitelist} and {@link
 * ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
 */

/**
 * @ngdoc object
 * @name ng.$sceDelegateProvider
 * @description
 *
 * The $sceDelegateProvider provider allows developers to configure the {@link ng.$sceDelegate
 * $sceDelegate} service.  This allows one to get/set the whitelists and blacklists used to ensure
 * that URLs used for sourcing Angular templates are safe.  Refer {@link
 * ng.$sceDelegateProvider#resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and
 * {@link ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
 *
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
 */

function $SceDelegateProvider() {
  this.SCE_CONTEXTS = SCE_CONTEXTS;

  // Resource URLs can also be trusted by policy.
  var resourceUrlWhitelist = ['self'],
      resourceUrlBlacklist = [];

  /**
   * @ngdoc function
   * @name ng.sceDelegateProvider#resourceUrlWhitelist
   * @methodOf ng.$sceDelegateProvider
   * @function
   *
   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
   *     provided.  This must be an array.
   *
   *     Each element of this array must either be a regex or the special string `'self'`.
   *
   *     When a regex is used, it is matched against the normalized / absolute URL of the resource
   *     being tested.
   *
   *     The **special string** `'self'` can be used to match against all URLs of the same domain as the
   *     application document with the same protocol (allows sourcing https resources from http documents.)
   *
   *     Please note that **an empty whitelist array will block all URLs**!
   *
   * @return {Array} the currently set whitelist array.
   *
   * The **default value** when no whitelist has been explicitly set is `['self']`.
   *
   * @description
   * Sets/Gets the whitelist of trusted resource URLs.
   */
  this.resourceUrlWhitelist = function (value) {
    if (arguments.length) {
      resourceUrlWhitelist = value;
    }
    return resourceUrlWhitelist;
  };

  /**
   * @ngdoc function
   * @name ng.sceDelegateProvider#resourceUrlBlacklist
   * @methodOf ng.$sceDelegateProvider
   * @function
   *
   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
   *     provided.  This must be an array.
   *
   *     Each element of this array must either be a regex or the special string `'self'` (see
   *     `resourceUrlWhitelist` for meaning - it's only really useful there.)
   *
   *     When a regex is used, it is matched against the normalized / absolute URL of the resource
   *     being tested.
   *
   *     The typical usage for the blacklist is to **block [open redirects](http://cwe.mitre.org/data/definitions/601.html)**
   *     served by your domain as these would otherwise be trusted but actually return content from the redirected
   *     domain.
   *
   *     Finally, **the blacklist overrides the whitelist** and has the final say.
   *
   * @return {Array} the currently set blacklist array.
   *
   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there is
   * no blacklist.)
   *
   * @description
   * Sets/Gets the blacklist of trusted resource URLs.
   */

  this.resourceUrlBlacklist = function (value) {
    if (arguments.length) {
      resourceUrlBlacklist = value;
    }
    return resourceUrlBlacklist;
  };

  // Helper functions for matching resource urls by policy.
  function isCompatibleProtocol(documentProtocol, resourceProtocol) {
    return ((documentProtocol === resourceProtocol) ||
            (documentProtocol === "http:" && resourceProtocol === "https:"));
  }

  this.$get = ['$log', '$document', '$injector', '$$urlUtils', function(
                $log,   $document,   $injector,   $$urlUtils) {

    var htmlSanitizer = function htmlSanitizer(html) {
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
    };

    if ($injector.has('$sanitize')) {
      htmlSanitizer = $injector.get('$sanitize');
    }


    function matchUrl(matcher, parsedUrl) {
      if (matcher === 'self') {
        return $$urlUtils.isSameOrigin(parsedUrl);
      } else {
        return !!parsedUrl.href.match(matcher);
      }
    }

    function isResourceUrlAllowedByPolicy(url) {
      var parsedUrl = $$urlUtils.resolve(url.toString(), true);
      var i, n, allowed = false;
      // Ensure that at least one item from the whitelist allows this url.
      for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
          allowed = true;
          break;
        }
      }
      if (allowed) {
        // Ensure that no item from the blacklist blocked this url.
        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
            allowed = false;
            break;
          }
        }
      }
      return allowed;
    }

    function generateHolderType(base) {
      var holderType = function TrustedValueHolderType(trustedValue) {
        this.$$unwrapTrustedValue = function() {
          return trustedValue;
        };
      };
      if (base) {
        holderType.prototype = new base();
      }
      holderType.prototype.valueOf = function sceValueOf() {
        return this.$$unwrapTrustedValue();
      }
      holderType.prototype.toString = function sceToString() {
        return this.$$unwrapTrustedValue().toString();
      }
      return holderType;
    }

    var trustedValueHolderBase = generateHolderType(),
        byType = {};

    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#trustAs
     * @methodOf ng.$sceDelegate
     *
     * @description
     * Returns an object that is trusted by angular for use in specified strict
     * contextual escaping contexts (such as ng-html-bind-unsafe, ng-include, any src
     * attribute interpolation, any dom event binding attribute interpolation
     * such as for onclick,  etc.) that uses the provided value.
     * See {@link ng.$sce $sce} for enabling strict contextual escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resourceUrl, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */
    function trustAs(type, trustedValue) {
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      if (!constructor) {
        throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
            type, trustedValue);
      }
      if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
        return trustedValue;
      }
      // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
      // mutable objects, we ensure here that the value passed in is actually a string.
      if (typeof trustedValue !== 'string') {
        throw $sceMinErr('itype',
            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
            type);
      }
      return new constructor(trustedValue);
    }

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#valueOf
     * @methodOf ng.$sceDelegate
     *
     * @description
     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
     *
     * If the passed parameter is not a value that had been returned by {@link
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.
     *
     * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
     *      call or anything else.
     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns `value`
     *     unchanged.
     */
    function valueOf(maybeTrusted) {
      if (maybeTrusted instanceof trustedValueHolderBase) {
        return maybeTrusted.$$unwrapTrustedValue();
      } else {
        return maybeTrusted;
      }
    }

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#getTrusted
     * @methodOf ng.$sceDelegate
     *
     * @description
     * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and returns the
     * originally supplied value if the queried context type is a supertype of the created type.  If
     * this condition isn't satisfied, throws an exception.
     *
     * @param {string} type The kind of context in which this value is to be used.
     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
     * `$sceDelegate.trustAs`} call.
     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.
     */
    function getTrusted(type, maybeTrusted) {
      if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
        return maybeTrusted;
      }
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      if (constructor && maybeTrusted instanceof constructor) {
        return maybeTrusted.$$unwrapTrustedValue();
      }
      // If we get here, then we may only take one of two actions.
      // 1. sanitize the value for the requested type, or
      // 2. throw an exception.
      if (type === SCE_CONTEXTS.RESOURCE_URL) {
        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
          return maybeTrusted;
        } else {
          throw $sceMinErr('insecurl',
              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
        }
      } else if (type === SCE_CONTEXTS.HTML) {
        return htmlSanitizer(maybeTrusted);
      }
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
    }

    return { trustAs: trustAs,
             getTrusted: getTrusted,
             valueOf: valueOf };
  }];
}


/**
 * @ngdoc object
 * @name ng.$sceProvider
 * @description
 *
 * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
 * -   enable/disable Strict Contextual Escaping (SCE) in a module
 * -   override the default implementation with a custom delegate
 *
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
 */

/**
 * @ngdoc service
 * @name ng.$sce
 * @function
 *
 * @description
 *
 * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.
 *
 * # Strict Contextual Escaping
 *
 * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
 * contexts to result in a value that is marked as safe to use for that context One example of such
 * a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer to these
 * contexts as privileged or SCE contexts.
 *
 * As of version 1.2, Angular ships with SCE enabled by default.
 *
 * Note:  When enabled (the default), IE8 in quirks mode is not supported.  In this mode, IE8 allows
 * one to execute arbitrary javascript by the use of the expression() syntax.  Refer
 * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
 * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
 * to the top of your HTML document.
 *
 * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
 * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.
 *
 * Here's an example of a binding in a privileged context:
 *
 * <pre class="prettyprint">
 *     <input ng-model="userHtml">
 *     <div ng-bind-html="{{userHtml}}">
 * </pre>
 *
 * Notice that `ng-bind-html` is bound to `{{userHtml}}` controlled by the user.  With SCE
 * disabled, this application allows the user to render arbitrary HTML into the DIV.
 * In a more realistic example, one may be rendering user comments, blog articles, etc. via
 * bindings.  (HTML is just one example of a context where rendering user controlled input creates
 * security vulnerabilities.)
 *
 * For the case of HTML, you might use a library, either on the client side, or on the server side,
 * to sanitize unsafe HTML before binding to the value and rendering it in the document.
 *
 * How would you ensure that every place that used these types of bindings was bound to a value that
 * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
 * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
 * properties/fields and forgot to update the binding to the sanitized value?
 *
 * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
 * determine that something explicitly says it's safe to use a value for binding in that
 * context.  You can then audit your code (a simple grep would do) to ensure that this is only done
 * for those values that you can easily tell are safe - because they were received from your server,
 * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
 * allowing only the files in a specific directory to do this.  Ensuring that the internal API
 * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.
 *
 * In the case of AngularJS' SCE service, one uses {@link ng.$sce#trustAs $sce.trustAs} (and shorthand
 * methods such as {@link ng.$sce#trustAsHtml $sce.trustAsHtml}, etc.) to obtain values that will be
 * accepted by SCE / privileged contexts.
 *
 *
 * ## How does it work?
 *
 * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#getTrusted
 * $sce.getTrusted(context, value)} rather than to the value directly.  Directives use {@link
 * ng.$sce#parse $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the
 * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on non-constant literals.
 *
 * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link
 * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
 * simplified):
 *
 * <pre class="prettyprint">
 *   var ngBindHtmlDirective = ['$sce', function($sce) {
 *     return function(scope, element, attr) {
 *       scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {
 *         element.html(value || '');
 *       });
 *     };
 *   }];
 * </pre>
 *
 * ## Impact on loading templates
 *
 * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as
 * `templateUrl`'s specified by {@link guide/directive directives}.
 *
 * By default, Angular only loads templates from the same domain and protocol as the application
 * document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
 * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or
 * protocols, you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist
 * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.
 *
 * *Please note*:
 * The browser's
 * {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest
 * Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing (CORS)}
 * policy apply in addition to this and may further restrict whether the template is successfully
 * loaded.  This means that without the right CORS policy, loading templates from a different domain
 * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
 * browsers.
 *
 * ## This feels like too much overhead for the developer?
 *
 * It's important to remember that SCE only applies to interpolation expressions.
 *
 * If your expressions are constant literals, they're automatically trusted and you don't need to
 * call `$sce.trustAs` on them.  (e.g.
 * `<div ng-html-bind-unsafe="'<b>implicitly trusted</b>'"></div>`) just works.
 *
 * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
 * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play a role here.
 *
 * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load
 * templates in `ng-include` from your application's domain without having to even know about SCE.
 * It blocks loading templates from other domains or loading templates over http from an https
 * served document.  You can change these by setting your own custom {@link
 * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link
 * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching such URLs.
 *
 * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
 * application that's secure and can be audited to verify that with much more ease than bolting
 * security onto an application later.
 *
 * ## What trusted context types are supported?<a name="contexts"></a>
 *
 * | Context             | Notes          |
 * |---------------------|----------------|
 * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. |
 * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
 * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't consititute an SCE context. |
 * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contens are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
 * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
 *
 * ## Show me an example.
 *
 *
 *
 * @example
 <example module="mySceApp">
  <file name="index.html">
    <div ng-controller="myAppController as myCtrl">
      <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
      <b>User comments</b><br>
      By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when $sanitize is available.  If $sanitize isn't available, this results in an error instead of an exploit.
      <div class="well">
        <div ng-repeat="userComment in myCtrl.userComments">
          <b>{{userComment.name}}</b>:
          <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
          <br>
        </div>
      </div>
    </div>
  </file>

  <file name="script.js">
    var mySceApp = angular.module('mySceApp', ['ngSanitize']);

    mySceApp.controller("myAppController", function myAppController($http, $templateCache, $sce) {
      var self = this;
      $http.get("test_data.json", {cache: $templateCache}).success(function(userComments) {
        self.userComments = userComments;
      });
      self.explicitlyTrustedHtml = $sce.trustAsHtml(
          '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
          'sanitization.&quot;">Hover over this text.</span>');
    });
  </file>

  <file name="test_data.json">
    [
      { "name": "Alice",
        "htmlComment": "<span onmouseover='this.textContent=\"PWN3D!\"'>Is <i>anyone</i> reading this?</span>"
      },
      { "name": "Bob",
        "htmlComment": "<i>Yes!</i>  Am I the only other one?"
      }
    ]
  </file>

  <file name="scenario.js">
    describe('SCE doc demo', function() {
      it('should sanitize untrusted values', function() {
        expect(element('.htmlComment').html()).toBe('<span>Is <i>anyone</i> reading this?</span>');
      });
      it('should NOT sanitize explicitly trusted values', function() {
        expect(element('#explicitlyTrustedHtml').html()).toBe(
            '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
            'sanitization.&quot;">Hover over this text.</span>');
      });
    });
  </file>
 </example>
 *
 *
 *
 * ## Can I disable SCE completely?
 *
 * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
 * for little coding overhead.  It will be much harder to take an SCE disabled application and
 * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
 * for cases where you have a lot of existing code that was written before SCE was introduced and
 * you're migrating them a module at a time.
 *
 * That said, here's how you can completely disable SCE:
 *
 * <pre class="prettyprint">
 *   angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
 *     // Completely disable SCE.  For demonstration purposes only!
 *     // Do not use in new projects.
 *     $sceProvider.enabled(false);
 *   });
 * </pre>
 *
 */

function $SceProvider() {
  var enabled = true;

  /**
   * @ngdoc function
   * @name ng.sceProvider#enabled
   * @methodOf ng.$sceProvider
   * @function
   *
   * @param {boolean=} value If provided, then enables/disables SCE.
   * @return {boolean} true if SCE is enabled, false otherwise.
   *
   * @description
   * Enables/disables SCE and returns the current value.
   */
  this.enabled = function (value) {
    if (arguments.length) {
      enabled = !!value;
    }
    return enabled;
  };


  /* Design notes on the default implementation for SCE.
   *
   * The API contract for the SCE delegate
   * -------------------------------------
   * The SCE delegate object must provide the following 3 methods:
   *
   * - trustAs(contextEnum, value)
   *     This method is used to tell the SCE service that the provided value is OK to use in the
   *     contexts specified by contextEnum.  It must return an object that will be accepted by
   *     getTrusted() for a compatible contextEnum and return this value.
   *
   * - valueOf(value)
   *     For values that were not produced by trustAs(), return them as is.  For values that were
   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if
   *     trustAs is wrapping the given values into some type, this operation unwraps it when given
   *     such a value.
   *
   * - getTrusted(contextEnum, value)
   *     This function should return the a value that is safe to use in the context specified by
   *     contextEnum or throw and exception otherwise.
   *
   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be opaque
   * or wrapped in some holder object.  That happens to be an implementation detail.  For instance,
   * an implementation could maintain a registry of all trusted objects by context.  In such a case,
   * trustAs() would return the same object that was passed in.  getTrusted() would return the same
   * object passed in if it was found in the registry under a compatible context or throw an
   * exception otherwise.  An implementation might only wrap values some of the time based on
   * some criteria.  getTrusted() might return a value and not throw an exception for special
   * constants or objects even if not wrapped.  All such implementations fulfill this contract.
   *
   *
   * A note on the inheritance model for SCE contexts
   * ------------------------------------------------
   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This
   * is purely an implementation details.
   *
   * The contract is simply this:
   *
   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)
   *     will also succeed.
   *
   * Inheritance happens to capture this in a natural way.  In some future, we
   * may not use inheritance anymore.  That is OK because no code outside of
   * sce.js and sceSpecs.js would need to be aware of this detail.
   */

  this.$get = ['$parse', '$document', '$sceDelegate', function(
                $parse,   $document,   $sceDelegate) {
    // Prereq: Ensure that we're not running in IE8 quirks mode.  In that mode, IE allows
    // the "expression(javascript expression)" syntax which is insecure.
    if (enabled && msie) {
      var documentMode = $document[0].documentMode;
      if (documentMode !== undefined && documentMode < 8) {
        throw $sceMinErr('iequirks',
          'Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks ' +
          'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
          'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
      }
    }

    var sce = copy(SCE_CONTEXTS);

    /**
     * @ngdoc function
     * @name ng.sce#isEnabled
     * @methodOf ng.$sce
     * @function
     *
     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
     *
     * @description
     * Returns a boolean indicating if SCE is enabled.
     */
    sce.isEnabled = function () {
      return enabled;
    };
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    if (!enabled) {
      sce.trustAs = sce.getTrusted = function(type, value) { return value; },
      sce.valueOf = identity
    }

    /**
     * @ngdoc method
     * @name ng.$sce#parse
     * @methodOf ng.$sce
     *
     * @description
     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
     * *result*)}
     *
     * @param {string} type The kind of SCE context in which this result will be used.
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     */
    sce.parseAs = function sceParseAs(type, expr) {
      var parsed = $parse(expr);
      if (parsed.literal && parsed.constant) {
        return parsed;
      } else {
        return function sceParseAsTrusted(self, locals) {
          return sce.getTrusted(type, parsed(self, locals));
        }
      }
    };

    /**
     * @ngdoc method
     * @name ng.$sce#trustAs
     * @methodOf ng.$sce
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such, returns an object
     * that is trusted by angular for use in specified strict contextual escaping contexts (such as
     * ng-html-bind-unsafe, ng-include, any src attribute interpolation, any dom event binding
     * attribute interpolation such as for onclick,  etc.) that uses the provided value.  See *
     * {@link ng.$sce $sce} for enabling strict contextual escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resource_url, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsHtml(value)` â†’ {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml
     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsUrl(value)` â†’ {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl
     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsResourceUrl(value)` â†’ {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl
     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the return
     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsJs(value)` â†’ {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs
     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrusted
     * @methodOf ng.$sce
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such, takes
     * the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the originally supplied
     * value if the queried context type is a supertype of the created type.  If this condition
     * isn't satisfied, throws an exception.
     *
     * @param {string} type The kind of context in which this value is to be used.
     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs `$sce.trustAs`} call.
     * @returns {*} The value the was originally provided to {@link ng.$sce#trustAs `$sce.trustAs`} if
     *     valid in this context.  Otherwise, throws an exception.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedHtml(value)` â†’ {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedCss
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedCss(value)` â†’ {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedUrl(value)` â†’ {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` â†’ {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedJs(value)` â†’ {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsHtml(expression string)` â†’ {@link ng.$sce#parse `$sce.parseAs($sce.HTML, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsCss
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsCss(value)` â†’ {@link ng.$sce#parse `$sce.parseAs($sce.CSS, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsUrl(value)` â†’ {@link ng.$sce#parse `$sce.parseAs($sce.URL, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsResourceUrl(value)` â†’ {@link ng.$sce#parse `$sce.parseAs($sce.RESOURCE_URL, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsJs(value)` â†’ {@link ng.$sce#parse `$sce.parseAs($sce.JS, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` â€“ `{object}` â€“ an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` â€“ `{object=}` â€“ local variables context object, useful for overriding values in
     *      `context`.
     */

    // Shorthand delegations.
    var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    angular.forEach(SCE_CONTEXTS, function (enumValue, name) {
      var lName = lowercase(name);
      sce[camelCase("parse_as_" + lName)] = function (expr) {
        return parse(enumValue, expr);
      }
      sce[camelCase("get_trusted_" + lName)] = function (value) {
        return getTrusted(enumValue, value);
      }
      sce[camelCase("trust_as_" + lName)] = function (value) {
        return trustAs(enumValue, value);
      }
    });

    return sce;
  }];
}

/**
 * !!! This is an undocumented "private" service !!!
 *
 * @name ng.$sniffer
 * @requires $window
 * @requires $document
 *
 * @property {boolean} history Does the browser support html5 history api ?
 * @property {boolean} hashchange Does the browser support hashchange event ?
 * @property {boolean} transitions Does the browser support CSS transition events ?
 * @property {boolean} animations Does the browser support CSS animation events ?
 *
 * @description
 * This is very simple implementation of testing browser's features.
 */
function $SnifferProvider() {
  this.$get = ['$window', '$document', function($window, $document) {
    var eventSupport = {},
        android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
        document = $document[0] || {},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = false,
        animations = false,
        match;

    if (bodyStyle) {
      for(var prop in bodyStyle) {
        if(match = vendorRegex.exec(prop)) {
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          break;
        }
      }

      if(!vendorPrefix) {
        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
      }

      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));

      if (android && (!transitions||!animations)) {
        transitions = isString(document.body.style.webkitTransition);
        animations = isString(document.body.style.webkitAnimation);
      }
    }


    return {
      // Android has history.pushState, but it does not update location correctly
      // so let's not use the history API at all.
      // http://code.google.com/p/android/issues/detail?id=17471
      // https://github.com/angular/angular.js/issues/904

      // older webit browser (533.9) on Boxee box has exactly the same problem as Android has
      // so let's not use the history API also
      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
      hashchange: 'onhashchange' in $window &&
                  // IE8 compatible mode lies
                  (!document.documentMode || document.documentMode > 7),
      hasEvent: function(event) {
        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
        // it. In particular the event is not fired when backspace or delete key are pressed or
        // when cut operation is performed.
        if (event == 'input' && msie == 9) return false;

        if (isUndefined(eventSupport[event])) {
          var divElm = document.createElement('div');
          eventSupport[event] = 'on' + event in divElm;
        }

        return eventSupport[event];
      },
      csp: document.securityPolicy ? document.securityPolicy.isActive : false,
      vendorPrefix: vendorPrefix,
      transitions : transitions,
      animations : animations
    };
  }];
}

function $TimeoutProvider() {
  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',
       function($rootScope,   $browser,   $q,   $exceptionHandler) {
    var deferreds = {};


     /**
      * @ngdoc function
      * @name ng.$timeout
      * @requires $browser
      *
      * @description
      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
      * block and delegates any exceptions to
      * {@link ng.$exceptionHandler $exceptionHandler} service.
      *
      * The return value of registering a timeout function is a promise, which will be resolved when
      * the timeout is reached and the timeout function is executed.
      *
      * To cancel a timeout request, call `$timeout.cancel(promise)`.
      *
      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
      * synchronously flush the queue of deferred functions.
      *
      * @param {function()} fn A function, whose execution should be delayed.
      * @param {number=} [delay=0] Delay in milliseconds.
      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
      *   promise will be resolved with is the return value of the `fn` function.
      */
    function timeout(fn, delay, invokeApply) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          skipApply = (isDefined(invokeApply) && !invokeApply),
          timeoutId;

      timeoutId = $browser.defer(function() {
        try {
          deferred.resolve(fn());
        } catch(e) {
          deferred.reject(e);
          $exceptionHandler(e);
        }
        finally {
          delete deferreds[promise.$$timeoutId];
        }

        if (!skipApply) $rootScope.$apply();
      }, delay);

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;

      return promise;
    }


     /**
      * @ngdoc function
      * @name ng.$timeout#cancel
      * @methodOf ng.$timeout
      *
      * @description
      * Cancels a task associated with the `promise`. As a result of this, the promise will be
      * resolved with a rejection.
      *
      * @param {Promise=} promise Promise returned by the `$timeout` function.
      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
      *   canceled.
      */
    timeout.cancel = function(promise) {
      if (promise && promise.$$timeoutId in deferreds) {
        deferreds[promise.$$timeoutId].reject('canceled');
        delete deferreds[promise.$$timeoutId];
        return $browser.defer.cancel(promise.$$timeoutId);
      }
      return false;
    };

    return timeout;
  }];
}

function $$UrlUtilsProvider() {
  this.$get = [function() {
    var urlParsingNode = document.createElement("a"),
        // NOTE:  The usage of window and document instead of $window and $document here is
        // deliberate.  This service depends on the specific behavior of anchor nodes created by the
        // browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and
        // cause us to break tests.  In addition, when the browser resolves a URL for XHR, it
        // doesn't know about mocked locations and resolves URLs to the real document - which is
        // exactly the behavior needed here.  There is little value is mocking these our for this
        // service.
        originUrl = resolve(window.location.href, true);

    /**
     * @description
     * Normalizes and optionally parses a URL.
     *
     * NOTE:  This is a private service.  The API is subject to change unpredictably in any commit.
     *
     * Implementation Notes for non-IE browsers
     * ----------------------------------------
     * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
     * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
     * URL will be resolved into an absolute URL in the context of the application document.
     * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
     * properties are all populated to reflect the normalized URL.  This approach has wide
     * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
     * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
     *
     * Implementation Notes for IE
     * ---------------------------
     * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other
     * browsers.  However, the parsed components will not be set if the URL assigned did not specify
     * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
     * work around that by performing the parsing in a 2nd step by taking a previously normalized
     * URL (e.g. by assining to a.href) and assigning it a.href again.  This correctly populates the
     * properties such as protocol, hostname, port, etc.
     *
     * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one
     * uses the inner HTML approach to assign the URL as part of an HTML snippet -
     * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.
     * Unfortunately, setting img[src] to something like "javascript:foo" on IE throws an exception.
     * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that
     * method and IE < 8 is unsupported.
     *
     * References:
     *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
     *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
     *   http://url.spec.whatwg.org/#urlutils
     *   https://github.com/angular/angular.js/pull/2902
     *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
     *
     * @param {string} url The URL to be parsed.
     * @param {boolean=} parse When true, returns an object for the parsed URL.  Otherwise, returns
     *   a single string that is the normalized URL.
     * @returns {object|string} When parse is true, returns the normalized URL as a string.
     * Otherwise, returns an object with the following members.
     *
     *   | member name   | Description    |
     *   |---------------|----------------|
     *   | href          | A normalized version of the provided URL if it was not an absolute URL |
     *   | protocol      | The protocol including the trailing colon                              |
     *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
     *
     * These fields from the UrlUtils interface are currently not needed and hence not returned.
     *
     *   | member name   | Description    |
     *   |---------------|----------------|
     *   | hostname      | The host without the port of the normalizedUrl                         |
     *   | pathname      | The path following the host in the normalizedUrl                       |
     *   | hash          | The URL hash if present                                                |
     *   | search        | The query string                                                       |
     *
     */
    function resolve(url, parse) {
      var href = url;
      if (msie <= 11) {
        // Normalize before parse.  Refer Implementation Notes on why this is
        // done in two steps on IE.
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute('href', href);

      if (!parse) {
        return urlParsingNode.href;
      }
      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol,
        host: urlParsingNode.host
        // Currently unused and hence commented out.
        // hostname: urlParsingNode.hostname,
        // port: urlParsingNode.port,
        // pathname: urlParsingNode.pathname,
        // hash: urlParsingNode.hash,
        // search: urlParsingNode.search
      };
    }

    return {
      resolve: resolve,
      /**
       * Parse a request URL and determine whether this is a same-origin request as the application document.
       *
       * @param {string|object} requestUrl The url of the request as a string that will be resolved
       * or a parsed URL object.
       * @returns {boolean} Whether the request is for the same origin as the application document.
       */
      isSameOrigin: function isSameOrigin(requestUrl) {
        var parsed = (typeof requestUrl === 'string') ? resolve(requestUrl, true) : requestUrl;
        return (parsed.protocol === originUrl.protocol &&
                parsed.host === originUrl.host);
      }
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$window
 *
 * @description
 * A reference to the browser's `window` object. While `window`
 * is globally available in JavaScript, it causes testability problems, because
 * it is a global variable. In angular we always refer to it through the
 * `$window` service, so it may be overridden, removed or mocked for testing.
 *
 * Expressions, like the one defined for the `ngClick` directive in the example
 * below, are evaluated with respect to the current scope.  Therefore, there is
 * no risk of inadvertently coding in a dependency on a global value in such an
 * expression.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope, $window) {
           $scope.$window = $window;
           $scope.greeting = 'Hello, World!';
         }
       </script>
       <div ng-controller="Ctrl">
         <input type="text" ng-model="greeting" />
         <button ng-click="$window.alert(greeting)">ALERT</button>
       </div>
     </doc:source>
     <doc:scenario>
      it('should display the greeting in the input box', function() {
       input('greeting').enter('Hello, E2E Tests');
       // If we click the button it will block the test runner
       // element(':button').click();
      });
     </doc:scenario>
   </doc:example>
 */
function $WindowProvider(){
  this.$get = valueFn(window);
}

/**
 * @ngdoc object
 * @name ng.$filterProvider
 * @description
 *
 * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To
 * achieve this a filter definition consists of a factory function which is annotated with dependencies and is
 * responsible for creating a filter function.
 *
 * <pre>
 *   // Filter registration
 *   function MyModule($provide, $filterProvider) {
 *     // create a service to demonstrate injection (not always needed)
 *     $provide.value('greet', function(name){
 *       return 'Hello ' + name + '!';
 *     });
 *
 *     // register a filter factory which uses the
 *     // greet service to demonstrate DI.
 *     $filterProvider.register('greet', function(greet){
 *       // return the filter function which uses the greet service
 *       // to generate salutation
 *       return function(text) {
 *         // filters need to be forgiving so check input validity
 *         return text && greet(text) || text;
 *       };
 *     });
 *   }
 * </pre>
 *
 * The filter function is registered with the `$injector` under the filter name suffix with `Filter`.
 * <pre>
 *   it('should be the same instance', inject(
 *     function($filterProvider) {
 *       $filterProvider.register('reverse', function(){
 *         return ...;
 *       });
 *     },
 *     function($filter, reverseFilter) {
 *       expect($filter('reverse')).toBe(reverseFilter);
 *     });
 * </pre>
 *
 *
 * For more information about how angular filters work, and how to create your own filters, see
 * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer
 * Guide.
 */
/**
 * @ngdoc method
 * @name ng.$filterProvider#register
 * @methodOf ng.$filterProvider
 * @description
 * Register filter factory function.
 *
 * @param {String} name Name of the filter.
 * @param {function} fn The filter factory function which is injectable.
 */


/**
 * @ngdoc function
 * @name ng.$filter
 * @function
 * @description
 * Filters are used for formatting data displayed to the user.
 *
 * The general syntax in templates is as follows:
 *
 *         {{ expression [| filter_name[:parameter_value] ... ] }}
 *
 * @param {String} name Name of the filter function to retrieve
 * @return {Function} the filter function
 */
$FilterProvider.$inject = ['$provide'];
function $FilterProvider($provide) {
  var suffix = 'Filter';

  function register(name, factory) {
    return $provide.factory(name + suffix, factory);
  }
  this.register = register;

  this.$get = ['$injector', function($injector) {
    return function(name) {
      return $injector.get(name + suffix);
    }
  }];

  ////////////////////////////////////////

  register('currency', currencyFilter);
  register('date', dateFilter);
  register('filter', filterFilter);
  register('json', jsonFilter);
  register('limitTo', limitToFilter);
  register('lowercase', lowercaseFilter);
  register('number', numberFilter);
  register('orderBy', orderByFilter);
  register('uppercase', uppercaseFilter);
}

/**
 * @ngdoc filter
 * @name ng.filter:filter
 * @function
 *
 * @description
 * Selects a subset of items from `array` and returns it as a new array.
 *
 * Note: This function is used to augment the `Array` type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array} array The source array.
 * @param {string|Object|function()} expression The predicate to be used for selecting items from
 *   `array`.
 *
 *   Can be one of:
 *
 *   - `string`: Predicate that results in a substring match using the value of `expression`
 *     string. All strings or objects with string properties in `array` that contain this string
 *     will be returned. The predicate can be negated by prefixing the string with `!`.
 *
 *   - `Object`: A pattern object can be used to filter specific properties on objects contained
 *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
 *     which have property `name` containing "M" and property `phone` containing "1". A special
 *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
 *     property of the object. That's equivalent to the simple substring match with a `string`
 *     as described above.
 *
 *   - `function`: A predicate function can be used to write arbitrary filters. The function is
 *     called for each element of `array`. The final result is an array of those elements that
 *     the predicate returned true for.
 *
 * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in
 *     determining if the expected value (from the filter expression) and actual value (from
 *     the object in the array) should be considered a match.
 *
 *   Can be one of:
 *
 *     - `function(expected, actual)`:
 *       The function will be given the object value and the predicate value to compare and
 *       should return true if the item should be included in filtered result.
 *
 *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.
 *       this is essentially strict comparison of expected and actual.
 *
 *     - `false|undefined`: A short hand for a function which will look for a substring match in case
 *       insensitive way.
 *
 * @example
   <doc:example>
     <doc:source>
       <div ng-init="friends = [{name:'John', phone:'555-1276'},
                                {name:'Mary', phone:'800-BIG-MARY'},
                                {name:'Mike', phone:'555-4321'},
                                {name:'Adam', phone:'555-5678'},
                                {name:'Julie', phone:'555-8765'},
                                {name:'Juliette', phone:'555-5678'}]"></div>

       Search: <input ng-model="searchText">
       <table id="searchTextResults">
         <tr><th>Name</th><th>Phone</th></tr>
         <tr ng-repeat="friend in friends | filter:searchText">
           <td>{{friend.name}}</td>
           <td>{{friend.phone}}</td>
         </tr>
       </table>
       <hr>
       Any: <input ng-model="search.$"> <br>
       Name only <input ng-model="search.name"><br>
       Phone only <input ng-model="search.phone"><br>
       Equality <input type="checkbox" ng-model="strict"><br>
       <table id="searchObjResults">
         <tr><th>Name</th><th>Phone</th></tr>
         <tr ng-repeat="friend in friends | filter:search:strict">
           <td>{{friend.name}}</td>
           <td>{{friend.phone}}</td>
         </tr>
       </table>
     </doc:source>
     <doc:scenario>
       it('should search across all fields when filtering with a string', function() {
         input('searchText').enter('m');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Adam']);

         input('searchText').enter('76');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['John', 'Julie']);
       });

       it('should search in specific fields when filtering with a predicate object', function() {
         input('search.$').enter('i');
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);
       });
       it('should use a equal comparison when comparator is true', function() {
         input('search.name').enter('Julie');
         input('strict').check();
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Julie']);
       });
     </doc:scenario>
   </doc:example>
 */
function filterFilter() {
  return function(array, expression, comperator) {
    if (!isArray(array)) return array;
    var predicates = [];
    predicates.check = function(value) {
      for (var j = 0; j < predicates.length; j++) {
        if(!predicates[j](value)) {
          return false;
        }
      }
      return true;
    };
    switch(typeof comperator) {
      case "function":
        break;
      case "boolean":
        if(comperator == true) {
          comperator = function(obj, text) {
            return angular.equals(obj, text);
          }
          break;
        }
      default:
        comperator = function(obj, text) {
          text = (''+text).toLowerCase();
          return (''+obj).toLowerCase().indexOf(text) > -1
        };
    }
    var search = function(obj, text){
      if (typeof text == 'string' && text.charAt(0) === '!') {
        return !search(obj, text.substr(1));
      }
      switch (typeof obj) {
        case "boolean":
        case "number":
        case "string":
          return comperator(obj, text);
        case "object":
          switch (typeof text) {
            case "object":
              return comperator(obj, text);
              break;
            default:
              for ( var objKey in obj) {
                if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
                  return true;
                }
              }
              break;
          }
          return false;
        case "array":
          for ( var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
      }
    };
    switch (typeof expression) {
      case "boolean":
      case "number":
      case "string":
        expression = {$:expression};
      case "object":
        for (var key in expression) {
          if (key == '$') {
            (function() {
              if (!expression[key]) return;
              var path = key
              predicates.push(function(value) {
                return search(value, expression[path]);
              });
            })();
          } else {
            (function() {
              if (typeof(expression[key]) == 'undefined') { return; }
              var path = key;
              predicates.push(function(value) {
                return search(getter(value,path), expression[path]);
              });
            })();
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
    }
    var filtered = [];
    for ( var j = 0; j < array.length; j++) {
      var value = array[j];
      if (predicates.check(value)) {
        filtered.push(value);
      }
    }
    return filtered;
  }
}

/**
 * @ngdoc filter
 * @name ng.filter:currency
 * @function
 *
 * @description
 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
 * symbol for current locale is used.
 *
 * @param {number} amount Input to filter.
 * @param {string=} symbol Currency symbol or identifier to be displayed.
 * @returns {string} Formatted number.
 *
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.amount = 1234.56;
         }
       </script>
       <div ng-controller="Ctrl">
         <input type="number" ng-model="amount"> <br>
         default currency symbol ($): {{amount | currency}}<br>
         custom currency identifier (USD$): {{amount | currency:"USD$"}}
       </div>
     </doc:source>
     <doc:scenario>
       it('should init with 1234.56', function() {
         expect(binding('amount | currency')).toBe('$1,234.56');
         expect(binding('amount | currency:"USD$"')).toBe('USD$1,234.56');
       });
       it('should update', function() {
         input('amount').enter('-1234');
         expect(binding('amount | currency')).toBe('($1,234.00)');
         expect(binding('amount | currency:"USD$"')).toBe('(USD$1,234.00)');
       });
     </doc:scenario>
   </doc:example>
 */
currencyFilter.$inject = ['$locale'];
function currencyFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(amount, currencySymbol){
    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(/\u00A4/g, currencySymbol);
  };
}

/**
 * @ngdoc filter
 * @name ng.filter:number
 * @function
 *
 * @description
 * Formats a number as text.
 *
 * If the input is not a number an empty string is returned.
 *
 * @param {number|string} number Number to format.
 * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
 * If this is not provided then the fraction size is computed from the current locale's number
 * formatting pattern. In the case of the default locale, it will be 3.
 * @returns {string} Number rounded to decimalPlaces and places a â€œ,â€ after each third digit.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.val = 1234.56789;
         }
       </script>
       <div ng-controller="Ctrl">
         Enter number: <input ng-model='val'><br>
         Default formatting: {{val | number}}<br>
         No fractions: {{val | number:0}}<br>
         Negative number: {{-val | number:4}}
       </div>
     </doc:source>
     <doc:scenario>
       it('should format numbers', function() {
         expect(binding('val | number')).toBe('1,234.568');
         expect(binding('val | number:0')).toBe('1,235');
         expect(binding('-val | number:4')).toBe('-1,234.5679');
       });

       it('should update', function() {
         input('val').enter('3374.333');
         expect(binding('val | number')).toBe('3,374.333');
         expect(binding('val | number:0')).toBe('3,374');
         expect(binding('-val | number:4')).toBe('-3,374.3330');
       });
     </doc:scenario>
   </doc:example>
 */


numberFilter.$inject = ['$locale'];
function numberFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(number, fractionSize) {
    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
      fractionSize);
  };
}

var DECIMAL_SEP = '.';
function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
  if (isNaN(number) || !isFinite(number)) return '';

  var isNegative = number < 0;
  number = Math.abs(number);
  var numStr = number + '',
      formatedText = '',
      parts = [];

  var hasExponent = false;
  if (numStr.indexOf('e') !== -1) {
    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
    if (match && match[2] == '-' && match[3] > fractionSize + 1) {
      numStr = '0';
    } else {
      formatedText = numStr;
      hasExponent = true;
    }
  }

  if (!hasExponent) {
    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;

    // determine fractionSize if it is not specified
    if (isUndefined(fractionSize)) {
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    }

    var pow = Math.pow(10, fractionSize);
    number = Math.round(number * pow) / pow;
    var fraction = ('' + number).split(DECIMAL_SEP);
    var whole = fraction[0];
    fraction = fraction[1] || '';

    var pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    if (whole.length >= (lgroup + group)) {
      pos = whole.length - lgroup;
      for (var i = 0; i < pos; i++) {
        if ((pos - i)%group === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
    }

    for (i = pos; i < whole.length; i++) {
      if ((whole.length - i)%lgroup === 0 && i !== 0) {
        formatedText += groupSep;
      }
      formatedText += whole.charAt(i);
    }

    // format fraction part.
    while(fraction.length < fractionSize) {
      fraction += '0';
    }

    if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
  } else {

    if (fractionSize > 0 && number > -1 && number < 1) {
      formatedText = number.toFixed(fractionSize);
    }
  }

  parts.push(isNegative ? pattern.negPre : pattern.posPre);
  parts.push(formatedText);
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
  return parts.join('');
}

function padNumber(num, digits, trim) {
  var neg = '';
  if (num < 0) {
    neg =  '-';
    num = -num;
  }
  num = '' + num;
  while(num.length < digits) num = '0' + num;
  if (trim)
    num = num.substr(num.length - digits);
  return neg + num;
}


function dateGetter(name, size, offset, trim) {
  offset = offset || 0;
  return function(date) {
    var value = date['get' + name]();
    if (offset > 0 || value > -offset)
      value += offset;
    if (value === 0 && offset == -12 ) value = 12;
    return padNumber(value, size, trim);
  };
}

function dateStrGetter(name, shortForm) {
  return function(date, formats) {
    var value = date['get' + name]();
    var get = uppercase(shortForm ? ('SHORT' + name) : name);

    return formats[get][value];
  };
}

function timeZoneGetter(date) {
  var zone = -1 * date.getTimezoneOffset();
  var paddedZone = (zone >= 0) ? "+" : "";

  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  return paddedZone;
}

function ampmGetter(date, formats) {
  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
}

var DATE_FORMATS = {
  yyyy: dateGetter('FullYear', 4),
    yy: dateGetter('FullYear', 2, 0, true),
     y: dateGetter('FullYear', 1),
  MMMM: dateStrGetter('Month'),
   MMM: dateStrGetter('Month', true),
    MM: dateGetter('Month', 2, 1),
     M: dateGetter('Month', 1, 1),
    dd: dateGetter('Date', 2),
     d: dateGetter('Date', 1),
    HH: dateGetter('Hours', 2),
     H: dateGetter('Hours', 1),
    hh: dateGetter('Hours', 2, -12),
     h: dateGetter('Hours', 1, -12),
    mm: dateGetter('Minutes', 2),
     m: dateGetter('Minutes', 1),
    ss: dateGetter('Seconds', 2),
     s: dateGetter('Seconds', 1),
     // while ISO 8601 requires fractions to be prefixed with `.` or `,`
     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
   sss: dateGetter('Milliseconds', 3),
  EEEE: dateStrGetter('Day'),
   EEE: dateStrGetter('Day', true),
     a: ampmGetter,
     Z: timeZoneGetter
};

var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
    NUMBER_STRING = /^\d+$/;

/**
 * @ngdoc filter
 * @name ng.filter:date
 * @function
 *
 * @description
 *   Formats `date` to a string based on the requested `format`.
 *
 *   `format` string can be composed of the following elements:
 *
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
 *   * `'MMMM'`: Month in year (January-December)
 *   * `'MMM'`: Month in year (Jan-Dec)
 *   * `'MM'`: Month in year, padded (01-12)
 *   * `'M'`: Month in year (1-12)
 *   * `'dd'`: Day in month, padded (01-31)
 *   * `'d'`: Day in month (1-31)
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
 *   * `'EEE'`: Day in Week, (Sun-Sat)
 *   * `'HH'`: Hour in day, padded (00-23)
 *   * `'H'`: Hour in day (0-23)
 *   * `'hh'`: Hour in am/pm, padded (01-12)
 *   * `'h'`: Hour in am/pm, (1-12)
 *   * `'mm'`: Minute in hour, padded (00-59)
 *   * `'m'`: Minute in hour (0-59)
 *   * `'ss'`: Second in minute, padded (00-59)
 *   * `'s'`: Second in minute (0-59)
 *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
 *   * `'a'`: am/pm marker
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
 *
 *   `format` string can also be one of the following predefined
 *   {@link guide/i18n localizable formats}:
 *
 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
 *     (e.g. Sep 3, 2010 12:05:08 pm)
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)
 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale
 *     (e.g. Friday, September 3, 2010)
 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)
 *
 *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.
 *   `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence
 *   (e.g. `"h 'o''clock'"`).
 *
 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
 *    specified in the string input, the time is considered to be in the local timezone.
 * @param {string=} format Formatting rules (see Description). If not specified,
 *    `mediumDate` is used.
 * @returns {string} Formatted string or the input if input is not recognized as date/millis.
 *
 * @example
   <doc:example>
     <doc:source>
       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
           {{1288323623006 | date:'medium'}}<br>
       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>
       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>
     </doc:source>
     <doc:scenario>
       it('should format date', function() {
         expect(binding("1288323623006 | date:'medium'")).
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
         expect(binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
         expect(binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
       });
     </doc:scenario>
   </doc:example>
 */
dateFilter.$inject = ['$locale'];
function dateFilter($locale) {


  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                     // 1        2       3         4          5          6          7          8  9     10      11
  function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
      var date = new Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = int(match[9] + match[10]);
        tzMin = int(match[9] + match[11]);
      }
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
      var h = int(match[4]||0) - tzHour;
      var m = int(match[5]||0) - tzMin
      var s = int(match[6]||0);
      var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return string;
  }


  return function(date, format) {
    var text = '',
        parts = [],
        fn, match;

    format = format || 'mediumDate';
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
      if (NUMBER_STRING.test(date)) {
        date = int(date);
      } else {
        date = jsonStringToDate(date);
      }
    }

    if (isNumber(date)) {
      date = new Date(date);
    }

    if (!isDate(date)) {
      return date;
    }

    while(format) {
      match = DATE_FORMATS_SPLIT.exec(format);
      if (match) {
        parts = concat(parts, match, 1);
        format = parts.pop();
      } else {
        parts.push(format);
        format = null;
      }
    }

    forEach(parts, function(value){
      fn = DATE_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
    });

    return text;
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:json
 * @function
 *
 * @description
 *   Allows you to convert a JavaScript object into JSON string.
 *
 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
 *   the binding is automatically converted to JSON.
 *
 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
 * @returns {string} JSON string.
 *
 *
 * @example:
   <doc:example>
     <doc:source>
       <pre>{{ {'name':'value'} | json }}</pre>
     </doc:source>
     <doc:scenario>
       it('should jsonify filtered objects', function() {
         expect(binding("{'name':'value'}")).toMatch(/\{\n  "name": ?"value"\n}/);
       });
     </doc:scenario>
   </doc:example>
 *
 */
function jsonFilter() {
  return function(object) {
    return toJson(object, true);
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:lowercase
 * @function
 * @description
 * Converts string to lowercase.
 * @see angular.lowercase
 */
var lowercaseFilter = valueFn(lowercase);


/**
 * @ngdoc filter
 * @name ng.filter:uppercase
 * @function
 * @description
 * Converts string to uppercase.
 * @see angular.uppercase
 */
var uppercaseFilter = valueFn(uppercase);

/**
 * @ngdoc function
 * @name ng.filter:limitTo
 * @function
 *
 * @description
 * Creates a new array or string containing only a specified number of elements. The elements
 * are taken from either the beginning or the end of the source array or string, as specified by
 * the value and sign (positive or negative) of `limit`.
 *
 * Note: This function is used to augment the `Array` type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array|string} input Source array or string to be limited.
 * @param {string|number} limit The length of the returned array or string. If the `limit` number 
 *     is positive, `limit` number of items from the beginning of the source array/string are copied.
 *     If the number is negative, `limit` number  of items from the end of the source array/string 
 *     are copied. The `limit` will be trimmed if it exceeds `array.length`
 * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
 *     had less than `limit` elements.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.numbers = [1,2,3,4,5,6,7,8,9];
           $scope.letters = "abcdefghi";
           $scope.numLimit = 3;
           $scope.letterLimit = 3;
         }
       </script>
       <div ng-controller="Ctrl">
         Limit {{numbers}} to: <input type="integer" ng-model="numLimit">
         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
         Limit {{letters}} to: <input type="integer" ng-model="letterLimit">
         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
       </div>
     </doc:source>
     <doc:scenario>
       it('should limit the number array to first three items', function() {
         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');
         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');
       });

       it('should update the output when -3 is entered', function() {
         input('numLimit').enter(-3);
         input('letterLimit').enter(-3);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');
       });

       it('should not exceed the maximum size of input array', function() {
         input('numLimit').enter(100);
         input('letterLimit').enter(100);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');
       });
     </doc:scenario>
   </doc:example>
 */
function limitToFilter(){
  return function(input, limit) {
    if (!isArray(input) && !isString(input)) return input;
    
    limit = int(limit);

    if (isString(input)) {
      //NaN check on limit
      if (limit) {
        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
      } else {
        return "";
      }
    }

    var out = [],
      i, n;

    // if abs(limit) exceeds maximum length, trim it
    if (limit > input.length)
      limit = input.length;
    else if (limit < -input.length)
      limit = -input.length;

    if (limit > 0) {
      i = 0;
      n = limit;
    } else {
      i = input.length + limit;
      n = input.length;
    }

    for (; i<n; i++) {
      out.push(input[i]);
    }

    return out;
  }
}

/**
 * @ngdoc function
 * @name ng.filter:orderBy
 * @function
 *
 * @description
 * Orders a specified `array` by the `expression` predicate.
 *
 * Note: this function is used to augment the `Array` type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array} array The array to sort.
 * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be
 *    used by the comparator to determine the order of elements.
 *
 *    Can be one of:
 *
 *    - `function`: Getter function. The result of this function will be sorted using the
 *      `<`, `=`, `>` operator.
 *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'
 *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control
 *      ascending or descending sort order (for example, +name or -name).
 *    - `Array`: An array of function or string predicates. The first predicate in the array
 *      is used for sorting, but when two items are equivalent, the next predicate is used.
 *
 * @param {boolean=} reverse Reverse the order the array.
 * @returns {Array} Sorted copy of the source array.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.friends =
               [{name:'John', phone:'555-1212', age:10},
                {name:'Mary', phone:'555-9876', age:19},
                {name:'Mike', phone:'555-4321', age:21},
                {name:'Adam', phone:'555-5678', age:35},
                {name:'Julie', phone:'555-8765', age:29}]
           $scope.predicate = '-age';
         }
       </script>
       <div ng-controller="Ctrl">
         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
         <hr/>
         [ <a href="" ng-click="predicate=''">unsorted</a> ]
         <table class="friend">
           <tr>
             <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
                 (<a href ng-click="predicate = '-name'; reverse=false">^</a>)</th>
             <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
             <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
           </tr>
           <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
             <td>{{friend.name}}</td>
             <td>{{friend.phone}}</td>
             <td>{{friend.age}}</td>
           </tr>
         </table>
       </div>
     </doc:source>
     <doc:scenario>
       it('should be reverse ordered by aged', function() {
         expect(binding('predicate')).toBe('-age');
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '29', '21', '19', '10']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);
       });

       it('should reorder the table when user selects different predicate', function() {
         element('.doc-example-live a:contains("Name")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '10', '29', '19', '21']);

         element('.doc-example-live a:contains("Phone")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).
           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);
       });
     </doc:scenario>
   </doc:example>
 */
orderByFilter.$inject = ['$parse'];
function orderByFilter($parse){
  return function(array, sortPredicate, reverseOrder) {
    if (!isArray(array)) return array;
    if (!sortPredicate) return array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
    sortPredicate = map(sortPredicate, function(predicate){
      var descending = false, get = predicate || identity;
      if (isString(predicate)) {
        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
          descending = predicate.charAt(0) == '-';
          predicate = predicate.substring(1);
        }
        get = $parse(predicate);
      }
      return reverseComparator(function(a,b){
        return compare(get(a),get(b));
      }, descending);
    });
    var arrayCopy = [];
    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

    function comparator(o1, o2){
      for ( var i = 0; i < sortPredicate.length; i++) {
        var comp = sortPredicate[i](o1, o2);
        if (comp !== 0) return comp;
      }
      return 0;
    }
    function reverseComparator(comp, descending) {
      return toBoolean(descending)
          ? function(a,b){return comp(b,a);}
          : comp;
    }
    function compare(v1, v2){
      var t1 = typeof v1;
      var t2 = typeof v2;
      if (t1 == t2) {
        if (t1 == "string") {
           v1 = v1.toLowerCase();
           v2 = v2.toLowerCase();
        }
        if (v1 === v2) return 0;
        return v1 < v2 ? -1 : 1;
      } else {
        return t1 < t2 ? -1 : 1;
      }
    }
  }
}

function ngDirective(directive) {
  if (isFunction(directive)) {
    directive = {
      link: directive
    }
  }
  directive.restrict = directive.restrict || 'AC';
  return valueFn(directive);
}

/**
 * @ngdoc directive
 * @name ng.directive:a
 * @restrict E
 *
 * @description
 * Modifies the default behavior of html A tag, so that the default action is prevented when href
 * attribute is empty.
 *
 * The reasoning for this change is to allow easy creation of action links with `ngClick` directive
 * without changing the location or causing page reloads, e.g.:
 * `<a href="" ng-click="model.$save()">Save</a>`
 */
var htmlAnchorDirective = valueFn({
  restrict: 'E',
  compile: function(element, attr) {

    if (msie <= 8) {

      // turn <a href ng-click="..">link</a> into a stylable link in IE
      // but only if it doesn't have name attribute, in which case it's an anchor
      if (!attr.href && !attr.name) {
        attr.$set('href', '');
      }

      // add a comment node to anchors to workaround IE bug that causes element content to be reset
      // to new attribute content if attribute is updated with value containing @ and element also
      // contains value with @
      // see issue #1949
      element.append(document.createComment('IE fix'));
    }

    return function(scope, element) {
      element.on('click', function(event){
        // if we have no href url, then don't navigate anywhere.
        if (!element.attr('href')) {
          event.preventDefault();
        }
      });
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngHref
 * @restrict A
 *
 * @description
 * Using Angular markup like {{hash}} in an href attribute makes
 * the page open to a wrong URL, if the user clicks that link before
 * angular has a chance to replace the {{hash}} with actual URL, the
 * link will be broken and will most likely return a 404 error.
 * The `ngHref` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <a href="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <a ng-href="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * @element A
 * @param {template} ngHref any string which can contain `{{}}` markup.
 *
 * @example
 * This example uses `link` variable inside `href` attribute:
    <doc:example>
      <doc:source>
        <input ng-model="value" /><br />
        <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
        <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
        <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
        <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
        <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
      </doc:source>
      <doc:scenario>
        it('should execute ng-click but not reload when href without value', function() {
          element('#link-1').click();
          expect(input('value').val()).toEqual('1');
          expect(element('#link-1').attr('href')).toBe("");
        });

        it('should execute ng-click but not reload when href empty string', function() {
          element('#link-2').click();
          expect(input('value').val()).toEqual('2');
          expect(element('#link-2').attr('href')).toBe("");
        });

        it('should execute ng-click and change url when ng-href specified', function() {
          expect(element('#link-3').attr('href')).toBe("/123");

          element('#link-3').click();
          expect(browser().window().path()).toEqual('/123');
        });

        it('should execute ng-click but not reload when href empty string and name specified', function() {
          element('#link-4').click();
          expect(input('value').val()).toEqual('4');
          expect(element('#link-4').attr('href')).toBe('');
        });

        it('should execute ng-click but not reload when no href but name specified', function() {
          element('#link-5').click();
          expect(input('value').val()).toEqual('5');
          expect(element('#link-5').attr('href')).toBe(undefined);
        });

        it('should only change url when only ng-href', function() {
          input('value').enter('6');
          expect(element('#link-6').attr('href')).toBe('6');

          element('#link-6').click();
          expect(browser().location().url()).toEqual('/6');
        });
      </doc:scenario>
    </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrc
 * @restrict A
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrc` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * @element IMG
 * @param {template} ngSrc any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrcset
 * @restrict A
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrcset` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
 * </pre>
 *
 * @element IMG
 * @param {template} ngSrcset any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngDisabled
 * @restrict A
 *
 * @description
 *
 * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
 * <pre>
 * <div ng-init="scope = { isDisabled: false }">
 *  <button disabled="{{scope.isDisabled}}">Disabled</button>
 * </div>
 * </pre>
 *
 * The HTML specs do not require browsers to preserve the special attributes such as disabled.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngDisabled` directive.
 *
 * @example
    <doc:example>
      <doc:source>
        Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
        <button ng-model="button" ng-disabled="checked">Button</button>
      </doc:source>
      <doc:scenario>
        it('should toggle button', function() {
          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngDisabled Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngChecked
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as checked.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngChecked` directive.
 * @example
    <doc:example>
      <doc:source>
        Check me to check both: <input type="checkbox" ng-model="master"><br/>
        <input id="checkSlave" type="checkbox" ng-checked="master">
      </doc:source>
      <doc:scenario>
        it('should check both checkBoxes', function() {
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();
          input('master').check();
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngChecked Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngReadonly
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as readonly.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngReadonly` directive.
 * @example
    <doc:example>
      <doc:source>
        Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
        <input type="text" ng-readonly="checked" value="I'm Angular"/>
      </doc:source>
      <doc:scenario>
        it('should toggle readonly attr', function() {
          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {string} expression Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSelected
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as selected.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduced the `ngSelected` directive.
 * @example
    <doc:example>
      <doc:source>
        Check me to select: <input type="checkbox" ng-model="selected"><br/>
        <select>
          <option>Hello!</option>
          <option id="greet" ng-selected="selected">Greetings!</option>
        </select>
      </doc:source>
      <doc:scenario>
        it('should select Greetings!', function() {
          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();
          input('selected').check();
          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element OPTION
 * @param {string} expression Angular expression that will be evaluated.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngOpen
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as open.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngOpen` directive.
 *
 * @example
     <doc:example>
       <doc:source>
         Check me check multiple: <input type="checkbox" ng-model="open"><br/>
         <details id="details" ng-open="open">
            <summary>Show/Hide me</summary>
         </details>
       </doc:source>
       <doc:scenario>
         it('should toggle open', function() {
           expect(element('#details').prop('open')).toBeFalsy();
           input('open').check();
           expect(element('#details').prop('open')).toBeTruthy();
         });
       </doc:scenario>
     </doc:example>
 *
 * @element DETAILS
 * @param {string} expression Angular expression that will be evaluated.
 */

var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
forEach(BOOLEAN_ATTR, function(propName, attrName) {
  // binding to multiple is not supported
  if (propName == "multiple") return;

  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 100,
      compile: function() {
        return function(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        };
      }
    };
  };
});


// ng-src, ng-srcset, ng-href are interpolated
forEach(['src', 'srcset', 'href'], function(attrName) {
  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 99, // it needs to run after the attributes are interpolated
      link: function(scope, element, attr) {
        attr.$observe(normalized, function(value) {
          if (!value)
             return;

          attr.$set(attrName, value);

          // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
          // to set the property as well to achieve the desired effect.
          // we use attr[attrName] value since $set can sanitize the url.
          if (msie) element.prop(attrName, attr[attrName]);
        });
      }
    };
  };
});

var nullFormCtrl = {
  $addControl: noop,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop
};

/**
 * @ngdoc object
 * @name ng.directive:form.FormController
 *
 * @property {boolean} $pristine True if user has not interacted with the form yet.
 * @property {boolean} $dirty True if user has already interacted with the form.
 * @property {boolean} $valid True if all of the containing forms and controls are valid.
 * @property {boolean} $invalid True if at least one containing control or form is invalid.
 *
 * @property {Object} $error Is an object hash, containing references to all invalid controls or
 *  forms, where:
 *
 *  - keys are validation tokens (error names) â€” such as `required`, `url` or `email`),
 *  - values are arrays of controls or forms that are invalid with given error.
 *
 * @description
 * `FormController` keeps track of all its controls and nested forms as well as state of them,
 * such as being valid/invalid or dirty/pristine.
 *
 * Each {@link ng.directive:form form} directive creates an instance
 * of `FormController`.
 *
 */
//asks for $scope to fool the BC controller module
FormController.$inject = ['$element', '$attrs', '$scope'];
function FormController(element, attrs) {
  var form = this,
      parentForm = element.parent().controller('form') || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      errors = form.$error = {},
      controls = [];

  // init state
  form.$name = attrs.name || attrs.ngForm;
  form.$dirty = false;
  form.$pristine = true;
  form.$valid = true;
  form.$invalid = false;

  parentForm.$addControl(form);

  // Setup initial state of the control
  element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$addControl
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Register a control with the form.
   *
   * Input elements using ngModelController do this automatically when they are linked.
   */
  form.$addControl = function(control) {
    controls.push(control);

    if (control.$name && !form.hasOwnProperty(control.$name)) {
      form[control.$name] = control;
    }
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$removeControl
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Deregister a control from the form.
   *
   * Input elements using ngModelController do this automatically when they are destroyed.
   */
  form.$removeControl = function(control) {
    if (control.$name && form[control.$name] === control) {
      delete form[control.$name];
    }
    forEach(errors, function(queue, validationToken) {
      form.$setValidity(validationToken, true, control);
    });

    arrayRemove(controls, control);
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setValidity
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the validity of a form control.
   *
   * This method will also propagate to parent forms.
   */
  form.$setValidity = function(validationToken, isValid, control) {
    var queue = errors[validationToken];

    if (isValid) {
      if (queue) {
        arrayRemove(queue, control);
        if (!queue.length) {
          invalidCount--;
          if (!invalidCount) {
            toggleValidCss(isValid);
            form.$valid = true;
            form.$invalid = false;
          }
          errors[validationToken] = false;
          toggleValidCss(true, validationToken);
          parentForm.$setValidity(validationToken, true, form);
        }
      }

    } else {
      if (!invalidCount) {
        toggleValidCss(isValid);
      }
      if (queue) {
        if (includes(queue, control)) return;
      } else {
        errors[validationToken] = queue = [];
        invalidCount++;
        toggleValidCss(false, validationToken);
        parentForm.$setValidity(validationToken, false, form);
      }
      queue.push(control);

      form.$valid = false;
      form.$invalid = true;
    }
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setDirty
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to a dirty state.
   *
   * This method can be called to add the 'ng-dirty' class and set the form to a dirty
   * state (ng-dirty class). This method will also propagate to parent forms.
   */
  form.$setDirty = function() {
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
    form.$dirty = true;
    form.$pristine = false;
    parentForm.$setDirty();
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setPristine
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to its pristine state.
   *
   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
   * state (ng-pristine class). This method will also propagate to all the controls contained
   * in this form.
   *
   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
   * saving or resetting it.
   */
  form.$setPristine = function () {
    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
    form.$dirty = false;
    form.$pristine = true;
    forEach(controls, function(control) {
      control.$setPristine();
    });
  };
}


/**
 * @ngdoc directive
 * @name ng.directive:ngForm
 * @restrict EAC
 *
 * @description
 * Nestable alias of {@link ng.directive:form `form`} directive. HTML
 * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
 * sub-group of controls needs to be determined.
 *
 * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 */

 /**
 * @ngdoc directive
 * @name ng.directive:form
 * @restrict E
 *
 * @description
 * Directive that instantiates
 * {@link ng.directive:form.FormController FormController}.
 *
 * If `name` attribute is specified, the form controller is published onto the current scope under
 * this name.
 *
 * # Alias: {@link ng.directive:ngForm `ngForm`}
 *
 * In angular forms can be nested. This means that the outer form is valid when all of the child
 * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this
 * reason angular provides {@link ng.directive:ngForm `ngForm`} alias
 * which behaves identical to `<form>` but allows form nesting.
 *
 *
 * # CSS classes
 *  - `ng-valid` Is set if the form is valid.
 *  - `ng-invalid` Is set if the form is invalid.
 *  - `ng-pristine` Is set if the form is pristine.
 *  - `ng-dirty` Is set if the form is dirty.
 *
 *
 * # Submitting a form and preventing default action
 *
 * Since the role of forms in client-side Angular applications is different than in classical
 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
 * page reload that sends the data to the server. Instead some javascript logic should be triggered
 * to handle the form submission in application specific way.
 *
 * For this reason, Angular prevents the default action (form submission to the server) unless the
 * `<form>` element has an `action` attribute specified.
 *
 * You can use one of the following two ways to specify what javascript method should be called when
 * a form is submitted:
 *
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
 * - {@link ng.directive:ngClick ngClick} directive on the first
  *  button or input field of type submit (input[type=submit])
 *
 * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This
 * is because of the following form submission rules coming from the html spec:
 *
 * - If a form has only one input field then hitting enter in this field triggers form submit
 * (`ngSubmit`)
 * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter
 * doesn't trigger submit
 * - if a form has one or more input fields and one or more buttons or input[type=submit] then
 * hitting enter in any of the input fields will trigger the click handler on the *first* button or
 * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
 *
 * @param {string=} name Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.userType = 'guest';
         }
       </script>
       <form name="myForm" ng-controller="Ctrl">
         userType: <input name="input" ng-model="userType" required>
         <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
         <tt>userType = {{userType}}</tt><br>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
         expect(binding('userType')).toEqual('guest');
         expect(binding('myForm.input.$valid')).toEqual('true');
        });

        it('should be invalid if empty', function() {
         input('userType').enter('');
         expect(binding('userType')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
        });
      </doc:scenario>
    </doc:example>
 */
var formDirectiveFactory = function(isNgForm) {
  return ['$timeout', function($timeout) {
    var formDirective = {
      name: 'form',
      restrict: 'E',
      controller: FormController,
      compile: function() {
        return {
          pre: function(scope, formElement, attr, controller) {
            if (!attr.action) {
              // we can't use jq events because if a form is destroyed during submission the default
              // action is not prevented. see #1238
              //
              // IE 9 is not affected because it doesn't fire a submit event and try to do a full
              // page reload if the form was destroyed by submission of the form via a click handler
              // on a button in the form. Looks like an IE9 specific bug.
              var preventDefaultListener = function(event) {
                event.preventDefault
                  ? event.preventDefault()
                  : event.returnValue = false; // IE
              };

              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);

              // unregister the preventDefault listener so that we don't not leak memory but in a
              // way that will achieve the prevention of the default action.
              formElement.on('$destroy', function() {
                $timeout(function() {
                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                }, 0, false);
              });
            }

            var parentFormCtrl = formElement.parent().controller('form'),
                alias = attr.name || attr.ngForm;

            if (alias) {
              setter(scope, alias, controller, alias);
            }
            if (parentFormCtrl) {
              formElement.on('$destroy', function() {
                parentFormCtrl.$removeControl(controller);
                if (alias) {
                  setter(scope, alias, undefined, alias);
                }
                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
              });
            }
          }
        };
      }
    };

    return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;
  }];
};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(true);

var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

var inputType = {

  /**
   * @ngdoc inputType
   * @name ng.directive:input.text
   *
   * @description
   * Standard HTML text input with angular data binding.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Adds `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trimming the
   *    input.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'guest';
             $scope.word = /^\s*\w*\s*$/;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Single word: <input type="text" name="input" ng-model="text"
                               ng-pattern="word" required ng-trim="false">
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.pattern">
             Single word only!</span>

           <tt>text = {{text}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('guest');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if multi word', function() {
            input('text').enter('hello world');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should not be trimmed', function() {
            input('text').enter('untrimmed ');
            expect(binding('text')).toEqual('untrimmed ');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });
        </doc:scenario>
      </doc:example>
   */
  'text': textInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.number
   *
   * @description
   * Text input with number validation and transformation. Sets the `number` validation
   * error if not a valid number.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.value = 12;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Number: <input type="number" name="input" ng-model="value"
                          min="0" max="99" required>
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.number">
             Not valid number!</span>
           <tt>value = {{value}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
           expect(binding('value')).toEqual('12');
           expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
           input('value').enter('');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if over max', function() {
           input('value').enter('123');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'number': numberInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.url
   *
   * @description
   * Text input with URL validation. Sets the `url` validation error key if the content is not a
   * valid URL.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'http://google.com';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           URL: <input type="url" name="input" ng-model="text" required>
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.url">
             Not valid url!</span>
           <tt>text = {{text}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('http://google.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if not url', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'url': urlInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.email
   *
   * @description
   * Text input with email validation. Sets the `email` validation error key if not a valid email
   * address.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'me@example.com';
           }
         </script>
           <form name="myForm" ng-controller="Ctrl">
             Email: <input type="email" name="input" ng-model="text" required>
             <span class="error" ng-show="myForm.input.$error.required">
               Required!</span>
             <span class="error" ng-show="myForm.input.$error.email">
               Not valid email!</span>
             <tt>text = {{text}}</tt><br/>
             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
           </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('me@example.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if not email', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'email': emailInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.radio
   *
   * @description
   * HTML radio button.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string} value The value to which the expression should be set when selected.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.color = 'blue';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           <input type="radio" ng-model="color" value="red">  Red <br/>
           <input type="radio" ng-model="color" value="green"> Green <br/>
           <input type="radio" ng-model="color" value="blue"> Blue <br/>
           <tt>color = {{color}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should change state', function() {
            expect(binding('color')).toEqual('blue');

            input('color').select('red');
            expect(binding('color')).toEqual('red');
          });
        </doc:scenario>
      </doc:example>
   */
  'radio': radioInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.checkbox
   *
   * @description
   * HTML checkbox.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngTrueValue The value to which the expression should be set when selected.
   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.value1 = true;
             $scope.value2 = 'YES'
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Value1: <input type="checkbox" ng-model="value1"> <br/>
           Value2: <input type="checkbox" ng-model="value2"
                          ng-true-value="YES" ng-false-value="NO"> <br/>
           <tt>value1 = {{value1}}</tt><br/>
           <tt>value2 = {{value2}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should change state', function() {
            expect(binding('value1')).toEqual('true');
            expect(binding('value2')).toEqual('YES');

            input('value1').check();
            input('value2').check();
            expect(binding('value1')).toEqual('false');
            expect(binding('value2')).toEqual('NO');
          });
        </doc:scenario>
      </doc:example>
   */
  'checkbox': checkboxInputType,

  'hidden': noop,
  'button': noop,
  'submit': noop,
  'reset': noop
};


function isEmpty(value) {
  return isUndefined(value) || value === '' || value === null || value !== value;
}


function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {

  var listener = function() {
    var value = element.val();

    // By default we will trim the value
    // If the attribute ng-trim exists we will avoid trimming
    // e.g. <input ng-model="foo" ng-trim="false">
    if (toBoolean(attr.ngTrim || 'T')) {
      value = trim(value);
    }

    if (ctrl.$viewValue !== value) {
      scope.$apply(function() {
        ctrl.$setViewValue(value);
      });
    }
  };

  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
  // input event on backspace, delete or cut
  if ($sniffer.hasEvent('input')) {
    element.on('input', listener);
  } else {
    var timeout;

    var deferListener = function() {
      if (!timeout) {
        timeout = $browser.defer(function() {
          listener();
          timeout = null;
        });
      }
    };

    element.on('keydown', function(event) {
      var key = event.keyCode;

      // ignore
      //    command            modifiers                   arrows
      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

      deferListener();
    });

    // if user paste into input using mouse, we need "change" event to catch it
    element.on('change', listener);

    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
    if ($sniffer.hasEvent('paste')) {
      element.on('paste cut', deferListener);
    }
  }


  ctrl.$render = function() {
    element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
  };

  // pattern validator
  var pattern = attr.ngPattern,
      patternValidator,
      match;

  var validate = function(regexp, value) {
    if (isEmpty(value) || regexp.test(value)) {
      ctrl.$setValidity('pattern', true);
      return value;
    } else {
      ctrl.$setValidity('pattern', false);
      return undefined;
    }
  };

  if (pattern) {
    match = pattern.match(/^\/(.*)\/([gim]*)$/);
    if (match) {
      pattern = new RegExp(match[1], match[2]);
      patternValidator = function(value) {
        return validate(pattern, value)
      };
    } else {
      patternValidator = function(value) {
        var patternObj = scope.$eval(pattern);

        if (!patternObj || !patternObj.test) {
          throw minErr('ngPattern')('noregexp',
            'Expected {0} to be a RegExp but was {1}. Element: {2}', pattern,
            patternObj, startingTag(element));
        }
        return validate(patternObj, value);
      };
    }

    ctrl.$formatters.push(patternValidator);
    ctrl.$parsers.push(patternValidator);
  }

  // min length validator
  if (attr.ngMinlength) {
    var minlength = int(attr.ngMinlength);
    var minLengthValidator = function(value) {
      if (!isEmpty(value) && value.length < minlength) {
        ctrl.$setValidity('minlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('minlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(minLengthValidator);
    ctrl.$formatters.push(minLengthValidator);
  }

  // max length validator
  if (attr.ngMaxlength) {
    var maxlength = int(attr.ngMaxlength);
    var maxLengthValidator = function(value) {
      if (!isEmpty(value) && value.length > maxlength) {
        ctrl.$setValidity('maxlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('maxlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxLengthValidator);
    ctrl.$formatters.push(maxLengthValidator);
  }
}

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$parsers.push(function(value) {
    var empty = isEmpty(value);
    if (empty || NUMBER_REGEXP.test(value)) {
      ctrl.$setValidity('number', true);
      return value === '' ? null : (empty ? value : parseFloat(value));
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });

  ctrl.$formatters.push(function(value) {
    return isEmpty(value) ? '' : '' + value;
  });

  if (attr.min) {
    var min = parseFloat(attr.min);
    var minValidator = function(value) {
      if (!isEmpty(value) && value < min) {
        ctrl.$setValidity('min', false);
        return undefined;
      } else {
        ctrl.$setValidity('min', true);
        return value;
      }
    };

    ctrl.$parsers.push(minValidator);
    ctrl.$formatters.push(minValidator);
  }

  if (attr.max) {
    var max = parseFloat(attr.max);
    var maxValidator = function(value) {
      if (!isEmpty(value) && value > max) {
        ctrl.$setValidity('max', false);
        return undefined;
      } else {
        ctrl.$setValidity('max', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxValidator);
    ctrl.$formatters.push(maxValidator);
  }

  ctrl.$formatters.push(function(value) {

    if (isEmpty(value) || isNumber(value)) {
      ctrl.$setValidity('number', true);
      return value;
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });
}

function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var urlValidator = function(value) {
    if (isEmpty(value) || URL_REGEXP.test(value)) {
      ctrl.$setValidity('url', true);
      return value;
    } else {
      ctrl.$setValidity('url', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
}

function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var emailValidator = function(value) {
    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
      ctrl.$setValidity('email', true);
      return value;
    } else {
      ctrl.$setValidity('email', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(emailValidator);
  ctrl.$parsers.push(emailValidator);
}

function radioInputType(scope, element, attr, ctrl) {
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.attr('name', nextUid());
  }

  element.on('click', function() {
    if (element[0].checked) {
      scope.$apply(function() {
        ctrl.$setViewValue(attr.value);
      });
    }
  });

  ctrl.$render = function() {
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  };

  attr.$observe('value', ctrl.$render);
}

function checkboxInputType(scope, element, attr, ctrl) {
  var trueValue = attr.ngTrueValue,
      falseValue = attr.ngFalseValue;

  if (!isString(trueValue)) trueValue = true;
  if (!isString(falseValue)) falseValue = false;

  element.on('click', function() {
    scope.$apply(function() {
      ctrl.$setViewValue(element[0].checked);
    });
  });

  ctrl.$render = function() {
    element[0].checked = ctrl.$viewValue;
  };

  ctrl.$formatters.push(function(value) {
    return value === trueValue;
  });

  ctrl.$parsers.push(function(value) {
    return value ? trueValue : falseValue;
  });
}


/**
 * @ngdoc directive
 * @name ng.directive:textarea
 * @restrict E
 *
 * @description
 * HTML textarea element control with angular data-binding. The data-binding and validation
 * properties of this element are exactly the same as those of the
 * {@link ng.directive:input input element}.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 */


/**
 * @ngdoc directive
 * @name ng.directive:input
 * @restrict E
 *
 * @description
 * HTML input element control with angular data-binding. Input control follows HTML5 input types
 * and polyfills the HTML5 validation behavior for older browsers.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {boolean=} ngRequired Sets `required` attribute if set to true
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.user = {name: 'guest', last: 'visitor'};
         }
       </script>
       <div ng-controller="Ctrl">
         <form name="myForm">
           User name: <input type="text" name="userName" ng-model="user.name" required>
           <span class="error" ng-show="myForm.userName.$error.required">
             Required!</span><br>
           Last name: <input type="text" name="lastName" ng-model="user.last"
             ng-minlength="3" ng-maxlength="10">
           <span class="error" ng-show="myForm.lastName.$error.minlength">
             Too short!</span>
           <span class="error" ng-show="myForm.lastName.$error.maxlength">
             Too long!</span><br>
         </form>
         <hr>
         <tt>user = {{user}}</tt><br/>
         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
       </div>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('user')).toEqual('{"name":"guest","last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

        it('should be invalid if empty when required', function() {
          input('user.name').enter('');
          expect(binding('user')).toEqual('{"last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('false');
          expect(binding('myForm.$valid')).toEqual('false');
        });

        it('should be valid if empty when min length is set', function() {
          input('user.last').enter('');
          expect(binding('user')).toEqual('{"name":"guest","last":""}');
          expect(binding('myForm.lastName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

        it('should be invalid if less than required min length', function() {
          input('user.last').enter('xx');
          expect(binding('user')).toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });

        it('should be invalid if longer than max length', function() {
          input('user.last').enter('some ridiculously long name');
          expect(binding('user'))
            .toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });
      </doc:scenario>
    </doc:example>
 */
var inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {
  return {
    restrict: 'E',
    require: '?ngModel',
    link: function(scope, element, attr, ctrl) {
      if (ctrl) {
        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                            $browser);
      }
    }
  };
}];

var VALID_CLASS = 'ng-valid',
    INVALID_CLASS = 'ng-invalid',
    PRISTINE_CLASS = 'ng-pristine',
    DIRTY_CLASS = 'ng-dirty';

/**
 * @ngdoc object
 * @name ng.directive:ngModel.NgModelController
 *
 * @property {string} $viewValue Actual string value in the view.
 * @property {*} $modelValue The value in the model, that the control is bound to.
 * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
       the control reads value from the DOM.  Each function is called, in turn, passing the value
       through to the next. Used to sanitize / convert the value as well as validation.
       For validation, the parsers should update the validity state using
       {@link ng.directive:ngModel.NgModelController#$setValidity $setValidity()},
       and return `undefined` for invalid values.

 *
 * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
       the model value changes. Each function is called, in turn, passing the value through to the
       next. Used to format / convert values for display in the control and validation.
 *      <pre>
 *      function formatter(value) {
 *        if (value) {
 *          return value.toUpperCase();
 *        }
 *      }
 *      ngModel.$formatters.push(formatter);
 *      </pre>
 * @property {Object} $error An object hash with all errors as keys.
 *
 * @property {boolean} $pristine True if user has not interacted with the control yet.
 * @property {boolean} $dirty True if user has already interacted with the control.
 * @property {boolean} $valid True if there is no error.
 * @property {boolean} $invalid True if at least one error on the control.
 *
 * @description
 *
 * `NgModelController` provides API for the `ng-model` directive. The controller contains
 * services for data-binding, validation, CSS update, value formatting and parsing. It
 * specifically does not contain any logic which deals with DOM rendering or listening to
 * DOM events. The `NgModelController` is meant to be extended by other directives where, the
 * directive provides DOM manipulation and the `NgModelController` provides the data-binding.
 * Note that you cannot use `NgModelController` in a directive with an isolated scope,
 * as, in that case, the `ng-model` value gets put into the isolated scope and does not get
 * propogated to the parent scope.
 *
 *
 * This example shows how to use `NgModelController` with a custom control to achieve
 * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
 * collaborate together to achieve the desired result.
 *
 * <example module="customControl">
    <file name="style.css">
      [contenteditable] {
        border: 1px solid black;
        background-color: white;
        min-height: 20px;
      }

      .ng-invalid {
        border: 1px solid red;
      }

    </file>
    <file name="script.js">
      angular.module('customControl', []).
        directive('contenteditable', function() {
          return {
            restrict: 'A', // only activate on element attribute
            require: '?ngModel', // get a hold of NgModelController
            link: function(scope, element, attrs, ngModel) {
              if(!ngModel) return; // do nothing if no ng-model

              // Specify how UI should be updated
              ngModel.$render = function() {
                element.html(ngModel.$viewValue || '');
              };

              // Listen for change events to enable binding
              element.on('blur keyup change', function() {
                scope.$apply(read);
              });
              read(); // initialize

              // Write data to the model
              function read() {
                var html = element.html();
                // When we clear the content editable the browser leaves a <br> behind
                // If strip-br attribute is provided then we strip this out
                if( attrs.stripBr && html == '<br>' ) {
                  html = '';
                }
                ngModel.$setViewValue(html);
              }
            }
          };
        });
    </file>
    <file name="index.html">
      <form name="myForm">
       <div contenteditable
            name="myWidget" ng-model="userContent"
            strip-br="true"
            required>Change me!</div>
        <span ng-show="myForm.myWidget.$error.required">Required!</span>
       <hr>
       <textarea ng-model="userContent"></textarea>
      </form>
    </file>
    <file name="scenario.js">
      it('should data-bind and become invalid', function() {
        var contentEditable = element('[contenteditable]');

        expect(contentEditable.text()).toEqual('Change me!');
        input('userContent').enter('');
        expect(contentEditable.text()).toEqual('');
        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);
      });
    </file>
 * </example>
 *
 */
var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
    function($scope, $exceptionHandler, $attr, $element, $parse) {
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$pristine = true;
  this.$dirty = false;
  this.$valid = true;
  this.$invalid = false;
  this.$name = $attr.name;

  var ngModelGet = $parse($attr.ngModel),
      ngModelSet = ngModelGet.assign;

  if (!ngModelSet) {
    throw minErr('ngModel')('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
        $attr.ngModel, startingTag($element));
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$render
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Called when the view needs to be updated. It is expected that the user of the ng-model
   * directive will implement this method.
   */
  this.$render = noop;

  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      $error = this.$error = {}; // keep invalid keys here


  // Setup initial state of the control
  $element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    $element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setValidity
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Change the validity state, and notifies the form when the control changes validity. (i.e. it
   * does not notify form if given validator is already marked as invalid).
   *
   * This method should be called by validators - i.e. the parser or formatter functions.
   *
   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign
   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.
   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).
   */
  this.$setValidity = function(validationErrorKey, isValid) {
    if ($error[validationErrorKey] === !isValid) return;

    if (isValid) {
      if ($error[validationErrorKey]) invalidCount--;
      if (!invalidCount) {
        toggleValidCss(true);
        this.$valid = true;
        this.$invalid = false;
      }
    } else {
      toggleValidCss(false);
      this.$invalid = true;
      this.$valid = false;
      invalidCount++;
    }

    $error[validationErrorKey] = !isValid;
    toggleValidCss(isValid, validationErrorKey);

    parentForm.$setValidity(validationErrorKey, isValid, this);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setPristine
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Sets the control to its pristine state.
   *
   * This method can be called to remove the 'ng-dirty' class and set the control to its pristine
   * state (ng-pristine class).
   */
  this.$setPristine = function () {
    this.$dirty = false;
    this.$pristine = true;
    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setViewValue
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Read a value from view.
   *
   * This method should be called from within a DOM event handler.
   * For example {@link ng.directive:input input} or
   * {@link ng.directive:select select} directives call it.
   *
   * It internally calls all `$parsers` (including validators) and updates the `$modelValue` and the actual model path.
   * Lastly it calls all registered change listeners.
   *
   * @param {string} value Value from the view.
   */
  this.$setViewValue = function(value) {
    this.$viewValue = value;

    // change to dirty
    if (this.$pristine) {
      this.$dirty = true;
      this.$pristine = false;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      parentForm.$setDirty();
    }

    forEach(this.$parsers, function(fn) {
      value = fn(value);
    });

    if (this.$modelValue !== value) {
      this.$modelValue = value;
      ngModelSet($scope, value);
      forEach(this.$viewChangeListeners, function(listener) {
        try {
          listener();
        } catch(e) {
          $exceptionHandler(e);
        }
      })
    }
  };

  // model -> value
  var ctrl = this;

  $scope.$watch(function ngModelWatch() {
    var value = ngModelGet($scope);

    // if scope model value and ngModel value are out of sync
    if (ctrl.$modelValue !== value) {

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      ctrl.$modelValue = value;
      while(idx--) {
        value = formatters[idx](value);
      }

      if (ctrl.$viewValue !== value) {
        ctrl.$viewValue = value;
        ctrl.$render();
      }
    }
  });
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngModel
 *
 * @element input
 *
 * @description
 * Is a directive that tells Angular to do two-way data binding. It works together with `input`,
 * `select`, `textarea` and even custom form controls that use {@link ng.directive:ngModel.NgModelController
 * NgModelController} exposed by this directive.
 *
 * `ngModel` is responsible for:
 *
 * - binding the view into the model, which other directives such as `input`, `textarea` or `select`
 *   require,
 * - providing validation behavior (i.e. required, number, email, url),
 * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),
 * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),
 * - register the control with parent {@link ng.directive:form form}.
 *
 * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
 * current scope. If the property doesn't already exist on this scope, it will be created
 * implicitly and added to the scope.
 *
 * For basic examples, how to use `ngModel`, see:
 *
 *  - {@link ng.directive:input input}
 *    - {@link ng.directive:input.text text}
 *    - {@link ng.directive:input.checkbox checkbox}
 *    - {@link ng.directive:input.radio radio}
 *    - {@link ng.directive:input.number number}
 *    - {@link ng.directive:input.email email}
 *    - {@link ng.directive:input.url url}
 *  - {@link ng.directive:select select}
 *  - {@link ng.directive:textarea textarea}
 *
 */
var ngModelDirective = function() {
  return {
    require: ['ngModel', '^?form'],
    controller: NgModelController,
    link: function(scope, element, attr, ctrls) {
      // notify others, especially parent forms

      var modelCtrl = ctrls[0],
          formCtrl = ctrls[1] || nullFormCtrl;

      formCtrl.$addControl(modelCtrl);

      element.on('$destroy', function() {
        formCtrl.$removeControl(modelCtrl);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngChange
 * @restrict E
 *
 * @description
 * Evaluate given expression when user changes the input.
 * The expression is not evaluated when the value change is coming from the model.
 *
 * Note, this directive requires `ngModel` to be present.
 *
 * @element input
 *
 * @example
 * <doc:example>
 *   <doc:source>
 *     <script>
 *       function Controller($scope) {
 *         $scope.counter = 0;
 *         $scope.change = function() {
 *           $scope.counter++;
 *         };
 *       }
 *     </script>
 *     <div ng-controller="Controller">
 *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
 *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
 *       <label for="ng-change-example2">Confirmed</label><br />
 *       debug = {{confirmed}}<br />
 *       counter = {{counter}}
 *     </div>
 *   </doc:source>
 *   <doc:scenario>
 *     it('should evaluate the expression if changing from view', function() {
 *       expect(binding('counter')).toEqual('0');
 *       element('#ng-change-example1').click();
 *       expect(binding('counter')).toEqual('1');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
 *
 *     it('should not evaluate the expression if changing from model', function() {
 *       element('#ng-change-example2').click();
 *       expect(binding('counter')).toEqual('0');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
 *   </doc:scenario>
 * </doc:example>
 */
var ngChangeDirective = valueFn({
  require: 'ngModel',
  link: function(scope, element, attr, ctrl) {
    ctrl.$viewChangeListeners.push(function() {
      scope.$eval(attr.ngChange);
    });
  }
});


var requiredDirective = function() {
  return {
    require: '?ngModel',
    link: function(scope, elm, attr, ctrl) {
      if (!ctrl) return;
      attr.required = true; // force truthy in case we are on non input element

      var validator = function(value) {
        if (attr.required && (isEmpty(value) || value === false)) {
          ctrl.$setValidity('required', false);
          return;
        } else {
          ctrl.$setValidity('required', true);
          return value;
        }
      };

      ctrl.$formatters.push(validator);
      ctrl.$parsers.unshift(validator);

      attr.$observe('required', function() {
        validator(ctrl.$viewValue);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngList
 *
 * @description
 * Text input that converts between comma-separated string into an array of strings.
 *
 * @element input
 * @param {string=} ngList optional delimiter that should be used to split the value. If
 *   specified in form `/something/` then the value will be converted into a regular expression.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.names = ['igor', 'misko', 'vojta'];
         }
       </script>
       <form name="myForm" ng-controller="Ctrl">
         List: <input name="namesInput" ng-model="names" ng-list required>
         <span class="error" ng-show="myForm.namesInput.$error.required">
           Required!</span>
         <br>
         <tt>names = {{names}}</tt><br/>
         <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
         <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('names')).toEqual('["igor","misko","vojta"]');
          expect(binding('myForm.namesInput.$valid')).toEqual('true');
          expect(element('span.error').css('display')).toBe('none');
        });

        it('should be invalid if empty', function() {
          input('names').enter('');
          expect(binding('names')).toEqual('[]');
          expect(binding('myForm.namesInput.$valid')).toEqual('false');
          expect(element('span.error').css('display')).not().toBe('none');
        });
      </doc:scenario>
    </doc:example>
 */
var ngListDirective = function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      var match = /\/(.*)\//.exec(attr.ngList),
          separator = match && new RegExp(match[1]) || attr.ngList || ',';

      var parse = function(viewValue) {
        var list = [];

        if (viewValue) {
          forEach(viewValue.split(separator), function(value) {
            if (value) list.push(trim(value));
          });
        }

        return list;
      };

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(function(value) {
        if (isArray(value)) {
          return value.join(', ');
        }

        return undefined;
      });
    }
  };
};


var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

var ngValueDirective = function() {
  return {
    priority: 100,
    compile: function(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function(scope, elm, attr) {
          attr.$set('value', scope.$eval(attr.ngValue));
        };
      } else {
        return function(scope, elm, attr) {
          scope.$watch(attr.ngValue, function valueWatchAction(value) {
            attr.$set('value', value);
          });
        };
      }
    }
  };
};

/**
 * @ngdoc directive
 * @name ng.directive:ngBind
 *
 * @description
 * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
 * with the value of a given expression, and to update the text content when the value of that
 * expression changes.
 *
 * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
 * `{{ expression }}` which is similar but less verbose.
 *
 * It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily 
 * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an 
 * element attribute, it makes the bindings invisible to the user while the page is loading.
 *
 * An alternative solution to this problem would be using the
 * {@link ng.directive:ngCloak ngCloak} directive.
 *
 *
 * @element ANY
 * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
 *
 * @example
 * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.name = 'Whirled';
         }
       </script>
       <div ng-controller="Ctrl">
         Enter name: <input type="text" ng-model="name"><br>
         Hello <span ng-bind="name"></span>!
       </div>
     </doc:source>
     <doc:scenario>
       it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('name')).toBe('Whirled');
         using('.doc-example-live').input('name').enter('world');
         expect(using('.doc-example-live').binding('name')).toBe('world');
       });
     </doc:scenario>
   </doc:example>
 */
var ngBindDirective = ngDirective(function(scope, element, attr) {
  element.addClass('ng-binding').data('$binding', attr.ngBind);
  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
    element.text(value == undefined ? '' : value);
  });
});


/**
 * @ngdoc directive
 * @name ng.directive:ngBindTemplate
 *
 * @description
 * The `ngBindTemplate` directive specifies that the element
 * text content should be replaced with the interpolation of the template
 * in the `ngBindTemplate` attribute.
 * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
 * expressions. This directive is needed since some HTML elements
 * (such as TITLE and OPTION) cannot contain SPAN elements.
 *
 * @element ANY
 * @param {string} ngBindTemplate template of form
 *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
 *
 * @example
 * Try it here: enter text in text box and watch the greeting change.
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.salutation = 'Hello';
           $scope.name = 'World';
         }
       </script>
       <div ng-controller="Ctrl">
        Salutation: <input type="text" ng-model="salutation"><br>
        Name: <input type="text" ng-model="name"><br>
        <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
       </div>
     </doc:source>
     <doc:scenario>
       it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Hello');
         expect(using('.doc-example-live').binding('name')).
           toBe('World');
         using('.doc-example-live').input('salutation').enter('Greetings');
         using('.doc-example-live').input('name').enter('user');
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Greetings');
         expect(using('.doc-example-live').binding('name')).
           toBe('user');
       });
     </doc:scenario>
   </doc:example>
 */
var ngBindTemplateDirective = ['$interpolate', function($interpolate) {
  return function(scope, element, attr) {
    // TODO: move this to scenario runner
    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
    element.addClass('ng-binding').data('$binding', interpolateFn);
    attr.$observe('ngBindTemplate', function(value) {
      element.text(value);
    });
  }
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngBindHtml
 *
 * @description
 * Creates a binding that will innerHTML the result of evaluating the `expression` into the current
 * element in a secure way.  By default, the innerHTML-ed content will be sanitized using the {@link
 * ngSanitize.$sanitize $sanitize} service.  To utilize this functionality, ensure that `$sanitize`
 * is available, for example, by including {@link ngSanitize} in your module's dependencies (not in
 * core Angular.)  You may also bypass sanitization for values you know are safe. To do so, bind to
 * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example
 * under {@link ng.$sce#Example Strict Contextual Escaping (SCE)}.
 *
 * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
 * will have an exception (instead of an exploit.)
 *
 * @element ANY
 * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
 */
var ngBindHtmlDirective = ['$sce', function($sce) {
  return function(scope, element, attr) {
    element.addClass('ng-binding').data('$binding', attr.ngBindHtml);
    scope.$watch(attr.ngBindHtml, function ngBindHtmlWatchAction(value) {
      element.html($sce.getTrustedHtml(value) || '');
    });
  };
}];

function classDirective(name, selector) {
  name = 'ngClass' + name;
  return function() {
    return {
      restrict: 'AC',
      link: function(scope, element, attr) {
        var oldVal = undefined;

        scope.$watch(attr[name], ngClassWatchAction, true);

        attr.$observe('class', function(value) {
          ngClassWatchAction(scope.$eval(attr[name]));
        });


        if (name !== 'ngClass') {
          scope.$watch('$index', function($index, old$index) {
            var mod = $index & 1;
            if (mod !== old$index & 1) {
              if (mod === selector) {
                addClass(scope.$eval(attr[name]));
              } else {
                removeClass(scope.$eval(attr[name]));
              }
            }
          });
        }


        function ngClassWatchAction(newVal) {
          if (selector === true || scope.$index % 2 === selector) {
            if (oldVal && !equals(newVal,oldVal)) {
              removeClass(oldVal);
            }
            addClass(newVal);
          }
          oldVal = copy(newVal);
        }


        function removeClass(classVal) {
          attr.$removeClass(flattenClasses(classVal));
        }


        function addClass(classVal) {
          attr.$addClass(flattenClasses(classVal));
        }

        function flattenClasses(classVal) {
          if(isArray(classVal)) {
            return classVal.join(' ');
          } else if (isObject(classVal)) {
            var classes = [], i = 0;
            forEach(classVal, function(v, k) {
              if (v) {
                classes.push(k);
              }
            });
            return classes.join(' ');
          }

          return classVal;
        };
      }
    };
  };
}

/**
 * @ngdoc directive
 * @name ng.directive:ngClass
 *
 * @description
 * The `ngClass` allows you to set CSS classes on HTML an element, dynamically, by databinding
 * an expression that represents all classes to be added.
 *
 * The directive won't add duplicate classes if a particular class was already set.
 *
 * When the expression changes, the previously added classes are removed and only then the
 * new classes are added.
 *
 * @animations
 * add - happens just before the class is applied to the element
 * remove - happens just before the class is removed from the element
 *
 * @element ANY
 * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class
 *   names, an array, or a map of class names to boolean values. In the case of a map, the
 *   names of the properties whose values are truthy will be added as css classes to the
 *   element.
 *
 * @example Example that demostrates basic bindings via ngClass directive.
   <example>
     <file name="index.html">
       <p ng-class="{strike: strike, bold: bold, red: red}">Map Syntax Example</p>
       <input type="checkbox" ng-model="bold"> bold
       <input type="checkbox" ng-model="strike"> strike
       <input type="checkbox" ng-model="red"> red
       <hr>
       <p ng-class="style">Using String Syntax</p>
       <input type="text" ng-model="style" placeholder="Type: bold strike red">
       <hr>
       <p ng-class="[style1, style2, style3]">Using Array Syntax</p>
       <input ng-model="style1" placeholder="Type: bold"><br>
       <input ng-model="style2" placeholder="Type: strike"><br>
       <input ng-model="style3" placeholder="Type: red"><br>
     </file>
     <file name="style.css">
       .strike {
         text-decoration: line-through;
       }
       .bold {
           font-weight: bold;
       }
       .red {
           color: red;
       }
     </file>
     <file name="scenario.js">
       it('should let you toggle the class', function() {

         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/bold/);
         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/red/);

         input('bold').check();
         expect(element('.doc-example-live p:first').prop('className')).toMatch(/bold/);

         input('red').check();
         expect(element('.doc-example-live p:first').prop('className')).toMatch(/red/);
       });

       it('should let you toggle string example', function() {
         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('');
         input('style').enter('red');
         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('red');
       });

       it('array example should have 3 classes', function() {
         expect(element('.doc-example-live p:last').prop('className')).toBe('');
         input('style1').enter('bold');
         input('style2').enter('strike');
         input('style3').enter('red');
         expect(element('.doc-example-live p:last').prop('className')).toBe('bold strike red');
       });
     </file>
   </example>

   ## Animations

   The example below demonstrates how to perform animations using ngClass.

   <example animations="true">
     <file name="index.html">
      <input type="button" value="set" ng-click="myVar='my-class'">
      <input type="button" value="clear" ng-click="myVar=''">
      <br>
      <span ng-class="myVar">Sample Text</span>
     </file>
     <file name="style.css">
       .my-class-add, .my-class-remove {
         -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
       }

       .my-class,
       .my-class-add.my-class-add-active {
         color: red;
         font-size:3em;
       }

       .my-class-remove.my-class-remove-active {
         font-size:1.0em;
         color:black;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class', function() {
         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:first').click();

         expect(element('.doc-example-live span').prop('className')).
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:last').click();

         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);
       });
     </file>
   </example>


   ## ngClass and pre-existing CSS3 Transitions/Animations
   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
   Therefore, if any CSS3 Transition/Animation styles (outside of ngAnimate) are set on the element, then, if a ngClass animation
   is triggered, the ngClass animation will be skipped so that ngAnimate can allow for the pre-existing transition or animation to
   take over. This restriction allows for ngClass to still work with standard CSS3 Transitions/Animations that are defined
   outside of ngAnimate.
 */
var ngClassDirective = classDirective('', true);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassOdd
 *
 * @description
 * The `ngClassOdd` and `ngClassEven` directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except it works in
 * conjunction with `ngRepeat` and takes affect only on odd (even) rows.
 *
 * This directive can be applied only within a scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   <example>
     <file name="index.html">
        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
          <li ng-repeat="name in names">
           <span ng-class-odd="'odd'" ng-class-even="'even'">
             {{name}}
           </span>
          </li>
        </ol>
     </file>
     <file name="style.css">
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
   </example>
 */
var ngClassOddDirective = classDirective('Odd', 0);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassEven
 *
 * @description
 * The `ngClassOdd` and `ngClassEven` directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except it works in
 * conjunction with `ngRepeat` and takes affect only on odd (even) rows.
 *
 * This directive can be applied only within a scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
 *   result of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   <example>
     <file name="index.html">
        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
          <li ng-repeat="name in names">
           <span ng-class-odd="'odd'" ng-class-even="'even'">
             {{name}} &nbsp; &nbsp; &nbsp;
           </span>
          </li>
        </ol>
     </file>
     <file name="style.css">
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
   </example>
 */
var ngClassEvenDirective = classDirective('Even', 1);

/**
 * @ngdoc directive
 * @name ng.directive:ngCloak
 *
 * @description
 * The `ngCloak` directive is used to prevent the Angular html template from being briefly
 * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
 * directive to avoid the undesirable flicker effect caused by the html template display.
 *
 * The directive can be applied to the `<body>` element, but typically a fine-grained application is
 * preferred in order to benefit from progressive rendering of the browser view.
 *
 * `ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and
 *  `angular.min.js` files. Following is the css rule:
 *
 * <pre>
 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
 *   display: none !important;
 * }
 * </pre>
 *
 * When this css rule is loaded by the browser, all html elements (including their children) that
 * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive
 * during the compilation of the template it deletes the `ngCloak` element attribute, which
 * makes the compiled element visible.
 *
 * For the best result, `angular.js` script must be loaded in the head section of the html file;
 * alternatively, the css rule (above) must be included in the external stylesheet of the
 * application.
 *
 * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
 * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
 * class `ngCloak` in addition to `ngCloak` directive as shown in the example below.
 *
 * @element ANY
 *
 * @example
   <doc:example>
     <doc:source>
        <div id="template1" ng-cloak>{{ 'hello' }}</div>
        <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
     </doc:source>
     <doc:scenario>
       it('should remove the template directive and css class', function() {
         expect(element('.doc-example-live #template1').attr('ng-cloak')).
           not().toBeDefined();
         expect(element('.doc-example-live #template2').attr('ng-cloak')).
           not().toBeDefined();
       });
     </doc:scenario>
   </doc:example>
 *
 */
var ngCloakDirective = ngDirective({
  compile: function(element, attr) {
    attr.$set('ngCloak', undefined);
    element.removeClass('ng-cloak');
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngController
 *
 * @description
 * The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular
 * supports the principles behind the Model-View-Controller design pattern.
 *
 * MVC components in angular:
 *
 * * Model â€” The Model is data in scope properties; scopes are attached to the DOM.
 * * View â€” The template (HTML with data bindings) is rendered into the View.
 * * Controller â€” The `ngController` directive specifies a Controller class; the class has
 *   methods that typically express the business logic behind the application.
 *
 * Note that an alternative way to define controllers is via the {@link ngRoute.$route $route} service.
 *
 * @element ANY
 * @scope
 * @param {expression} ngController Name of a globally accessible constructor function or an
 *     {@link guide/expression expression} that on the current scope evaluates to a
 *     constructor function. The controller instance can further be published into the scope
 *     by adding `as localName` the controller name attribute.
 *
 * @example
 * Here is a simple form for editing user contact information. Adding, removing, clearing, and
 * greeting are methods declared on the controller (see source tab). These methods can
 * easily be called from the angular markup. Notice that the scope becomes the `this` for the
 * controller's instance. This allows for easy access to the view data from the controller. Also
 * notice that any changes to the data are automatically reflected in the View without the need
 * for a manual update. The example is included in two different declaration styles based on
 * your style preferences.
   <doc:example>
     <doc:source>
      <script>
        function SettingsController1() {
          this.name = "John Smith";
          this.contacts = [
            {type: 'phone', value: '408 555 1212'},
            {type: 'email', value: 'john.smith@example.org'} ];
          };

        SettingsController1.prototype.greet = function() {
          alert(this.name);
        };

        SettingsController1.prototype.addContact = function() {
          this.contacts.push({type: 'email', value: 'yourname@example.org'});
        };

        SettingsController1.prototype.removeContact = function(contactToRemove) {
         var index = this.contacts.indexOf(contactToRemove);
          this.contacts.splice(index, 1);
        };

        SettingsController1.prototype.clearContact = function(contact) {
          contact.type = 'phone';
          contact.value = '';
        };
      </script>
      <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
        Name: <input type="text" ng-model="settings.name"/>
        [ <a href="" ng-click="settings.greet()">greet</a> ]<br/>
        Contact:
        <ul>
          <li ng-repeat="contact in settings.contacts">
            <select ng-model="contact.type">
               <option>phone</option>
               <option>email</option>
            </select>
            <input type="text" ng-model="contact.value"/>
            [ <a href="" ng-click="settings.clearContact(contact)">clear</a>
            | <a href="" ng-click="settings.removeContact(contact)">X</a> ]
          </li>
          <li>[ <a href="" ng-click="settings.addContact()">add</a> ]</li>
       </ul>
      </div>
     </doc:source>
     <doc:scenario>
       it('should check controller as', function() {
         expect(element('#ctrl-as-exmpl>:input').val()).toBe('John Smith');
         expect(element('#ctrl-as-exmpl li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('#ctrl-as-exmpl li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

         element('#ctrl-as-exmpl li:first a:contains("clear")').click();
         expect(element('#ctrl-as-exmpl li:first input').val()).toBe('');

         element('#ctrl-as-exmpl li:last a:contains("add")').click();
         expect(element('#ctrl-as-exmpl li:nth-child(3) input').val())
           .toBe('yourname@example.org');
       });
     </doc:scenario>
   </doc:example>
    <doc:example>
     <doc:source>
      <script>
        function SettingsController2($scope) {
          $scope.name = "John Smith";
          $scope.contacts = [
            {type:'phone', value:'408 555 1212'},
            {type:'email', value:'john.smith@example.org'} ];

          $scope.greet = function() {
           alert(this.name);
          };

          $scope.addContact = function() {
           this.contacts.push({type:'email', value:'yourname@example.org'});
          };

          $scope.removeContact = function(contactToRemove) {
           var index = this.contacts.indexOf(contactToRemove);
           this.contacts.splice(index, 1);
          };

          $scope.clearContact = function(contact) {
           contact.type = 'phone';
           contact.value = '';
          };
        }
      </script>
      <div id="ctrl-exmpl" ng-controller="SettingsController2">
        Name: <input type="text" ng-model="name"/>
        [ <a href="" ng-click="greet()">greet</a> ]<br/>
        Contact:
        <ul>
          <li ng-repeat="contact in contacts">
            <select ng-model="contact.type">
               <option>phone</option>
               <option>email</option>
            </select>
            <input type="text" ng-model="contact.value"/>
            [ <a href="" ng-click="clearContact(contact)">clear</a>
            | <a href="" ng-click="removeContact(contact)">X</a> ]
          </li>
          <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
       </ul>
      </div>
     </doc:source>
     <doc:scenario>
       it('should check controller', function() {
         expect(element('#ctrl-exmpl>:input').val()).toBe('John Smith');
         expect(element('#ctrl-exmpl li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('#ctrl-exmpl li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

         element('#ctrl-exmpl li:first a:contains("clear")').click();
         expect(element('#ctrl-exmpl li:first input').val()).toBe('');

         element('#ctrl-exmpl li:last a:contains("add")').click();
         expect(element('#ctrl-exmpl li:nth-child(3) input').val())
           .toBe('yourname@example.org');
       });
     </doc:scenario>
   </doc:example>

 */
var ngControllerDirective = [function() {
  return {
    scope: true,
    controller: '@'
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngCsp
 * @priority 1000
 *
 * @element html
 * @description
 * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
 * 
 * This is necessary when developing things like Google Chrome Extensions.
 * 
 * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
 * For us to be compatible, we just need to implement the "getterFn" in $parse without violating
 * any of these restrictions.
 * 
 * AngularJS uses `Function(string)` generated functions as a speed optimization. By applying `ngCsp`
 * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will
 * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
 * be raised.
 * 
 * In order to use this feature put `ngCsp` directive on the root element of the application.
 * 
 * @example
 * This example shows how to apply the `ngCsp` directive to the `html` tag.
   <pre>
     <!doctype html>
     <html ng-app ng-csp>
     ...
     ...
     </html>
   </pre>
 */

var ngCspDirective = ['$sniffer', function($sniffer) {
  return {
    priority: 1000,
    compile: function() {
      $sniffer.csp = true;
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngClick
 *
 * @description
 * The ngClick allows you to specify custom behavior when
 * element is clicked.
 *
 * @element ANY
 * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
 * click. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-click="count = count + 1" ng-init="count=0">
        Increment
      </button>
      count: {{count}}
     </doc:source>
     <doc:scenario>
       it('should check ng-click', function() {
         expect(binding('count')).toBe('0');
         element('.doc-example-live :button').click();
         expect(binding('count')).toBe('1');
       });
     </doc:scenario>
   </doc:example>
 */
/*
 * A directive that allows creation of custom onclick handlers that are defined as angular
 * expressions and are compiled and executed within the current scope.
 *
 * Events that are handled via these handler are always configured not to propagate further.
 */
var ngEventDirectives = {};
forEach(
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur'.split(' '),
  function(name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = ['$parse', function($parse) {
      return function(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        element.on(lowercase(name), function(event) {
          scope.$apply(function() {
            fn(scope, {$event:event});
          });
        });
      };
    }];
  }
);

/**
 * @ngdoc directive
 * @name ng.directive:ngDblclick
 *
 * @description
 * The `ngDblclick` directive allows you to specify custom behavior on dblclick event.
 *
 * @element ANY
 * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
 * dblclick. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousedown
 *
 * @description
 * The ngMousedown directive allows you to specify custom behavior on mousedown event.
 *
 * @element ANY
 * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
 * mousedown. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseup
 *
 * @description
 * Specify custom behavior on mouseup event.
 *
 * @element ANY
 * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
 * mouseup. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngMouseover
 *
 * @description
 * Specify custom behavior on mouseover event.
 *
 * @element ANY
 * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
 * mouseover. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseenter
 *
 * @description
 * Specify custom behavior on mouseenter event.
 *
 * @element ANY
 * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
 * mouseenter. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseleave
 *
 * @description
 * Specify custom behavior on mouseleave event.
 *
 * @element ANY
 * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
 * mouseleave. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousemove
 *
 * @description
 * Specify custom behavior on mousemove event.
 *
 * @element ANY
 * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
 * mousemove. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeydown
 *
 * @description
 * Specify custom behavior on keydown event.
 *
 * @element ANY
 * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
 * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeyup
 *
 * @description
 * Specify custom behavior on keyup event.
 *
 * @element ANY
 * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
 * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeypress
 *
 * @description
 * Specify custom behavior on keypress event.
 *
 * @element ANY
 * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
 * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSubmit
 *
 * @description
 * Enables binding angular expressions to onsubmit events.
 *
 * Additionally it prevents the default action (which for form means sending the request to the
 * server and reloading the current page) **but only if the form does not contain an `action`
 * attribute**.
 *
 * @element form
 * @param {expression} ngSubmit {@link guide/expression Expression} to eval. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <script>
        function Ctrl($scope) {
          $scope.list = [];
          $scope.text = 'hello';
          $scope.submit = function() {
            if (this.text) {
              this.list.push(this.text);
              this.text = '';
            }
          };
        }
      </script>
      <form ng-submit="submit()" ng-controller="Ctrl">
        Enter text and hit enter:
        <input type="text" ng-model="text" name="text" />
        <input type="submit" id="submit" value="Submit" />
        <pre>list={{list}}</pre>
      </form>
     </doc:source>
     <doc:scenario>
       it('should check ng-submit', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
         expect(input('text').val()).toBe('');
       });
       it('should ignore empty strings', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
       });
     </doc:scenario>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngFocus
 *
 * @description
 * Specify custom behavior on focus event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
 * focus. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngBlur
 *
 * @description
 * Specify custom behavior on blur event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
 * blur. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngIf
 * @restrict A
 *
 * @description
 * The `ngIf` directive removes and recreates a portion of the DOM tree (HTML)
 * conditionally based on **"falsy"** and **"truthy"** values, respectively, evaluated within
 * an {expression}. In other words, if the expression assigned to **ngIf evaluates to a false
 * value** then **the element is removed from the DOM** and **if true** then **a clone of the
 * element is reinserted into the DOM**.
 *
 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
 * element in the DOM rather than changing its visibility via the `display` css property.  A common
 * case when this difference is significant is when using css selectors that rely on an element's
 * position within the DOM (HTML), such as the `:first-child` or `:last-child` pseudo-classes.
 *
 * Note that **when an element is removed using ngIf its scope is destroyed** and **a new scope
 * is created when the element is restored**.  The scope created within `ngIf` inherits from 
 * its parent scope using
 * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.
 * An important implication of this is if `ngModel` is used within `ngIf` to bind to
 * a javascript primitive defined in the parent scope. In this case any modifications made to the
 * variable within the child scope will override (hide) the value in the parent scope.
 *
 * Also, `ngIf` recreates elements using their compiled state. An example scenario of this behavior
 * is if an element's class attribute is directly modified after it's compiled, using something like 
 * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
 * the added class will be lost because the original compiled state is used to regenerate the element.
 *
 * Additionally, you can provide animations via the ngAnimate module to animate the **enter**
 * and **leave** effects.
 *
 * @animations
 * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container
 * leave - happens just before the ngIf contents are removed from the DOM
 *
 * @element ANY
 * @scope
 * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
 *     the element is removed from the DOM tree (HTML).
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
      Show when checked:
      <span ng-if="checked" class="animate-if">
        I'm removed when the checkbox is unchecked.
      </span>
    </file>
    <file name="animations.css">
      .animate-if {
        background:white;
        border:1px solid black;
        padding:10px;
      }

      .animate-if.ng-enter, .animate-if.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

      .animate-if.ng-enter,
      .animate-if.ng-leave.ng-leave-active {
        opacity:0;
      }

      .animate-if.ng-enter.ng-enter-active,
      .animate-if.ng-leave {
        opacity:1;
      }
    </file>
  </example>
 */
var ngIfDirective = ['$animate', function($animate) {
  return {
    transclude: 'element',
    priority: 1000,
    terminal: true,
    restrict: 'A',
    compile: function (element, attr, transclude) {
      return function ($scope, $element, $attr) {
        var childElement, childScope;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
          if (childElement) {
            $animate.leave(childElement);
            childElement = undefined;
          }
          if (childScope) {
            childScope.$destroy();
            childScope = undefined;
          }
          if (toBoolean(value)) {
            childScope = $scope.$new();
            transclude(childScope, function (clone) {
              childElement = clone;
              $animate.enter(clone, $element.parent(), $element);
            });
          }
        });
      }
    }
  }
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInclude
 * @restrict ECA
 *
 * @description
 * Fetches, compiles and includes an external HTML fragment.
 *
 * Keep in mind that:
 *
 * -    by default, the template URL is restricted to the same domain and protocol as the
 *      application document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
 *      $sce.getTrustedResourceUrl} on it.  To load templates from other domains and/or protocols,
 *      you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or
 *      {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.  Refer Angular's {@link
 *      ng.$sce Strict Contextual Escaping}.
 * -    in addition, the browser's
 *      {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest
 *      Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing
 *      (CORS)} policy apply that may further restrict whether the template is successfully loaded.
 *      (e.g.  ngInclude won't work for cross-domain requests on all browsers and for `file://`
 *      access on some browsers)
 *
 * @animations
 * enter - animation is used to bring new content into the browser.
 * leave - animation is used to animate existing content away.
 *
 * The enter and leave animation occur concurrently.
 *
 * @scope
 *
 * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
 *                 make sure you wrap it in quotes, e.g. `src="'myPartialTemplate.html'"`.
 * @param {string=} onload Expression to evaluate when a new partial is loaded.
 *
 * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
 *                  $anchorScroll} to scroll the viewport after the content is loaded.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
 *
 * @example
  <example animations="true">
    <file name="index.html">
     <div ng-controller="Ctrl">
       <select ng-model="template" ng-options="t.name for t in templates">
        <option value="">(blank)</option>
       </select>
       url of the template: <tt>{{template.url}}</tt>
       <hr/>
       <div class="example-animate-container">
         <div class="include-example" ng-include="template.url"></div>
       </div>
     </div>
    </file>
    <file name="script.js">
      function Ctrl($scope) {
        $scope.templates =
          [ { name: 'template1.html', url: 'template1.html'}
          , { name: 'template2.html', url: 'template2.html'} ];
        $scope.template = $scope.templates[0];
      }
     </file>
    <file name="template1.html">
      Content of template1.html
    </file>
    <file name="template2.html">
      Content of template2.html
    </file>
    <file name="animations.css">
      .example-animate-container {
        position:relative;
        background:white;
        border:1px solid black;
        height:40px;
        overflow:hidden;
      }

      .example-animate-container > div {
        padding:10px;
      }

      .include-example.ng-enter, .include-example.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
        display:block;
        padding:10px;
      }

      .include-example.ng-enter {
        top:-50px;
      }
      .include-example.ng-enter.ng-enter-active {
        top:0;
      }

      .include-example.ng-leave {
        top:0;
      }
      .include-example.ng-leave.ng-leave-active {
        top:50px;
      }
    </file>
    <file name="scenario.js">
      it('should load template1.html', function() {
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template1.html/);
      });
      it('should load template2.html', function() {
       select('template').option('1');
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template2.html/);
      });
      it('should change to blank', function() {
       select('template').option('');
       expect(element('.doc-example-live [ng-include]')).toBe(undefined);
      });
    </file>
  </example>
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentRequested
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the scope ngInclude was declared in
 * @description
 * Emitted every time the ngInclude content is requested.
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentLoaded
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the current ngInclude scope
 * @description
 * Emitted every time the ngInclude content is reloaded.
 */
var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile', '$animate', '$sce',
                  function($http,   $templateCache,   $anchorScroll,   $compile,   $animate,   $sce) {
  return {
    restrict: 'ECA',
    terminal: true,
    transclude: 'element',
    compile: function(element, attr, transclusion) {
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || '',
          autoScrollExp = attr.autoscroll;

      return function(scope, $element) {
        var changeCounter = 0,
            currentScope,
            currentElement;

        var cleanupLastIncludeContent = function() {
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if(currentElement) {
            $animate.leave(currentElement);
            currentElement = null;
          }
        };

        scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
          var thisChangeId = ++changeCounter;

          if (src) {
            $http.get(src, {cache: $templateCache}).success(function(response) {
              if (thisChangeId !== changeCounter) return;
              var newScope = scope.$new();

              transclusion(newScope, function(clone) {
                cleanupLastIncludeContent();

                currentScope = newScope;
                currentElement = clone;

                currentElement.html(response);
                $animate.enter(currentElement, null, $element);
                $compile(currentElement.contents())(currentScope);

                if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }

                currentScope.$emit('$includeContentLoaded');
                scope.$eval(onloadExp);
              });
            }).error(function() {
              if (thisChangeId === changeCounter) cleanupLastIncludeContent();
            });
            scope.$emit('$includeContentRequested');
          } else {
            cleanupLastIncludeContent();
          }
        });
      };
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInit
 *
 * @description
 * The `ngInit` directive specifies initialization tasks to be executed
 *  before the template enters execution mode during bootstrap.
 *
 * @element ANY
 * @param {expression} ngInit {@link guide/expression Expression} to eval.
 *
 * @example
   <doc:example>
     <doc:source>
    <div ng-init="greeting='Hello'; person='World'">
      {{greeting}} {{person}}!
    </div>
     </doc:source>
     <doc:scenario>
       it('should check greeting', function() {
         expect(binding('greeting')).toBe('Hello');
         expect(binding('person')).toBe('World');
       });
     </doc:scenario>
   </doc:example>
 */
var ngInitDirective = ngDirective({
  compile: function() {
    return {
      pre: function(scope, element, attrs) {
        scope.$eval(attrs.ngInit);
      }
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngNonBindable
 * @priority 1000
 *
 * @description
 * Sometimes it is necessary to write code which looks like bindings but which should be left alone
 * by angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.
 *
 * @element ANY
 *
 * @example
 * In this example there are two location where a simple binding (`{{}}`) is present, but the one
 * wrapped in `ngNonBindable` is left alone.
 *
 * @example
    <doc:example>
      <doc:source>
        <div>Normal: {{1 + 2}}</div>
        <div ng-non-bindable>Ignored: {{1 + 2}}</div>
      </doc:source>
      <doc:scenario>
       it('should check ng-non-bindable', function() {
         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');
         expect(using('.doc-example-live').element('div:last').text()).
           toMatch(/1 \+ 2/);
       });
      </doc:scenario>
    </doc:example>
 */
var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });

/**
 * @ngdoc directive
 * @name ng.directive:ngPluralize
 * @restrict EA
 *
 * @description
 * # Overview
 * `ngPluralize` is a directive that displays messages according to en-US localization rules.
 * These rules are bundled with angular.js, but can be overridden
 * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
 * by specifying the mappings between
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} and the strings to be displayed.
 *
 * # Plural categories and explicit number rules
 * There are two
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} in Angular's default en-US locale: "one" and "other".
 *
 * While a plural category may match many numbers (for example, in en-US locale, "other" can match
 * any number that is not 1), an explicit number rule can only match one number. For example, the
 * explicit number rule for "3" matches the number 3. There are examples of plural categories
 * and explicit number rules throughout the rest of this documentation.
 *
 * # Configuring ngPluralize
 * You configure ngPluralize by providing 2 attributes: `count` and `when`.
 * You can also provide an optional attribute, `offset`.
 *
 * The value of the `count` attribute can be either a string or an {@link guide/expression
 * Angular expression}; these are evaluated on the current scope for its bound value.
 *
 * The `when` attribute specifies the mappings between plural categories and the actual
 * string to be displayed. The value of the attribute should be a JSON object.
 *
 * The following example shows how to configure ngPluralize:
 *
 * <pre>
 * <ng-pluralize count="personCount"
                 when="{'0': 'Nobody is viewing.',
 *                      'one': '1 person is viewing.',
 *                      'other': '{} people are viewing.'}">
 * </ng-pluralize>
 *</pre>
 *
 * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
 * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
 * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
 * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
 * show "a dozen people are viewing".
 *
 * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted
 * into pluralized strings. In the previous example, Angular will replace `{}` with
 * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
 * for <span ng-non-bindable>{{numberExpression}}</span>.
 *
 * # Configuring ngPluralize with offset
 * The `offset` attribute allows further customization of pluralized text, which can result in
 * a better user experience. For example, instead of the message "4 people are viewing this document",
 * you might display "John, Kate and 2 others are viewing this document".
 * The offset attribute allows you to offset a number by any desired value.
 * Let's take a look at an example:
 *
 * <pre>
 * <ng-pluralize count="personCount" offset=2
 *               when="{'0': 'Nobody is viewing.',
 *                      '1': '{{person1}} is viewing.',
 *                      '2': '{{person1}} and {{person2}} are viewing.',
 *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',
 *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
 * </ng-pluralize>
 * </pre>
 *
 * Notice that we are still using two plural categories(one, other), but we added
 * three explicit number rules 0, 1 and 2.
 * When one person, perhaps John, views the document, "John is viewing" will be shown.
 * When three people view the document, no explicit number rule is found, so
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
 * In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"
 * is shown.
 *
 * Note that when you specify offsets, you must provide explicit number rules for
 * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
 * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
 * plural categories "one" and "other".
 *
 * @param {string|expression} count The variable to be bounded to.
 * @param {string} when The mapping between plural category to its corresponding strings.
 * @param {number=} offset Offset to deduct from the total number.
 *
 * @example
    <doc:example>
      <doc:source>
        <script>
          function Ctrl($scope) {
            $scope.person1 = 'Igor';
            $scope.person2 = 'Misko';
            $scope.personCount = 1;
          }
        </script>
        <div ng-controller="Ctrl">
          Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
          Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
          Number of People:<input type="text" ng-model="personCount" value="1" /><br/>

          <!--- Example with simple pluralization rules for en locale --->
          Without Offset:
          <ng-pluralize count="personCount"
                        when="{'0': 'Nobody is viewing.',
                               'one': '1 person is viewing.',
                               'other': '{} people are viewing.'}">
          </ng-pluralize><br>

          <!--- Example with offset --->
          With Offset(2):
          <ng-pluralize count="personCount" offset=2
                        when="{'0': 'Nobody is viewing.',
                               '1': '{{person1}} is viewing.',
                               '2': '{{person1}} and {{person2}} are viewing.',
                               'one': '{{person1}}, {{person2}} and one other person are viewing.',
                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
          </ng-pluralize>
        </div>
      </doc:source>
      <doc:scenario>
        it('should show correct pluralized string', function() {
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                             toBe('1 person is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                                toBe('Igor is viewing.');

          using('.doc-example-live').input('personCount').enter('0');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                               toBe('Nobody is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                              toBe('Nobody is viewing.');

          using('.doc-example-live').input('personCount').enter('2');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('2 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor and Misko are viewing.');

          using('.doc-example-live').input('personCount').enter('3');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('3 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and one other person are viewing.');

          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('4 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and 2 other people are viewing.');
        });

        it('should show data-binded names', function() {
          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Igor, Misko and 2 other people are viewing.');

          using('.doc-example-live').input('person1').enter('Di');
          using('.doc-example-live').input('person2').enter('Vojta');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Di, Vojta and 2 other people are viewing.');
        });
      </doc:scenario>
    </doc:example>
 */
var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {
  var BRACE = /{}/g;
  return {
    restrict: 'EA',
    link: function(scope, element, attr) {
      var numberExp = attr.count,
          whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || {},
          whensExpFns = {},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          isWhen = /^when(Minus)?(.+)$/;

      forEach(attr, function(expression, attributeName) {
        if (isWhen.test(attributeName)) {
          whens[lowercase(attributeName.replace('when', '').replace('Minus', '-'))] =
            element.attr(attr.$attr[attributeName]);
        }
      });
      forEach(whens, function(expression, key) {
        whensExpFns[key] =
          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +
            offset + endSymbol));
      });

      scope.$watch(function ngPluralizeWatch() {
        var value = parseFloat(scope.$eval(numberExp));

        if (!isNaN(value)) {
          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
          //check it against pluralization rules in $locale service
          if (!(value in whens)) value = $locale.pluralCat(value - offset);
           return whensExpFns[value](scope, element, true);
        } else {
          return '';
        }
      }, function ngPluralizeWatchAction(newVal) {
        element.text(newVal);
      });
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngRepeat
 *
 * @description
 * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
 * instance gets its own scope, where the given loop variable is set to the current collection item,
 * and `$index` is set to the item index or key.
 *
 * Special properties are exposed on the local scope of each template instance, including:
 *
 * | Variable  | Type            | Details                                                                     |
 * |-----------|-----------------|-----------------------------------------------------------------------------|
 * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
 * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
 * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
 * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
 * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
 * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
 *
 *
 * # Special repeat start and end points
 * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
 * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
 * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
 * up to and including the ending HTML tag where **ng-repeat-end** is placed.
 *
 * The example below makes use of this feature:
 * <pre>
 *   <header ng-repeat-start="item in items">
 *     Header {{ item }}
 *   </header>
 *   <div class="body">
 *     Body {{ item }}
 *   </div>
 *   <footer ng-repeat-end>
 *     Footer {{ item }}
 *   </footer>
 * </pre>
 *
 * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
 * <pre>
 *   <header>
 *     Header A
 *   </header>
 *   <div class="body">
 *     Body A
 *   </div>
 *   <footer>
 *     Footer A
 *   </footer>
 *   <header>
 *     Header B
 *   </header>
 *   <div class="body">
 *     Body B
 *   </div>
 *   <footer>
 *     Footer B
 *   </footer>
 * </pre>
 *
 * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
 * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
 *
 * @animations
 * enter - when a new item is added to the list or when an item is revealed after a filter
 * leave - when an item is removed from the list or when an item is filtered out
 * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
 *
 * @element ANY
 * @scope
 * @priority 1000
 * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
 *   formats are currently supported:
 *
 *   * `variable in expression` â€“ where variable is the user defined loop variable and `expression`
 *     is a scope expression giving the collection to enumerate.
 *
 *     For example: `album in artist.albums`.
 *
 *   * `(key, value) in expression` â€“ where `key` and `value` can be any user defined identifiers,
 *     and `expression` is the scope expression giving the collection to enumerate.
 *
 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
 *
 *   * `variable in expression track by tracking_expression` â€“ You can also provide an optional tracking function
 *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function
 *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
 *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are
 *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,
 *     before specifying a tracking expression.
 *
 *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements
 *     will be associated by item identity in the array.
 *
 *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
 *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
 *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
 *     element in the same way ian the DOM.
 *
 *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this
 *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
 *     property is same.
 *
 *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter
 *     to items in conjunction with a tracking expression.
 *
 * @example
 * This example initializes the scope to a list of names and
 * then uses `ngRepeat` to display every person:
  <example animations="true">
    <file name="index.html">
      <div ng-init="friends = [
        {name:'John', age:25, gender:'boy'},
        {name:'Jessie', age:30, gender:'girl'},
        {name:'Johanna', age:28, gender:'girl'},
        {name:'Joy', age:15, gender:'girl'},
        {name:'Mary', age:28, gender:'girl'},
        {name:'Peter', age:95, gender:'boy'},
        {name:'Sebastian', age:50, gender:'boy'},
        {name:'Erika', age:27, gender:'girl'},
        {name:'Patrick', age:40, gender:'boy'},
        {name:'Samantha', age:60, gender:'girl'}
      ]">
        I have {{friends.length}} friends. They are:
        <input type="search" ng-model="q" placeholder="filter friends..." />
        <ul class="example-animate-container">
          <li class="animate-repeat" ng-repeat="friend in friends | filter:q">
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
          </li>
        </ul>
      </div>
    </file>
    <file name="animations.css">
      .example-animate-container {
        background:white;
        border:1px solid black;
        list-style:none;
        margin:0;
        padding:0;
      }

      .example-animate-container > li {
        padding:10px;
        list-style:none;
      }

      .animate-repeat.ng-enter,
      .animate-repeat.ng-leave,
      .animate-repeat.ng-move {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .animate-repeat.ng-enter {
        line-height:0;
        opacity:0;
        padding-top:0;
        padding-bottom:0;
      }
      .animate-repeat.ng-enter.ng-enter-active {
        line-height:20px;
        opacity:1;
        padding:10px;
      }

      .animate-repeat.ng-leave {
        opacity:1;
        line-height:20px;
        padding:10px;
      }
      .animate-repeat.ng-leave.ng-leave-active {
        opacity:0;
        line-height:0;
        padding-top:0;
        padding-bottom:0;
      }

      .animate-repeat.ng-move { }
      .animate-repeat.ng-move.ng-move-active { }
    </file>
    <file name="scenario.js">
       it('should render initial data set', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);
         expect(r.row(0)).toEqual(["1","John","25"]);
         expect(r.row(1)).toEqual(["2","Jessie","30"]);
         expect(r.row(9)).toEqual(["10","Samantha","60"]);
         expect(binding('friends.length')).toBe("10");
       });

       it('should update repeater when filter predicate changes', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);

         input('q').enter('ma');

         expect(r.count()).toBe(2);
         expect(r.row(0)).toEqual(["1","Mary","28"]);
         expect(r.row(1)).toEqual(["2","Samantha","60"]);
       });
      </file>
    </example>
 */
var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
  var NG_REMOVED = '$$NG_REMOVED';
  var ngRepeatMinErr = minErr('ngRepeat');
  return {
    transclude: 'element',
    priority: 1000,
    terminal: true,
    compile: function(element, attr, linker) {
      return function($scope, $element, $attr){
        var expression = $attr.ngRepeat;
        var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
          trackByExp, trackByExpGetter, trackByIdFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier,
          hashFnLocals = {$id: hashKey};

        if (!match) {
          throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
        }

        lhs = match[1];
        rhs = match[2];
        trackByExp = match[4];

        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
          trackByIdFn = function(key, value, index) {
            // assign key, value, and $index to the locals so that they can be used in hash functions
            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          }
          trackByIdObjFn = function(key) {
            return key;
          }
        }

        match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
        if (!match) {
          throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
                                                                    lhs);
        }
        valueIdentifier = match[3] || match[1];
        keyIdentifier = match[2];

        // Store a list of elements from previous run. This is a hash where key is the item from the
        // iterator, and the value is objects with following properties.
        //   - scope: bound scope
        //   - element: previous element.
        //   - index: position
        var lastBlockMap = {};

        //watch props
        $scope.$watchCollection(rhs, function ngRepeatAction(collection){
          var index, length,
              previousNode = $element[0],     // current position of the node
              nextNode,
              // Same as lastBlockMap but it has the current state. It will become the
              // lastBlockMap on the next iteration.
              nextBlockMap = {},
              arrayLength,
              childScope,
              key, value, // key/value of iteration
              trackById,
              collectionKeys,
              block,       // last object information {scope, element, id}
              nextBlockOrder = [];


          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdFn || trackByIdObjFn;
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (key in collection) {
              if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                collectionKeys.push(key);
              }
            }
            collectionKeys.sort();
          }

          arrayLength = collectionKeys.length;

          // locate existing items
          length = nextBlockOrder.length = collectionKeys.length;
          for(index = 0; index < length; index++) {
           key = (collection === collectionKeys) ? index : collectionKeys[index];
           value = collection[key];
           trackById = trackByIdFn(key, value, index);
           if(lastBlockMap.hasOwnProperty(trackById)) {
             block = lastBlockMap[trackById]
             delete lastBlockMap[trackById];
             nextBlockMap[trackById] = block;
             nextBlockOrder[index] = block;
           } else if (nextBlockMap.hasOwnProperty(trackById)) {
             // restore lastBlockMap
             forEach(nextBlockOrder, function(block) {
               if (block && block.startNode) lastBlockMap[block.id] = block;
             });
             // This is a duplicate and we need to throw an error
             throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}",
                                                                                                                                                    expression,       trackById);
           } else {
             // new never before seen block
             nextBlockOrder[index] = { id: trackById };
             nextBlockMap[trackById] = false;
           }
         }

          // remove existing items
          for (key in lastBlockMap) {
            if (lastBlockMap.hasOwnProperty(key)) {
              block = lastBlockMap[key];
              $animate.leave(block.elements);
              forEach(block.elements, function(element) { element[NG_REMOVED] = true});
              block.scope.$destroy();
            }
          }

          // we are not using forEach for perf reasons (trying to avoid #call)
          for (index = 0, length = collectionKeys.length; index < length; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            if (block.startNode) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element
              childScope = block.scope;

              nextNode = previousNode;
              do {
                nextNode = nextNode.nextSibling;
              } while(nextNode && nextNode[NG_REMOVED]);

              if (block.startNode == nextNode) {
                // do nothing
              } else {
                // existing item which got moved
                $animate.move(block.elements, null, jqLite(previousNode));
              }
              previousNode = block.endNode;
            } else {
              // new item which we don't know about
              childScope = $scope.$new();
            }

            childScope[valueIdentifier] = value;
            if (keyIdentifier) childScope[keyIdentifier] = key;
            childScope.$index = index;
            childScope.$first = (index === 0);
            childScope.$last = (index === (arrayLength - 1));
            childScope.$middle = !(childScope.$first || childScope.$last);
            childScope.$odd = !(childScope.$even = index%2==0);

            if (!block.startNode) {
              linker(childScope, function(clone) {
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = clone;
                block.scope = childScope;
                block.startNode = clone[0];
                block.elements = clone;
                block.endNode = clone[clone.length - 1];
                nextBlockMap[block.id] = block;
              });
            }
          }
          lastBlockMap = nextBlockMap;
        });
      };
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngShow
 *
 * @description
 * The `ngShow` directive shows and hides the given HTML element conditionally based on the expression
 * provided to the ngShow attribute. The show and hide mechanism is a achieved by removing and adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is a predefined CSS class present
 * in AngularJS which sets the display style to none (using an !important flag).
 *
 * <pre>
 * <!-- when $scope.myValue is truthy (element is visible) -->
 * <div ng-show="myValue"></div>
 *
 * <!-- when $scope.myValue is falsy (element is hidden) -->
 * <div ng-show="myValue" class="ng-hide"></div>
 * </pre>
 *
 * When the ngShow expression evaluates to false then the ng-hide CSS class is added to the class attribute
 * on the element causing it to become hidden. When true, the ng-hide CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
 *
 * ### Overriding .ng-hide
 *
 * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
 * restating the styles for the .ng-hide class in CSS:
 * <pre>
 * .ng-hide {
 *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
 *   display:block!important;
 *
 *   //this is just another form of hiding an element
 *   position:absolute;
 *   top:-9999px;
 *   left:-9999px;
 * }
 * </pre>
 *
 * Just remember to include the important flag so the CSS override will function.
 *
 * ## A note about animations with ngShow
 *
 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
 * is true and false. This system works similar to the animation system present with ngClass, however, the
 * only difference is that you must also include the !important flag to override the display property so
 * that you can perform an animation when the element is hidden during the time of the animation.
 *
 * <pre>
 * //
 * //a working example can be found at the bottom of this page
 * //
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
 *   transition:0.5s linear all;
 *   display:block!important;
 * }
 *
 * .my-element.ng-hide-add { ... }
 * .my-element.ng-hide-add.ng-hide-add-active { ... }
 * .my-element.ng-hide-remove { ... }
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
 * </pre>
 *
 * @animations
 * addClass: .ng-hide - happens after the ngShow expression evaluates to a truthy value and the just before contents are set to visible
 * removeClass: .ng-hide - happens after the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden
 *
 * @element ANY
 * @param {expression} ngShow If the {@link guide/expression expression} is truthy
 *     then the element is shown or hidden respectively.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked"><br/>
      <div>
        Show:
        <div class="check-element animate-show" ng-show="checked">
          <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
        </div>
      </div>
      <div>
        Hide:
        <div class="check-element animate-show" ng-hide="checked">
          <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
        </div>
      </div>
    </file>
    <file name="animations.css">
      .animate-show.ng-hide-add, 
      .animate-show.ng-hide-remove {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
        display:block!important;
      }

      .animate-show.ng-hide-add.ng-hide-add-active,
      .animate-show.ng-hide-remove {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .animate-show.ng-hide-add,
      .animate-show.ng-hide-remove.ng-hide-remove-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    </file>
    <file name="scenario.js">
       it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);
       });
    </file>
  </example>
 */
var ngShowDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngShow, function ngShowWatchAction(value){
      $animate[toBoolean(value) ? 'removeClass' : 'addClass'](element, 'ng-hide');
    });
  };
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngHide
 *
 * @description
 * The `ngHide` directive shows and hides the given HTML element conditionally based on the expression
 * provided to the ngHide attribute. The show and hide mechanism is a achieved by removing and adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is a predefined CSS class present
 * in AngularJS which sets the display style to none (using an !important flag).
 *
 * <pre>
 * <!-- when $scope.myValue is truthy (element is hidden) -->
 * <div ng-hide="myValue"></div>
 *
 * <!-- when $scope.myValue is falsy (element is visible) -->
 * <div ng-hide="myValue" class="ng-hide"></div>
 * </pre>
 *
 * When the ngHide expression evaluates to true then the .ng-hide CSS class is added to the class attribute
 * on the element causing it to become hidden. When false, the ng-hide CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
 *
 * ### Overriding .ng-hide
 *
 * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
 * restating the styles for the .ng-hide class in CSS:
 * <pre>
 * .ng-hide {
 *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
 *   display:block!important;
 *
 *   //this is just another form of hiding an element
 *   position:absolute;
 *   top:-9999px;
 *   left:-9999px;
 * }
 * </pre>
 *
 * Just remember to include the important flag so the CSS override will function.
 *
 * ## A note about animations with ngHide
 *
 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
 * is true and false. This system works similar to the animation system present with ngClass, however, the
 * only difference is that you must also include the !important flag to override the display property so
 * that you can perform an animation when the element is hidden during the time of the animation.
 *
 * <pre>
 * //
 * //a working example can be found at the bottom of this page
 * //
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
 *   transition:0.5s linear all;
 *   display:block!important;
 * }
 *
 * .my-element.ng-hide-add { ... }
 * .my-element.ng-hide-add.ng-hide-add-active { ... }
 * .my-element.ng-hide-remove { ... }
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
 * </pre>
 *
 * @animations
 * removeClass: .ng-hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden
 * addClass: .ng-hide - happens after the ngHide expression evaluates to a non truthy value and just before the contents are set to visible
 *
 * @element ANY
 * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
 *     the element is shown or hidden respectively.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked"><br/>
      <div>
        Show:
        <div class="check-element animate-hide" ng-show="checked">
          <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
        </div>
      </div>
      <div>
        Hide:
        <div class="check-element animate-hide" ng-hide="checked">
          <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
        </div>
      </div>
    </file>
    <file name="animations.css">
      .animate-hide.ng-hide-add, 
      .animate-hide.ng-hide-remove {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
        display:block!important;
      }

      .animate-hide.ng-hide-add.ng-hide-add-active,
      .animate-hide.ng-hide-remove {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .animate-hide.ng-hide-add,
      .animate-hide.ng-hide-remove.ng-hide-remove-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    </file>
    <file name="scenario.js">
       it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);
       });
    </file>
  </example>
 */
var ngHideDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngHide, function ngHideWatchAction(value){
      $animate[toBoolean(value) ? 'addClass' : 'removeClass'](element, 'ng-hide');
    });
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngStyle
 *
 * @description
 * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
 *
 * @element ANY
 * @param {expression} ngStyle {@link guide/expression Expression} which evals to an
 *      object whose keys are CSS style names and values are corresponding values for those CSS
 *      keys.
 *
 * @example
   <example>
     <file name="index.html">
        <input type="button" value="set" ng-click="myStyle={color:'red'}">
        <input type="button" value="clear" ng-click="myStyle={}">
        <br/>
        <span ng-style="myStyle">Sample Text</span>
        <pre>myStyle={{myStyle}}</pre>
     </file>
     <file name="style.css">
       span {
         color: black;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-style', function() {
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
         element('.doc-example-live :button[value=set]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');
         element('.doc-example-live :button[value=clear]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
       });
     </file>
   </example>
 */
var ngStyleDirective = ngDirective(function(scope, element, attr) {
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
    if (oldStyles && (newStyles !== oldStyles)) {
      forEach(oldStyles, function(val, style) { element.css(style, '');});
    }
    if (newStyles) element.css(newStyles);
  }, true);
});

/**
 * @ngdoc directive
 * @name ng.directive:ngSwitch
 * @restrict EA
 *
 * @description
 * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.
 * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location
 * as specified in the template.
 *
 * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
 * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element
 * matches the value obtained from the evaluated expression. In other words, you define a container element
 * (where you place the directive), place an expression on the **on="..." attribute**
 * (or the **ng-switch="..." attribute**), define any inner elements inside of the directive and place
 * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
 * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
 * attribute is displayed.
 *
 * @animations
 * enter - happens after the ngSwtich contents change and the matched child element is placed inside the container
 * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
 *
 * @usage
 * <ANY ng-switch="expression">
 *   <ANY ng-switch-when="matchValue1">...</ANY>
 *   <ANY ng-switch-when="matchValue2">...</ANY>
 *   <ANY ng-switch-default>...</ANY>
 * </ANY>
 *
 * @scope
 * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.
 * @paramDescription
 * On child elements add:
 *
 * * `ngSwitchWhen`: the case statement to match against. If match then this
 *   case will be displayed. If the same match appears multiple times, all the
 *   elements will be displayed.
 * * `ngSwitchDefault`: the default case when no other case match. If there
 *   are multiple default cases, all of them will be displayed when no other
 *   case match.
 *
 *
 * @example
  <example animations="true">
    <file name="index.html">
      <div ng-controller="Ctrl">
        <select ng-model="selection" ng-options="item for item in items">
        </select>
        <tt>selection={{selection}}</tt>
        <hr/>
        <div class="animate-switch-container"
          ng-switch on="selection">
            <div ng-switch-when="settings">Settings Div</div>
            <div ng-switch-when="home">Home Span</div>
            <div ng-switch-default>default</div>
        </div>
      </div>
    </file>
    <file name="script.js">
      function Ctrl($scope) {
        $scope.items = ['settings', 'home', 'other'];
        $scope.selection = $scope.items[0];
      }
    </file>
    <file name="animations.css">
      .animate-switch-container {
        position:relative;
        background:white;
        border:1px solid black;
        height:40px;
        overflow:hidden;
      }

      .animate-switch-container > div {
        padding:10px;
      }

      .animate-switch-container > .ng-enter,
      .animate-switch-container > .ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

      .animate-switch-container > .ng-enter {
        top:-50px;
      }
      .animate-switch-container > .ng-enter.ng-enter-active {
        top:0;
      }

      .animate-switch-container > .ng-leave {
        top:0;
      }
      .animate-switch-container > .ng-leave.ng-leave-active {
        top:50px;
      }
    </file>
    <file name="scenario.js">
      it('should start in settings', function() {
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);
      });
      it('should change to home', function() {
        select('selection').option('home');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);
      });
      it('should select default', function() {
        select('selection').option('other');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);
      });
    </file>
  </example>
 */
var ngSwitchDirective = ['$animate', function($animate) {
  return {
    restrict: 'EA',
    require: 'ngSwitch',

    // asks for $scope to fool the BC controller module
    controller: ['$scope', function ngSwitchController() {
     this.cases = {};
    }],
    link: function(scope, element, attr, ngSwitchController) {
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes,
          selectedElements,
          selectedScopes = [];

      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
        for (var i= 0, ii=selectedScopes.length; i<ii; i++) {
          selectedScopes[i].$destroy();
          $animate.leave(selectedElements[i]);
        }

        selectedElements = [];
        selectedScopes = [];

        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
          scope.$eval(attr.change);
          forEach(selectedTranscludes, function(selectedTransclude) {
            var selectedScope = scope.$new();
            selectedScopes.push(selectedScope);
            selectedTransclude.transclude(selectedScope, function(caseElement) {
              var anchor = selectedTransclude.element;

              selectedElements.push(caseElement);
              $animate.enter(caseElement, anchor.parent(), anchor);
            });
          });
        }
      });
    }
  }
}];

var ngSwitchWhenDirective = ngDirective({
  transclude: 'element',
  priority: 500,
  require: '^ngSwitch',
  compile: function(element, attrs, transclude) {
    return function(scope, element, attr, ctrl) {
      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
      ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: transclude, element: element });
    };
  }
});

var ngSwitchDefaultDirective = ngDirective({
  transclude: 'element',
  priority: 500,
  require: '^ngSwitch',
  compile: function(element, attrs, transclude) {
    return function(scope, element, attr, ctrl) {
      ctrl.cases['?'] = (ctrl.cases['?'] || []);
      ctrl.cases['?'].push({ transclude: transclude, element: element });
    };
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngTransclude
 *
 * @description
 * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
 *
 * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
 *
 * @element ANY
 *
 * @example
   <doc:example module="transclude">
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.title = 'Lorem Ipsum';
           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
         }

         angular.module('transclude', [])
          .directive('pane', function(){
             return {
               restrict: 'E',
               transclude: true,
               scope: { title:'@' },
               template: '<div style="border: 1px solid black;">' +
                           '<div style="background-color: gray">{{title}}</div>' +
                           '<div ng-transclude></div>' +
                         '</div>'
             };
         });
       </script>
       <div ng-controller="Ctrl">
         <input ng-model="title"><br>
         <textarea ng-model="text"></textarea> <br/>
         <pane title="{{title}}">{{text}}</pane>
       </div>
     </doc:source>
     <doc:scenario>
        it('should have transcluded', function() {
          input('title').enter('TITLE');
          input('text').enter('TEXT');
          expect(binding('title')).toEqual('TITLE');
          expect(binding('text')).toEqual('TEXT');
        });
     </doc:scenario>
   </doc:example>
 *
 */
var ngTranscludeDirective = ngDirective({
  controller: ['$transclude', function($transclude) {
    // remember the transclusion fn but call it during linking so that we don't process transclusion before directives on
    // the parent element even when the transclusion replaces the current element. (we can't use priority here because
    // that applies only to compile fns and not controllers
    this.$transclude = $transclude;
  }],

  link: function($scope, $element, $attrs, controller) {
    controller.$transclude(function(clone) {
      $element.html('');
      $element.append(clone);
    });
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:script
 *
 * @description
 * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the
 * template can be used by `ngInclude`, `ngView` or directive templates.
 *
 * @restrict E
 * @param {'text/ng-template'} type must be set to `'text/ng-template'`
 *
 * @example
  <doc:example>
    <doc:source>
      <script type="text/ng-template" id="/tpl.html">
        Content of the template.
      </script>

      <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
      <div id="tpl-content" ng-include src="currentTpl"></div>
    </doc:source>
    <doc:scenario>
      it('should load template defined inside script tag', function() {
        element('#tpl-link').click();
        expect(element('#tpl-content').text()).toMatch(/Content of the template/);
      });
    </doc:scenario>
  </doc:example>
 */
var scriptDirective = ['$templateCache', function($templateCache) {
  return {
    restrict: 'E',
    terminal: true,
    compile: function(element, attr) {
      if (attr.type == 'text/ng-template') {
        var templateUrl = attr.id,
            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      }
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:select
 * @restrict E
 *
 * @description
 * HTML `SELECT` element with angular data-binding.
 *
 * # `ngOptions`
 *
 * Optionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`
 * elements for a `<select>` element using an array or an object obtained by evaluating the
 * `ngOptions` expression.
 *
 * When an item in the `<select>` menu is selected, the value of array element or object property
 * represented by the selected option will be bound to the model identified by the `ngModel`
 * directive of the parent select element.
 *
 * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
 * be nested into the `<select>` element. This element will then represent `null` or "not selected"
 * option. See example below for demonstration.
 *
 * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead
 * of {@link ng.directive:ngRepeat ngRepeat} when you want the
 * `select` model to be bound to a non-string value. This is because an option element can currently
 * be bound to string values only.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required The control is considered valid only if value is entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {comprehension_expression=} ngOptions in one of the following forms:
 *
 *   * for array data sources:
 *     * `label` **`for`** `value` **`in`** `array`
 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
 *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
 *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
 *   * for object data sources:
 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
 *     * `select` **`as`** `label` **`group by`** `group`
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
 *
 * Where:
 *
 *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
 *   * `value`: local variable which will refer to each item in the `array` or each property value
 *      of `object` during iteration.
 *   * `key`: local variable which will refer to a property name in `object` during iteration.
 *   * `label`: The result of this expression will be the label for `<option>` element. The
 *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
 *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
 *      element. If not specified, `select` expression will default to `value`.
 *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
 *      DOM element.
 *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
 *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
 *     `value` variable (e.g. `value.propertyName`).
 *
 * @example
    <doc:example>
      <doc:source>
        <script>
        function MyCntrl($scope) {
          $scope.colors = [
            {name:'black', shade:'dark'},
            {name:'white', shade:'light'},
            {name:'red', shade:'dark'},
            {name:'blue', shade:'dark'},
            {name:'yellow', shade:'light'}
          ];
          $scope.color = $scope.colors[2]; // red
        }
        </script>
        <div ng-controller="MyCntrl">
          <ul>
            <li ng-repeat="color in colors">
              Name: <input ng-model="color.name">
              [<a href ng-click="colors.splice($index, 1)">X</a>]
            </li>
            <li>
              [<a href ng-click="colors.push({})">add</a>]
            </li>
          </ul>
          <hr/>
          Color (null not allowed):
          <select ng-model="color" ng-options="c.name for c in colors"></select><br>

          Color (null allowed):
          <span  class="nullable">
            <select ng-model="color" ng-options="c.name for c in colors">
              <option value="">-- chose color --</option>
            </select>
          </span><br/>

          Color grouped by shade:
          <select ng-model="color" ng-options="c.name group by c.shade for c in colors">
          </select><br/>


          Select <a href ng-click="color={name:'not in list'}">bogus</a>.<br>
          <hr/>
          Currently selected: {{ {selected_color:color}  }}
          <div style="border:solid 1px black; height:20px"
               ng-style="{'background-color':color.name}">
          </div>
        </div>
      </doc:source>
      <doc:scenario>
         it('should check ng-options', function() {
           expect(binding('{selected_color:color}')).toMatch('red');
           select('color').option('0');
           expect(binding('{selected_color:color}')).toMatch('black');
           using('.nullable').select('color').option('');
           expect(binding('{selected_color:color}')).toMatch('null');
         });
      </doc:scenario>
    </doc:example>
 */

var ngOptionsDirective = valueFn({ terminal: true });
var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000007777000000000000000000088888
  var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
      nullModelCtrl = {$setViewValue: noop};

  return {
    restrict: 'E',
    require: ['select', '?ngModel'],
    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
      var self = this,
          optionsMap = {},
          ngModelCtrl = nullModelCtrl,
          nullOption,
          unknownOption;


      self.databound = $attrs.ngModel;


      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
        ngModelCtrl = ngModelCtrl_;
        nullOption = nullOption_;
        unknownOption = unknownOption_;
      }


      self.addOption = function(value) {
        optionsMap[value] = true;

        if (ngModelCtrl.$viewValue == value) {
          $element.val(value);
          if (unknownOption.parent()) unknownOption.remove();
        }
      };


      self.removeOption = function(value) {
        if (this.hasOption(value)) {
          delete optionsMap[value];
          if (ngModelCtrl.$viewValue == value) {
            this.renderUnknownOption(value);
          }
        }
      };


      self.renderUnknownOption = function(val) {
        var unknownVal = '? ' + hashKey(val) + ' ?';
        unknownOption.val(unknownVal);
        $element.prepend(unknownOption);
        $element.val(unknownVal);
        unknownOption.prop('selected', true); // needed for IE
      }


      self.hasOption = function(value) {
        return optionsMap.hasOwnProperty(value);
      }

      $scope.$on('$destroy', function() {
        // disable unknown option so that we don't do work when the whole select is being destroyed
        self.renderUnknownOption = noop;
      });
    }],

    link: function(scope, element, attr, ctrls) {
      // if ngModel is not defined, we don't need to do anything
      if (!ctrls[1]) return;

      var selectCtrl = ctrls[0],
          ngModelCtrl = ctrls[1],
          multiple = attr.multiple,
          optionsExp = attr.ngOptions,
          nullOption = false, // if false, user will not be able to select it (used by ngOptions)
          emptyOption,
          // we can't just jqLite('<option>') since jqLite is not smart enough
          // to create it in <select> and IE barfs otherwise.
          optionTemplate = jqLite(document.createElement('option')),
          optGroupTemplate =jqLite(document.createElement('optgroup')),
          unknownOption = optionTemplate.clone();

      // find "null" option
      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
        if (children[i].value == '') {
          emptyOption = nullOption = children.eq(i);
          break;
        }
      }

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      // required validator
      if (multiple && (attr.required || attr.ngRequired)) {
        var requiredValidator = function(value) {
          ngModelCtrl.$setValidity('required', !attr.required || (value && value.length));
          return value;
        };

        ngModelCtrl.$parsers.push(requiredValidator);
        ngModelCtrl.$formatters.unshift(requiredValidator);

        attr.$observe('required', function() {
          requiredValidator(ngModelCtrl.$viewValue);
        });
      }

      if (optionsExp) Options(scope, element, ngModelCtrl);
      else if (multiple) Multiple(scope, element, ngModelCtrl);
      else Single(scope, element, ngModelCtrl, selectCtrl);


      ////////////////////////////



      function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
        ngModelCtrl.$render = function() {
          var viewValue = ngModelCtrl.$viewValue;

          if (selectCtrl.hasOption(viewValue)) {
            if (unknownOption.parent()) unknownOption.remove();
            selectElement.val(viewValue);
            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
          } else {
            if (isUndefined(viewValue) && emptyOption) {
              selectElement.val('');
            } else {
              selectCtrl.renderUnknownOption(viewValue);
            }
          }
        };

        selectElement.on('change', function() {
          scope.$apply(function() {
            if (unknownOption.parent()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          });
        });
      }

      function Multiple(scope, selectElement, ctrl) {
        var lastView;
        ctrl.$render = function() {
          var items = new HashMap(ctrl.$viewValue);
          forEach(selectElement.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        scope.$watch(function selectMultipleWatch() {
          if (!equals(lastView, ctrl.$viewValue)) {
            lastView = copy(ctrl.$viewValue);
            ctrl.$render();
          }
        });

        selectElement.on('change', function() {
          scope.$apply(function() {
            var array = [];
            forEach(selectElement.find('option'), function(option) {
              if (option.selected) {
                array.push(option.value);
              }
            });
            ctrl.$setViewValue(array);
          });
        });
      }

      function Options(scope, selectElement, ctrl) {
        var match;

        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw minErr('ngOptions')('iexp',
            "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}",
            optionsExp, startingTag(selectElement));
        }

        var displayFn = $parse(match[2] || match[1]),
            valueName = match[4] || match[6],
            keyName = match[5],
            groupByFn = $parse(match[3] || ''),
            valueFn = $parse(match[2] ? match[1] : valueName),
            valuesFn = $parse(match[7]),
            track = match[8],
            trackFn = track ? $parse(match[8]) : null,
            // This is an array of array of existing option groups in DOM. We try to reuse these if possible
            // optionGroupsCache[0] is the options with no option group
            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
            optionGroupsCache = [[{element: selectElement, label:''}]];

        if (nullOption) {
          // compile the element since there might be bindings in it
          $compile(nullOption)(scope);

          // remove the class, which is added automatically because we recompile the element and it
          // becomes the compilation root
          nullOption.removeClass('ng-scope');

          // we need to remove it before calling selectElement.html('') because otherwise IE will
          // remove the label from the element. wtf?
          nullOption.remove();
        }

        // clear contents, we'll add what's needed based on the model
        selectElement.html('');

        selectElement.on('change', function() {
          scope.$apply(function() {
            var optionGroup,
                collection = valuesFn(scope) || [],
                locals = {},
                key, value, optionElement, index, groupIndex, length, groupLength;

            if (multiple) {
              value = [];
              for (groupIndex = 0, groupLength = optionGroupsCache.length;
                   groupIndex < groupLength;
                   groupIndex++) {
                // list of options for that group. (first item has the parent)
                optionGroup = optionGroupsCache[groupIndex];

                for(index = 1, length = optionGroup.length; index < length; index++) {
                  if ((optionElement = optionGroup[index].element)[0].selected) {
                    key = optionElement.val();
                    if (keyName) locals[keyName] = key;
                    if (trackFn) {
                      for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                        locals[valueName] = collection[trackIndex];
                        if (trackFn(scope, locals) == key) break;
                      }
                    } else {
                      locals[valueName] = collection[key];
                    }
                    value.push(valueFn(scope, locals));
                  }
                }
              }
            } else {
              key = selectElement.val();
              if (key == '?') {
                value = undefined;
              } else if (key == ''){
                value = null;
              } else {
                if (trackFn) {
                  for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                    locals[valueName] = collection[trackIndex];
                    if (trackFn(scope, locals) == key) {
                      value = valueFn(scope, locals);
                      break;
                    }
                  }
                } else {
                  locals[valueName] = collection[key];
                  if (keyName) locals[keyName] = key;
                  value = valueFn(scope, locals);
                }
              }
            }
            ctrl.$setViewValue(value);
          });
        });

        ctrl.$render = render;

        // TODO(vojta): can't we optimize this ?
        scope.$watch(render);

        function render() {
          var optionGroups = {'':[]}, // Temporary location for the option groups before we render them
              optionGroupNames = [''],
              optionGroupName,
              optionGroup,
              option,
              existingParent, existingOptions, existingOption,
              modelValue = ctrl.$modelValue,
              values = valuesFn(scope) || [],
              keys = keyName ? sortedKeys(values) : values,
              groupLength, length,
              groupIndex, index,
              locals = {},
              selected,
              selectedSet = false, // nothing is selected yet
              lastElement,
              element,
              label;

          if (multiple) {
            if (trackFn && isArray(modelValue)) {
              selectedSet = new HashMap([]);
              for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                locals[valueName] = modelValue[trackIndex];
                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
              }
            } else {
              selectedSet = new HashMap(modelValue);
            }
          }

          // We now build up the list of options we need (we merge later)
          for (index = 0; length = keys.length, index < length; index++) {
               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];
               optionGroupName = groupByFn(scope, locals) || '';
            if (!(optionGroup = optionGroups[optionGroupName])) {
              optionGroup = optionGroups[optionGroupName] = [];
              optionGroupNames.push(optionGroupName);
            }
            if (multiple) {
              selected = selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)) != undefined;
            } else {
              if (trackFn) {
                var modelCast = {};
                modelCast[valueName] = modelValue;
                selected = trackFn(scope, modelCast) === trackFn(scope, locals);
              } else {
                selected = modelValue === valueFn(scope, locals);
              }
              selectedSet = selectedSet || selected; // see if at least one item is selected
            }
            label = displayFn(scope, locals); // what will be seen by the user
            label = label === undefined ? '' : label; // doing displayFn(scope, locals) || '' overwrites zero values
            optionGroup.push({
              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),   // either the index into array or key from object
              label: label,
              selected: selected                   // determine if we should be selected
            });
          }
          if (!multiple) {
            if (nullOption || modelValue === null) {
              // insert null option if we have a placeholder, or the model is null
              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});
            } else if (!selectedSet) {
              // option could not be found, we have to insert the undefined item
              optionGroups[''].unshift({id:'?', label:'', selected:true});
            }
          }

          // Now we need to update the list of DOM nodes to match the optionGroups we computed above
          for (groupIndex = 0, groupLength = optionGroupNames.length;
               groupIndex < groupLength;
               groupIndex++) {
            // current option group name or '' if no group
            optionGroupName = optionGroupNames[groupIndex];

            // list of options for that group. (first item has the parent)
            optionGroup = optionGroups[optionGroupName];

            if (optionGroupsCache.length <= groupIndex) {
              // we need to grow the optionGroups
              existingParent = {
                element: optGroupTemplate.clone().attr('label', optionGroupName),
                label: optionGroup.label
              };
              existingOptions = [existingParent];
              optionGroupsCache.push(existingOptions);
              selectElement.append(existingParent.element);
            } else {
              existingOptions = optionGroupsCache[groupIndex];
              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

              // update the OPTGROUP label if not the same.
              if (existingParent.label != optionGroupName) {
                existingParent.element.attr('label', existingParent.label = optionGroupName);
              }
            }

            lastElement = null;  // start at the beginning
            for(index = 0, length = optionGroup.length; index < length; index++) {
              option = optionGroup[index];
              if ((existingOption = existingOptions[index+1])) {
                // reuse elements
                lastElement = existingOption.element;
                if (existingOption.label !== option.label) {
                  lastElement.text(existingOption.label = option.label);
                }
                if (existingOption.id !== option.id) {
                  lastElement.val(existingOption.id = option.id);
                }
                // lastElement.prop('selected') provided by jQuery has side-effects
                if (lastElement[0].selected !== option.selected) {
                  lastElement.prop('selected', (existingOption.selected = option.selected));
                }
              } else {
                // grow elements

                // if it's a null option
                if (option.id === '' && nullOption) {
                  // put back the pre-compiled element
                  element = nullOption;
                } else {
                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                  // in this version of jQuery on some browser the .text() returns a string
                  // rather then the element.
                  (element = optionTemplate.clone())
                      .val(option.id)
                      .attr('selected', option.selected)
                      .text(option.label);
                }

                existingOptions.push(existingOption = {
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                });
                if (lastElement) {
                  lastElement.after(element);
                } else {
                  existingParent.element.append(element);
                }
                lastElement = element;
              }
            }
            // remove any excessive OPTIONs in a group
            index++; // increment since the existingOptions[0] is parent element not OPTION
            while(existingOptions.length > index) {
              existingOptions.pop().element.remove();
            }
          }
          // remove any excessive OPTGROUPs from select
          while(optionGroupsCache.length > groupIndex) {
            optionGroupsCache.pop()[0].element.remove();
          }
        }
      }
    }
  }
}];

var optionDirective = ['$interpolate', function($interpolate) {
  var nullSelectCtrl = {
    addOption: noop,
    removeOption: noop
  };

  return {
    restrict: 'E',
    priority: 100,
    compile: function(element, attr) {
      if (isUndefined(attr.value)) {
        var interpolateFn = $interpolate(element.text(), true);
        if (!interpolateFn) {
          attr.$set('value', element.text());
        }
      }

      return function (scope, element, attr) {
        var selectCtrlName = '$selectController',
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); // in case we are in optgroup

        if (selectCtrl && selectCtrl.databound) {
          // For some reason Opera defaults to true and if not overridden this messes up the repeater.
          // We don't want the view to drive the initialization of the model anyway.
          element.prop('selected', false);
        } else {
          selectCtrl = nullSelectCtrl;
        }

        if (interpolateFn) {
          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
            attr.$set('value', newVal);
            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
            selectCtrl.addOption(newVal);
          });
        } else {
          selectCtrl.addOption(attr.value);
        }

        element.on('$destroy', function() {
          selectCtrl.removeOption(attr.value);
        });
      };
    }
  }
}];

var styleDirective = valueFn({
  restrict: 'E',
  terminal: true
});

  //try to bind to jquery now so that one can write angular.element().read()
  //but we will rebind on bootstrap again.
  bindJQuery();

  publishExternalAPI(angular);

  jqLite(document).ready(function() {
    angularInit(document, bootstrap);
  });

})(window, document);
angular.element(document).find('head').prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}</style>');
},{}],23:[function(require,module,exports){
;(function (exports) {

//List from node-htmlparser
var singleTags = {
  area: 1,
  base: 1,
  basefont: 1,
  br: 1,
  col: 1,
  frame: 1,
  hr: 1,
  img: 1,
  input: 1,
  isindex: 1,
  link: 1,
  meta: 1,
  param: 1,
  embed: 1
};

var expr = {
  upperCaseChars: /([A-Z])/g,
  breakBetweenTags: /(<(\/?\w+).*?>)(?=<(?!\/\2))/gi,
  singleTag: (function() {
    var tags = [];
    for (var i in singleTags) {
      tags.push(i);
    }
    return new RegExp('<' + tags.join('|<'), 'i');
  })()
};

var uncanon = function(str, letter) {
  return '-' + letter.toLowerCase();
};

var HTMLEncode = function(text) { return text; }; // Noop

exports.stringifyElement = function stringifyElement(element) {
  var tagName = element.tagName.toLowerCase(),
      ret = {
        start: "<" + tagName,
        end:''
      },
      attributes = [],
      i,
      attribute = null;

  if (element.attributes.length) {
    ret.start += " ";
    for (i = 0; i<element.attributes.length; i++) {
      attribute = element.attributes.item(i);
      attributes.push(attribute.name + '="' +
                      HTMLEncode(attribute.nodeValue, true) + '"');
    }
  }
  ret.start += attributes.join(" ");

  if (singleTags[tagName]) {
    ret.start += " />";
    ret.end = '';
  } else {
    ret.start += ">";
    ret.end = "</" + tagName + ">";
  }

  return ret;
};

var rawTextElements = /SCRIPT|STYLE/i;

function stringifyDoctype (doctype) {
  if (doctype.ownerDocument && doctype.ownerDocument.fullDT) {
    return doctype.ownerDocument.fullDT;
  }

  var dt = '<!DOCTYPE ' + doctype.name;
  if (doctype.publicId) {
    // Public ID may never contain double quotes, so this is always safe.
    dt += ' PUBLIC "' + doctype.publicId + '" ';
  }
  if (!doctype.publicId && doctype.systemId) {
    dt += ' SYSTEM ';
  }
  if (doctype.systemId) {
    // System ID may contain double quotes OR single quotes, not never both.
    if (doctype.systemId.indexOf('"') > -1) {
      dt += "'" + doctype.systemId + "'";
    } else {
      dt += '"' + doctype.systemId + '"';
    }
  }
  dt += '>';
  return dt;
}

exports.makeHtmlGenerator = function makeHtmlGenerator(indentUnit, eol) {
  indentUnit = indentUnit || "";
  eol = eol || "";

  return function generateHtmlRecursive(node, rawText, curIndent) {
    var ret = "", parent, current, i, children;
    curIndent = curIndent || "";
    if (node) {
      if (node.nodeType &&
          node.nodeType === node.ENTITY_REFERENCE_NODE) {
        node = node.entity;
      }

      var childNodesRawText = rawText || rawTextElements.test(node.nodeName);
      
      switch (node.nodeType) {
        case node.ELEMENT_NODE:
          if (node.tagName === "TEMPLATE") {
            children = node.content.childNodes;
            childNodesRawText = true;
          } else {
            children = node.childNodes;
          }
          
          current = exports.stringifyElement(node);
          
          if (childNodesRawText) {
            ret += curIndent + current.start;
          } else {
            ret += curIndent + current.start;
          }
          
          if (node.nodeName === "HTML") ret += eol;

          if (children.length > 0) {
            if (children[0].nodeType !== node.TEXT_NODE) {
              ret += eol;
            }
            for (i=0; i<children.length; i++) {
              ret += generateHtmlRecursive(children[i], childNodesRawText, curIndent + indentUnit) || (i === 0 && children.length > 1 ? eol : "");
            }
            if (children[children.length - 1].nodeType !== node.TEXT_NODE || ret.charAt(ret.length - 1) === eol) {
              ret += curIndent;
            }
            ret += current.end + eol;
          } else {
            ret += ((rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '') + current.end + eol;
          }
          
          if (node.nodeName === "HEAD" || node.nodeName === "BODY") ret += eol;
          
          break;
        case node.TEXT_NODE:
          // Skip pure whitespace nodes if we're indenting
          if (!indentUnit || !/^[\s\n]*$/.test(node.nodeValue)) {
            ret += (rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '';
          }
          break;
        case node.COMMENT_NODE:
          ret += curIndent + '<!--' + node.nodeValue + '-->' + eol;
          break;
        case node.DOCUMENT_NODE:
          for (i=0; i<node.childNodes.length; i++) {
            ret += generateHtmlRecursive(node.childNodes[i], childNodesRawText, curIndent);
          }
          break;
        case node.DOCUMENT_TYPE_NODE:
          ret += stringifyDoctype(node);
          ret += eol; // Two newlines after doctype
        break;
      }
    }
    return ret;
  };
};

exports.domToHtml = function(dom, noformat, raw) {
  var htmlGenerator = exports.makeHtmlGenerator(noformat ? "" : "  ",
                                                noformat ? "" : "\n");
  if (dom.toArray) {
    // node list
    dom = dom.toArray();
  }
  if (typeof dom.length !== 'undefined') {
    var ret = "";
    for (var i=0,len=dom.length; i<len; i++) {
      ret += htmlGenerator(dom[i], raw);
    }
    return ret;
  } else {
    // single node
    return htmlGenerator(dom, raw);
  }
};


})(typeof exports === "object" ? exports : dominatrix = {});
},{}],24:[function(require,module,exports){
/**
 * Operative
 * ---
 * Operative is a small JS utility for seamlessly creating Web Worker scripts.
 * ---
 * @author James Padolsey http://james.padolsey.com
 * @repo http://github.com/padolsey/operative
 * @version 0.2.1
 * @license MIT
 */
(function() {

	if (typeof window == 'undefined' && self.importScripts) {
		// I'm a worker! Run the boiler-script:
		// (Operative itself is called in IE10 as a worker,
		//  to avoid SecurityErrors)
		workerBoilerScript();
		return;
	}

	var slice = [].slice;
	var hasOwn = {}.hasOwnProperty;

	var scripts = document.getElementsByTagName('script');
	var opScript = scripts[scripts.length - 1];
	var opScriptURL = /operative/.test(opScript.src) && opScript.src;

	// Default base URL (to be prepended to relative dependency URLs)
	// is current page's parent dir:
	var baseURL = (
		location.protocol + '//' +
		location.hostname +
		(location.port?':'+location.port:'') +
		location.pathname
	).replace(/[^\/]+$/, '');

	var URL = window.URL || window.webkitURL;
	var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

	var workerViaBlobSupport = (function() {
		try {
			new Worker(makeBlobURI(';'));
		} catch(e) {
			return false;
		}
		return true;
	}());

	/**
	 * Provide Object.create shim
	 */
	var objCreate = Object.create || function(o) {
		function F() {}
		F.prototype = o;
		return new F();
	};

	function makeBlobURI(script) {
		var blob;

		try {
			blob = new Blob([script], { type: 'text/javascript' });
		} catch (e) { 
			blob = new BlobBuilder();
			blob.append(script);
			blob = blob.getBlob();
		}

		return URL.createObjectURL(blob);
	}

	// Indicates whether operatives will run within workers:
	operative.hasWorkerSupport = !!window.Worker;

	operative.Promise = window.Promise;

	// Expose:
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = operative;
	} else {
		window.operative = operative;
	}
	

	operative.setSelfURL = function(url) {
		opScriptURL = url;
	};

	operative.setBaseURL = function(base) {
		baseURL = base;
	};

	operative.getBaseURL = function() {
		return baseURL;
	};

	/**
	 * Operative: Exposed Operative Constructor
	 * @param {Object} module Object containing methods/properties
	 */
	function Operative(module, dependencies) {

		var _self = this;

		module.get = module.get || function(prop) {
			return this[prop];
		};

		module.set = module.set || function(prop, value) {
			return this[prop] = value;
		};

		this._curToken = 0;
		this._queue = [];

		this.isDestroyed = false;
		this.isContextReady = false;

		this.module = module;
		this.dependencies = dependencies || [];

		this.dataProperties = {};
		this.api = {};
		this.callbacks = {};
		this.deferreds = {};

		this._fixDependencyURLs();
		this._setup();

		for (var methodName in module) {
			if (hasOwn.call(module, methodName)) {
				this._createExposedMethod(methodName);
			}
		}

		this.api.__operative__ = this;

		// Provide the instance's destroy method on the exposed API:
		this.api.destroy = function() {
			return _self.destroy();
		};

	}

	Operative.prototype = {

		_marshal: function(v) {
			return v;
		},

		_demarshal: function(v) {
			return v;
		},

		_enqueue: function(fn) {
			this._queue.push(fn);
		},

		_fixDependencyURLs: function() {
			var deps = this.dependencies;
			for (var i = 0, l = deps.length; i < l; ++i) {
				var dep = deps[i];
				if (!/\/\//.test(dep)) {
					deps[i] = dep.replace(/^\/?/, baseURL);
				}
			}
		},

		_dequeueAll: function() {
			for (var i = 0, l = this._queue.length; i < l; ++i) {
				this._queue[i].call(this);
			}
			this._queue = [];
		},

		_buildContextScript: function(boilerScript) {

			var script = [];
			var module = this.module;
			var dataProperties = this.dataProperties;
			var property;

			for (var i in module) {
				property = module[i];
				if (typeof property == 'function') {
					script.push('   self["' + i.replace(/"/g, '\\"') + '"] = ' + property.toString() + ';');
				} else {
					dataProperties[i] = property;
				}
			}

			return script.join('\n') + (
				boilerScript ? '\n(' + boilerScript.toString() + '());' : ''
			);

		},

		_createExposedMethod: function(methodName) {

			var self = this;

			this.api[methodName] = function() {

				if (self.isDestroyed) {
					throw new Error('Operative: Cannot run method. Operative has already been destroyed');
				}

				var token = ++self._curToken;
				var args = slice.call(arguments);
				var cb = typeof args[args.length - 1] == 'function' && args.pop();

				if (!cb && !operative.Promise) {
					throw new Error(
						'Operative: No callback has been passed. Assumed that you want a promise. ' +
						'But `operative.Promise` is null. Please provide Promise polyfill/lib.'
					);
				}

				if (cb) {

					self.callbacks[token] = cb;

					// Ensure either context runs the method async:
					setTimeout(function() {
						runMethod();
					}, 1);

				} else if (operative.Promise) {

					// No Callback -- Promise used:

					return new operative.Promise(function(deferred) {
						deferred.fulfil = deferred.fulfill;
						self.deferreds[token] = deferred;
						runMethod();
					});

				}

				function runMethod() {
					if (self.isContextReady) {
						self._runMethod(methodName, token, args);
					} else {
						self._enqueue(runMethod);
					}
				}

			};

		},

		destroy: function() {
			this.isDestroyed = true;
		}
	};


	/**
	 * Operative Worker
	 */
	Operative.Worker = function Worker(module) {
		this._msgQueue = [];
		Operative.apply(this, arguments);
	};

	var WorkerProto = Operative.Worker.prototype = objCreate(Operative.prototype);

	WorkerProto._onWorkerMessage = function(e) {
		var data = e.data;

		if (typeof data === 'string' && data.indexOf('pingback') === 0) {
			if (data === 'pingback:structuredCloningSupport=NO') {
				// No structuredCloningSupport support (marshal JSON from now on):
				this._marshal = function(o) { return JSON.stringify(o); };
				this._demarshal = function(o) { return JSON.parse(o); };
			}

			this.isContextReady = true;
			this._postMessage({
				definitions: this.dataProperties
			});
			this._dequeueAll();
			return;

		}

		data = this._demarshal(data);

		switch (data.cmd) {
			case 'console':
				window.console && window.console[data.method].apply(window.console, data.args);
				break;
			case 'result':

				var callback = this.callbacks[data.token];
				var deferred = this.deferreds[data.token];

				delete this.callbacks[data.token];
				delete this.deferreds[data.token];

				var deferredAction = data.result && data.result.isDeferred && data.result.action;

				if (deferred && deferredAction) {
					deferred[deferredAction](data.result.args[0]);
				} else if (callback) {
					callback.apply(this, data.result.args);
				}

				break;
		}
	};

	WorkerProto._setup = function() {
		var self = this;

		var worker;
		var script = this._buildContextScript(
			// The script is not included if we're Eval'ing this file directly:
			workerViaBlobSupport ? workerBoilerScript : ''
		);

		if (this.dependencies.length) {
			script = 'importScripts("' + this.dependencies.join('", "') + '");\n' + script;
		}

		if (workerViaBlobSupport) {
			worker = this.worker = new Worker( makeBlobURI(script) );
		}  else {
			if (!opScriptURL) {
				throw new Error('Operaritve: No operative.js URL available. Please set via operative.setSelfURL(...)');
			}
			worker = this.worker = new Worker( opScriptURL );
			// Marshal-agnostic initial message is boiler-code:
			// (We don't yet know if structured-cloning is supported so we send a string)
			worker.postMessage('EVAL|' + script);
		}

		worker.postMessage(['PING']); // Initial PING

		worker.addEventListener('message', function(e) {
			self._onWorkerMessage(e);
		});
	};

	WorkerProto._postMessage = function(msg) {
		return this.worker.postMessage(this._marshal(msg));
	};

	WorkerProto._runMethod = function(methodName, token, args) {
		this._postMessage({
			method: methodName,
			args: args,
			token: token
		});
	};

	WorkerProto.destroy = function() {
		this.worker.terminate();
		Operative.prototype.destroy.call(this);
	};


	/**
	 * Operative IFrame
	 */
	Operative.Iframe = function Iframe(module) {
		Operative.apply(this, arguments);
	};

	var IframeProto = Operative.Iframe.prototype = objCreate(Operative.prototype);

	var _loadedMethodNameI = 0;

	IframeProto._setup = function() {

		var self = this;
		var loadedMethodName = '__operativeIFrameLoaded' + ++_loadedMethodNameI;

		this.module.isWorker = false;

		var iframe = this.iframe = document.body.appendChild(
			document.createElement('iframe')
		);

		iframe.style.display = 'none';

		var iWin = this.iframeWindow = iframe.contentWindow;
		var iDoc = iWin.document;

		// Cross browser (tested in IE8,9) way to call method from within
		// IFRAME after all <Script>s have loaded:
		window[loadedMethodName] = function() {

			window[loadedMethodName] = null;

			var script = iDoc.createElement('script');
			var js = self._buildContextScript(iframeBoilerScript);

			if (script.text !== void 0) {
				script.text = js;
			} else {
				script.innerHTML = js;
			}

			iDoc.documentElement.appendChild(script);

			for (var i in self.dataProperties) {
				iWin[i] = self.dataProperties[i];
			}

			self.isContextReady = true;
			self._dequeueAll();

		};

		iDoc.open();
		if (this.dependencies.length) {
			iDoc.write(
				'<script src="' + this.dependencies.join('"></script><script src="') + '"></script>'
			);
		}
		// Place <script> at bottom to tell parent-page when dependencies are loaded:
		iDoc.write('<script>window.top.' + loadedMethodName + '();</script>');
		iDoc.close();

	};

	IframeProto._runMethod = function(methodName, token, args) {
		var self = this;
		var callback = this.callbacks[token];
		var deferred = this.deferreds[token];
		delete this.callbacks[token];
		delete this.deferreds[token];
		this.iframeWindow.__run__(methodName, args, function() {
			var cb = callback;
			if (cb) {
				callback = null;
				cb.apply(self, arguments);
			} else {
				throw new Error('Operative: You have already returned.');
			}
		}, deferred);
	};

	IframeProto.destroy = function() {
		this.iframe.parentNode.removeChild(this.iframe);
		Operative.prototype.destroy.call(this);
	};

	operative.Operative = Operative;

	/**
	 * Exposed operative factory
	 */
	function operative(module, dependencies) {

		var OperativeContext = operative.hasWorkerSupport ?
			Operative.Worker : Operative.Iframe;

		if (typeof module == 'function') {
			// Allow a single function to be passed.
			var o = new OperativeContext({ main: module }, dependencies);
			return function() {
				return o.api.main.apply(o, arguments);
			};
		}

		return new OperativeContext(module, dependencies).api;

	}

/**
 * The boilerplate for the Iframe Context
 * NOTE:
 *  this'll be executed within an iframe, not here.
 *  Indented @ Zero to make nicer debug code within worker
 */
function iframeBoilerScript() {

	// Called from parent-window:
	window.__run__ = function(methodName, args, cb, deferred) {

		var isAsync = false;
		var isDeferred = false;

		window.async = function() {
			isAsync = true;
			return cb;
		};

		window.deferred = function() {
			isDeferred = true;
			return deferred;
		};

		if (cb) {
			args.push(cb);
		}

		var result = window[methodName].apply(window, args);

		window.async = function() {
			throw new Error('Operative: async() called at odd time');
		};

		window.deferred = function() {
			throw new Error('Operative: deferred() called at odd time');
		};


		if (!isDeferred && !isAsync && result !== void 0) {
			// Deprecated direct-returning as of 0.2.0
			cb(result);
		}
	};
}

/**
 * The boilerplate for the Worker Blob
 * NOTE:
 *  this'll be executed within an iframe, not here.
 *  Indented @ Zero to make nicer debug code within worker
 */
function workerBoilerScript() {

	var postMessage = self.postMessage;
	var structuredCloningSupport = null;

	self.console = {};
	self.isWorker = true;

	// Provide basic console interface:
	['log', 'debug', 'error', 'info', 'warn', 'time', 'timeEnd'].forEach(function(meth) {
		self.console[meth] = function() {
			postMessage({
				cmd: 'console',
				method: meth,
				args: [].slice.call(arguments)
			});
		};
	});

	self.addEventListener('message', function(e) {

		var data = e.data;

		if (typeof data == 'string' && data.indexOf('EVAL|') === 0) {
			eval(data.substring(5));
			return;
		}

		if (structuredCloningSupport == null) {

			// e.data of ['PING'] (An array) indicates transferrableObjSupport
			// e.data of '"PING"' (A string) indicates no support (Array has been serialized)
			structuredCloningSupport = e.data[0] === 'PING';

			// Pingback to parent page:
			self.postMessage(
				structuredCloningSupport ?
					'pingback:structuredCloningSupport=YES' :
					'pingback:structuredCloningSupport=NO'
			);

			if (!structuredCloningSupport) {
				postMessage = function(msg) {
					// Marshal before sending
					return self.postMessage(JSON.stringify(msg));
				};
			}

			return;
		}

		if (!structuredCloningSupport) {
			// Demarshal:
			data = JSON.parse(data);
		}

		var defs = data.definitions;
		var isDeferred = false;
		var isAsync = false;
		var args = data.args;

		if (defs) {
			// Initial definitions:
			for (var i in defs) {
				self[i] = defs[i];
			}
			return;
		}

		args.push(function() {
			// Callback function to be passed to operative method
			returnResult({
				args: [].slice.call(arguments)
			});
		});

		self.async = function() { // Async deprecated as of 0.2.0
			isAsync = true;
			return function() { returnResult({ args: [].slice.call(arguments) }); };
		};

		self.deferred = function() {
			isDeferred = true;
			var def = {};
			function fulfill(r) {
				returnResult({
					isDeferred: true,
					action: 'fulfill',
					args: [r]
				});
				return def;
			}
			function reject(r) {
				returnResult({
					isDeferred: true,
					action: 'reject',
					args: [r]
				});
			}
			def.fulfil = def.fulfill = fulfill;
			def.reject = reject;
			return def;
		};

		// Call actual operative method:
		var result = self[data.method].apply(self, args);

		if (!isDeferred && !isAsync && result !== void 0) {
			// Deprecated direct-returning as of 0.2.0
			returnResult({
				args: [result]
			});
		}

		self.deferred = function() {
			throw new Error('Operative: deferred() called at odd time');
		};

		self.async = function() { // Async deprecated as of 0.2.0
			throw new Error('Operative: async() called at odd time');
		};

		function returnResult(res) {
			postMessage({
				cmd: 'result',
				token: data.token,
				result: res
			});
			// Override with error-thrower if we've already returned:
			returnResult = function() {
				throw new Error('Operative: You have already returned.');
			};
		}
	});
}

}());
},{}],25:[function(require,module,exports){
(function(){
function e() {
  return function() {
  }
}
function m(a) {
  return function(b) {
    this[a] = b
  }
}
function aa(a) {
  return function() {
    return this[a]
  }
}
function ba(a) {
  return function() {
    return a
  }
}
var p, ca = ca || {}, q = this;
function da(a) {
  a = a.split(".");
  for(var b = q, c;c = a.shift();) {
    if(null != b[c]) {
      b = b[c]
    }else {
      return null
    }
  }
  return b
}
function ea() {
}
function fa(a) {
  var b = typeof a;
  if("object" == b) {
    if(a) {
      if(a instanceof Array) {
        return"array"
      }
      if(a instanceof Object) {
        return b
      }
      var c = Object.prototype.toString.call(a);
      if("[object Window]" == c) {
        return"object"
      }
      if("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return"array"
      }
      if("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return"function"
      }
    }else {
      return"null"
    }
  }else {
    if("function" == b && "undefined" == typeof a.call) {
      return"object"
    }
  }
  return b
}
function s(a) {
  return"array" == fa(a)
}
function ga(a) {
  var b = fa(a);
  return"array" == b || "object" == b && "number" == typeof a.length
}
function u(a) {
  return"string" == typeof a
}
function ha(a) {
  return"function" == fa(a)
}
function v(a) {
  return a[ia] || (a[ia] = ++ja)
}
var ia = "closure_uid_" + (1E9 * Math.random() >>> 0), ja = 0;
function ka(a, b, c) {
  return a.call.apply(a.bind, arguments)
}
function la(a, b, c) {
  if(!a) {
    throw Error();
  }
  if(2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c)
    }
  }
  return function() {
    return a.apply(b, arguments)
  }
}
function w(a, b, c) {
  w = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ka : la;
  return w.apply(null, arguments)
}
var x = Date.now || function() {
  return+new Date
};
function y(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.ra = b.prototype;
  a.prototype = new c
}
;function ma(a, b) {
  for(var c = 1;c < arguments.length;c++) {
    var d = String(arguments[c]).replace(/\$/g, "$$$$");
    a = a.replace(/\%s/, d)
  }
  return a
}
function na(a) {
  if(!oa.test(a)) {
    return a
  }
  -1 != a.indexOf("&") && (a = a.replace(pa, "&amp;"));
  -1 != a.indexOf("<") && (a = a.replace(qa, "&lt;"));
  -1 != a.indexOf(">") && (a = a.replace(ra, "&gt;"));
  -1 != a.indexOf('"') && (a = a.replace(sa, "&quot;"));
  return a
}
var pa = /&/g, qa = /</g, ra = />/g, sa = /\"/g, oa = /[&<>\"]/;
var z, ta, ua, va;
function wa() {
  return q.navigator ? q.navigator.userAgent : null
}
va = ua = ta = z = !1;
var xa;
if(xa = wa()) {
  var ya = q.navigator;
  z = 0 == xa.indexOf("Opera");
  ta = !z && -1 != xa.indexOf("MSIE");
  ua = !z && -1 != xa.indexOf("WebKit");
  va = !z && !ua && "Gecko" == ya.product
}
var za = z, A = ta, Aa = va, B = ua, Ba = q.navigator, Ca = -1 != (Ba && Ba.platform || "").indexOf("Mac");
function Da() {
  var a = q.document;
  return a ? a.documentMode : void 0
}
var Ea;
a: {
  var Fa = "", Ga;
  if(za && q.opera) {
    var Ha = q.opera.version, Fa = "function" == typeof Ha ? Ha() : Ha
  }else {
    if(Aa ? Ga = /rv\:([^\);]+)(\)|;)/ : A ? Ga = /MSIE\s+([^\);]+)(\)|;)/ : B && (Ga = /WebKit\/(\S+)/), Ga) {
      var Ia = Ga.exec(wa()), Fa = Ia ? Ia[1] : ""
    }
  }
  if(A) {
    var Ja = Da();
    if(Ja > parseFloat(Fa)) {
      Ea = String(Ja);
      break a
    }
  }
  Ea = Fa
}
var Ka = {};
function C(a) {
  var b;
  if(!(b = Ka[a])) {
    b = 0;
    for(var c = String(Ea).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), d = String(a).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), f = Math.max(c.length, d.length), g = 0;0 == b && g < f;g++) {
      var h = c[g] || "", n = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), t = RegExp("(\\d*)(\\D*)", "g");
      do {
        var l = k.exec(h) || ["", "", ""], r = t.exec(n) || ["", "", ""];
        if(0 == l[0].length && 0 == r[0].length) {
          break
        }
        b = ((0 == l[1].length ? 0 : parseInt(l[1], 10)) < (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? -1 : (0 == l[1].length ? 0 : parseInt(l[1], 10)) > (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? 1 : 0) || ((0 == l[2].length) < (0 == r[2].length) ? -1 : (0 == l[2].length) > (0 == r[2].length) ? 1 : 0) || (l[2] < r[2] ? -1 : l[2] > r[2] ? 1 : 0)
      }while(0 == b)
    }
    b = Ka[a] = 0 <= b
  }
  return b
}
var La = q.document, Ma = La && A ? Da() || ("CSS1Compat" == La.compatMode ? parseInt(Ea, 10) : 5) : void 0;
function Na(a) {
  Error.captureStackTrace ? Error.captureStackTrace(this, Na) : this.stack = Error().stack || "";
  a && (this.message = String(a))
}
y(Na, Error);
Na.prototype.name = "CustomError";
function Oa(a, b) {
  b.unshift(a);
  Na.call(this, ma.apply(null, b));
  b.shift();
  this.Jc = a
}
y(Oa, Na);
Oa.prototype.name = "AssertionError";
function Pa(a, b) {
  throw new Oa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
}
;var Qa = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
function Ra(a) {
  var b = Sa, c;
  for(c in b) {
    a.call(void 0, b[c], c, b)
  }
}
function Ta(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = a[d]
  }
  return b
}
function Ua(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = d
  }
  return b
}
var Va = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Wa(a, b) {
  for(var c, d, f = 1;f < arguments.length;f++) {
    d = arguments[f];
    for(c in d) {
      a[c] = d[c]
    }
    for(var g = 0;g < Va.length;g++) {
      c = Va[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c])
    }
  }
}
;var D = Array.prototype, Xa = D.indexOf ? function(a, b, c) {
  return D.indexOf.call(a, b, c)
} : function(a, b, c) {
  c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
  if(u(a)) {
    return u(b) && 1 == b.length ? a.indexOf(b, c) : -1
  }
  for(;c < a.length;c++) {
    if(c in a && a[c] === b) {
      return c
    }
  }
  return-1
}, Ya = D.forEach ? function(a, b, c) {
  D.forEach.call(a, b, c)
} : function(a, b, c) {
  for(var d = a.length, f = u(a) ? a.split("") : a, g = 0;g < d;g++) {
    g in f && b.call(c, f[g], g, a)
  }
};
function Za(a) {
  return D.concat.apply(D, arguments)
}
function $a(a) {
  var b = a.length;
  if(0 < b) {
    for(var c = Array(b), d = 0;d < b;d++) {
      c[d] = a[d]
    }
    return c
  }
  return[]
}
;function ab(a) {
  if("function" == typeof a.N) {
    return a.N()
  }
  if(u(a)) {
    return a.split("")
  }
  if(ga(a)) {
    for(var b = [], c = a.length, d = 0;d < c;d++) {
      b.push(a[d])
    }
    return b
  }
  return Ta(a)
}
function E(a, b, c) {
  if("function" == typeof a.forEach) {
    a.forEach(b, c)
  }else {
    if(ga(a) || u(a)) {
      Ya(a, b, c)
    }else {
      var d;
      if("function" == typeof a.ka) {
        d = a.ka()
      }else {
        if("function" != typeof a.N) {
          if(ga(a) || u(a)) {
            d = [];
            for(var f = a.length, g = 0;g < f;g++) {
              d.push(g)
            }
          }else {
            d = Ua(a)
          }
        }else {
          d = void 0
        }
      }
      for(var f = ab(a), g = f.length, h = 0;h < g;h++) {
        b.call(c, f[h], d && d[h], a)
      }
    }
  }
}
;function bb(a, b) {
  this.O = {};
  this.j = [];
  var c = arguments.length;
  if(1 < c) {
    if(c % 2) {
      throw Error("Uneven number of arguments");
    }
    for(var d = 0;d < c;d += 2) {
      this.set(arguments[d], arguments[d + 1])
    }
  }else {
    if(a) {
      a instanceof bb ? (c = a.ka(), d = a.N()) : (c = Ua(a), d = Ta(a));
      for(var f = 0;f < c.length;f++) {
        this.set(c[f], d[f])
      }
    }
  }
}
p = bb.prototype;
p.f = 0;
p.bc = 0;
p.N = function() {
  cb(this);
  for(var a = [], b = 0;b < this.j.length;b++) {
    a.push(this.O[this.j[b]])
  }
  return a
};
p.ka = function() {
  cb(this);
  return this.j.concat()
};
p.ia = function(a) {
  return db(this.O, a)
};
p.remove = function(a) {
  return db(this.O, a) ? (delete this.O[a], this.f--, this.bc++, this.j.length > 2 * this.f && cb(this), !0) : !1
};
function cb(a) {
  if(a.f != a.j.length) {
    for(var b = 0, c = 0;b < a.j.length;) {
      var d = a.j[b];
      db(a.O, d) && (a.j[c++] = d);
      b++
    }
    a.j.length = c
  }
  if(a.f != a.j.length) {
    for(var f = {}, c = b = 0;b < a.j.length;) {
      d = a.j[b], db(f, d) || (a.j[c++] = d, f[d] = 1), b++
    }
    a.j.length = c
  }
}
p.get = function(a, b) {
  return db(this.O, a) ? this.O[a] : b
};
p.set = function(a, b) {
  db(this.O, a) || (this.f++, this.j.push(a), this.bc++);
  this.O[a] = b
};
p.n = function() {
  return new bb(this)
};
function db(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b)
}
;function F(a, b) {
  var c;
  if(a instanceof F) {
    this.D = void 0 !== b ? b : a.D, eb(this, a.qa), c = a.ab, H(this), this.ab = c, fb(this, a.ja), gb(this, a.Ba), hb(this, a.H), ib(this, a.R.n()), c = a.Ma, H(this), this.Ma = c
  }else {
    if(a && (c = String(a).match(Qa))) {
      this.D = !!b;
      eb(this, c[1] || "", !0);
      var d = c[2] || "";
      H(this);
      this.ab = d ? decodeURIComponent(d) : "";
      fb(this, c[3] || "", !0);
      gb(this, c[4]);
      hb(this, c[5] || "", !0);
      ib(this, c[6] || "", !0);
      c = c[7] || "";
      H(this);
      this.Ma = c ? decodeURIComponent(c) : ""
    }else {
      this.D = !!b, this.R = new jb(null, 0, this.D)
    }
  }
}
p = F.prototype;
p.qa = "";
p.ab = "";
p.ja = "";
p.Ba = null;
p.H = "";
p.Ma = "";
p.mc = !1;
p.D = !1;
p.toString = function() {
  var a = [], b = this.qa;
  b && a.push(kb(b, lb), ":");
  if(b = this.ja) {
    a.push("//");
    var c = this.ab;
    c && a.push(kb(c, lb), "@");
    a.push(encodeURIComponent(String(b)));
    b = this.Ba;
    null != b && a.push(":", String(b))
  }
  if(b = this.H) {
    this.ja && "/" != b.charAt(0) && a.push("/"), a.push(kb(b, "/" == b.charAt(0) ? mb : nb))
  }
  (b = this.R.toString()) && a.push("?", b);
  (b = this.Ma) && a.push("#", kb(b, ob));
  return a.join("")
};
p.n = function() {
  return new F(this)
};
function eb(a, b, c) {
  H(a);
  a.qa = c ? b ? decodeURIComponent(b) : "" : b;
  a.qa && (a.qa = a.qa.replace(/:$/, ""))
}
function fb(a, b, c) {
  H(a);
  a.ja = c ? b ? decodeURIComponent(b) : "" : b
}
function gb(a, b) {
  H(a);
  if(b) {
    b = Number(b);
    if(isNaN(b) || 0 > b) {
      throw Error("Bad port number " + b);
    }
    a.Ba = b
  }else {
    a.Ba = null
  }
}
function hb(a, b, c) {
  H(a);
  a.H = c ? b ? decodeURIComponent(b) : "" : b
}
function ib(a, b, c) {
  H(a);
  b instanceof jb ? (a.R = b, a.R.qb(a.D)) : (c || (b = kb(b, pb)), a.R = new jb(b, 0, a.D))
}
function I(a, b, c) {
  H(a);
  a.R.set(b, c)
}
function qb(a, b, c) {
  H(a);
  s(c) || (c = [String(c)]);
  rb(a.R, b, c)
}
function J(a) {
  H(a);
  I(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ x()).toString(36));
  return a
}
function H(a) {
  if(a.mc) {
    throw Error("Tried to modify a read-only Uri");
  }
}
p.qb = function(a) {
  this.D = a;
  this.R && this.R.qb(a);
  return this
};
function sb(a, b, c, d) {
  var f = new F(null, void 0);
  a && eb(f, a);
  b && fb(f, b);
  c && gb(f, c);
  d && hb(f, d);
  return f
}
function kb(a, b) {
  return u(a) ? encodeURI(a).replace(b, tb) : null
}
function tb(a) {
  a = a.charCodeAt(0);
  return"%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16)
}
var lb = /[#\/\?@]/g, nb = /[\#\?:]/g, mb = /[\#\?]/g, pb = /[\#\?@]/g, ob = /#/g;
function jb(a, b, c) {
  this.C = a || null;
  this.D = !!c
}
function K(a) {
  if(!a.i && (a.i = new bb, a.f = 0, a.C)) {
    for(var b = a.C.split("&"), c = 0;c < b.length;c++) {
      var d = b[c].indexOf("="), f = null, g = null;
      0 <= d ? (f = b[c].substring(0, d), g = b[c].substring(d + 1)) : f = b[c];
      f = decodeURIComponent(f.replace(/\+/g, " "));
      f = L(a, f);
      a.add(f, g ? decodeURIComponent(g.replace(/\+/g, " ")) : "")
    }
  }
}
p = jb.prototype;
p.i = null;
p.f = null;
p.add = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  var c = this.i.get(a);
  c || this.i.set(a, c = []);
  c.push(b);
  this.f++;
  return this
};
p.remove = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a) ? (this.C = null, this.f -= this.i.get(a).length, this.i.remove(a)) : !1
};
p.ia = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a)
};
p.ka = function() {
  K(this);
  for(var a = this.i.N(), b = this.i.ka(), c = [], d = 0;d < b.length;d++) {
    for(var f = a[d], g = 0;g < f.length;g++) {
      c.push(b[d])
    }
  }
  return c
};
p.N = function(a) {
  K(this);
  var b = [];
  if(a) {
    this.ia(a) && (b = Za(b, this.i.get(L(this, a))))
  }else {
    a = this.i.N();
    for(var c = 0;c < a.length;c++) {
      b = Za(b, a[c])
    }
  }
  return b
};
p.set = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  this.ia(a) && (this.f -= this.i.get(a).length);
  this.i.set(a, [b]);
  this.f++;
  return this
};
p.get = function(a, b) {
  var c = a ? this.N(a) : [];
  return 0 < c.length ? String(c[0]) : b
};
function rb(a, b, c) {
  a.remove(b);
  0 < c.length && (a.C = null, a.i.set(L(a, b), $a(c)), a.f += c.length)
}
p.toString = function() {
  if(this.C) {
    return this.C
  }
  if(!this.i) {
    return""
  }
  for(var a = [], b = this.i.ka(), c = 0;c < b.length;c++) {
    for(var d = b[c], f = encodeURIComponent(String(d)), d = this.N(d), g = 0;g < d.length;g++) {
      var h = f;
      "" !== d[g] && (h += "=" + encodeURIComponent(String(d[g])));
      a.push(h)
    }
  }
  return this.C = a.join("&")
};
p.n = function() {
  var a = new jb;
  a.C = this.C;
  this.i && (a.i = this.i.n(), a.f = this.f);
  return a
};
function L(a, b) {
  var c = String(b);
  a.D && (c = c.toLowerCase());
  return c
}
p.qb = function(a) {
  a && !this.D && (K(this), this.C = null, E(this.i, function(a, c) {
    var d = c.toLowerCase();
    c != d && (this.remove(c), rb(this, d, a))
  }, this));
  this.D = a
};
function ub() {
}
ub.prototype.Ga = null;
var vb;
function wb() {
}
y(wb, ub);
function xb(a) {
  return(a = yb(a)) ? new ActiveXObject(a) : new XMLHttpRequest
}
function zb(a) {
  var b = {};
  yb(a) && (b[0] = !0, b[1] = !0);
  return b
}
function yb(a) {
  if(!a.Gb && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
    for(var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0;c < b.length;c++) {
      var d = b[c];
      try {
        return new ActiveXObject(d), a.Gb = d
      }catch(f) {
      }
    }
    throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
  }
  return a.Gb
}
vb = new wb;
function M() {
  0 != Ab && (this.Gc = Error().stack, Bb[v(this)] = this)
}
var Ab = 0, Bb = {};
M.prototype.yb = !1;
M.prototype.Ia = function() {
  if(!this.yb && (this.yb = !0, this.u(), 0 != Ab)) {
    var a = v(this);
    delete Bb[a]
  }
};
M.prototype.u = function() {
  if(this.Nb) {
    for(;this.Nb.length;) {
      this.Nb.shift()()
    }
  }
};
function N(a, b) {
  this.type = a;
  this.currentTarget = this.target = b
}
p = N.prototype;
p.u = e();
p.Ia = e();
p.na = !1;
p.defaultPrevented = !1;
p.Wa = !0;
p.preventDefault = function() {
  this.defaultPrevented = !0;
  this.Wa = !1
};
var Cb = 0;
function Db() {
}
p = Db.prototype;
p.key = 0;
p.ea = !1;
p.Ha = !1;
p.Oa = function(a, b, c, d, f, g) {
  if(ha(a)) {
    this.Ib = !0
  }else {
    if(a && a.handleEvent && ha(a.handleEvent)) {
      this.Ib = !1
    }else {
      throw Error("Invalid listener argument");
    }
  }
  this.W = a;
  this.Ub = b;
  this.src = c;
  this.type = d;
  this.capture = !!f;
  this.lb = g;
  this.Ha = !1;
  this.key = ++Cb;
  this.ea = !1
};
p.handleEvent = function(a) {
  return this.Ib ? this.W.call(this.lb || this.src, a) : this.W.handleEvent.call(this.W, a)
};
var Eb = !A || A && 9 <= Ma, Fb = A && !C("9");
!B || C("528");
Aa && C("1.9b") || A && C("8") || za && C("9.5") || B && C("528");
Aa && !C("8") || A && C("9");
function Gb(a) {
  Gb[" "](a);
  return a
}
Gb[" "] = ea;
function Hb(a, b) {
  a && this.Oa(a, b)
}
y(Hb, N);
p = Hb.prototype;
p.target = null;
p.relatedTarget = null;
p.offsetX = 0;
p.offsetY = 0;
p.clientX = 0;
p.clientY = 0;
p.screenX = 0;
p.screenY = 0;
p.button = 0;
p.keyCode = 0;
p.charCode = 0;
p.ctrlKey = !1;
p.altKey = !1;
p.shiftKey = !1;
p.metaKey = !1;
p.yc = !1;
p.zb = null;
p.Oa = function(a, b) {
  var c = this.type = a.type;
  N.call(this, c);
  this.target = a.target || a.srcElement;
  this.currentTarget = b;
  var d = a.relatedTarget;
  if(d) {
    if(Aa) {
      var f;
      a: {
        try {
          Gb(d.nodeName);
          f = !0;
          break a
        }catch(g) {
        }
        f = !1
      }
      f || (d = null)
    }
  }else {
    "mouseover" == c ? d = a.fromElement : "mouseout" == c && (d = a.toElement)
  }
  this.relatedTarget = d;
  this.offsetX = B || void 0 !== a.offsetX ? a.offsetX : a.layerX;
  this.offsetY = B || void 0 !== a.offsetY ? a.offsetY : a.layerY;
  this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX;
  this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY;
  this.screenX = a.screenX || 0;
  this.screenY = a.screenY || 0;
  this.button = a.button;
  this.keyCode = a.keyCode || 0;
  this.charCode = a.charCode || ("keypress" == c ? a.keyCode : 0);
  this.ctrlKey = a.ctrlKey;
  this.altKey = a.altKey;
  this.shiftKey = a.shiftKey;
  this.metaKey = a.metaKey;
  this.yc = Ca ? a.metaKey : a.ctrlKey;
  this.state = a.state;
  this.zb = a;
  a.defaultPrevented && this.preventDefault();
  delete this.na
};
p.preventDefault = function() {
  Hb.ra.preventDefault.call(this);
  var a = this.zb;
  if(a.preventDefault) {
    a.preventDefault()
  }else {
    if(a.returnValue = !1, Fb) {
      try {
        if(a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {
          a.keyCode = -1
        }
      }catch(b) {
      }
    }
  }
};
p.u = e();
var Sa = {}, O = {}, P = {}, Ib = {};
function Jb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Jb(a, b[g], c, d, f)
    }
    return null
  }
  a: {
    if(!b) {
      throw Error("Invalid event type");
    }
    d = !!d;
    var h = O;
    b in h || (h[b] = {f:0, t:0});
    h = h[b];
    d in h || (h[d] = {f:0, t:0}, h.f++);
    var h = h[d], g = v(a), n;
    h.t++;
    if(h[g]) {
      n = h[g];
      for(var k = 0;k < n.length;k++) {
        if(h = n[k], h.W == c && h.lb == f) {
          if(h.ea) {
            break
          }
          n[k].Ha = !1;
          a = n[k];
          break a
        }
      }
    }else {
      n = h[g] = [], h.f++
    }
    k = Kb();
    h = new Db;
    h.Oa(c, k, a, b, d, f);
    h.Ha = !1;
    k.src = a;
    k.W = h;
    n.push(h);
    P[g] || (P[g] = []);
    P[g].push(h);
    a.addEventListener ? a != q && a.wb || a.addEventListener(b, k, d) : a.attachEvent(b in Ib ? Ib[b] : Ib[b] = "on" + b, k);
    a = h
  }
  b = a.key;
  Sa[b] = a;
  return b
}
function Kb() {
  var a = Lb, b = Eb ? function(c) {
    return a.call(b.src, b.W, c)
  } : function(c) {
    c = a.call(b.src, b.W, c);
    if(!c) {
      return c
    }
  };
  return b
}
function Mb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Mb(a, b[g], c, d, f)
    }
  }else {
    d = !!d;
    a: {
      g = O;
      if(b in g && (g = g[b], d in g && (g = g[d], a = v(a), g[a]))) {
        a = g[a];
        break a
      }
      a = null
    }
    if(a) {
      for(g = 0;g < a.length;g++) {
        if(a[g].W == c && a[g].capture == d && a[g].lb == f) {
          Nb(a[g].key);
          break
        }
      }
    }
  }
}
function Nb(a) {
  var b = Sa[a];
  if(!b || b.ea) {
    return!1
  }
  var c = b.src, d = b.type, f = b.Ub, g = b.capture;
  c.removeEventListener ? c != q && c.wb || c.removeEventListener(d, f, g) : c.detachEvent && c.detachEvent(d in Ib ? Ib[d] : Ib[d] = "on" + d, f);
  c = v(c);
  if(P[c]) {
    var f = P[c], h = Xa(f, b);
    0 <= h && D.splice.call(f, h, 1);
    0 == f.length && delete P[c]
  }
  b.ea = !0;
  if(b = O[d][g][c]) {
    b.Mb = !0, Ob(d, g, c, b)
  }
  delete Sa[a];
  return!0
}
function Ob(a, b, c, d) {
  if(!d.Qa && d.Mb) {
    for(var f = 0, g = 0;f < d.length;f++) {
      d[f].ea ? d[f].Ub.src = null : (f != g && (d[g] = d[f]), g++)
    }
    d.length = g;
    d.Mb = !1;
    0 == g && (delete O[a][b][c], O[a][b].f--, 0 == O[a][b].f && (delete O[a][b], O[a].f--), 0 == O[a].f && delete O[a])
  }
}
function Pb(a) {
  var b = 0;
  if(null != a) {
    if(a = v(a), P[a]) {
      a = P[a];
      for(var c = a.length - 1;0 <= c;c--) {
        Nb(a[c].key), b++
      }
    }
  }else {
    Ra(function(a, c) {
      Nb(c);
      b++
    })
  }
}
function Qb(a, b, c, d, f) {
  var g = 1;
  b = v(b);
  if(a[b]) {
    var h = --a.t, n = a[b];
    n.Qa ? n.Qa++ : n.Qa = 1;
    try {
      for(var k = n.length, t = 0;t < k;t++) {
        var l = n[t];
        l && !l.ea && (g &= !1 !== Rb(l, f))
      }
    }finally {
      a.t = Math.max(h, a.t), n.Qa--, Ob(c, d, b, n)
    }
  }
  return Boolean(g)
}
function Rb(a, b) {
  a.Ha && Nb(a.key);
  return a.handleEvent(b)
}
function Lb(a, b) {
  if(a.ea) {
    return!0
  }
  var c = a.type, d = O;
  if(!(c in d)) {
    return!0
  }
  var d = d[c], f, g;
  if(!Eb) {
    f = b || da("window.event");
    var h = !0 in d, n = !1 in d;
    if(h) {
      if(0 > f.keyCode || void 0 != f.returnValue) {
        return!0
      }
      a: {
        var k = !1;
        if(0 == f.keyCode) {
          try {
            f.keyCode = -1;
            break a
          }catch(t) {
            k = !0
          }
        }
        if(k || void 0 == f.returnValue) {
          f.returnValue = !0
        }
      }
    }
    k = new Hb;
    k.Oa(f, this);
    f = !0;
    try {
      if(h) {
        for(var l = [], r = k.currentTarget;r;r = r.parentNode) {
          l.push(r)
        }
        g = d[!0];
        g.t = g.f;
        for(var G = l.length - 1;!k.na && 0 <= G && g.t;G--) {
          k.currentTarget = l[G], f &= Qb(g, l[G], c, !0, k)
        }
        if(n) {
          for(g = d[!1], g.t = g.f, G = 0;!k.na && G < l.length && g.t;G++) {
            k.currentTarget = l[G], f &= Qb(g, l[G], c, !1, k)
          }
        }
      }else {
        f = Rb(a, k)
      }
    }finally {
      l && (l.length = 0)
    }
    return f
  }
  c = new Hb(b, this);
  return f = Rb(a, c)
}
;function Sb() {
  M.call(this)
}
y(Sb, M);
p = Sb.prototype;
p.wb = !0;
p.pb = null;
p.addEventListener = function(a, b, c, d) {
  Jb(this, a, b, c, d)
};
p.removeEventListener = function(a, b, c, d) {
  Mb(this, a, b, c, d)
};
p.dispatchEvent = function(a) {
  var b = a.type || a, c = O;
  if(b in c) {
    if(u(a)) {
      a = new N(a, this)
    }else {
      if(a instanceof N) {
        a.target = a.target || this
      }else {
        var d = a;
        a = new N(b, this);
        Wa(a, d)
      }
    }
    var d = 1, f, c = c[b], b = !0 in c, g;
    if(b) {
      f = [];
      for(g = this;g;g = g.pb) {
        f.push(g)
      }
      g = c[!0];
      g.t = g.f;
      for(var h = f.length - 1;!a.na && 0 <= h && g.t;h--) {
        a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !0, a) && !1 != a.Wa
      }
    }
    if(!1 in c) {
      if(g = c[!1], g.t = g.f, b) {
        for(h = 0;!a.na && h < f.length && g.t;h++) {
          a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !1, a) && !1 != a.Wa
        }
      }else {
        for(f = this;!a.na && f && g.t;f = f.pb) {
          a.currentTarget = f, d &= Qb(g, f, a.type, !1, a) && !1 != a.Wa
        }
      }
    }
    a = Boolean(d)
  }else {
    a = !0
  }
  return a
};
p.u = function() {
  Sb.ra.u.call(this);
  Pb(this);
  this.pb = null
};
function Tb(a, b) {
  M.call(this);
  this.da = a || 1;
  this.Ea = b || q;
  this.eb = w(this.Ec, this);
  this.ob = x()
}
y(Tb, Sb);
p = Tb.prototype;
p.enabled = !1;
p.r = null;
p.setInterval = function(a) {
  this.da = a;
  this.r && this.enabled ? (this.stop(), this.start()) : this.r && this.stop()
};
p.Ec = function() {
  if(this.enabled) {
    var a = x() - this.ob;
    0 < a && a < 0.8 * this.da ? this.r = this.Ea.setTimeout(this.eb, this.da - a) : (this.dispatchEvent(Ub), this.enabled && (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x()))
  }
};
p.start = function() {
  this.enabled = !0;
  this.r || (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x())
};
p.stop = function() {
  this.enabled = !1;
  this.r && (this.Ea.clearTimeout(this.r), this.r = null)
};
p.u = function() {
  Tb.ra.u.call(this);
  this.stop();
  delete this.Ea
};
var Ub = "tick";
function Vb(a) {
  M.call(this);
  this.e = a;
  this.j = []
}
y(Vb, M);
var Wb = [];
function Xb(a, b, c, d) {
  s(c) || (Wb[0] = c, c = Wb);
  for(var f = 0;f < c.length;f++) {
    var g = Jb(b, c[f], d || a, !1, a.e || a);
    a.j.push(g)
  }
}
Vb.prototype.u = function() {
  Vb.ra.u.call(this);
  Ya(this.j, Nb);
  this.j.length = 0
};
Vb.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Yb(a, b, c) {
  M.call(this);
  this.nc = a;
  this.da = b;
  this.e = c;
  this.hc = w(this.tc, this)
}
y(Yb, M);
p = Yb.prototype;
p.Xa = !1;
p.Tb = 0;
p.r = null;
p.stop = function() {
  this.r && (q.clearTimeout(this.r), this.r = null, this.Xa = !1)
};
p.u = function() {
  Yb.ra.u.call(this);
  this.stop()
};
p.tc = function() {
  this.r = null;
  this.Xa && !this.Tb && (this.Xa = !1, Zb(this))
};
function Zb(a) {
  var b;
  b = a.hc;
  var c = a.da;
  if(!ha(b)) {
    if(b && "function" == typeof b.handleEvent) {
      b = w(b.handleEvent, b)
    }else {
      throw Error("Invalid listener argument");
    }
  }
  b = 2147483647 < c ? -1 : q.setTimeout(b, c || 0);
  a.r = b;
  a.nc.call(a.e)
}
;function Q(a, b, c, d, f) {
  this.b = a;
  this.a = b;
  this.Z = c;
  this.B = d;
  this.Ca = f || 1;
  this.Da = $b;
  this.jb = new Vb(this);
  this.Sa = new Tb;
  this.Sa.setInterval(ac)
}
p = Q.prototype;
p.v = null;
p.J = !1;
p.ua = null;
p.sb = null;
p.pa = null;
p.sa = null;
p.T = null;
p.w = null;
p.X = null;
p.l = null;
p.Fa = 0;
p.K = null;
p.ta = null;
p.p = null;
p.h = -1;
p.Xb = !0;
p.aa = !1;
p.oa = 0;
p.Ta = null;
var $b = 45E3, ac = 250;
function bc(a, b) {
  switch(a) {
    case 0:
      return"Non-200 return code (" + b + ")";
    case 1:
      return"XMLHTTP failure (no data)";
    case 2:
      return"HttpConnection timeout";
    default:
      return"Unknown error"
  }
}
var cc = {}, dc = {};
function ec() {
  return!A || A && 10 <= Ma
}
p = Q.prototype;
p.Y = m("v");
p.setTimeout = m("Da");
p.$b = m("oa");
function fc(a, b, c) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = c;
  a.xb = !0;
  gc(a, null)
}
function hc(a, b, c, d, f) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = null;
  a.xb = c;
  f && (a.Xb = !1);
  gc(a, d)
}
function gc(a, b) {
  a.pa = x();
  ic(a);
  a.w = a.T.n();
  qb(a.w, "t", a.Ca);
  a.Fa = 0;
  a.l = a.b.hb(a.b.Ya() ? b : null);
  0 < a.oa && (a.Ta = new Yb(w(a.dc, a, a.l), a.oa));
  Xb(a.jb, a.l, "readystatechange", a.Ac);
  var c;
  if(a.v) {
    c = a.v;
    var d = {}, f;
    for(f in c) {
      d[f] = c[f]
    }
    c = d
  }else {
    c = {}
  }
  a.X ? (a.ta = "POST", c["Content-Type"] = "application/x-www-form-urlencoded", a.l.send(a.w, a.ta, a.X, c)) : (a.ta = "GET", a.Xb && !B && (c.Connection = "close"), a.l.send(a.w, a.ta, null, c));
  a.b.G(jc);
  if(d = a.X) {
    for(c = "", d = d.split("&"), f = 0;f < d.length;f++) {
      var g = d[f].split("=");
      if(1 < g.length) {
        var h = g[0], g = g[1], n = h.split("_");
        c = 2 <= n.length && "type" == n[1] ? c + (h + "=" + g + "&") : c + (h + "=redacted&")
      }
    }
  }else {
    c = null
  }
  a.a.info("XMLHTTP REQ (" + a.B + ") [attempt " + a.Ca + "]: " + a.ta + "\n" + a.w + "\n" + c)
}
p.Ac = function(a) {
  a = a.target;
  var b = this.Ta;
  b && 3 == R(a) ? (this.a.debug("Throttling readystatechange."), b.r || b.Tb ? b.Xa = !0 : Zb(b)) : this.dc(a)
};
p.dc = function(a) {
  try {
    if(a == this.l) {
      a: {
        var b = R(this.l), c = this.l.la, d = kc(this.l);
        if(!ec() || B && !C("420+")) {
          if(4 > b) {
            break a
          }
        }else {
          if(3 > b || 3 == b && !za && !lc(this.l)) {
            break a
          }
        }
        this.aa || (4 != b || c == mc) || (c == nc || 0 >= d ? this.b.G(oc) : this.b.G(pc));
        qc(this);
        var f = kc(this.l);
        this.h = f;
        var g = lc(this.l);
        g || this.a.debug("No response text for uri " + this.w + " status " + f);
        this.J = 200 == f;
        this.a.info("XMLHTTP RESP (" + this.B + ") [ attempt " + this.Ca + "]: " + this.ta + "\n" + this.w + "\n" + b + " " + f);
        this.J ? (4 == b && S(this), this.xb ? (rc(this, b, g), za && 3 == b && (Xb(this.jb, this.Sa, Ub, this.zc), this.Sa.start())) : (sc(this.a, this.B, g, null), tc(this, g)), this.J && !this.aa && (4 == b ? this.b.ma(this) : (this.J = !1, ic(this)))) : (400 == f && 0 < g.indexOf("Unknown SID") ? (this.p = 3, T(uc), this.a.$("XMLHTTP Unknown SID (" + this.B + ")")) : (this.p = 0, T(vc), this.a.$("XMLHTTP Bad status " + f + " (" + this.B + ")")), S(this), wc(this))
      }
    }else {
      this.a.$("Called back with an unexpected xmlhttp")
    }
  }catch(h) {
    this.a.debug("Failed call to OnXmlHttpReadyStateChanged_"), this.l && lc(this.l) ? xc(this.a, h, "ResponseText: " + lc(this.l)) : xc(this.a, h, "No response text")
  }finally {
  }
};
function rc(a, b, c) {
  for(var d = !0;!a.aa && a.Fa < c.length;) {
    var f = yc(a, c);
    if(f == dc) {
      4 == b && (a.p = 4, T(zc), d = !1);
      sc(a.a, a.B, null, "[Incomplete Response]");
      break
    }else {
      if(f == cc) {
        a.p = 4;
        T(Ac);
        sc(a.a, a.B, c, "[Invalid Chunk]");
        d = !1;
        break
      }else {
        sc(a.a, a.B, f, null), tc(a, f)
      }
    }
  }
  4 == b && 0 == c.length && (a.p = 1, T(Bc), d = !1);
  a.J = a.J && d;
  d || (sc(a.a, a.B, c, "[Invalid Chunked Response]"), S(a), wc(a))
}
p.zc = function() {
  var a = R(this.l), b = lc(this.l);
  this.Fa < b.length && (qc(this), rc(this, a, b), this.J && 4 != a && ic(this))
};
function yc(a, b) {
  var c = a.Fa, d = b.indexOf("\n", c);
  if(-1 == d) {
    return dc
  }
  c = Number(b.substring(c, d));
  if(isNaN(c)) {
    return cc
  }
  d += 1;
  if(d + c > b.length) {
    return dc
  }
  var f = b.substr(d, c);
  a.Fa = d + c;
  return f
}
function Cc(a, b) {
  a.pa = x();
  ic(a);
  var c = b ? window.location.hostname : "";
  a.w = a.T.n();
  I(a.w, "DOMAIN", c);
  I(a.w, "t", a.Ca);
  try {
    a.K = new ActiveXObject("htmlfile")
  }catch(d) {
    a.a.I("ActiveX blocked");
    S(a);
    a.p = 7;
    T(Dc);
    wc(a);
    return
  }
  var f = "<html><body>";
  b && (f += '<script>document.domain="' + c + '"\x3c/script>');
  f += "</body></html>";
  a.K.open();
  a.K.write(f);
  a.K.close();
  a.K.parentWindow.m = w(a.wc, a);
  a.K.parentWindow.d = w(a.Sb, a, !0);
  a.K.parentWindow.rpcClose = w(a.Sb, a, !1);
  c = a.K.createElement("div");
  a.K.parentWindow.document.body.appendChild(c);
  c.innerHTML = '<iframe src="' + a.w + '"></iframe>';
  a.a.info("TRIDENT REQ (" + a.B + ") [ attempt " + a.Ca + "]: GET\n" + a.w);
  a.b.G(jc)
}
p.wc = function(a) {
  U(w(this.vc, this, a), 0)
};
p.vc = function(a) {
  if(!this.aa) {
    var b = this.a;
    b.info("TRIDENT TEXT (" + this.B + "): " + Ec(b, a));
    qc(this);
    tc(this, a);
    ic(this)
  }
};
p.Sb = function(a) {
  U(w(this.uc, this, a), 0)
};
p.uc = function(a) {
  this.aa || (this.a.info("TRIDENT TEXT (" + this.B + "): " + a ? "success" : "failure"), S(this), this.J = a, this.b.ma(this), this.b.G(Fc))
};
p.lc = function() {
  qc(this);
  this.b.ma(this)
};
p.cancel = function() {
  this.aa = !0;
  S(this)
};
function ic(a) {
  a.sb = x() + a.Da;
  Gc(a, a.Da)
}
function Gc(a, b) {
  if(null != a.ua) {
    throw Error("WatchDog timer not null");
  }
  a.ua = U(w(a.xc, a), b)
}
function qc(a) {
  a.ua && (q.clearTimeout(a.ua), a.ua = null)
}
p.xc = function() {
  this.ua = null;
  var a = x();
  0 <= a - this.sb ? (this.J && this.a.I("Received watchdog timeout even though request loaded successfully"), this.a.info("TIMEOUT: " + this.w), 2 != this.sa && this.b.G(oc), S(this), this.p = 2, T(Hc), wc(this)) : (this.a.$("WatchDog timer called too early"), Gc(this, this.sb - a))
};
function wc(a) {
  a.b.Hb() || a.aa || a.b.ma(a)
}
function S(a) {
  qc(a);
  var b = a.Ta;
  b && "function" == typeof b.Ia && b.Ia();
  a.Ta = null;
  a.Sa.stop();
  b = a.jb;
  Ya(b.j, Nb);
  b.j.length = 0;
  a.l && (b = a.l, a.l = null, b.abort(), b.Ia());
  a.K && (a.K = null)
}
p.Eb = aa("p");
function tc(a, b) {
  try {
    a.b.Pb(a, b), a.b.G(Fc)
  }catch(c) {
    xc(a.a, c, "Error in httprequest callback")
  }
}
;function Ic(a) {
  a = String(a);
  if(/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) {
    try {
      return eval("(" + a + ")")
    }catch(b) {
    }
  }
  throw Error("Invalid JSON string: " + a);
}
function Jc(a) {
  return eval("(" + a + ")")
}
function Kc(a) {
  var b = [];
  Lc(new Mc(void 0), a, b);
  return b.join("")
}
function Mc(a) {
  this.Va = a
}
function Lc(a, b, c) {
  switch(typeof b) {
    case "string":
      Nc(b, c);
      break;
    case "number":
      c.push(isFinite(b) && !isNaN(b) ? b : "null");
      break;
    case "boolean":
      c.push(b);
      break;
    case "undefined":
      c.push("null");
      break;
    case "object":
      if(null == b) {
        c.push("null");
        break
      }
      if(s(b)) {
        var d = b.length;
        c.push("[");
        for(var f = "", g = 0;g < d;g++) {
          c.push(f), f = b[g], Lc(a, a.Va ? a.Va.call(b, String(g), f) : f, c), f = ","
        }
        c.push("]");
        break
      }
      c.push("{");
      d = "";
      for(g in b) {
        Object.prototype.hasOwnProperty.call(b, g) && (f = b[g], "function" != typeof f && (c.push(d), Nc(g, c), c.push(":"), Lc(a, a.Va ? a.Va.call(b, g, f) : f, c), d = ","))
      }
      c.push("}");
      break;
    case "function":
      break;
    default:
      throw Error("Unknown type: " + typeof b);
  }
}
var Oc = {'"':'\\"', "\\":"\\\\", "/":"\\/", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t", "\x0B":"\\u000b"}, Pc = /\uffff/.test("\uffff") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
function Nc(a, b) {
  b.push('"', a.replace(Pc, function(a) {
    if(a in Oc) {
      return Oc[a]
    }
    var b = a.charCodeAt(0), f = "\\u";
    16 > b ? f += "000" : 256 > b ? f += "00" : 4096 > b && (f += "0");
    return Oc[a] = f + b.toString(16)
  }), '"')
}
;function Qc(a) {
  return Rc(a || arguments.callee.caller, [])
}
function Rc(a, b) {
  var c = [];
  if(0 <= Xa(b, a)) {
    c.push("[...circular reference...]")
  }else {
    if(a && 50 > b.length) {
      c.push(Sc(a) + "(");
      for(var d = a.arguments, f = 0;f < d.length;f++) {
        0 < f && c.push(", ");
        var g;
        g = d[f];
        switch(typeof g) {
          case "object":
            g = g ? "object" : "null";
            break;
          case "string":
            break;
          case "number":
            g = String(g);
            break;
          case "boolean":
            g = g ? "true" : "false";
            break;
          case "function":
            g = (g = Sc(g)) ? g : "[fn]";
            break;
          default:
            g = typeof g
        }
        40 < g.length && (g = g.substr(0, 40) + "...");
        c.push(g)
      }
      b.push(a);
      c.push(")\n");
      try {
        c.push(Rc(a.caller, b))
      }catch(h) {
        c.push("[exception trying to get caller]\n")
      }
    }else {
      a ? c.push("[...long stack...]") : c.push("[end]")
    }
  }
  return c.join("")
}
function Sc(a) {
  if(Tc[a]) {
    return Tc[a]
  }
  a = String(a);
  if(!Tc[a]) {
    var b = /function ([^\(]+)/.exec(a);
    Tc[a] = b ? b[1] : "[Anonymous]"
  }
  return Tc[a]
}
var Tc = {};
function Uc(a, b, c, d, f) {
  this.reset(a, b, c, d, f)
}
Uc.prototype.Cc = 0;
Uc.prototype.Bb = null;
Uc.prototype.Ab = null;
var Vc = 0;
Uc.prototype.reset = function(a, b, c, d, f) {
  this.Cc = "number" == typeof f ? f : Vc++;
  this.Qc = d || x();
  this.za = a;
  this.oc = b;
  this.Ic = c;
  delete this.Bb;
  delete this.Ab
};
Uc.prototype.Yb = m("za");
function V(a) {
  this.pc = a
}
V.prototype.Ra = null;
V.prototype.za = null;
V.prototype.fb = null;
V.prototype.Fb = null;
function Wc(a, b) {
  this.name = a;
  this.value = b
}
Wc.prototype.toString = aa("name");
var Xc = new Wc("SEVERE", 1E3), Yc = new Wc("WARNING", 900), Zc = new Wc("INFO", 800), $c = new Wc("CONFIG", 700), ad = new Wc("FINE", 500);
p = V.prototype;
p.getParent = aa("Ra");
p.Yb = m("za");
function bd(a) {
  if(a.za) {
    return a.za
  }
  if(a.Ra) {
    return bd(a.Ra)
  }
  Pa("Root logger has no level set.");
  return null
}
p.log = function(a, b, c) {
  if(a.value >= bd(this).value) {
    for(a = this.kc(a, b, c), b = "log:" + a.oc, q.console && (q.console.timeStamp ? q.console.timeStamp(b) : q.console.markTimeline && q.console.markTimeline(b)), q.msWriteProfilerMark && q.msWriteProfilerMark(b), b = this;b;) {
      c = b;
      var d = a;
      if(c.Fb) {
        for(var f = 0, g = void 0;g = c.Fb[f];f++) {
          g(d)
        }
      }
      b = b.getParent()
    }
  }
};
p.kc = function(a, b, c) {
  var d = new Uc(a, String(b), this.pc);
  if(c) {
    d.Bb = c;
    var f;
    var g = arguments.callee.caller;
    try {
      var h;
      var n = da("window.location.href");
      if(u(c)) {
        h = {message:c, name:"Unknown error", lineNumber:"Not available", fileName:n, stack:"Not available"}
      }else {
        var k, t, l = !1;
        try {
          k = c.lineNumber || c.Hc || "Not available"
        }catch(r) {
          k = "Not available", l = !0
        }
        try {
          t = c.fileName || c.filename || c.sourceURL || q.$googDebugFname || n
        }catch(G) {
          t = "Not available", l = !0
        }
        h = !l && c.lineNumber && c.fileName && c.stack ? c : {message:c.message, name:c.name, lineNumber:k, fileName:t, stack:c.stack || "Not available"}
      }
      f = "Message: " + na(h.message) + '\nUrl: <a href="view-source:' + h.fileName + '" target="_new">' + h.fileName + "</a>\nLine: " + h.lineNumber + "\n\nBrowser stack:\n" + na(h.stack + "-> ") + "[end]\n\nJS stack traversal:\n" + na(Qc(g) + "-> ")
    }catch(Sd) {
      f = "Exception trying to expose exception! You win, we lose. " + Sd
    }
    d.Ab = f
  }
  return d
};
p.I = function(a, b) {
  this.log(Xc, a, b)
};
p.$ = function(a, b) {
  this.log(Yc, a, b)
};
p.info = function(a, b) {
  this.log(Zc, a, b)
};
function W(a, b) {
  a.log(ad, b, void 0)
}
var cd = {}, dd = null;
function ed(a) {
  dd || (dd = new V(""), cd[""] = dd, dd.Yb($c));
  var b;
  if(!(b = cd[a])) {
    b = new V(a);
    var c = a.lastIndexOf("."), d = a.substr(c + 1), c = ed(a.substr(0, c));
    c.fb || (c.fb = {});
    c.fb[d] = b;
    b.Ra = c;
    cd[a] = b
  }
  return b
}
;function X() {
  this.q = ed("goog.net.BrowserChannel")
}
function sc(a, b, c, d) {
  a.info("XMLHTTP TEXT (" + b + "): " + Ec(a, c) + (d ? " " + d : ""))
}
X.prototype.debug = function(a) {
  this.info(a)
};
function xc(a, b, c) {
  a.I((c || "Exception") + b)
}
X.prototype.info = function(a) {
  this.q.info(a)
};
X.prototype.$ = function(a) {
  this.q.$(a)
};
X.prototype.I = function(a) {
  this.q.I(a)
};
function Ec(a, b) {
  if(!b || b == fd) {
    return b
  }
  try {
    var c = Jc(b);
    if(c) {
      for(var d = 0;d < c.length;d++) {
        if(s(c[d])) {
          var f = c[d];
          if(!(2 > f.length)) {
            var g = f[1];
            if(s(g) && !(1 > g.length)) {
              var h = g[0];
              if("noop" != h && "stop" != h) {
                for(var n = 1;n < g.length;n++) {
                  g[n] = ""
                }
              }
            }
          }
        }
      }
    }
    return Kc(c)
  }catch(k) {
    return a.debug("Exception parsing expected JS array - probably was not JS"), b
  }
}
;function gd(a, b) {
  this.Oc = new Mc(a);
  this.P = b ? Jc : Ic
}
gd.prototype.parse = function(a) {
  return this.P(a)
};
var mc = 7, nc = 8;
function hd(a) {
  M.call(this);
  this.headers = new bb;
  this.va = a || null
}
y(hd, Sb);
hd.prototype.q = ed("goog.net.XhrIo");
var id = /^https?$/i;
p = hd.prototype;
p.S = !1;
p.g = null;
p.bb = null;
p.Pa = "";
p.Jb = "";
p.la = 0;
p.p = "";
p.ib = !1;
p.Na = !1;
p.mb = !1;
p.ca = !1;
p.$a = 0;
p.fa = null;
p.Wb = "";
p.cc = !1;
p.send = function(a, b, c, d) {
  if(this.g) {
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.Pa + "; newUri=" + a);
  }
  b = b ? b.toUpperCase() : "GET";
  this.Pa = a;
  this.p = "";
  this.la = 0;
  this.Jb = b;
  this.ib = !1;
  this.S = !0;
  this.g = this.va ? xb(this.va) : xb(vb);
  this.bb = this.va ? this.va.Ga || (this.va.Ga = zb(this.va)) : vb.Ga || (vb.Ga = zb(vb));
  this.g.onreadystatechange = w(this.Ob, this);
  try {
    W(this.q, Y(this, "Opening Xhr")), this.mb = !0, this.g.open(b, a, !0), this.mb = !1
  }catch(f) {
    W(this.q, Y(this, "Error opening Xhr: " + f.message));
    jd(this, f);
    return
  }
  a = c || "";
  var g = this.headers.n();
  d && E(d, function(a, b) {
    g.set(b, a)
  });
  d = q.FormData && a instanceof q.FormData;
  "POST" != b || (g.ia("Content-Type") || d) || g.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  E(g, function(a, b) {
    this.g.setRequestHeader(b, a)
  }, this);
  this.Wb && (this.g.responseType = this.Wb);
  "withCredentials" in this.g && (this.g.withCredentials = this.cc);
  try {
    this.fa && (q.clearTimeout(this.fa), this.fa = null), 0 < this.$a && (W(this.q, Y(this, "Will abort after " + this.$a + "ms if incomplete")), this.fa = q.setTimeout(w(this.Da, this), this.$a)), W(this.q, Y(this, "Sending request")), this.Na = !0, this.g.send(a), this.Na = !1
  }catch(h) {
    W(this.q, Y(this, "Send error: " + h.message)), jd(this, h)
  }
};
p.Da = function() {
  "undefined" != typeof ca && this.g && (this.p = "Timed out after " + this.$a + "ms, aborting", this.la = nc, W(this.q, Y(this, this.p)), this.dispatchEvent("timeout"), this.abort(nc))
};
function jd(a, b) {
  a.S = !1;
  a.g && (a.ca = !0, a.g.abort(), a.ca = !1);
  a.p = b;
  a.la = 5;
  kd(a);
  ld(a)
}
function kd(a) {
  a.ib || (a.ib = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"))
}
p.abort = function(a) {
  this.g && this.S && (W(this.q, Y(this, "Aborting")), this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1, this.la = a || mc, this.dispatchEvent("complete"), this.dispatchEvent("abort"), ld(this))
};
p.u = function() {
  this.g && (this.S && (this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1), ld(this, !0));
  hd.ra.u.call(this)
};
p.Ob = function() {
  this.mb || this.Na || this.ca ? md(this) : this.sc()
};
p.sc = function() {
  md(this)
};
function md(a) {
  if(a.S && "undefined" != typeof ca) {
    if(a.bb[1] && 4 == R(a) && 2 == kc(a)) {
      W(a.q, Y(a, "Local request error detected and ignored"))
    }else {
      if(a.Na && 4 == R(a)) {
        q.setTimeout(w(a.Ob, a), 0)
      }else {
        if(a.dispatchEvent("readystatechange"), 4 == R(a)) {
          W(a.q, Y(a, "Request complete"));
          a.S = !1;
          try {
            var b = kc(a), c, d;
            a: {
              switch(b) {
                case 200:
                ;
                case 201:
                ;
                case 202:
                ;
                case 204:
                ;
                case 206:
                ;
                case 304:
                ;
                case 1223:
                  d = !0;
                  break a;
                default:
                  d = !1
              }
            }
            if(!(c = d)) {
              var f;
              if(f = 0 === b) {
                var g = String(a.Pa).match(Qa)[1] || null;
                if(!g && self.location) {
                  var h = self.location.protocol, g = h.substr(0, h.length - 1)
                }
                f = !id.test(g ? g.toLowerCase() : "")
              }
              c = f
            }
            if(c) {
              a.dispatchEvent("complete"), a.dispatchEvent("success")
            }else {
              a.la = 6;
              var n;
              try {
                n = 2 < R(a) ? a.g.statusText : ""
              }catch(k) {
                W(a.q, "Can not get status: " + k.message), n = ""
              }
              a.p = n + " [" + kc(a) + "]";
              kd(a)
            }
          }finally {
            ld(a)
          }
        }
      }
    }
  }
}
function ld(a, b) {
  if(a.g) {
    var c = a.g, d = a.bb[0] ? ea : null;
    a.g = null;
    a.bb = null;
    a.fa && (q.clearTimeout(a.fa), a.fa = null);
    b || a.dispatchEvent("ready");
    try {
      c.onreadystatechange = d
    }catch(f) {
      a.q.I("Problem encountered resetting onreadystatechange: " + f.message)
    }
  }
}
p.isActive = function() {
  return!!this.g
};
function R(a) {
  return a.g ? a.g.readyState : 0
}
function kc(a) {
  try {
    return 2 < R(a) ? a.g.status : -1
  }catch(b) {
    return a.q.$("Can not get status: " + b.message), -1
  }
}
function lc(a) {
  try {
    return a.g ? a.g.responseText : ""
  }catch(b) {
    return W(a.q, "Can not get responseText: " + b.message), ""
  }
}
p.Eb = function() {
  return u(this.p) ? this.p : String(this.p)
};
function Y(a, b) {
  return b + " [" + a.Jb + " " + a.Pa + " " + kc(a) + "]"
}
;function nd() {
  this.Vb = x()
}
new nd;
nd.prototype.set = m("Vb");
nd.prototype.reset = function() {
  this.set(x())
};
nd.prototype.get = aa("Vb");
function od(a, b, c, d, f) {
  (new X).debug("TestLoadImageWithRetries: " + f);
  if(0 == d) {
    c(!1)
  }else {
    var g = f || 0;
    d--;
    pd(a, b, function(f) {
      f ? c(!0) : q.setTimeout(function() {
        od(a, b, c, d, g)
      }, g)
    })
  }
}
function pd(a, b, c) {
  function d(a, b) {
    return function() {
      try {
        f.debug("TestLoadImage: " + b), g.onload = null, g.onerror = null, g.onabort = null, g.ontimeout = null, q.clearTimeout(h), c(a)
      }catch(d) {
        xc(f, d)
      }
    }
  }
  var f = new X;
  f.debug("TestLoadImage: loading " + a);
  var g = new Image, h = null;
  g.onload = d(!0, "loaded");
  g.onerror = d(!1, "error");
  g.onabort = d(!1, "abort");
  g.ontimeout = d(!1, "timeout");
  h = q.setTimeout(function() {
    if(g.ontimeout) {
      g.ontimeout()
    }
  }, b);
  g.src = a
}
;function qd(a, b) {
  this.b = a;
  this.a = b;
  this.P = new gd(null, !0)
}
p = qd.prototype;
p.v = null;
p.A = null;
p.Ua = !1;
p.ac = null;
p.Ka = null;
p.nb = null;
p.H = null;
p.c = null;
p.h = -1;
p.L = null;
p.wa = null;
p.Y = m("v");
p.Zb = m("P");
p.gb = function(a) {
  this.H = a;
  a = rd(this.b, this.H);
  T(sd);
  this.ac = x();
  var b = this.b.Cb;
  null != b ? (this.L = this.b.correctHostPrefix(b[0]), (this.wa = b[1]) ? (this.c = 1, td(this)) : (this.c = 2, ud(this))) : (qb(a, "MODE", "init"), this.A = new Q(this, this.a, void 0, void 0, void 0), this.A.Y(this.v), hc(this.A, a, !1, null, !0), this.c = 0)
};
function td(a) {
  var b = vd(a.b, a.wa, "/mail/images/cleardot.gif");
  J(b);
  od(b.toString(), 5E3, w(a.ic, a), 3, 2E3);
  a.G(jc)
}
p.ic = function(a) {
  if(a) {
    this.c = 2, ud(this)
  }else {
    T(wd);
    var b = this.b;
    b.a.debug("Test Connection Blocked");
    b.h = b.U.h;
    Z(b, 9)
  }
  a && this.G(pc)
};
function ud(a) {
  a.a.debug("TestConnection: starting stage 2");
  a.A = new Q(a, a.a, void 0, void 0, void 0);
  a.A.Y(a.v);
  var b = xd(a.b, a.L, a.H);
  T(yd);
  if(ec()) {
    qb(b, "TYPE", "xmlhttp"), hc(a.A, b, !1, a.L, !1)
  }else {
    qb(b, "TYPE", "html");
    var c = a.A;
    a = Boolean(a.L);
    c.sa = 3;
    c.T = J(b.n());
    Cc(c, a)
  }
}
p.hb = function(a) {
  return this.b.hb(a)
};
p.abort = function() {
  this.A && (this.A.cancel(), this.A = null);
  this.h = -1
};
p.Hb = ba(!1);
p.Pb = function(a, b) {
  this.h = a.h;
  if(0 == this.c) {
    if(this.a.debug("TestConnection: Got data for stage 1"), b) {
      try {
        var c = this.P.parse(b)
      }catch(d) {
        xc(this.a, d);
        zd(this.b, this);
        return
      }
      this.L = this.b.correctHostPrefix(c[0]);
      this.wa = c[1]
    }else {
      this.a.debug("TestConnection: Null responseText"), zd(this.b, this)
    }
  }else {
    if(2 == this.c) {
      if(this.Ua) {
        T(Ad), this.nb = x()
      }else {
        if("11111" == b) {
          if(T(Bd), this.Ua = !0, this.Ka = x(), c = this.Ka - this.ac, ec() || 500 > c) {
            this.h = 200, this.A.cancel(), this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)
          }
        }else {
          T(Ed), this.Ka = this.nb = x(), this.Ua = !1
        }
      }
    }
  }
};
p.ma = function() {
  this.h = this.A.h;
  if(!this.A.J) {
    this.a.debug("TestConnection: request failed, in state " + this.c), 0 == this.c ? T(Fd) : 2 == this.c && T(Gd), zd(this.b, this)
  }else {
    if(0 == this.c) {
      this.a.debug("TestConnection: request complete for initial check"), this.wa ? (this.c = 1, td(this)) : (this.c = 2, ud(this))
    }else {
      if(2 == this.c) {
        this.a.debug("TestConnection: request complete for stage 2");
        var a = !1;
        (a = ec() ? this.Ua : 200 > this.nb - this.Ka ? !1 : !0) ? (this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)) : (this.a.debug("Test connection failed; not using streaming"), T(Hd), Dd(this.b, this, !1))
      }
    }
  }
};
p.Ya = function() {
  return this.b.Ya()
};
p.isActive = function() {
  return this.b.isActive()
};
p.G = function(a) {
  this.b.G(a)
};
function Id(a, b) {
  this.vb = a || null;
  this.c = Jd;
  this.s = [];
  this.Q = [];
  this.a = new X;
  this.P = new gd(null, !0);
  this.Cb = b || null
}
function Kd(a, b) {
  this.Lb = a;
  this.map = b;
  this.Fc = null
}
p = Id.prototype;
p.v = null;
p.xa = null;
p.o = null;
p.k = null;
p.H = null;
p.La = null;
p.ub = null;
p.L = null;
p.fc = !0;
p.Aa = 0;
p.qc = 0;
p.Ja = !1;
p.e = null;
p.F = null;
p.M = null;
p.ba = null;
p.U = null;
p.rb = null;
p.ec = !0;
p.ya = -1;
p.Kb = -1;
p.h = -1;
p.V = 0;
p.ga = 0;
p.gc = 5E3;
p.Bc = 1E4;
p.kb = 2;
p.Db = 2E4;
p.oa = 0;
p.Za = !1;
p.ha = 8;
var Jd = 1, Ld = new Sb;
function Md(a, b) {
  N.call(this, "statevent", a);
  this.Pc = b
}
y(Md, N);
function Nd(a, b, c, d) {
  N.call(this, "timingevent", a);
  this.size = b;
  this.Nc = c;
  this.Mc = d
}
y(Nd, N);
var jc = 1, pc = 2, oc = 3, Fc = 4;
function Od(a, b) {
  N.call(this, "serverreachability", a);
  this.Lc = b
}
y(Od, N);
var sd = 3, wd = 4, yd = 5, Bd = 6, Ad = 7, Ed = 8, Fd = 9, Gd = 10, Hd = 11, Cd = 12, uc = 13, vc = 14, zc = 15, Ac = 16, Bc = 17, Hc = 18, Dc = 22, fd = "y2f%";
p = Id.prototype;
p.gb = function(a, b, c, d, f) {
  this.a.debug("connect()");
  T(0);
  this.H = b;
  this.xa = c || {};
  d && void 0 !== f && (this.xa.OSID = d, this.xa.OAID = f);
  this.a.debug("connectTest_()");
  Pd(this) && (this.U = new qd(this, this.a), this.U.Y(this.v), this.U.Zb(this.P), this.U.gb(a))
};
p.disconnect = function() {
  this.a.debug("disconnect()");
  Qd(this);
  if(3 == this.c) {
    var a = this.Aa++, b = this.La.n();
    I(b, "SID", this.Z);
    I(b, "RID", a);
    I(b, "TYPE", "terminate");
    Rd(this, b);
    a = new Q(this, this.a, this.Z, a, void 0);
    a.sa = 2;
    a.T = J(b.n());
    b = new Image;
    b.src = a.T;
    b.onload = b.onerror = w(a.lc, a);
    a.pa = x();
    ic(a)
  }
  Td(this)
};
function Qd(a) {
  a.U && (a.U.abort(), a.U = null);
  a.k && (a.k.cancel(), a.k = null);
  a.M && (q.clearTimeout(a.M), a.M = null);
  Ud(a);
  a.o && (a.o.cancel(), a.o = null);
  a.F && (q.clearTimeout(a.F), a.F = null)
}
p.Y = m("v");
p.$b = m("oa");
p.Hb = function() {
  return 0 == this.c
};
p.Zb = m("P");
function Vd(a) {
  a.o || a.F || (a.F = U(w(a.Rb, a), 0), a.V = 0)
}
p.Rb = function(a) {
  this.F = null;
  this.a.debug("startForwardChannel_");
  if(Pd(this)) {
    if(this.c == Jd) {
      if(a) {
        this.a.I("Not supposed to retry the open")
      }else {
        this.a.debug("open_()");
        this.Aa = Math.floor(1E5 * Math.random());
        a = this.Aa++;
        var b = new Q(this, this.a, "", a, void 0);
        b.Y(this.v);
        var c = Wd(this), d = this.La.n();
        I(d, "RID", a);
        this.vb && I(d, "CVER", this.vb);
        Rd(this, d);
        fc(b, d, c);
        this.o = b;
        this.c = 2
      }
    }else {
      3 == this.c && (a ? Xd(this, a) : 0 == this.s.length ? this.a.debug("startForwardChannel_ returned: nothing to send") : this.o ? this.a.I("startForwardChannel_ returned: connection already in progress") : (Xd(this), this.a.debug("startForwardChannel_ finished, sent request")))
    }
  }
};
function Xd(a, b) {
  var c, d;
  b ? 6 < a.ha ? (a.s = a.Q.concat(a.s), a.Q.length = 0, c = a.Aa - 1, d = Wd(a)) : (c = b.B, d = b.X) : (c = a.Aa++, d = Wd(a));
  var f = a.La.n();
  I(f, "SID", a.Z);
  I(f, "RID", c);
  I(f, "AID", a.ya);
  Rd(a, f);
  c = new Q(a, a.a, a.Z, c, a.V + 1);
  c.Y(a.v);
  c.setTimeout(Math.round(0.5 * a.Db) + Math.round(0.5 * a.Db * Math.random()));
  a.o = c;
  fc(c, f, d)
}
function Rd(a, b) {
  if(a.e) {
    var c = a.e.getAdditionalParams(a);
    c && E(c, function(a, c) {
      I(b, c, a)
    })
  }
}
function Wd(a) {
  var b = Math.min(a.s.length, 1E3), c = ["count=" + b], d;
  6 < a.ha && 0 < b ? (d = a.s[0].Lb, c.push("ofs=" + d)) : d = 0;
  for(var f = 0;f < b;f++) {
    var g = a.s[f].Lb, h = a.s[f].map, g = 6 >= a.ha ? f : g - d;
    try {
      E(h, function(a, b) {
        c.push("req" + g + "_" + b + "=" + encodeURIComponent(a))
      })
    }catch(n) {
      c.push("req" + g + "_type=" + encodeURIComponent("_badmap")), a.e && a.e.badMapError(a, h)
    }
  }
  a.Q = a.Q.concat(a.s.splice(0, b));
  return c.join("&")
}
function Yd(a) {
  a.k || a.M || (a.tb = 1, a.M = U(w(a.Qb, a), 0), a.ga = 0)
}
function Zd(a) {
  if(a.k || a.M) {
    return a.a.I("Request already in progress"), !1
  }
  if(3 <= a.ga) {
    return!1
  }
  a.a.debug("Going to retry GET");
  a.tb++;
  a.M = U(w(a.Qb, a), $d(a, a.ga));
  a.ga++;
  return!0
}
p.Qb = function() {
  this.M = null;
  if(Pd(this)) {
    this.a.debug("Creating new HttpRequest");
    this.k = new Q(this, this.a, this.Z, "rpc", this.tb);
    this.k.Y(this.v);
    this.k.$b(this.oa);
    var a = this.ub.n();
    I(a, "RID", "rpc");
    I(a, "SID", this.Z);
    I(a, "CI", this.rb ? "0" : "1");
    I(a, "AID", this.ya);
    Rd(this, a);
    if(ec()) {
      I(a, "TYPE", "xmlhttp"), hc(this.k, a, !0, this.L, !1)
    }else {
      I(a, "TYPE", "html");
      var b = this.k, c = Boolean(this.L);
      b.sa = 3;
      b.T = J(a.n());
      Cc(b, c)
    }
    this.a.debug("New Request created")
  }
};
function Pd(a) {
  if(a.e) {
    var b = a.e.okToMakeRequest(a);
    if(0 != b) {
      return a.a.debug("Handler returned error code from okToMakeRequest"), Z(a, b), !1
    }
  }
  return!0
}
function Dd(a, b, c) {
  a.a.debug("Test Connection Finished");
  a.rb = a.ec && c;
  a.h = b.h;
  a.a.debug("connectChannel_()");
  a.jc(Jd, 0);
  a.La = rd(a, a.H);
  Vd(a)
}
function zd(a, b) {
  a.a.debug("Test Connection Failed");
  a.h = b.h;
  Z(a, 2)
}
p.Pb = function(a, b) {
  if(0 != this.c && (this.k == a || this.o == a)) {
    if(this.h = a.h, this.o == a && 3 == this.c) {
      if(7 < this.ha) {
        var c;
        try {
          c = this.P.parse(b)
        }catch(d) {
          c = null
        }
        if(s(c) && 3 == c.length) {
          var f = c;
          if(0 == f[0]) {
            a: {
              if(this.a.debug("Server claims our backchannel is missing."), this.M) {
                this.a.debug("But we are currently starting the request.")
              }else {
                if(this.k) {
                  if(this.k.pa + 3E3 < this.o.pa) {
                    Ud(this), this.k.cancel(), this.k = null
                  }else {
                    break a
                  }
                }else {
                  this.a.$("We do not have a BackChannel established")
                }
                Zd(this);
                T(19)
              }
            }
          }else {
            this.Kb = f[1], c = this.Kb - this.ya, 0 < c && (f = f[2], this.a.debug(f + " bytes (in " + c + " arrays) are outstanding on the BackChannel"), 37500 > f && (this.rb && 0 == this.ga) && !this.ba && (this.ba = U(w(this.rc, this), 6E3)))
          }
        }else {
          this.a.debug("Bad POST response data returned"), Z(this, 11)
        }
      }else {
        b != fd && (this.a.debug("Bad data returned - missing/invald magic cookie"), Z(this, 11))
      }
    }else {
      if(this.k == a && Ud(this), !/^[\s\xa0]*$/.test(b)) {
        c = this.P.parse(b);
        for(var f = this.e && this.e.channelHandleMultipleArrays ? [] : null, g = 0;g < c.length;g++) {
          var h = c[g];
          this.ya = h[0];
          h = h[1];
          2 == this.c ? "c" == h[0] ? (this.Z = h[1], this.L = this.correctHostPrefix(h[2]), h = h[3], this.ha = null != h ? h : 6, this.c = 3, this.e && this.e.channelOpened(this), this.ub = xd(this, this.L, this.H), Yd(this)) : "stop" == h[0] && Z(this, 7) : 3 == this.c && ("stop" == h[0] ? (f && f.length && (this.e.channelHandleMultipleArrays(this, f), f.length = 0), Z(this, 7)) : "noop" != h[0] && (f ? f.push(h) : this.e && this.e.channelHandleArray(this, h)), this.ga = 0)
        }
        f && f.length && this.e.channelHandleMultipleArrays(this, f)
      }
    }
  }
};
p.correctHostPrefix = function(a) {
  return this.fc ? this.e ? this.e.correctHostPrefix(a) : a : null
};
p.rc = function() {
  null != this.ba && (this.ba = null, this.k.cancel(), this.k = null, Zd(this), T(20))
};
function Ud(a) {
  null != a.ba && (q.clearTimeout(a.ba), a.ba = null)
}
p.ma = function(a) {
  this.a.debug("Request complete");
  var b;
  if(this.k == a) {
    Ud(this), this.k = null, b = 2
  }else {
    if(this.o == a) {
      this.o = null, b = 1
    }else {
      return
    }
  }
  this.h = a.h;
  if(0 != this.c) {
    if(a.J) {
      1 == b ? (b = x() - a.pa, Ld.dispatchEvent(new Nd(Ld, a.X ? a.X.length : 0, b, this.V)), Vd(this), this.Q.length = 0) : Yd(this)
    }else {
      var c = a.Eb();
      if(3 == c || 7 == c || 0 == c && 0 < this.h) {
        this.a.debug("Not retrying due to error type")
      }else {
        this.a.debug("Maybe retrying, last error: " + bc(c, this.h));
        var d;
        if(d = 1 == b) {
          this.o || this.F ? (this.a.I("Request already in progress"), d = !1) : this.c == Jd || this.V >= (this.Ja ? 0 : this.kb) ? d = !1 : (this.a.debug("Going to retry POST"), this.F = U(w(this.Rb, this, a), $d(this, this.V)), this.V++, d = !0)
        }
        if(d || 2 == b && Zd(this)) {
          return
        }
        this.a.debug("Exceeded max number of retries")
      }
      this.a.debug("Error: HTTP request failed");
      switch(c) {
        case 1:
          Z(this, 5);
          break;
        case 4:
          Z(this, 10);
          break;
        case 3:
          Z(this, 6);
          break;
        case 7:
          Z(this, 12);
          break;
        default:
          Z(this, 2)
      }
    }
  }
};
function $d(a, b) {
  var c = a.gc + Math.floor(Math.random() * a.Bc);
  a.isActive() || (a.a.debug("Inactive channel"), c *= 2);
  return c * b
}
p.jc = function(a) {
  if(!(0 <= Xa(arguments, this.c))) {
    throw Error("Unexpected channel state: " + this.c);
  }
};
function Z(a, b) {
  a.a.info("Error code " + b);
  if(2 == b || 9 == b) {
    var c = null;
    a.e && (c = a.e.getNetworkTestImageUri(a));
    var d = w(a.Dc, a);
    c || (c = new F("//www.google.com/images/cleardot.gif"), J(c));
    pd(c.toString(), 1E4, d)
  }else {
    T(2)
  }
  ae(a, b)
}
p.Dc = function(a) {
  a ? (this.a.info("Successfully pinged google.com"), T(2)) : (this.a.info("Failed to ping google.com"), T(1), ae(this, 8))
};
function ae(a, b) {
  a.a.debug("HttpChannel: error - " + b);
  a.c = 0;
  a.e && a.e.channelError(a, b);
  Td(a);
  Qd(a)
}
function Td(a) {
  a.c = 0;
  a.h = -1;
  if(a.e) {
    if(0 == a.Q.length && 0 == a.s.length) {
      a.e.channelClosed(a)
    }else {
      a.a.debug("Number of undelivered maps, pending: " + a.Q.length + ", outgoing: " + a.s.length);
      var b = $a(a.Q), c = $a(a.s);
      a.Q.length = 0;
      a.s.length = 0;
      a.e.channelClosed(a, b, c)
    }
  }
}
function rd(a, b) {
  var c = vd(a, null, b);
  a.a.debug("GetForwardChannelUri: " + c);
  return c
}
function xd(a, b, c) {
  b = vd(a, a.Ya() ? b : null, c);
  a.a.debug("GetBackChannelUri: " + b);
  return b
}
function vd(a, b, c) {
  var d = c instanceof F ? c.n() : new F(c, void 0);
  if("" != d.ja) {
    b && fb(d, b + "." + d.ja), gb(d, d.Ba)
  }else {
    var f = window.location, d = sb(f.protocol, b ? b + "." + f.hostname : f.hostname, f.port, c)
  }
  a.xa && E(a.xa, function(a, b) {
    I(d, b, a)
  });
  I(d, "VER", a.ha);
  Rd(a, d);
  return d
}
p.hb = function(a) {
  if(a && !this.Za) {
    throw Error("Can't create secondary domain capable XhrIo object.");
  }
  a = new hd;
  a.cc = this.Za;
  return a
};
p.isActive = function() {
  return!!this.e && this.e.isActive(this)
};
function U(a, b) {
  if(!ha(a)) {
    throw Error("Fn must not be null and must be a function");
  }
  return q.setTimeout(function() {
    a()
  }, b)
}
p.G = function(a) {
  Ld.dispatchEvent(new Od(Ld, a))
};
function T(a) {
  Ld.dispatchEvent(new Md(Ld, a))
}
p.Ya = function() {
  return this.Za || !ec()
};
function be() {
}
p = be.prototype;
p.channelHandleMultipleArrays = null;
p.okToMakeRequest = ba(0);
p.channelOpened = e();
p.channelHandleArray = e();
p.channelError = e();
p.channelClosed = e();
p.getAdditionalParams = function() {
  return{}
};
p.getNetworkTestImageUri = ba(null);
p.isActive = ba(!0);
p.badMapError = e();
p.correctHostPrefix = function(a) {
  return a
};
var $, ce, de = [].slice;
ce = {0:"Ok", 4:"User is logging out", 6:"Unknown session ID", 7:"Stopped by server", 8:"General network error", 2:"Request failed", 9:"Blocked by a network administrator", 5:"No data from server", 10:"Got bad data from the server", 11:"Got a bad response from the server"};
$ = function(a, b) {
  var c, d, f, g, h, n, k, t, l, r;
  t = this;
  a || (a = "channel");
  a.match(/:\/\//) && a.replace(/^ws/, "http");
  b || (b = {});
  s(b || "string" === typeof b) && (b = {});
  n = b.reconnectTime || 3E3;
  r = function(a) {
    t.readyState = t.readyState = a
  };
  r(this.CLOSED);
  l = null;
  g = b.Kc;
  c = function() {
    var a, b;
    b = arguments[0];
    a = 2 <= arguments.length ? de.call(arguments, 1) : [];
    try {
      return"function" === typeof t[b] ? t[b].apply(t, a) : void 0
    }catch(c) {
      throw a = c, "undefined" !== typeof console && null !== console && console.error(a.stack), a;
    }
  };
  d = new be;
  d.channelOpened = function() {
    g = l;
    r($.OPEN);
    return c("onopen")
  };
  f = null;
  d.channelError = function(a, b) {
    var d;
    d = ce[b];
    f = b;
    r($.cb);
    try {
      return c("onerror", d, b)
    }catch(g) {
    }
  };
  k = null;
  d.channelClosed = function(a, d, g) {
    if(t.readyState !== $.CLOSED) {
      l = null;
      a = f ? ce[f] : "Closed";
      r($.CLOSED);
      try {
        c("onclose", a, d, g)
      }catch(ee) {
      }
      b.reconnect && (7 !== f && 0 !== f) && (d = 6 === f ? 0 : n, clearTimeout(k), k = setTimeout(h, d));
      return f = null
    }
  };
  d.channelHandleArray = function(a, b) {
    return c("onmessage", b)
  };
  h = function() {
    if(l) {
      throw Error("Reconnect() called from invalid state");
    }
    r($.CONNECTING);
    c("onconnecting");
    clearTimeout(k);
    l = new Id(b.appVersion, null != g ? g.Cb : void 0);
    b.crossDomainXhr && (l.Za = !0);
    l.e = d;
    f = null;
    if(b.failFast) {
      var h = l;
      h.Ja = !0;
      h.a.info("setFailFast: true");
      (h.o || h.F) && h.V > (h.Ja ? 0 : h.kb) && (h.a.info("Retry count " + h.V + " > new maxRetries " + (h.Ja ? 0 : h.kb) + ". Fail immediately!"), h.o ? (h.o.cancel(), h.ma(h.o)) : (q.clearTimeout(h.F), h.F = null, Z(h, 2)))
    }
    return l.gb("" + a + "/test", "" + a + "/bind", b.extraParams, null != g ? g.Z : void 0, null != g ? g.ya : void 0)
  };
  this.open = function() {
    if(t.readyState !== t.CLOSED) {
      throw Error("Already open");
    }
    return h()
  };
  this.close = function() {
    clearTimeout(k);
    f = 0;
    if(t.readyState !== $.CLOSED) {
      return r($.cb), l.disconnect()
    }
  };
  this.sendMap = function(a) {
    var b;
    if((b = t.readyState) === $.cb || b === $.CLOSED) {
      throw Error("Cannot send to a closed connection");
    }
    b = l;
    if(0 == b.c) {
      throw Error("Invalid operation: sending map when state is closed");
    }
    1E3 == b.s.length && b.a.I("Already have 1000 queued maps upon queueing " + Kc(a));
    b.s.push(new Kd(b.qc++, a));
    2 != b.c && 3 != b.c || Vd(b)
  };
  this.send = function(a) {
    return this.sendMap({JSON:Kc(a)})
  };
  h();
  return this
};
$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;
$.prototype.OPEN = $.OPEN = $.OPEN = 1;
$.prototype.CLOSING = $.CLOSING = $.cb = 2;
$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;
("undefined" !== typeof exports && null !== exports ? exports : window).BCSocket = $;

})();

},{}],26:[function(require,module,exports){
(function(){
(function(){var r={exports:{}},e=r.exports;e.name="text",e.uri="http://sharejs.org/types/textv1",e.create=function(r){if(null!=r&&"string"!=typeof r)throw Error("Initial data must be a string");return r||""};var t=Array.isArray||function(r){return"[object Array]"===Object.prototype.toString.call(r)},n=function(r){if(!t(r))throw Error("Op must be an array of components");for(var e=null,n=0;r.length>n;n++){var o=r[n];switch(typeof o){case"object":if(!("number"==typeof o.d&&o.d>0))throw Error("Object components must be deletes of size > 0");break;case"string":if(!(o.length>0))throw Error("Inserts cannot be empty");break;case"number":if(!(o>0))throw Error("Skip components must be >0");if("number"==typeof e)throw Error("Adjacent skip components should be combined")}e=o}if("number"==typeof e)throw Error("Op has a trailing skip")},o=function(r){return function(e){return e&&0!==e.d?0===r.length?r.push(e):typeof e==typeof r[r.length-1]?"object"==typeof e?r[r.length-1].d+=e.d:r[r.length-1]+=e:r.push(e):void 0}},s=function(r){var e=0,t=0,n=function(n,o){if(e===r.length)return-1===n?null:n;var s,i=r[e];return"number"==typeof i?-1===n||n>=i-t?(s=i-t,++e,t=0,s):(t+=n,n):"string"==typeof i?-1===n||"i"===o||n>=i.length-t?(s=i.slice(t),++e,t=0,s):(s=i.slice(t,t+n),t+=n,s):-1===n||"d"===o||n>=i.d-t?(s={d:i.d-t},++e,t=0,s):(t+=n,{d:n})},o=function(){return r[e]};return[n,o]},i=function(r){return"number"==typeof r?r:r.length||r.d},a=function(r){return r.length>0&&"number"==typeof r[r.length-1]&&r.pop(),r};e.normalize=function(r){for(var e=[],t=o(e),n=0;r.length>n;n++)t(r[n]);return a(e)},e.apply=function(r,e){if("string"!=typeof r)throw Error("Snapshot should be a string");n(e);for(var t=[],o=0;e.length>o;o++){var s=e[o];switch(typeof s){case"number":if(s>r.length)throw Error("The op is too long for this document");t.push(r.slice(0,s)),r=r.slice(s);break;case"string":t.push(s);break;case"object":r=r.slice(s.d)}}return t.join("")+r},e.transform=function(r,e,t){if("left"!=t&&"right"!=t)throw Error("side ("+t+") must be 'left' or 'right'");n(r),n(e);for(var c=[],f=o(c),u=s(r),h=u[0],p=u[1],b=0;e.length>b;b++){var l,g,m=e[b];switch(typeof m){case"number":for(l=m;l>0;)g=h(l,"i"),f(g),"string"!=typeof g&&(l-=i(g));break;case"string":"left"===t&&"string"==typeof p()&&f(h(-1)),f(m.length);break;case"object":for(l=m.d;l>0;)switch(g=h(l,"i"),typeof g){case"number":l-=g;break;case"string":f(g);break;case"object":l-=g.d}}}for(;m=h(-1);)f(m);return a(c)},e.compose=function(r,e){n(r),n(e);for(var t=[],c=o(t),f=s(r)[0],u=0;e.length>u;u++){var h,p,b=e[u];switch(typeof b){case"number":for(h=b;h>0;)p=f(h,"d"),c(p),"object"!=typeof p&&(h-=i(p));break;case"string":c(b);break;case"object":for(h=b.d;h>0;)switch(p=f(h,"d"),typeof p){case"number":c({d:p}),h-=p;break;case"string":h-=p.length;break;case"object":c(p)}}}for(;b=f(-1);)c(b);return a(t)};var c=function(r,e){for(var t=0,n=0;e.length>n;n++){var o=e[n];if(t>=r)break;switch(typeof o){case"number":if(t+o>=r)return r;t+=o;break;case"string":t+=o.length,r+=o.length;break;case"object":r-=Math.min(o.d,r-t)}}return r};e.transformCursor=function(r,e,t){var n=0;if(t){for(var o=0;e.length>o;o++){var s=e[o];switch(typeof s){case"number":n+=s;break;case"string":n+=s.length}}return[n,n]}return[c(r[0],e),c(r[1],e)]};var f=window.ottypes=window.ottypes||{},u=r.exports;f[u.name]=u,u.uri&&(f[u.uri]=u)})();// Text document API for the 'text' type.

// The API implements the standard text API methods. In particular:
//
// - getLength() returns the length of the document in characters
// - getText() returns a string of the document
// - insert(pos, text, [callback]) inserts text at position pos in the document
// - remove(pos, length, [callback]) removes length characters at position pos
//
// Events are implemented by just adding the appropriate methods to your
// context object.
// onInsert(pos, text): Called when text is inserted.
// onRemove(pos, length): Called when text is removed.

var _types = (typeof brequire !== 'undefined') ?
  brequire('ottypes') : window.ottypes;

_types['http://sharejs.org/types/textv1'].api = {
  provides: {text: true},
  
  // Returns the number of characters in the string
  getLength: function() { return this.getSnapshot().length; },

  // Returns the text content of the document
  getText: function() { return this.getSnapshot(); },

  // Insert the specified text at the given position in the document
  insert: function(pos, text, callback) {
    return this.submitOp([pos, text], callback);
  },

  remove: function(pos, length, callback) {
    return this.submitOp([pos, {d:length}], callback);
  },

  // When you use this API, you should implement these two methods
  // in your editing context.
  //onInsert: function(pos, text) {},
  //onRemove: function(pos, removedLength) {},

  _onOp: function(op) {
    var pos = 0;
    var spos = 0;
    for (var i = 0; i < op.length; i++) {
      var component = op[i];
      switch (typeof component) {
        case 'number':
          pos += component;
          spos += component;
          break;
        case 'string':
          if (this.onInsert) this.onInsert(pos, component);
          pos += component.length;
          break;
        case 'object':
          if (this.onRemove) this.onRemove(pos, component.d);
          spos += component.d;
      }
    }
  }
};
// This is a prelude which comes before the JS blob of each JS type for the web.
(function(){
  var module = {exports:{}};
  var exports = module.exports;

// These methods let you build a transform function from a transformComponent
// function for OT types like JSON0 in which operations are lists of components
// and transforming them reqreuires N^2 work. I find it kind of nasty that I need
// this, but I'm not really sure what a better solution is. Maybe I should do
// this automatically to types that don't have a compose function defined.

// Add transform and transformX functions for an OT type which has
// transformComponent defined.  transformComponent(destination array,
// component, other component, side)
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    transformComponent(destRight, right, left, 'right');
  };

  var transformX = type.transformX = function(leftOp, rightOp) {
    checkValidOp(leftOp);
    checkValidOp(rightOp);
    var newRightOp = [];

    for (var i = 0; i < rightOp.length; i++) {
      var rightComponent = rightOp[i];

      // Generate newLeftOp by composing leftOp by rightComponent
      var newLeftOp = [];
      var k = 0;
      while (k < leftOp.length) {
        var nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;

        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          for (var j = k; j < leftOp.length; j++) {
            append(newLeftOp, leftOp[j]);
          }
          rightComponent = null;
          break;
        } else {
          // Recurse.
          var pair = transformX(leftOp.slice(k), nextC);
          for (var l = 0; l < pair[0].length; l++) {
            append(newLeftOp, pair[0][l]);
          }
          for (var r = 0; r < pair[1].length; r++) {
            append(newRightOp, pair[1][r]);
          }
          rightComponent = null;
          break;
        }
      }

      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };

  // Transforms op with specified type ('left' or 'right') by otherOp.
  type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right'))
      throw new Error("type must be 'left' or 'right'");

    if (otherOp.length === 0) return op;

    if (op.length === 1 && otherOp.length === 1)
      return transformComponent([], op[0], otherOp[0], type);

    if (type === 'left')
      return transformX(op, otherOp)[0];
    else
      return transformX(otherOp, op)[1];
  };
};
// DEPRECATED!
//
// This type works, but is not exported, and will be removed in a future version of this library.


// A simple text implementation
//
// Operations are lists of components.
// Each component either inserts or deletes at a specified position in the document.
//
// Components are either:
//  {i:'str', p:100}: Insert 'str' at position 100 in the document
//  {d:'str', p:100}: Delete 'str' at position 100 in the document
//
// Components in an operation are executed sequentially, so the position of components
// assumes previous components have already executed.
//
// Eg: This op:
//   [{i:'abc', p:0}]
// is equivalent to this op:
//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]

// NOTE: The global scope here is shared with other sharejs files when built with closure.
// Be careful what ends up in your namespace.

var text = module.exports = {
  name: 'text0',
  uri: 'http://sharejs.org/types/textv0',
  create: function(initial) {
    if ((initial != null) && typeof initial !== 'string') {
      throw new Error('Initial data must be a string');
    }
    return initial || '';
  }
};

/** Insert s2 into s1 at pos. */
var strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

/** Check that an operation component is valid. Throws if its invalid. */
var checkValidComponent = function(c) {
  if (typeof c.p !== 'number')
    throw new Error('component missing position field');

  if ((typeof c.i === 'string') === (typeof c.d === 'string'))
    throw new Error('component needs an i or d field');

  if (c.p < 0)
    throw new Error('position cannot be negative');
};

/** Check that an operation is valid */
var checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
    checkValidComponent(op[i]);
  }
};

/** Apply op to snapshot */
text.apply = function(snapshot, op) {
  var deleted;

  checkValidOp(op);
  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted)
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");

      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

/**
 * Append a component to the end of newOp. Exported for use by the random op
 * generator and the JSON0 type.
 */
var append = text._append = function(newOp, c) {
  if (c.i === '' || c.d === '') return;

  if (newOp.length === 0) {
    newOp.push(c);
  } else {
    var last = newOp[newOp.length - 1];

    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
      // Compose the insert into the previous insert
      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};

    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
      // Compose the deletes together
      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};

    } else {
      newOp.push(c);
    }
  }
};

/** Compose op1 and op2 together */
text.compose = function(op1, op2) {
  checkValidOp(op1);
  checkValidOp(op2);
  var newOp = op1.slice();
  for (var i = 0; i < op2.length; i++) {
    append(newOp, op2[i]);
  }
  return newOp;
};

/** Clean up an op */
text.normalize = function(op) {
  var newOp = [];

  // Normalize should allow ops which are a single (unwrapped) component:
  // {i:'asdf', p:23}.
  // There's no good way to test if something is an array:
  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  // so this is probably the least bad solution.
  if (op.i != null || op.p != null) op = [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = 0;

    append(newOp, c);
  }

  return newOp;
};

// This helper method transforms a position by an op component.
//
// If c is an insert, insertAfter specifies whether the transform
// is pushed after the insert (true) or before it (false).
//
// insertAfter is optional for deletes.
var transformPosition = function(pos, c, insertAfter) {
  // This will get collapsed into a giant ternary by uglify.
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    // I think this could also be written as: Math.min(c.p, Math.min(c.p -
    // otherC.p, otherC.d.length)) but I think its harder to read that way, and
    // it compiles using ternary operators anyway so its no slower written like
    // this.
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

// Helper method to transform a cursor position as a result of an op.
//
// Like transformPosition above, if c is an insert, insertAfter specifies
// whether the cursor position is pushed after an insert (true) or before it
// (false).
text.transformCursor = function(position, op, side) {
  var insertAfter = side === 'right';
  for (var i = 0; i < op.length; i++) {
    position = transformPosition(position, op[i], insertAfter);
  }

  return position;
};

// Transform an op component by another op component. Asymmetric.
// The result will be appended to destination.
//
// exported for use in JSON type
var transformComponent = text._tc = function(dest, c, otherC, side) {
  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidComponent(c);
  checkValidComponent(otherC);

  if (c.i != null) {
    // Insert.
    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});
  } else {
    // Delete
    if (otherC.i != null) {
      // Delete vs insert
      var s = c.d;
      if (c.p < otherC.p) {
        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '')
        append(dest, {d: s, p: c.p + otherC.i.length});

    } else {
      // Delete vs delete
      if (c.p >= otherC.p + otherC.d.length)
        append(dest, {d: c.d, p: c.p - otherC.d.length});
      else if (c.p + c.d.length <= otherC.p)
        append(dest, c);
      else {
        // They overlap somewhere.
        var newC = {d: '', p: c.p};

        if (c.p < otherC.p)
          newC.d = c.d.slice(0, otherC.p - c.p);

        if (c.p + c.d.length > otherC.p + otherC.d.length)
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);

        // This is entirely optional - I'm just checking the deleted text in
        // the two ops matches
        var intersectStart = Math.max(c.p, otherC.p);
        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect)
          throw new Error('Delete ops delete different text in the same region of the document');

        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }

  return dest;
};

var invertComponent = function(c) {
  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};
};

// No need to use append for invert, because the components won't be able to
// cancel one another.
text.invert = function(op) {
  // Shallow copy & reverse that sucka.
  op = op.slice().reverse();
  for (var i = 0; i < op.length; i++) {
    op[i] = invertComponent(op[i]);
  }
  return op;
};

exports._bootstrapTransform(text, transformComponent, checkValidOp, append);

/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};

/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
if (typeof text === 'undefined')
  var text = window.ottypes.text;

/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);


module.exports = json;
// This is included after the JS for each type when we build for the web.

  var _types = window.ottypes = window.ottypes || {};
  var _t = module.exports;
  _types[_t.name] = _t;

  if (_t.uri) _types[_t.uri] = _t;
})();
// JSON document API for the 'json0' type.

(function() {
  var __slice = [].slice;
  var _types = typeof brequire !== 'undefined' ? brequire('ottypes') : window.ottypes;
  var _type = _types['http://sharejs.org/types/JSONv0'];

  // Helpers

  function depath(path) {
    if (path.length === 1 && path[0].constructor === Array) {
      return path[0];
    } else {
      return path;
    }
  }

  function traverse(snapshot, path) {
    var key = 'data';
    var elem = { data: snapshot };

    for (var i = 0; i < path.length; i++) {
      elem = elem[key];
      if (typeof elem === 'undefined') {
        throw new Error('bad path');
      }
      key = path[i];
    }

    return {
      elem: elem,
      key: key
    };
  }

  function pathEquals(p1, p2) {
    if (p1.length !== p2.length) {
      return false;
    }
    for (var i = 0; i < p1.length; ++i) {
      if (p1[i] !== p2[i]) {
        return false;
      }
    }
    return true;
  }

  function containsPath(p1, p2) {
    if (p1.length < p2.length) return false;
    return pathEquals( p1.slice(0,p2.length), p2);
  }

  // does nothing, used as a default callback
  function nullFunction(){}

  // helper for creating functions with the method signature func([path],arg1,arg2,...,[cb])
  // populates an array of arguments with a default path and callback
  function normalizeArgs(obj,args,func){
    args = Array.prototype.slice.call(args);
    var path_prefix = obj.path || [];

    if (func.length > 1 && typeof args[args.length-1] !== 'function') {
      args.push(nullFunction);
    }

    if (args.length < func.length) {
      args.unshift(path_prefix);
    } else {
      args[0] = path_prefix.concat(args[0]);
    }

    return func.apply(obj,args);
  };


  // SubDoc
  // this object is returned from context.createContextAt()

  var SubDoc = function(context, path) {
    this.context = context;
    this.path = path || [];
  };

  SubDoc.prototype._updatePath = function(op){
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      if(c.lm !== undefined && containsPath(this.path,c.p)){
        var new_path_prefix = c.p.slice(0,c.p.length-1);
        new_path_prefix.push(c.lm);
        this.path = new_path_prefix.concat(this.path.slice(new_path_prefix.length));
      }
    }
  };

  SubDoc.prototype.createContextAt = function() {
    var path = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.context.createContextAt(this.path.concat(depath(path)));
  };

  SubDoc.prototype.get = function(path) {
    return normalizeArgs(this,arguments,function(path){
      return this.context.get(path);
    });
  };

  SubDoc.prototype.set = function(path,value,cb) {
    return normalizeArgs(this,arguments,function(path,value,cb){
      return this.context.set(path, value, cb);
    });
  };

  SubDoc.prototype.insert = function(path, pos, value, cb) {
    return normalizeArgs(this,arguments,function(path, pos, value, cb){
      return this.context.insert(path, pos, value, cb);
    });
  };

  SubDoc.prototype.remove = function(path, cb) {
    return normalizeArgs(this,arguments,function(path, cb) {
      return this.context.remove(path, cb);
    });
  };

  SubDoc.prototype.push = function(path, value, cb) {
    return normalizeArgs(this,arguments,function(path, value, cb) {
      return this.context.insert(path, this.get().length, value, cb);
    });
  };

  SubDoc.prototype.move = function(path, from, to, cb) {
    return normalizeArgs(this,arguments,function(path, from, to, cb) {
      return this.context.move(path, from, to, cb);
    });
  };

  SubDoc.prototype.add = function(path, amount, cb) {
    return normalizeArgs(this,arguments,function(path, amount, cb) {
      return this.context.add(path, amount, cb);
    });
  };

  SubDoc.prototype.on = function(event, cb) {
    return this.context.addListener(this.path, event, cb);
  };

  SubDoc.prototype.removeListener = function(l) {
    return this.context.removeListener(l);
  };

  SubDoc.prototype.getLength = function(path) {
    return normalizeArgs(this,arguments,function(path) {
      return this.context.getLength(path);
    });
  };

  SubDoc.prototype.getText = function(path) {
    return normalizeArgs(this,arguments,function(path) {
      return this.context.getText(path);
    });
  };
  
  SubDoc.prototype.deleteText = function(path, pos, length, cb) {
    return normalizeArgs(this,arguments,function(path, pos, length, cb) {
      return this.context.deleteText(path, length, pos, cb);
    });
  };

  SubDoc.prototype.destroy = function() {
    this.context._removeSubDoc(this);
  };


  // JSON API methods
  // these methods are mixed in to the context return from doc.createContext()

  _type.api = {

    provides: {
      json: true
    },

    _fixComponentPaths: function(c) {
      if (!this._listeners) {
        return;
      }
      if (c.na !== undefined || c.si !== undefined || c.sd !== undefined) {
        return;
      }

      var to_remove = [];
      var _ref = this._listeners;

      for (var i = 0; i < _ref.length; i++) {
        var l = _ref[i];
        var dummy = {
          p: l.path,
          na: 0
        };
        var xformed = _type.transformComponent([], dummy, c, 'left');
        if (xformed.length === 0) {
          to_remove.push(i);
        } else if (xformed.length === 1) {
          l.path = xformed[0].p;
        } else {
          throw new Error("Bad assumption in json-api: xforming an 'na' op will always result in 0 or 1 components.");
        }
      }

      to_remove.sort(function(a, b) {
        return b - a;
      });

      var _results = [];
      for (var j = 0; j < to_remove.length; j++) {
        i = to_remove[j];
        _results.push(this._listeners.splice(i, 1));
      }

      return _results;
    },

    _fixPaths: function(op) {
      var _results = [];
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        _results.push(this._fixComponentPaths(c));
      }
      return _results;
    },

    _submit: function(op, callback) {
      this._fixPaths(op);
      return this.submitOp(op, callback);
    },

    _addSubDoc: function(subdoc){
      this._subdocs || (this._subdocs = []);
      this._subdocs.push(subdoc);
    },

    _removeSubDoc: function(subdoc){
      this._subdocs || (this._subdocs = []);
      for(var i = 0; i < this._subdocs.length; i++){
        if(this._subdocs[i] === subdoc) this._subdocs.splice(i,1);
        return;
      }
    },

    _updateSubdocPaths: function(op){
      this._subdocs || (this._subdocs = []);
      for(var i = 0; i < this._subdocs.length; i++){
        this._subdocs[i]._updatePath(op);
      }
    },

    createContextAt: function() {
      var path = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      var subdoc =  new SubDoc(this, depath(path));
      this._addSubDoc(subdoc);
      return subdoc;
    },

    get: function(path) {
      if (!path) return this.getSnapshot();  
      
      var _ref = traverse(this.getSnapshot(), path);
      return _ref.elem[_ref.key];
    },

    set: function(path, value, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var elem = _ref.elem;
        var key = _ref.key;
        var op = {
          p: path
        };

        if (elem.constructor === Array) {
          op.li = value;
          if (typeof elem[key] !== 'undefined') {
            op.ld = elem[key];
          }
        } else if (typeof elem === 'object') {
          op.oi = value;
          if (typeof elem[key] !== 'undefined') {
            op.od = elem[key];
          }
        } else {
          throw new Error('bad path');
        }

        return this._submit([op], cb);
      });
    },

    remove: function(path, cb) {
      return normalizeArgs(this,arguments,function(path, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var elem = _ref.elem;
        var key = _ref.key;
        var op = {
          p: path
        };

        if (typeof elem[key] === 'undefined') {
          throw new Error('no element at that path');
        }

        if (elem.constructor === Array) {
          op.ld = elem[key];
        } else if (typeof elem === 'object') {
          op.od = elem[key];
        } else {
          throw new Error('bad path');
        }

        return this._submit([op], cb);
      });
    },

    insert: function(path, pos, value, cb) {
      return normalizeArgs(this,arguments,function(path, pos, value, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var elem = _ref.elem;
        var key = _ref.key;
        var op = {
          p: path.concat(pos)
        };

        if (elem[key].constructor === Array) {
          op.li = value;
        } else if (typeof elem[key] === 'string') {
          op.si = value;
        }

        return this._submit([op], cb);
      });
    },

    move: function(path, from, to, cb) {
      return normalizeArgs(this,arguments,function(path, from, to, cb) {
        var self = this;
        var op = [
          {
            p: path.concat(from),
            lm: to
          }
        ];

        return this._submit(op, function(){
          self._updateSubdocPaths(op);
          if(cb) cb.apply(cb,arguments);
        });
      });
    },

    push: function(path, value, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        return this.insert(path, this.get().length, value, cb);
      });
    },

    add: function(path, amount, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        var op = [
          {
            p: path,
            na: amount
          }
        ];
        return this._submit(op, cb);
      });
    },

    getLength: function(path) {
        return normalizeArgs(this,arguments,function(path) {
          return this.get(path).length;
        });
    },

    getText: function(path) {
      return normalizeArgs(this,arguments,function(path) {
        return this.get(path);
      });
    },

    deleteText: function(path, length, pos, cb) {
      return normalizeArgs(this,arguments,function(path, length, pos, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var op = [
          {
            p: path.concat(pos),
            sd: _ref.elem[_ref.key].slice(pos, pos + length)
          }
        ];

        return this._submit(op, cb);
      });
    },

    addListener: function(path, event, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        var listener = {
          path: path,
          event: event,
          cb: cb
        };
        this._listeners || (this._listeners = []);
        this._listeners.push(listener);
        return listener;
      });
    },

    removeListener: function(listener) {
      if (!this._listeners) {
        return;
      }
      var i = this._listeners.indexOf(listener);
      if (i < 0) {
        return false;
      }
      this._listeners.splice(i, 1);
      return true;
    },

    _onOp: function(op) {
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        this._fixComponentPaths(c);

        if(c.lm !== undefined) {
          this._updateSubdocPaths([c]);
        }

        var match_path = c.na === undefined ? c.p.slice(0, c.p.length - 1) : c.p;

        for (var l = 0; l < this._listeners.length; l++) {
          var listener = this._listeners[l];
          var cb = listener.cb;

          if (pathEquals(listener.path, match_path)) {
            switch (listener.event) {
              case 'insert':
                if (c.li !== undefined && c.ld === undefined) {
                  cb(c.p[c.p.length - 1], c.li);
                } else if (c.oi !== undefined && c.od === undefined) {
                  cb(c.p[c.p.length - 1], c.oi);
                } else if (c.si !== undefined) {
                  cb(c.p[c.p.length - 1], c.si);
                }
                break;
              case 'delete':
                if (c.li === undefined && c.ld !== undefined) {
                  cb(c.p[c.p.length - 1], c.ld);
                } else if (c.oi === undefined && c.od !== undefined) {
                  cb(c.p[c.p.length - 1], c.od);
                } else if (c.sd !== undefined) {
                  cb(c.p[c.p.length - 1], c.sd);
                }
                break;
              case 'replace':
                if (c.li !== undefined && c.ld !== undefined) {
                  cb(c.p[c.p.length - 1], c.ld, c.li);
                } else if (c.oi !== undefined && c.od !== undefined) {
                  cb(c.p[c.p.length - 1], c.od, c.oi);
                }
                break;
              case 'move':
                if (c.lm !== undefined) {
                  cb(c.p[c.p.length - 1], c.lm);
                }
                break;
              case 'add':
                if (c.na !== undefined) {
                  cb(c.na);
                }
            }
          } else if (_type.canOpAffectOp(listener.path, match_path)
              && listener.event === 'child op') {
            var child_path = c.p.slice(listener.path.length);
            cb(child_path, c);
          }
        }
      }
    }
  };

}).call(this);
// This file is included at the top of the compiled client JS.

// All the modules will just add stuff to exports, and it'll all get exported.
var exports = window.sharejs = {version: '0.7.0'};

// This is a simple rewrite of microevent.js. I've changed the
// function names to be consistent with node.js EventEmitter.
//
// microevent.js is copyright Jerome Etienne, and licensed under the MIT license:
// https://github.com/jeromeetienne/microevent.js

var MicroEvent = function() {};

MicroEvent.prototype.on = function(event, fn) {
  var events = this._events = this._events || {};
  (events[event] = events[event] || []).push(fn);
};

MicroEvent.prototype.removeListener = function(event, fn) {
  var events = this._events = this._events || {};
  var listeners = events[event] = events[event] || [];

  // Sadly, no IE8 support for indexOf.
  var i = 0;
  while (i < listeners.length) {
    if (listeners[i] === fn) {
      listeners[i] = undefined;
    }
    i++;
  }

  // Compact the list when no event handler is actually running.
  setTimeout(function() {
    events[event] = [];
    var fn;
    for (var i = 0; i < listeners.length; i++) {
      // Only add back event handlers which exist.
      if ((fn = listeners[i])) events[event].push(fn);
    }
  }, 0);
};

MicroEvent.prototype.emit = function(event) {
  var events = this._events;
  var args = Array.prototype.splice.call(arguments, 1);

  if (!events || !events[event]) {
    if (event == 'error') {
      if (console) {
        console.error.apply(console, args);
      }
    }
    return;
  }

  var listeners = events[event];
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i]) {
      listeners[i].apply(this, args);
    }
  }
};

MicroEvent.prototype.once = function(event, fn) {
  var listener, _this = this;
  this.on(event, listener = function() {
    _this.removeListener(event, listener);
    fn.apply(_this, arguments);
  });
};

MicroEvent.mixin = function(obj) {
  var proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof module !== "undefined") module.exports = MicroEvent;

var types, MicroEvent;

if (typeof brequire !== "undefined") {
  types = brequire('ottypes');
  MicroEvent = brequire('./microevent');
} else {
  types = window.ottypes;
}

/*
 * A Doc is a client's view on a sharejs document.
 *
 * Documents should not be created directly. Create them by calling the
 * document getting functions in connection.
 *
 * Documents are event emitters. Use doc.on(eventname, fn) to subscribe.
 *
 * Documents currently get mixed in with their type's API methods. So, you can
 * .insert('foo', 0) into a text document and stuff like that.
 *
 * Events:
 * - before op (op, localSite): Fired before an operation is applied to the
 *   document.
 * - op (op, localSite): Fired right after an operation (or part of an
 *   operation) has been applied to the document. Submitting another op here is
 *   invalid - wait until 'after op' if you want to submit more operations.  -
 *   changed (op)
 * - after op (op, localSite): Fired after an operation has been applied. You
 *   can submit more ops here.
 * - subscribed (error): The document was subscribed
 * - unsubscribed (error): The document was unsubscribed
 * - created: The document was created. That means its type was set and it has
 *   some initial data.
 * - error
 */
var Doc = exports.Doc = function(connection, collection, name) {
  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;

  // **** State in document:
 
  // Action. This is either null, or one of the actions (subscribe,
  // unsubscribe, fetch, submit). Only one action can be happening at a time to
  // prevent me from going mad.
  //
  // Possible values:
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit
  this.action = null;
 
  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];
  
  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];
};

MicroEvent.mixin(Doc);

Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    setTimeout(function() {
      // There'll probably be nothing here seeing as how we just unsubscribed.
      for (var i = 0; i < doc._subscribeCallbacks.length; i++) {
        doc._subscribeCallbacks[i]('Document destroyed');
      }
      doc._subscribeCallbacks.length = 0;
    }, 0);

    doc.connection._destroyDoc(doc);
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to injest data that was exported with a webpage and data
// that was received from the server during a fetch.
Doc.prototype.injestData = function(data) {
  if (this.state) {
    if (typeof console !== "undefined") console.warn('Ignoring attempt to injest data in state', this.state);
    return;
  }
  if (typeof data.v !== 'number') throw new Error('Missing version in injested data');


  this.version = data.v;
  this.snapshot = data.snapshot;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.on('ready', fn);
  }
};

Doc.prototype.hasPending = function() {
  return this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error("Got message for wrong document.");
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.injestData(msg.data);
      this._finishSub('fetch', msg.error);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction('fetch');
      break;

    case 'sub':
      // Subscribe reply.
      if (msg.error && msg.error !== 'Already subscribed') {
        if (console) console.error("Could not subscribe: " + msg.error);
        this.emit('error', msg.error);
        // There's probably a reason we couldn't subscribe. Don't retry.
        this._setWantSubscribe(false, null, msg.error)
      } else {
        if (msg.data) this.injestData(msg.data);
        this.subscribed = true;
        this.emit('subscribe');
        this._finishSub(true);
      }

      this._clearAction('subscribe');
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._finishSub(false, msg.error);
      this._clearAction('unsubscribe');
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed). However, if the op doesn't get accepted, we still need to
      // clear some state.
      //
      // If the message error is 'Op already submitted', that means we've
      // resent an op that the server already got. It will also be confirmed
      // normally.
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for some reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
          this._tryRollback(this.inflightData);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          if (console) console.warn('Second acknowledgement message (error) received', msg, this);
        }
          
        this._clearInflightOp(msg.error);
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v !== this.version) {
        // I should add the name of the document to all errors - mostly this is
        // to track down one particular bug.
        this.emit('error', 'In document ' + this.name + ' expected version ' + this.version + ' but got ' + msg.v);
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      this._afterOtApply(msg, false);
      //console.log('applied', JSON.stringify(msg));
      break;

    case 'meta':
      if (console) console.warn('Unhandled meta op:', msg);
      break;

    default:
      if (console) console.warn('Unhandled document message:', msg);
      break;
  }
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting') {
    if (this.inflightData) {
      this._sendOpData();
    } else {
      this.flush();
    }
  } else if (state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again.
    this.flush();
  } else if (state === 'disconnected') {
    this.action = null;
    this.subscribed = false;
    if (this.subscribed) this.emit('unsubscribed');
  }
};




// ****** Dealing with actions

Doc.prototype._clearAction = function(expectedAction) {
  if (this.action !== expectedAction) {
    console.warn('Unexpected action ' + this.action + ' expected: ' + expectedAction);
  }
  this.action = null;
  this.flush();
};



// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // First consider changing state
  if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    this._send(this.state === 'ready' ? {a:'sub', v:this.version} : {a:'sub'});
  } else if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in 
    this.inflightData = this.pendingData.shift();

    // Delay for debugging.
    //var that = this;
    //setTimeout(function() { that._sendOpData(); }, 1000);

    // This also sets action to 'submit'.
    this._sendOpData();
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }
  
  if (!this.wantSubscribe !== !value) {
    // Call all the current subscribe/unsubscribe callbacks.
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      // Should I return an error here? What happened is the user unsubcribed
      // with a callback then resubscribed straight after. Does that mean the
      // unsubscribe failed?
      this._subscribeCallbacks[i](err);
    }
    this._subscribeCallbacks.length = 0;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(value, error) {
  if (value === this.wantSubscribe) {
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      this._subscribeCallbacks[i](error);
    }
    this._subscribeCallbacks.length = 0;
  }
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug.');

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    //console.log('xf', JSON.stringify(client.op), JSON.stringify(server.op));
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
    //console.log('->', JSON.stringify(client.op), JSON.stringify(server.op));
  }
};

// Internal method to actually apply the given op data to our local model.
//
// _afterOtApply() should always be called synchronously afterwards.
Doc.prototype._otApply = function(opData, context) {
  // Lock the document. Nobody is allowed to call submitOp() until _afterOtApply is called.
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist');

    var type = this.type;

    var op = opData.op;
    
    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.
};

// This should be called right after _otApply.
Doc.prototype._afterOtApply = function(opData, context) {
  this.locked = false;
  this.emit('unlock');
  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts.remove) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('invalid state ' + this.action + ' for sendOpData');
  this.action = 'submit';

  var msg = {a:'op', v:this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  // The server autodetects this.
  //if (this.state === 'unsubscribed') msg.f = true; // fetch intermediate ops

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);
   
  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Internal method called to do the actual work for submitOp(), create() and del().
//
// context is optional.
Doc.prototype._submitOpData = function(opData, context, callback) {
  //console.log('submit', JSON.stringify(opData), 'v=', this.version);

  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) callback(err);
    else if (console) console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler");
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).

  if (opData.op) {
    if (!this.type) return error('Document has not been created');

    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  // Actually apply the operation locally.
  this._otApply(opData, context);

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var entry = this.pendingData[this.pendingData.length - 1];

  if (this.pendingData.length &&
      (entry = this.pendingData[this.pendingData.length - 1],
       tryCompose(this.type, entry, opData))) {
  } else {
    entry = opData;
    opData.type = this.type;
    opData.callbacks = [];
    this.pendingData.push(opData);
  }

  if (callback) entry.callbacks.push(callback);

  this._afterOtApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn't matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document. The op must be valid given the current OT type.
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }
  if (this.type) {
    if (callback) callback('Document already exists');
    return 
  }

  this._submitOpData({create: {type:type, data:data}}, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Pausing stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    var undo = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], undo);
    }

    // ... and apply it locally, reverting the changes.
    // 
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(undo, false);
    this._afterOtApply(undo, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this._clearAction('submit');

  if (!this.pendingData.length) {
    // This isn't a very good name.
    this.emit('nothing pending');
  }
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen.');
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op.');

    // Our create has been acknowledged. This is the same as injesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version)
      throw new Error('Invalid version from server. Please file an issue, this is a bug.');
  }
  
  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// API Contexts

// This creates and returns an editing context using the current OT type.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type');

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      delete this._onOp;
      this.remove = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};

Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};

// A Connection wraps a persistant BC connection to a sharejs server.
//
// This class implements the client side of the protocol defined here:
// https://github.com/josephg/ShareJS/wiki/Wire-Protocol
//
// The equivalent server code is in src/server/session.
//
// This file is a bit of a mess. I'm dreadfully sorry about that. It passes all the tests,
// so I have hope that its *correct* even if its not clean.
//
// To make a connection, use:
//  new sharejs.Connection(socket)
//
// The socket should look like a websocket connection. It should have the following properties:
//  send(msg): Send the given message. msg may be an object - if so, you might need to JSON.stringify it.
//  close(): Disconnect the session
//
//  onmessage = function(msg){}: Event handler which is called whenever a message is received. The message
//     passed in should already be an object. (It may need to be JSON.parsed)
//  onclose
//  onerror
//  onopen
//  onconnecting
//
// The socket should probably automatically reconnect. If so, it should emit the appropriate events as it
// disconnects & reconnects. (onclose(), onconnecting(), onopen()).

var types, Doc;
if (typeof brequire !== 'undefined') {
  types = brequire('ottypes');
  Doc = brequire('./doc').Doc;
  Query = brequire('./query').Query;
} else {
  types = window.ottypes;
  Doc = exports.Doc;
}

var Connection = exports.Connection = function (socket) {
  this.socket = socket;

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // Connection state.
  // 
  // States:
  // - 'connecting': The connection has been established, but we don't have our client ID yet
  // - 'connected': We have connected and recieved our client ID. Ready for data.
  // - 'disconnected': The connection is closed, but it will reconnect automatically.
  // - 'stopped': The connection is closed, and should not reconnect.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if the state is 'connecting' or 'connected'.
  this.canSend = this.state === 'connecting';

  // Reset some more state variables.
  this.reset();

  this.debug = false;
  // I'll store the most recent 100 messages so when errors occur we can see what happened.
  this.messageBuffer = [];

  var connection = this;

  var handleMessage = function(msg) {
    // Switch on the message action. Most messages are for documents and are
    // handled in the doc class.
    switch (msg.a) {
      case 'init':
        // Client initialization packet. This bundle of joy contains our client
        // ID.
        if (msg.protocol !== 0) throw new Error('Invalid protocol version');
        if (typeof msg.id != 'string') throw new Error('Invalid client id');

        connection.id = msg.id;
        connection._setState('connected');
        break;

      case 'qfetch':
      case 'qsub':
      case 'q':
      case 'qunsub':
        // Query message. Pass this to the appropriate query object.
        var query = connection.queries[msg.id];
        if (query) query._onMessage(msg);
        break;

      default:
        // Document message. Pull out the referenced document and forward the
        // message.
        var collection, docName, doc;
        if (msg.d) {
          collection = connection._lastReceivedCollection = msg.c;
          docName = connection._lastReceivedDoc = msg.d;
        } else {
          collection = msg.c = connection._lastReceivedCollection;
          docName = msg.d = connection._lastReceivedDoc;
        }

        doc = connection.get(collection, docName);
        if (!doc) {
          if (console) console.error('Message for unknown doc. Ignoring.', msg);
          break;
        }
        doc._onMessage(msg);
    }
  };

  // Attach event handlers to the socket.
  socket.onmessage = function(msg) {
    if (connection.debug) console.log('RECV', JSON.stringify(msg));
    connection.messageBuffer.push({t:(new Date()).toTimeString(), recv:JSON.stringify(msg)});
    while (connection.messageBuffer.length > 100) {
      connection.messageBuffer.shift();
    }

    try {
      handleMessage(msg);
    } catch (e) {
      connection.emit('error', e);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
    }
  }

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
}

/* Why does this function exist? Is it important?
Connection.prototype._error = function(e) {
  this._setState('stopped', e);
  return this.disconnect(e);
};
*/

Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};

// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = newState === 'connecting' || newState === 'connected';

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }

  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }
  this.opQueue = null;
  
  for (var id in this.queries) {
    this.queries[id]._onConnectionStateChanged(newState, data);
  }
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

// Send a message to the connection.
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));
  this.messageBuffer.push({t:(new Date()).toTimeString(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length > 100) {
    this.messageBuffer.shift();
  }

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  this.socket.send(msg);
};

Connection.prototype.disconnect = function() {
  // This will call @socket.onclose(), which in turn will emit the 'disconnected' event.
  this.socket.close();
};


// ***** Document management

Connection.prototype.getExisting = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};

Connection.prototype.getOrCreate = function(collection, name, data) {
  console.trace('getOrCreate is deprecated. Use get() instead');
  return this.get(collection, name, data);
};

// Create a document if it doesn't exist. Returns the document synchronously.
Connection.prototype.get = function(collection, name, data) {
  var doc = this.getExisting(collection, name);

  if (!doc) {
    // Create it.
    doc = new Doc(this, collection, name);

    var collectionObject = this.collections[collection] =
      (this.collections[collection] || {});
    collectionObject[name] = doc;
  }

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.snapshot !== undefined && !doc.state) {
    doc.injestData(data);
  }

  return doc;
};

// Call doc.destroy()
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};
 
function hasKeys(object) {
  for (var key in object) return true;
  return false;
};

// **** Queries.

// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

if (typeof brequire !== 'undefined') {
  MicroEvent = brequire('./microevent');
}

MicroEvent.mixin(Connection);

/* This contains the textarea binding for ShareJS. This binding is really
 * simple, and a bit slow on big documents (Its O(N). However, it brequires no
 * changes to the DOM and no heavy libraries like ace. It works for any kind of
 * text input field.
 *
 * You probably want to use this binding for small fields on forms and such.
 * For code editors or rich text editors or whatever, I recommend something
 * heavier.
 */


/* applyChange creates the edits to convert oldval -> newval.
 *
 * This function should be called every time the text element is changed.
 * Because changes are always localised, the diffing is quite easy. We simply
 * scan in from the start and scan in from the end to isolate the edited range,
 * then delete everything that was removed & add everything that was added.
 * This wouldn't work for complex changes, but this function should be called
 * on keystroke - so the edits will mostly just be single character changes.
 * Sometimes they'll paste text over other text, but even then the diff
 * generated by this algorithm is correct.
 *
 * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.
 */
var applyChange = function(ctx, oldval, newval) {
  // Strings are immutable and have reference equality. I think this test is O(1), so its worth doing.
  if (oldval === newval) return;

  var commonStart = 0;
  while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {
    commonStart++;
  }

  var commonEnd = 0;
  while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) &&
      commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {
    commonEnd++;
  }

  if (oldval.length !== commonStart + commonEnd) {
    ctx.remove(commonStart, oldval.length - commonStart - commonEnd);
  }
  if (newval.length !== commonStart + commonEnd) {
    ctx.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));
  }
};

// Attach a textarea to a document's editing context.
//
// The context is optional, and will be created from the document if its not
// specified.
window.sharejs.Doc.prototype.attachTextarea = function(elem, ctx) {
  if (!ctx) ctx = this.createContext();

  if (!ctx.provides.text) throw new Error('Cannot attach to non-text document');

  elem.value = ctx.getText();

  // The current value of the element's text is stored so we can quickly check
  // if its been changed in the event handlers. This is mostly for browsers on
  // windows, where the content contains \r\n newlines. applyChange() is only
  // called after the \r\n newlines are converted, and that check is quite
  // slow. So we also cache the string before conversion so we can do a quick
  // check incase the conversion isn't needed.
  var prevvalue;

  // Replace the content of the text area with newText, and transform the
  // current cursor by the specified function.
  var replaceText = function(newText, transformCursor) {
    if (transformCursor) {
      var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
    }

    // Fixate the window's scroll while we set the element's value. Otherwise
    // the browser scrolls to the element.
    var scrollTop = elem.scrollTop;
    elem.value = newText;
    prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.
    if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;

    // Setting the selection moves the cursor. We'll just have to let your
    // cursor drift if the element isn't active, though usually users don't
    // care.
    if (newSelection && window.document.activeElement === elem) {
      elem.selectionStart = newSelection[0];
      elem.selectionEnd = newSelection[1];
    }
  };

  replaceText(ctx.getText());


  // *** remote -> local changes

  ctx.onInsert = function(pos, text) {
    var transformCursor = function(cursor) {
      return pos < cursor ? cursor + text.length : cursor;
    };

    // Remove any window-style newline characters. Windows inserts these, and
    // they mess up the generated diff.
    var prev = elem.value.replace(/\r\n/g, '\n');
    replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);
  };

  ctx.onRemove = function(pos, length) {
    var transformCursor = function(cursor) {
      // If the cursor is inside the deleted region, we only want to move back to the start
      // of the region. Hence the Math.min.
      return pos < cursor ? cursor - Math.min(length, cursor - pos) : cursor;
    };

    var prev = elem.value.replace(/\r\n/g, '\n');
    replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);
  };


  // *** local -> remote changes

  // This function generates operations from the changed content in the textarea.
  var genOp = function(event) {
    // In a timeout so the browser has time to propogate the event's changes to the DOM.
    setTimeout(function() {
      if (elem.value !== prevvalue) {
        prevvalue = elem.value;
        applyChange(ctx, ctx.getText(), elem.value.replace(/\r\n/g, '\n'));
      }
    }, 0);
  };

  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
  for (var i = 0; i < eventNames.length; i++) {
    var e = eventNames[i];
    if (elem.addEventListener) {
      elem.addEventListener(e, genOp, false);
    } else {
      elem.attachEvent('on' + e, genOp);
    }
  }

  ctx.detach = function() {
    for (var i = 0; i < eventNames.length; i++) {
      var e = eventNames[i];
      if (elem.removeEventListener) {
        elem.removeEventListener(e, genOp, false);
      } else {
        elem.detachEvent('on' + e, genOp);
      }
    }
  };

  return ctx;
};

var Doc;
if (typeof brequire !== 'undefined') {
  Doc = brequire('./doc').Doc;
}

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] = collectionVersions[doc.collection] || {};
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
    // Force the document to know its subscribed if we're in docmode:subscribe.
    if (this.docMode === 'sub') {
      doc.subscribed = true; // Set before setWantSubscribe() so flush doesn't send a subscribe request.
      doc._setWantSubscribe(true); // this will call any subscribe callbacks or whatever.
      doc.emit('subscribe');
      doc._finishSub(true); // this doesn't actually do anything here, but its more correct to have it.
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll injest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

var MicroEvent;
if (typeof brequire !== 'undefined') {
  MicroEvent = brequire('./microevent');
}

MicroEvent.mixin(Query);

})();

},{}],27:[function(require,module,exports){
module.exports = function genid(len, prefix, keyspace) {
  if (len == null) {
    len = 32;
  }
  if (prefix == null) {
    prefix = "";
  }
  if (keyspace == null) {
    keyspace = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  }
  while (len-- > 0) {
    prefix += keyspace.charAt(Math.floor(Math.random() * keyspace.length));
  }
  return prefix;
};
},{}],28:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var isFunction = require('lodash.isfunction'),
    isObject = require('lodash.isobject'),
    reNative = require('lodash._renative');

/** Used as a safe reference for `undefined` in pre ES5 environments */
var undefined;

/** Used for native method references */
var objectProto = Object.prototype;

/** Native method shortcuts */
var now = reNative.test(now = Date.now) && now || function() { return +new Date; };

/* Native method shortcuts for methods with the same name as other `lodash` methods */
var nativeMax = Math.max;

/**
 * Creates a function that will delay the execution of `func` until after
 * `wait` milliseconds have elapsed since the last time it was invoked.
 * Provide an options object to indicate that `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
 * to the debounced function will return the result of the last `func` call.
 *
 * Note: If `leading` and `trailing` options are `true` `func` will be called
 * on the trailing edge of the timeout only if the the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * @static
 * @memberOf _
 * @category Functions
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
 * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // avoid costly calculations while the window size is in flux
 * var lazyLayout = _.debounce(calculateLayout, 150);
 * jQuery(window).on('resize', lazyLayout);
 *
 * // execute `sendMail` when the click event is fired, debouncing subsequent calls
 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * });
 *
 * // ensure `batchLog` is executed once after 1 second of debounced calls
 * var source = new EventSource('/stream');
 * source.addEventListener('message', _.debounce(batchLog, 250, {
 *   'maxWait': 1000
 * }, false);
 */
function debounce(func, wait, options) {
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (!isFunction(func)) {
    throw new TypeError;
  }
  wait = nativeMax(0, wait) || 0;
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (isObject(options)) {
    leading = options.leading;
    maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function() {
    var remaining = wait - (now() - stamp);
    if (remaining <= 0) {
      if (maxTimeoutId) {
        clearTimeout(maxTimeoutId);
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (isCalled) {
        lastCalled = now();
        result = func.apply(thisArg, args);
      }
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  };

  var maxDelayed = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (trailing || (maxWait !== wait)) {
      lastCalled = now();
      result = func.apply(thisArg, args);
    }
  };

  return function() {
    args = arguments;
    stamp = now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled);
      if (remaining <= 0) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result = func.apply(thisArg, args);
      }
      else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      result = func.apply(thisArg, args);
    }
    return result;
  };
}

module.exports = debounce;

},{"lodash._renative":29,"lodash.isfunction":30,"lodash.isobject":31}],29:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

/** Used for native method references */
var objectProto = Object.prototype;

/** Used to detect if a method is native */
var reNative = RegExp('^' +
  String(objectProto.valueOf)
    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    .replace(/valueOf|for [^\]]+/g, '.+?') + '$'
);

module.exports = reNative;

},{}],30:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

/**
 * Checks if `value` is a function.
 *
 * @static
 * @memberOf _
 * @category Objects
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 */
function isFunction(value) {
  return typeof value == 'function';
}

module.exports = isFunction;

},{}],31:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var objectTypes = require('lodash._objecttypes');

/**
 * Checks if `value` is the language type of Object.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Objects
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // check if the value is the ECMAScript language type of Object
  // http://es5.github.io/#x8
  // and avoid a V8 bug
  // http://code.google.com/p/v8/issues/detail?id=2291
  return !!(value && objectTypes[typeof value]);
}

module.exports = isObject;

},{"lodash._objecttypes":32}],32:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

/** Used to determine if values are of the language type Object */
var objectTypes = {
  'boolean': false,
  'function': true,
  'object': true,
  'number': false,
  'string': false,
  'undefined': false
};

module.exports = objectTypes;

},{}],33:[function(require,module,exports){
(function(){
(function(){var r={exports:{}},e=r.exports;e.name="text",e.uri="http://sharejs.org/types/textv1",e.create=function(r){if(null!=r&&"string"!=typeof r)throw Error("Initial data must be a string");return r||""};var t=Array.isArray||function(r){return"[object Array]"===Object.prototype.toString.call(r)},n=function(r){if(!t(r))throw Error("Op must be an array of components");for(var e=null,n=0;r.length>n;n++){var o=r[n];switch(typeof o){case"object":if(!("number"==typeof o.d&&o.d>0))throw Error("Object components must be deletes of size > 0");break;case"string":if(!(o.length>0))throw Error("Inserts cannot be empty");break;case"number":if(!(o>0))throw Error("Skip components must be >0");if("number"==typeof e)throw Error("Adjacent skip components should be combined")}e=o}if("number"==typeof e)throw Error("Op has a trailing skip")},o=function(r){return function(e){return e&&0!==e.d?0===r.length?r.push(e):typeof e==typeof r[r.length-1]?"object"==typeof e?r[r.length-1].d+=e.d:r[r.length-1]+=e:r.push(e):void 0}},s=function(r){var e=0,t=0,n=function(n,o){if(e===r.length)return-1===n?null:n;var s,i=r[e];return"number"==typeof i?-1===n||n>=i-t?(s=i-t,++e,t=0,s):(t+=n,n):"string"==typeof i?-1===n||"i"===o||n>=i.length-t?(s=i.slice(t),++e,t=0,s):(s=i.slice(t,t+n),t+=n,s):-1===n||"d"===o||n>=i.d-t?(s={d:i.d-t},++e,t=0,s):(t+=n,{d:n})},o=function(){return r[e]};return[n,o]},i=function(r){return"number"==typeof r?r:r.length||r.d},a=function(r){return r.length>0&&"number"==typeof r[r.length-1]&&r.pop(),r};e.normalize=function(r){for(var e=[],t=o(e),n=0;r.length>n;n++)t(r[n]);return a(e)},e.apply=function(r,e){if("string"!=typeof r)throw Error("Snapshot should be a string");n(e);for(var t=[],o=0;e.length>o;o++){var s=e[o];switch(typeof s){case"number":if(s>r.length)throw Error("The op is too long for this document");t.push(r.slice(0,s)),r=r.slice(s);break;case"string":t.push(s);break;case"object":r=r.slice(s.d)}}return t.join("")+r},e.transform=function(r,e,t){if("left"!=t&&"right"!=t)throw Error("side ("+t+") must be 'left' or 'right'");n(r),n(e);for(var c=[],f=o(c),u=s(r),h=u[0],p=u[1],b=0;e.length>b;b++){var l,g,m=e[b];switch(typeof m){case"number":for(l=m;l>0;)g=h(l,"i"),f(g),"string"!=typeof g&&(l-=i(g));break;case"string":"left"===t&&"string"==typeof p()&&f(h(-1)),f(m.length);break;case"object":for(l=m.d;l>0;)switch(g=h(l,"i"),typeof g){case"number":l-=g;break;case"string":f(g);break;case"object":l-=g.d}}}for(;m=h(-1);)f(m);return a(c)},e.compose=function(r,e){n(r),n(e);for(var t=[],c=o(t),f=s(r)[0],u=0;e.length>u;u++){var h,p,b=e[u];switch(typeof b){case"number":for(h=b;h>0;)p=f(h,"d"),c(p),"object"!=typeof p&&(h-=i(p));break;case"string":c(b);break;case"object":for(h=b.d;h>0;)switch(p=f(h,"d"),typeof p){case"number":c({d:p}),h-=p;break;case"string":h-=p.length;break;case"object":c(p)}}}for(;b=f(-1);)c(b);return a(t)};var c=function(r,e){for(var t=0,n=0;e.length>n;n++){var o=e[n];if(t>=r)break;switch(typeof o){case"number":if(t+o>=r)return r;t+=o;break;case"string":t+=o.length,r+=o.length;break;case"object":r-=Math.min(o.d,r-t)}}return r};e.transformCursor=function(r,e,t){var n=0;if(t){for(var o=0;e.length>o;o++){var s=e[o];switch(typeof s){case"number":n+=s;break;case"string":n+=s.length}}return[n,n]}return[c(r[0],e),c(r[1],e)]};var f=window.ottypes=window.ottypes||{},u=r.exports;f[u.name]=u,u.uri&&(f[u.uri]=u)})();// Text document API for the 'text' type.

// The API implements the standard text API methods. In particular:
//
// - getLength() returns the length of the document in characters
// - getText() returns a string of the document
// - insert(pos, text, [callback]) inserts text at position pos in the document
// - remove(pos, length, [callback]) removes length characters at position pos
//
// Events are implemented by just adding the appropriate methods to your
// context object.
// onInsert(pos, text): Called when text is inserted.
// onRemove(pos, length): Called when text is removed.

var _types = (typeof brequire !== 'undefined') ?
  brequire('ottypes') : window.ottypes;

_types['http://sharejs.org/types/textv1'].api = {
  provides: {text: true},
  
  // Returns the number of characters in the string
  getLength: function() { return this.getSnapshot().length; },

  // Returns the text content of the document
  getText: function() { return this.getSnapshot(); },

  // Insert the specified text at the given position in the document
  insert: function(pos, text, callback) {
    return this.submitOp([pos, text], callback);
  },

  remove: function(pos, length, callback) {
    return this.submitOp([pos, {d:length}], callback);
  },

  // When you use this API, you should implement these two methods
  // in your editing context.
  //onInsert: function(pos, text) {},
  //onRemove: function(pos, removedLength) {},

  _onOp: function(op) {
    var pos = 0;
    var spos = 0;
    for (var i = 0; i < op.length; i++) {
      var component = op[i];
      switch (typeof component) {
        case 'number':
          pos += component;
          spos += component;
          break;
        case 'string':
          if (this.onInsert) this.onInsert(pos, component);
          pos += component.length;
          break;
        case 'object':
          if (this.onRemove) this.onRemove(pos, component.d);
          spos += component.d;
      }
    }
  }
};
// This is a prelude which comes before the JS blob of each JS type for the web.
(function(){
  var module = {exports:{}};
  var exports = module.exports;

// These methods let you build a transform function from a transformComponent
// function for OT types like JSON0 in which operations are lists of components
// and transforming them reqreuires N^2 work. I find it kind of nasty that I need
// this, but I'm not really sure what a better solution is. Maybe I should do
// this automatically to types that don't have a compose function defined.

// Add transform and transformX functions for an OT type which has
// transformComponent defined.  transformComponent(destination array,
// component, other component, side)
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    transformComponent(destRight, right, left, 'right');
  };

  var transformX = type.transformX = function(leftOp, rightOp) {
    checkValidOp(leftOp);
    checkValidOp(rightOp);
    var newRightOp = [];

    for (var i = 0; i < rightOp.length; i++) {
      var rightComponent = rightOp[i];

      // Generate newLeftOp by composing leftOp by rightComponent
      var newLeftOp = [];
      var k = 0;
      while (k < leftOp.length) {
        var nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;

        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          for (var j = k; j < leftOp.length; j++) {
            append(newLeftOp, leftOp[j]);
          }
          rightComponent = null;
          break;
        } else {
          // Recurse.
          var pair = transformX(leftOp.slice(k), nextC);
          for (var l = 0; l < pair[0].length; l++) {
            append(newLeftOp, pair[0][l]);
          }
          for (var r = 0; r < pair[1].length; r++) {
            append(newRightOp, pair[1][r]);
          }
          rightComponent = null;
          break;
        }
      }

      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };

  // Transforms op with specified type ('left' or 'right') by otherOp.
  type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right'))
      throw new Error("type must be 'left' or 'right'");

    if (otherOp.length === 0) return op;

    if (op.length === 1 && otherOp.length === 1)
      return transformComponent([], op[0], otherOp[0], type);

    if (type === 'left')
      return transformX(op, otherOp)[0];
    else
      return transformX(otherOp, op)[1];
  };
};
// DEPRECATED!
//
// This type works, but is not exported, and will be removed in a future version of this library.


// A simple text implementation
//
// Operations are lists of components.
// Each component either inserts or deletes at a specified position in the document.
//
// Components are either:
//  {i:'str', p:100}: Insert 'str' at position 100 in the document
//  {d:'str', p:100}: Delete 'str' at position 100 in the document
//
// Components in an operation are executed sequentially, so the position of components
// assumes previous components have already executed.
//
// Eg: This op:
//   [{i:'abc', p:0}]
// is equivalent to this op:
//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]

// NOTE: The global scope here is shared with other sharejs files when built with closure.
// Be careful what ends up in your namespace.

var text = module.exports = {
  name: 'text0',
  uri: 'http://sharejs.org/types/textv0',
  create: function(initial) {
    if ((initial != null) && typeof initial !== 'string') {
      throw new Error('Initial data must be a string');
    }
    return initial || '';
  }
};

/** Insert s2 into s1 at pos. */
var strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

/** Check that an operation component is valid. Throws if its invalid. */
var checkValidComponent = function(c) {
  if (typeof c.p !== 'number')
    throw new Error('component missing position field');

  if ((typeof c.i === 'string') === (typeof c.d === 'string'))
    throw new Error('component needs an i or d field');

  if (c.p < 0)
    throw new Error('position cannot be negative');
};

/** Check that an operation is valid */
var checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
    checkValidComponent(op[i]);
  }
};

/** Apply op to snapshot */
text.apply = function(snapshot, op) {
  var deleted;

  checkValidOp(op);
  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted)
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");

      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

/**
 * Append a component to the end of newOp. Exported for use by the random op
 * generator and the JSON0 type.
 */
var append = text._append = function(newOp, c) {
  if (c.i === '' || c.d === '') return;

  if (newOp.length === 0) {
    newOp.push(c);
  } else {
    var last = newOp[newOp.length - 1];

    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
      // Compose the insert into the previous insert
      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};

    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
      // Compose the deletes together
      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};

    } else {
      newOp.push(c);
    }
  }
};

/** Compose op1 and op2 together */
text.compose = function(op1, op2) {
  checkValidOp(op1);
  checkValidOp(op2);
  var newOp = op1.slice();
  for (var i = 0; i < op2.length; i++) {
    append(newOp, op2[i]);
  }
  return newOp;
};

/** Clean up an op */
text.normalize = function(op) {
  var newOp = [];

  // Normalize should allow ops which are a single (unwrapped) component:
  // {i:'asdf', p:23}.
  // There's no good way to test if something is an array:
  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  // so this is probably the least bad solution.
  if (op.i != null || op.p != null) op = [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = 0;

    append(newOp, c);
  }

  return newOp;
};

// This helper method transforms a position by an op component.
//
// If c is an insert, insertAfter specifies whether the transform
// is pushed after the insert (true) or before it (false).
//
// insertAfter is optional for deletes.
var transformPosition = function(pos, c, insertAfter) {
  // This will get collapsed into a giant ternary by uglify.
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    // I think this could also be written as: Math.min(c.p, Math.min(c.p -
    // otherC.p, otherC.d.length)) but I think its harder to read that way, and
    // it compiles using ternary operators anyway so its no slower written like
    // this.
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

// Helper method to transform a cursor position as a result of an op.
//
// Like transformPosition above, if c is an insert, insertAfter specifies
// whether the cursor position is pushed after an insert (true) or before it
// (false).
text.transformCursor = function(position, op, side) {
  var insertAfter = side === 'right';
  for (var i = 0; i < op.length; i++) {
    position = transformPosition(position, op[i], insertAfter);
  }

  return position;
};

// Transform an op component by another op component. Asymmetric.
// The result will be appended to destination.
//
// exported for use in JSON type
var transformComponent = text._tc = function(dest, c, otherC, side) {
  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidComponent(c);
  checkValidComponent(otherC);

  if (c.i != null) {
    // Insert.
    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});
  } else {
    // Delete
    if (otherC.i != null) {
      // Delete vs insert
      var s = c.d;
      if (c.p < otherC.p) {
        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '')
        append(dest, {d: s, p: c.p + otherC.i.length});

    } else {
      // Delete vs delete
      if (c.p >= otherC.p + otherC.d.length)
        append(dest, {d: c.d, p: c.p - otherC.d.length});
      else if (c.p + c.d.length <= otherC.p)
        append(dest, c);
      else {
        // They overlap somewhere.
        var newC = {d: '', p: c.p};

        if (c.p < otherC.p)
          newC.d = c.d.slice(0, otherC.p - c.p);

        if (c.p + c.d.length > otherC.p + otherC.d.length)
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);

        // This is entirely optional - I'm just checking the deleted text in
        // the two ops matches
        var intersectStart = Math.max(c.p, otherC.p);
        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect)
          throw new Error('Delete ops delete different text in the same region of the document');

        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }

  return dest;
};

var invertComponent = function(c) {
  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};
};

// No need to use append for invert, because the components won't be able to
// cancel one another.
text.invert = function(op) {
  // Shallow copy & reverse that sucka.
  op = op.slice().reverse();
  for (var i = 0; i < op.length; i++) {
    op[i] = invertComponent(op[i]);
  }
  return op;
};

exports._bootstrapTransform(text, transformComponent, checkValidOp, append);

/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};

/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
if (typeof text === 'undefined')
  var text = window.ottypes.text;

/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);


module.exports = json;
// This is included after the JS for each type when we build for the web.

  var _types = window.ottypes = window.ottypes || {};
  var _t = module.exports;
  _types[_t.name] = _t;

  if (_t.uri) _types[_t.uri] = _t;
})();
// JSON document API for the 'json0' type.

(function() {
  var __slice = [].slice;
  var _types = typeof brequire !== 'undefined' ? brequire('ottypes') : window.ottypes;
  var _type = _types['http://sharejs.org/types/JSONv0'];

  // Helpers

  function depath(path) {
    if (path.length === 1 && path[0].constructor === Array) {
      return path[0];
    } else {
      return path;
    }
  }

  function traverse(snapshot, path) {
    var key = 'data';
    var elem = { data: snapshot };

    for (var i = 0; i < path.length; i++) {
      elem = elem[key];
      if (typeof elem === 'undefined') {
        throw new Error('bad path');
      }
      key = path[i];
    }

    return {
      elem: elem,
      key: key
    };
  }

  function pathEquals(p1, p2) {
    if (p1.length !== p2.length) {
      return false;
    }
    for (var i = 0; i < p1.length; ++i) {
      if (p1[i] !== p2[i]) {
        return false;
      }
    }
    return true;
  }

  function containsPath(p1, p2) {
    if (p1.length < p2.length) return false;
    return pathEquals( p1.slice(0,p2.length), p2);
  }

  // does nothing, used as a default callback
  function nullFunction(){}

  // helper for creating functions with the method signature func([path],arg1,arg2,...,[cb])
  // populates an array of arguments with a default path and callback
  function normalizeArgs(obj,args,func){
    args = Array.prototype.slice.call(args);
    var path_prefix = obj.path || [];

    if (func.length > 1 && typeof args[args.length-1] !== 'function') {
      args.push(nullFunction);
    }

    if (args.length < func.length) {
      args.unshift(path_prefix);
    } else {
      args[0] = path_prefix.concat(args[0]);
    }

    return func.apply(obj,args);
  };


  // SubDoc
  // this object is returned from context.createContextAt()

  var SubDoc = function(context, path) {
    this.context = context;
    this.path = path || [];
  };

  SubDoc.prototype._updatePath = function(op){
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      if(c.lm !== undefined && containsPath(this.path,c.p)){
        var new_path_prefix = c.p.slice(0,c.p.length-1);
        new_path_prefix.push(c.lm);
        this.path = new_path_prefix.concat(this.path.slice(new_path_prefix.length));
      }
    }
  };

  SubDoc.prototype.createContextAt = function() {
    var path = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.context.createContextAt(this.path.concat(depath(path)));
  };

  SubDoc.prototype.get = function(path) {
    return normalizeArgs(this,arguments,function(path){
      return this.context.get(path);
    });
  };

  SubDoc.prototype.set = function(path,value,cb) {
    return normalizeArgs(this,arguments,function(path,value,cb){
      return this.context.set(path, value, cb);
    });
  };

  SubDoc.prototype.insert = function(path, pos, value, cb) {
    return normalizeArgs(this,arguments,function(path, pos, value, cb){
      return this.context.insert(path, pos, value, cb);
    });
  };

  SubDoc.prototype.remove = function(path, cb) {
    return normalizeArgs(this,arguments,function(path, cb) {
      return this.context.remove(path, cb);
    });
  };

  SubDoc.prototype.push = function(path, value, cb) {
    return normalizeArgs(this,arguments,function(path, value, cb) {
      return this.context.insert(path, this.get().length, value, cb);
    });
  };

  SubDoc.prototype.move = function(path, from, to, cb) {
    return normalizeArgs(this,arguments,function(path, from, to, cb) {
      return this.context.move(path, from, to, cb);
    });
  };

  SubDoc.prototype.add = function(path, amount, cb) {
    return normalizeArgs(this,arguments,function(path, amount, cb) {
      return this.context.add(path, amount, cb);
    });
  };

  SubDoc.prototype.on = function(event, cb) {
    return this.context.addListener(this.path, event, cb);
  };

  SubDoc.prototype.removeListener = function(l) {
    return this.context.removeListener(l);
  };

  SubDoc.prototype.getLength = function(path) {
    return normalizeArgs(this,arguments,function(path) {
      return this.context.getLength(path);
    });
  };

  SubDoc.prototype.getText = function(path) {
    return normalizeArgs(this,arguments,function(path) {
      return this.context.getText(path);
    });
  };
  
  SubDoc.prototype.deleteText = function(path, pos, length, cb) {
    return normalizeArgs(this,arguments,function(path, pos, length, cb) {
      return this.context.deleteText(path, length, pos, cb);
    });
  };

  SubDoc.prototype.destroy = function() {
    this.context._removeSubDoc(this);
  };


  // JSON API methods
  // these methods are mixed in to the context return from doc.createContext()

  _type.api = {

    provides: {
      json: true
    },

    _fixComponentPaths: function(c) {
      if (!this._listeners) {
        return;
      }
      if (c.na !== undefined || c.si !== undefined || c.sd !== undefined) {
        return;
      }

      var to_remove = [];
      var _ref = this._listeners;

      for (var i = 0; i < _ref.length; i++) {
        var l = _ref[i];
        var dummy = {
          p: l.path,
          na: 0
        };
        var xformed = _type.transformComponent([], dummy, c, 'left');
        if (xformed.length === 0) {
          to_remove.push(i);
        } else if (xformed.length === 1) {
          l.path = xformed[0].p;
        } else {
          throw new Error("Bad assumption in json-api: xforming an 'na' op will always result in 0 or 1 components.");
        }
      }

      to_remove.sort(function(a, b) {
        return b - a;
      });

      var _results = [];
      for (var j = 0; j < to_remove.length; j++) {
        i = to_remove[j];
        _results.push(this._listeners.splice(i, 1));
      }

      return _results;
    },

    _fixPaths: function(op) {
      var _results = [];
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        _results.push(this._fixComponentPaths(c));
      }
      return _results;
    },

    _submit: function(op, callback) {
      this._fixPaths(op);
      return this.submitOp(op, callback);
    },

    _addSubDoc: function(subdoc){
      this._subdocs || (this._subdocs = []);
      this._subdocs.push(subdoc);
    },

    _removeSubDoc: function(subdoc){
      this._subdocs || (this._subdocs = []);
      for(var i = 0; i < this._subdocs.length; i++){
        if(this._subdocs[i] === subdoc) this._subdocs.splice(i,1);
        return;
      }
    },

    _updateSubdocPaths: function(op){
      this._subdocs || (this._subdocs = []);
      for(var i = 0; i < this._subdocs.length; i++){
        this._subdocs[i]._updatePath(op);
      }
    },

    createContextAt: function() {
      var path = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      var subdoc =  new SubDoc(this, depath(path));
      this._addSubDoc(subdoc);
      return subdoc;
    },

    get: function(path) {
      if (!path) return this.getSnapshot();  
      
      var _ref = traverse(this.getSnapshot(), path);
      return _ref.elem[_ref.key];
    },

    set: function(path, value, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var elem = _ref.elem;
        var key = _ref.key;
        var op = {
          p: path
        };

        if (elem.constructor === Array) {
          op.li = value;
          if (typeof elem[key] !== 'undefined') {
            op.ld = elem[key];
          }
        } else if (typeof elem === 'object') {
          op.oi = value;
          if (typeof elem[key] !== 'undefined') {
            op.od = elem[key];
          }
        } else {
          throw new Error('bad path');
        }

        return this._submit([op], cb);
      });
    },

    remove: function(path, cb) {
      return normalizeArgs(this,arguments,function(path, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var elem = _ref.elem;
        var key = _ref.key;
        var op = {
          p: path
        };

        if (typeof elem[key] === 'undefined') {
          throw new Error('no element at that path');
        }

        if (elem.constructor === Array) {
          op.ld = elem[key];
        } else if (typeof elem === 'object') {
          op.od = elem[key];
        } else {
          throw new Error('bad path');
        }

        return this._submit([op], cb);
      });
    },

    insert: function(path, pos, value, cb) {
      return normalizeArgs(this,arguments,function(path, pos, value, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var elem = _ref.elem;
        var key = _ref.key;
        var op = {
          p: path.concat(pos)
        };

        if (elem[key].constructor === Array) {
          op.li = value;
        } else if (typeof elem[key] === 'string') {
          op.si = value;
        }

        return this._submit([op], cb);
      });
    },

    move: function(path, from, to, cb) {
      return normalizeArgs(this,arguments,function(path, from, to, cb) {
        var self = this;
        var op = [
          {
            p: path.concat(from),
            lm: to
          }
        ];

        return this._submit(op, function(){
          self._updateSubdocPaths(op);
          if(cb) cb.apply(cb,arguments);
        });
      });
    },

    push: function(path, value, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        return this.insert(path, this.get().length, value, cb);
      });
    },

    add: function(path, amount, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        var op = [
          {
            p: path,
            na: amount
          }
        ];
        return this._submit(op, cb);
      });
    },

    getLength: function(path) {
        return normalizeArgs(this,arguments,function(path) {
          return this.get(path).length;
        });
    },

    getText: function(path) {
      return normalizeArgs(this,arguments,function(path) {
        return this.get(path);
      });
    },

    deleteText: function(path, length, pos, cb) {
      return normalizeArgs(this,arguments,function(path, length, pos, cb) {
        var _ref = traverse(this.getSnapshot(), path);
        var op = [
          {
            p: path.concat(pos),
            sd: _ref.elem[_ref.key].slice(pos, pos + length)
          }
        ];

        return this._submit(op, cb);
      });
    },

    addListener: function(path, event, cb) {
      return normalizeArgs(this,arguments,function(path, value, cb) {
        var listener = {
          path: path,
          event: event,
          cb: cb
        };
        this._listeners || (this._listeners = []);
        this._listeners.push(listener);
        return listener;
      });
    },

    removeListener: function(listener) {
      if (!this._listeners) {
        return;
      }
      var i = this._listeners.indexOf(listener);
      if (i < 0) {
        return false;
      }
      this._listeners.splice(i, 1);
      return true;
    },

    _onOp: function(op) {
      for (var i = 0; i < op.length; i++) {
        var c = op[i];
        this._fixComponentPaths(c);

        if(c.lm !== undefined) {
          this._updateSubdocPaths([c]);
        }

        var match_path = c.na === undefined ? c.p.slice(0, c.p.length - 1) : c.p;

        for (var l = 0; l < this._listeners.length; l++) {
          var listener = this._listeners[l];
          var cb = listener.cb;

          if (pathEquals(listener.path, match_path)) {
            switch (listener.event) {
              case 'insert':
                if (c.li !== undefined && c.ld === undefined) {
                  cb(c.p[c.p.length - 1], c.li);
                } else if (c.oi !== undefined && c.od === undefined) {
                  cb(c.p[c.p.length - 1], c.oi);
                } else if (c.si !== undefined) {
                  cb(c.p[c.p.length - 1], c.si);
                }
                break;
              case 'delete':
                if (c.li === undefined && c.ld !== undefined) {
                  cb(c.p[c.p.length - 1], c.ld);
                } else if (c.oi === undefined && c.od !== undefined) {
                  cb(c.p[c.p.length - 1], c.od);
                } else if (c.sd !== undefined) {
                  cb(c.p[c.p.length - 1], c.sd);
                }
                break;
              case 'replace':
                if (c.li !== undefined && c.ld !== undefined) {
                  cb(c.p[c.p.length - 1], c.ld, c.li);
                } else if (c.oi !== undefined && c.od !== undefined) {
                  cb(c.p[c.p.length - 1], c.od, c.oi);
                }
                break;
              case 'move':
                if (c.lm !== undefined) {
                  cb(c.p[c.p.length - 1], c.lm);
                }
                break;
              case 'add':
                if (c.na !== undefined) {
                  cb(c.na);
                }
            }
          } else if (_type.canOpAffectOp(listener.path, match_path)
              && listener.event === 'child op') {
            var child_path = c.p.slice(listener.path.length);
            cb(child_path, c);
          }
        }
      }
    }
  };

}).call(this);
// This file is included at the top of the compiled client JS.

// All the modules will just add stuff to exports, and it'll all get exported.
var exports = window.sharejs = {version: '0.7.0'};

// This is a simple rewrite of microevent.js. I've changed the
// function names to be consistent with node.js EventEmitter.
//
// microevent.js is copyright Jerome Etienne, and licensed under the MIT license:
// https://github.com/jeromeetienne/microevent.js

var MicroEvent = function() {};

MicroEvent.prototype.on = function(event, fn) {
  var events = this._events = this._events || {};
  (events[event] = events[event] || []).push(fn);
};

MicroEvent.prototype.removeListener = function(event, fn) {
  var events = this._events = this._events || {};
  var listeners = events[event] = events[event] || [];

  // Sadly, no IE8 support for indexOf.
  var i = 0;
  while (i < listeners.length) {
    if (listeners[i] === fn) {
      listeners[i] = undefined;
    }
    i++;
  }

  // Compact the list when no event handler is actually running.
  setTimeout(function() {
    events[event] = [];
    var fn;
    for (var i = 0; i < listeners.length; i++) {
      // Only add back event handlers which exist.
      if ((fn = listeners[i])) events[event].push(fn);
    }
  }, 0);
};

MicroEvent.prototype.emit = function(event) {
  var events = this._events;
  var args = Array.prototype.splice.call(arguments, 1);

  if (!events || !events[event]) {
    if (event == 'error') {
      if (console) {
        console.error.apply(console, args);
      }
    }
    return;
  }

  var listeners = events[event];
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i]) {
      listeners[i].apply(this, args);
    }
  }
};

MicroEvent.prototype.once = function(event, fn) {
  var listener, _this = this;
  this.on(event, listener = function() {
    _this.removeListener(event, listener);
    fn.apply(_this, arguments);
  });
};

MicroEvent.mixin = function(obj) {
  var proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof module !== "undefined") module.exports = MicroEvent;

var types, MicroEvent;

if (typeof brequire !== "undefined") {
  types = brequire('ottypes');
  MicroEvent = brequire('./microevent');
} else {
  types = window.ottypes;
}

/*
 * A Doc is a client's view on a sharejs document.
 *
 * Documents should not be created directly. Create them by calling the
 * document getting functions in connection.
 *
 * Documents are event emitters. Use doc.on(eventname, fn) to subscribe.
 *
 * Documents currently get mixed in with their type's API methods. So, you can
 * .insert('foo', 0) into a text document and stuff like that.
 *
 * Events:
 * - before op (op, localSite): Fired before an operation is applied to the
 *   document.
 * - op (op, localSite): Fired right after an operation (or part of an
 *   operation) has been applied to the document. Submitting another op here is
 *   invalid - wait until 'after op' if you want to submit more operations.  -
 *   changed (op)
 * - after op (op, localSite): Fired after an operation has been applied. You
 *   can submit more ops here.
 * - subscribed (error): The document was subscribed
 * - unsubscribed (error): The document was unsubscribed
 * - created: The document was created. That means its type was set and it has
 *   some initial data.
 * - error
 */
var Doc = exports.Doc = function(connection, collection, name) {
  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;

  // **** State in document:
 
  // Action. This is either null, or one of the actions (subscribe,
  // unsubscribe, fetch, submit). Only one action can be happening at a time to
  // prevent me from going mad.
  //
  // Possible values:
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit
  this.action = null;
 
  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];
  
  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];
};

MicroEvent.mixin(Doc);

Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    setTimeout(function() {
      // There'll probably be nothing here seeing as how we just unsubscribed.
      for (var i = 0; i < doc._subscribeCallbacks.length; i++) {
        doc._subscribeCallbacks[i]('Document destroyed');
      }
      doc._subscribeCallbacks.length = 0;
    }, 0);

    doc.connection._destroyDoc(doc);
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to injest data that was exported with a webpage and data
// that was received from the server during a fetch.
Doc.prototype.injestData = function(data) {
  if (this.state) {
    if (typeof console !== "undefined") console.warn('Ignoring attempt to injest data in state', this.state);
    return;
  }
  if (typeof data.v !== 'number') throw new Error('Missing version in injested data');


  this.version = data.v;
  this.snapshot = data.snapshot;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.on('ready', fn);
  }
};

Doc.prototype.hasPending = function() {
  return this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error("Got message for wrong document.");
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.injestData(msg.data);
      this._finishSub('fetch', msg.error);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction('fetch');
      break;

    case 'sub':
      // Subscribe reply.
      if (msg.error && msg.error !== 'Already subscribed') {
        if (console) console.error("Could not subscribe: " + msg.error);
        this.emit('error', msg.error);
        // There's probably a reason we couldn't subscribe. Don't retry.
        this._setWantSubscribe(false, null, msg.error)
      } else {
        if (msg.data) this.injestData(msg.data);
        this.subscribed = true;
        this.emit('subscribe');
        this._finishSub(true);
      }

      this._clearAction('subscribe');
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._finishSub(false, msg.error);
      this._clearAction('unsubscribe');
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed). However, if the op doesn't get accepted, we still need to
      // clear some state.
      //
      // If the message error is 'Op already submitted', that means we've
      // resent an op that the server already got. It will also be confirmed
      // normally.
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for some reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
          this._tryRollback(this.inflightData);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          if (console) console.warn('Second acknowledgement message (error) received', msg, this);
        }
          
        this._clearInflightOp(msg.error);
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v !== this.version) {
        // I should add the name of the document to all errors - mostly this is
        // to track down one particular bug.
        this.emit('error', 'In document ' + this.name + ' expected version ' + this.version + ' but got ' + msg.v);
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      this._afterOtApply(msg, false);
      //console.log('applied', JSON.stringify(msg));
      break;

    case 'meta':
      if (console) console.warn('Unhandled meta op:', msg);
      break;

    default:
      if (console) console.warn('Unhandled document message:', msg);
      break;
  }
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting') {
    if (this.inflightData) {
      this._sendOpData();
    } else {
      this.flush();
    }
  } else if (state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again.
    this.flush();
  } else if (state === 'disconnected') {
    this.action = null;
    this.subscribed = false;
    if (this.subscribed) this.emit('unsubscribed');
  }
};




// ****** Dealing with actions

Doc.prototype._clearAction = function(expectedAction) {
  if (this.action !== expectedAction) {
    console.warn('Unexpected action ' + this.action + ' expected: ' + expectedAction);
  }
  this.action = null;
  this.flush();
};



// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // First consider changing state
  if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    this._send(this.state === 'ready' ? {a:'sub', v:this.version} : {a:'sub'});
  } else if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in 
    this.inflightData = this.pendingData.shift();

    // Delay for debugging.
    //var that = this;
    //setTimeout(function() { that._sendOpData(); }, 1000);

    // This also sets action to 'submit'.
    this._sendOpData();
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }
  
  if (!this.wantSubscribe !== !value) {
    // Call all the current subscribe/unsubscribe callbacks.
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      // Should I return an error here? What happened is the user unsubcribed
      // with a callback then resubscribed straight after. Does that mean the
      // unsubscribe failed?
      this._subscribeCallbacks[i](err);
    }
    this._subscribeCallbacks.length = 0;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(value, error) {
  if (value === this.wantSubscribe) {
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      this._subscribeCallbacks[i](error);
    }
    this._subscribeCallbacks.length = 0;
  }
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug.');

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    //console.log('xf', JSON.stringify(client.op), JSON.stringify(server.op));
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
    //console.log('->', JSON.stringify(client.op), JSON.stringify(server.op));
  }
};

// Internal method to actually apply the given op data to our local model.
//
// _afterOtApply() should always be called synchronously afterwards.
Doc.prototype._otApply = function(opData, context) {
  // Lock the document. Nobody is allowed to call submitOp() until _afterOtApply is called.
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist');

    var type = this.type;

    var op = opData.op;
    
    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.
};

// This should be called right after _otApply.
Doc.prototype._afterOtApply = function(opData, context) {
  this.locked = false;
  this.emit('unlock');
  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts.remove) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('invalid state ' + this.action + ' for sendOpData');
  this.action = 'submit';

  var msg = {a:'op', v:this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  // The server autodetects this.
  //if (this.state === 'unsubscribed') msg.f = true; // fetch intermediate ops

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);
   
  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Internal method called to do the actual work for submitOp(), create() and del().
//
// context is optional.
Doc.prototype._submitOpData = function(opData, context, callback) {
  //console.log('submit', JSON.stringify(opData), 'v=', this.version);

  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) callback(err);
    else if (console) console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler");
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).

  if (opData.op) {
    if (!this.type) return error('Document has not been created');

    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  // Actually apply the operation locally.
  this._otApply(opData, context);

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var entry = this.pendingData[this.pendingData.length - 1];

  if (this.pendingData.length &&
      (entry = this.pendingData[this.pendingData.length - 1],
       tryCompose(this.type, entry, opData))) {
  } else {
    entry = opData;
    opData.type = this.type;
    opData.callbacks = [];
    this.pendingData.push(opData);
  }

  if (callback) entry.callbacks.push(callback);

  this._afterOtApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn't matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document. The op must be valid given the current OT type.
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }
  if (this.type) {
    if (callback) callback('Document already exists');
    return 
  }

  this._submitOpData({create: {type:type, data:data}}, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Pausing stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    var undo = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], undo);
    }

    // ... and apply it locally, reverting the changes.
    // 
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(undo, false);
    this._afterOtApply(undo, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this._clearAction('submit');

  if (!this.pendingData.length) {
    // This isn't a very good name.
    this.emit('nothing pending');
  }
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen.');
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op.');

    // Our create has been acknowledged. This is the same as injesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version)
      throw new Error('Invalid version from server. Please file an issue, this is a bug.');
  }
  
  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// API Contexts

// This creates and returns an editing context using the current OT type.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type');

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      delete this._onOp;
      this.remove = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};

Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};

// A Connection wraps a persistant BC connection to a sharejs server.
//
// This class implements the client side of the protocol defined here:
// https://github.com/josephg/ShareJS/wiki/Wire-Protocol
//
// The equivalent server code is in src/server/session.
//
// This file is a bit of a mess. I'm dreadfully sorry about that. It passes all the tests,
// so I have hope that its *correct* even if its not clean.
//
// To make a connection, use:
//  new sharejs.Connection(socket)
//
// The socket should look like a websocket connection. It should have the following properties:
//  send(msg): Send the given message. msg may be an object - if so, you might need to JSON.stringify it.
//  close(): Disconnect the session
//
//  onmessage = function(msg){}: Event handler which is called whenever a message is received. The message
//     passed in should already be an object. (It may need to be JSON.parsed)
//  onclose
//  onerror
//  onopen
//  onconnecting
//
// The socket should probably automatically reconnect. If so, it should emit the appropriate events as it
// disconnects & reconnects. (onclose(), onconnecting(), onopen()).

var types, Doc;
if (typeof brequire !== 'undefined') {
  types = brequire('ottypes');
  Doc = brequire('./doc').Doc;
  Query = brequire('./query').Query;
} else {
  types = window.ottypes;
  Doc = exports.Doc;
}

var Connection = exports.Connection = function (socket) {
  this.socket = socket;

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // Connection state.
  // 
  // States:
  // - 'connecting': The connection has been established, but we don't have our client ID yet
  // - 'connected': We have connected and recieved our client ID. Ready for data.
  // - 'disconnected': The connection is closed, but it will reconnect automatically.
  // - 'stopped': The connection is closed, and should not reconnect.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if the state is 'connecting' or 'connected'.
  this.canSend = this.state === 'connecting';

  // Reset some more state variables.
  this.reset();

  this.debug = false;
  // I'll store the most recent 100 messages so when errors occur we can see what happened.
  this.messageBuffer = [];

  var connection = this;

  var handleMessage = function(msg) {
    // Switch on the message action. Most messages are for documents and are
    // handled in the doc class.
    switch (msg.a) {
      case 'init':
        // Client initialization packet. This bundle of joy contains our client
        // ID.
        if (msg.protocol !== 0) throw new Error('Invalid protocol version');
        if (typeof msg.id != 'string') throw new Error('Invalid client id');

        connection.id = msg.id;
        connection._setState('connected');
        break;

      case 'qfetch':
      case 'qsub':
      case 'q':
      case 'qunsub':
        // Query message. Pass this to the appropriate query object.
        var query = connection.queries[msg.id];
        if (query) query._onMessage(msg);
        break;

      default:
        // Document message. Pull out the referenced document and forward the
        // message.
        var collection, docName, doc;
        if (msg.d) {
          collection = connection._lastReceivedCollection = msg.c;
          docName = connection._lastReceivedDoc = msg.d;
        } else {
          collection = msg.c = connection._lastReceivedCollection;
          docName = msg.d = connection._lastReceivedDoc;
        }

        doc = connection.get(collection, docName);
        if (!doc) {
          if (console) console.error('Message for unknown doc. Ignoring.', msg);
          break;
        }
        doc._onMessage(msg);
    }
  };

  // Attach event handlers to the socket.
  socket.onmessage = function(msg) {
    if (connection.debug) console.log('RECV', JSON.stringify(msg));
    connection.messageBuffer.push({t:(new Date()).toTimeString(), recv:JSON.stringify(msg)});
    while (connection.messageBuffer.length > 100) {
      connection.messageBuffer.shift();
    }

    try {
      handleMessage(msg);
    } catch (e) {
      connection.emit('error', e);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
    }
  }

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
}

/* Why does this function exist? Is it important?
Connection.prototype._error = function(e) {
  this._setState('stopped', e);
  return this.disconnect(e);
};
*/

Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};

// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = newState === 'connecting' || newState === 'connected';

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }

  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }
  this.opQueue = null;
  
  for (var id in this.queries) {
    this.queries[id]._onConnectionStateChanged(newState, data);
  }
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

// Send a message to the connection.
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));
  this.messageBuffer.push({t:(new Date()).toTimeString(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length > 100) {
    this.messageBuffer.shift();
  }

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  this.socket.send(msg);
};

Connection.prototype.disconnect = function() {
  // This will call @socket.onclose(), which in turn will emit the 'disconnected' event.
  this.socket.close();
};


// ***** Document management

Connection.prototype.getExisting = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};

Connection.prototype.getOrCreate = function(collection, name, data) {
  console.trace('getOrCreate is deprecated. Use get() instead');
  return this.get(collection, name, data);
};

// Create a document if it doesn't exist. Returns the document synchronously.
Connection.prototype.get = function(collection, name, data) {
  var doc = this.getExisting(collection, name);

  if (!doc) {
    // Create it.
    doc = new Doc(this, collection, name);

    var collectionObject = this.collections[collection] =
      (this.collections[collection] || {});
    collectionObject[name] = doc;
  }

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.snapshot !== undefined && !doc.state) {
    doc.injestData(data);
  }

  return doc;
};

// Call doc.destroy()
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};
 
function hasKeys(object) {
  for (var key in object) return true;
  return false;
};

// **** Queries.

// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

if (typeof brequire !== 'undefined') {
  MicroEvent = brequire('./microevent');
}

MicroEvent.mixin(Connection);

/* This contains the textarea binding for ShareJS. This binding is really
 * simple, and a bit slow on big documents (Its O(N). However, it brequires no
 * changes to the DOM and no heavy libraries like ace. It works for any kind of
 * text input field.
 *
 * You probably want to use this binding for small fields on forms and such.
 * For code editors or rich text editors or whatever, I recommend something
 * heavier.
 */


/* applyChange creates the edits to convert oldval -> newval.
 *
 * This function should be called every time the text element is changed.
 * Because changes are always localised, the diffing is quite easy. We simply
 * scan in from the start and scan in from the end to isolate the edited range,
 * then delete everything that was removed & add everything that was added.
 * This wouldn't work for complex changes, but this function should be called
 * on keystroke - so the edits will mostly just be single character changes.
 * Sometimes they'll paste text over other text, but even then the diff
 * generated by this algorithm is correct.
 *
 * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.
 */
var applyChange = function(ctx, oldval, newval) {
  // Strings are immutable and have reference equality. I think this test is O(1), so its worth doing.
  if (oldval === newval) return;

  var commonStart = 0;
  while (oldval.charAt(commonStart) === newval.charAt(commonStart)) {
    commonStart++;
  }

  var commonEnd = 0;
  while (oldval.charAt(oldval.length - 1 - commonEnd) === newval.charAt(newval.length - 1 - commonEnd) &&
      commonEnd + commonStart < oldval.length && commonEnd + commonStart < newval.length) {
    commonEnd++;
  }

  if (oldval.length !== commonStart + commonEnd) {
    ctx.remove(commonStart, oldval.length - commonStart - commonEnd);
  }
  if (newval.length !== commonStart + commonEnd) {
    ctx.insert(commonStart, newval.slice(commonStart, newval.length - commonEnd));
  }
};

// Attach a textarea to a document's editing context.
//
// The context is optional, and will be created from the document if its not
// specified.
window.sharejs.Doc.prototype.attachTextarea = function(elem, ctx) {
  if (!ctx) ctx = this.createContext();

  if (!ctx.provides.text) throw new Error('Cannot attach to non-text document');

  elem.value = ctx.getText();

  // The current value of the element's text is stored so we can quickly check
  // if its been changed in the event handlers. This is mostly for browsers on
  // windows, where the content contains \r\n newlines. applyChange() is only
  // called after the \r\n newlines are converted, and that check is quite
  // slow. So we also cache the string before conversion so we can do a quick
  // check incase the conversion isn't needed.
  var prevvalue;

  // Replace the content of the text area with newText, and transform the
  // current cursor by the specified function.
  var replaceText = function(newText, transformCursor) {
    if (transformCursor) {
      var newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];
    }

    // Fixate the window's scroll while we set the element's value. Otherwise
    // the browser scrolls to the element.
    var scrollTop = elem.scrollTop;
    elem.value = newText;
    prevvalue = elem.value; // Not done on one line so the browser can do newline conversion.
    if (elem.scrollTop !== scrollTop) elem.scrollTop = scrollTop;

    // Setting the selection moves the cursor. We'll just have to let your
    // cursor drift if the element isn't active, though usually users don't
    // care.
    if (newSelection && window.document.activeElement === elem) {
      elem.selectionStart = newSelection[0];
      elem.selectionEnd = newSelection[1];
    }
  };

  replaceText(ctx.getText());


  // *** remote -> local changes

  ctx.onInsert = function(pos, text) {
    var transformCursor = function(cursor) {
      return pos < cursor ? cursor + text.length : cursor;
    };

    // Remove any window-style newline characters. Windows inserts these, and
    // they mess up the generated diff.
    var prev = elem.value.replace(/\r\n/g, '\n');
    replaceText(prev.slice(0, pos) + text + prev.slice(pos), transformCursor);
  };

  ctx.onRemove = function(pos, length) {
    var transformCursor = function(cursor) {
      // If the cursor is inside the deleted region, we only want to move back to the start
      // of the region. Hence the Math.min.
      return pos < cursor ? cursor - Math.min(length, cursor - pos) : cursor;
    };

    var prev = elem.value.replace(/\r\n/g, '\n');
    replaceText(prev.slice(0, pos) + prev.slice(pos + length), transformCursor);
  };


  // *** local -> remote changes

  // This function generates operations from the changed content in the textarea.
  var genOp = function(event) {
    // In a timeout so the browser has time to propogate the event's changes to the DOM.
    setTimeout(function() {
      if (elem.value !== prevvalue) {
        prevvalue = elem.value;
        applyChange(ctx, ctx.getText(), elem.value.replace(/\r\n/g, '\n'));
      }
    }, 0);
  };

  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];
  for (var i = 0; i < eventNames.length; i++) {
    var e = eventNames[i];
    if (elem.addEventListener) {
      elem.addEventListener(e, genOp, false);
    } else {
      elem.attachEvent('on' + e, genOp);
    }
  }

  ctx.detach = function() {
    for (var i = 0; i < eventNames.length; i++) {
      var e = eventNames[i];
      if (elem.removeEventListener) {
        elem.removeEventListener(e, genOp, false);
      } else {
        elem.detachEvent('on' + e, genOp);
      }
    }
  };

  return ctx;
};

var Doc;
if (typeof brequire !== 'undefined') {
  Doc = brequire('./doc').Doc;
}

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] = collectionVersions[doc.collection] || {};
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
    // Force the document to know its subscribed if we're in docmode:subscribe.
    if (this.docMode === 'sub') {
      doc.subscribed = true; // Set before setWantSubscribe() so flush doesn't send a subscribe request.
      doc._setWantSubscribe(true); // this will call any subscribe callbacks or whatever.
      doc.emit('subscribe');
      doc._finishSub(true); // this doesn't actually do anything here, but its more correct to have it.
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll injest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

var MicroEvent;
if (typeof brequire !== 'undefined') {
  MicroEvent = brequire('./microevent');
}

MicroEvent.mixin(Query);

})();

},{}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvanMvYXBwcy9lZGl0b3IuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL2RpcmVjdGl2ZXMvYm9yZGVyTGF5b3V0LmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9kaXJlY3RpdmVzL2NvZGVFZGl0b3IuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL2RpcmVjdGl2ZXMvcHJldmlld2VyLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9kaXJlY3RpdmVzL3Rvb2xiYXIuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL2Fubm90YXRpb25zLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9iYXNlUGx1bmsuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL2NvbGxhYi5jb2ZmZWUiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvanMvc2VydmljZXMvZGlzYWJsZXIuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL2h0bWxGaWxlLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9sYXlvdXQuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL25vdGlmaWVyLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9zZXNzaW9uLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9zZXR0aW5ncy5jb2ZmZWUiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvanMvc2VydmljZXMvdHlwZXMuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL3VwZGF0ZXIuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL3VybC5jb2ZmZWUiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvdmVuZG9yL2FuZ3VsYXItZ3Jvd2wvYW5ndWxhci1ncm93bC5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy92ZW5kb3IvYW5ndWxhci11aS91aS1ib290c3RyYXAuanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvdmVuZG9yL2FuZ3VsYXItdWkvdWktcm91dGVyLmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL3ZlbmRvci9hbmd1bGFyL2FuZ3VsYXItY29va2llcy5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy92ZW5kb3IvYW5ndWxhci9hbmd1bGFyLmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL3ZlbmRvci9kb21pbmF0cml4L2RvbWluYXRyaXguanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvdmVuZG9yL29wZXJhdGl2ZS5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy92ZW5kb3Ivc2hhcmUvYmNzb2NrZXQtdW5jb21wcmVzc2VkLmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL3ZlbmRvci9zaGFyZS9zaGFyZS51bmNvbXByZXNzZWQuanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9ub2RlX21vZHVsZXMvZ2VuaWQvaW5kZXguanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9ub2RlX21vZHVsZXMvbG9kYXNoLl9yZW5hdGl2ZS9pbmRleC5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2Uvbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2Z1bmN0aW9uL2luZGV4LmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9ub2RlX21vZHVsZXMvbG9kYXNoLmlzb2JqZWN0L2luZGV4LmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9ub2RlX21vZHVsZXMvbG9kYXNoLmlzb2JqZWN0L25vZGVfbW9kdWxlcy9sb2Rhc2guX29iamVjdHR5cGVzL2luZGV4LmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvbm9kZV9tb2R1bGVzL3NoYXJlL3dlYmNsaWVudC9zaGFyZS51bmNvbXByZXNzZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLEtBQUEsdUJBQUE7O0NBQUEsQ0FDQSxLQUFBLCtCQUFBOztDQURBLENBRUEsS0FBQSwrQkFBQTs7Q0FGQSxDQUdBLEtBQUEsNEJBQUE7O0NBSEEsQ0FNQSxLQUFBLHFCQUFBOztDQU5BLENBT0EsS0FBQSxzQkFBQTs7Q0FQQSxDQVFBLEtBQUEsc0JBQUE7O0NBUkEsQ0FTQSxLQUFBLHVCQUFBOztDQVRBLENBVUEsS0FBQSxvQkFBQTs7Q0FWQSxDQVdBLEtBQUEscUJBQUE7O0NBWEEsQ0FZQSxLQUFBLG9CQUFBOztDQVpBLENBY0EsS0FBQSw0QkFBQTs7Q0FkQSxDQWVBLEtBQUEsMEJBQUE7O0NBZkEsQ0FnQkEsS0FBQSx5QkFBQTs7Q0FoQkEsQ0FpQkEsS0FBQSx1QkFBQTs7Q0FqQkEsQ0FvQkEsQ0FBUyxHQUFULENBQWdCLElBQThCLEdBQUEsR0FBQSxHQUFyQyxJQUFxQyxDQUFBLENBQUEsQ0FBQSxFQUFBLENBQUE7O0NBcEI5QyxDQXVDQSxJQUFNO0VBQTJCLENBQTJDLEVBQTdELElBQThELEtBQUQsRUFBOUQsQ0FBOEQsQ0FBQSxDQUE5RCxDQUFBO0NBQ1osR0FBQSxFQUFBLEdBQUEsUUFBaUI7Q0FBakIsQ0FFaUMsRUFBakMsRUFBQSxDQUFBLENBQUEsVUFBa0I7Q0FFQyxPQUFuQixDQUFBLElBQUEsS0FBa0I7Q0FMTixJQUE4RDtDQXZDNUUsR0F1Q0E7O0NBdkNBLENBK0NBLElBQU07RUFBMkIsQ0FBc0IsRUFBeEMsSUFBeUMsS0FBRCxFQUF6QyxFQUF5QyxFQUF6QztDQUVaLENBQ0UsR0FERixDQUFBLEVBQUEsTUFBYztDQUNaLENBQUssQ0FBTCxJQUFBLENBQUE7Q0FBQSxDQUNVLEVBRFYsSUFDQTtDQURBLENBRVUsTUFBVixzQkFGQTtDQURGLE9BQUE7Q0FBQSxDQVFFLEdBREYsQ0FBQSxRQUFjO0NBQ1osQ0FBSyxDQUFMLEtBQUE7Q0FBQSxDQUVFLEdBREYsR0FBQTtDQUNFLENBQ0UsSUFERixJQUFBO0NBQ0UsQ0FBWSxRQUFaLEVBQUE7RUFBdUIsQ0FBb0IsR0FBQSxFQUEvQixDQUFnQyxNQUEvQjtDQUNKLENBQVAsSUFBTSxNQUFOLFdBQUE7Q0FEVSxjQUErQjtjQUEzQztZQURGO1VBRkY7Q0FSRixPQU9BO0NBUEEsQ0FnQkUsR0FERixDQUFBLE1BQUEsRUFBYztDQUNaLENBQUssQ0FBTCxHQUFBLEVBQUE7Q0FBQSxDQUVFLEdBREYsR0FBQTtDQUNFLENBQ0UsSUFERixJQUFBO0NBQ0UsQ0FBYSxTQUFiLENBQUEsV0FBQTtDQUFBLENBQ1ksUUFBWixFQUFBO0VBQXVCLENBQXFFLEdBQUEsQ0FBQSxDQUFoRixDQUFBLENBQUEsQ0FBQSxJQUFDO0NBQ1gsS0FBQSxjQUFBO0NBQUEsRUFBa0MsRUFBbEMsQ0FBTSxDQUFRLEVBQVUsT0FBeEI7Q0FBQSxFQUVTLEdBQVQsQ0FBZ0IsS0FBUCxJQUFUO0NBRVMsQ0FBa0IsQ0FBK0IsQ0FBL0IsRUFBQSxDQUEzQixDQUFRLENBQW1CLGNBQTNCO0NBQ0UsRUFBQSxtQkFBQTtDQUFBLEdBQUEsQ0FBQSxDQUFNLFlBQU47Q0FBQSxFQUM0QixDQUFBLEVBQXRCLE1BQTRCLEVBQWxDLElBQUE7Q0FFUyxNQUFULENBQVEsS0FBUixZQUFBO0NBSnlCLGdCQUErQjtDQUxoRCxjQUFnRjtjQUQ1RjtZQURGO1VBRkY7Q0FoQkYsT0FlQTtDQWZBLENBa0NFLEdBREYsQ0FBQSxRQUFjLENBQWQ7Q0FDRSxDQUFLLENBQUwsS0FBQSxzQkFBQTtDQUFBLENBRUUsR0FERixHQUFBO0NBQ0UsQ0FDRSxJQURGLElBQUE7Q0FDRSxDQUFhLFNBQWIsQ0FBQSxXQUFBO0NBQUEsQ0FDWSxRQUFaLEVBQUE7RUFBNkIsQ0FBc0csQ0FBdkgsQ0FBdUgsQ0FBQSxDQUF2SCxDQUFBLENBQUEsQ0FBQSxFQUF1SCxFQUF2SCxDQUFDO0NBQ1gsRUFBa0MsQ0FBbEMsRUFBTSxDQUFRLEVBQVUsT0FBeEI7Q0FFUyxDQUFrQixDQUEyQyxDQUEzQyxFQUFNLENBQWpDLENBQVEsQ0FBK0QsR0FBakIsV0FBdEQ7Q0FDVyxNQUFULENBQVEsYUFBUixJQUFBO0NBRHlCLENBRXpCLENBQUEsTUFBQSxRQUZvRTtDQUczRCxJQUFULEdBQVEsaUJBQVIsSUFBQTtDQUh5QixnQkFFekI7Q0FMUSxjQUF1SDtjQURuSTtZQURGO1VBRkY7Q0FsQ0YsT0FpQ0E7Q0FnQmUsQ0FDYixHQURGLFFBQUEsQ0FBYztDQUNaLENBQUssQ0FBTCxLQUFBLDRCQUFBO0NBQUEsQ0FFRSxHQURGLEdBQUE7Q0FDRSxDQUNFLElBREYsSUFBQTtDQUNFLENBQWEsU0FBYixDQUFBLFdBQUE7Q0FBQSxDQUNZLFFBQVosRUFBQTtFQUE2QixDQUF1RyxDQUF4SCxDQUF3SCxDQUFBLENBQXhILENBQUEsQ0FBQSxDQUFBLEVBQXdILEVBQXhILENBQUM7Q0FDWCxtQkFBQSxHQUFBO0NBQUEsRUFBa0MsQ0FBbEMsRUFBTSxDQUFRLEVBQVUsT0FBeEI7Q0FBQSxFQUVTLEdBQVQsQ0FBZ0IsSUFBUCxDQUFBLElBQVQ7Q0FGQSxDQUkyQixDQUFVLEVBQUssQ0FBUSxDQUFsRCxDQUFRLElBQW9GLElBQTVGLFNBQXFDLE1BQWE7Q0FKbEQsRUFNUyxDQUFBLEVBQVQsQ0FBZ0IsQ0FBTSxDQUFDLE9BQXZCO0NBQ0UscUJBQUEsdUJBQUE7Q0FBQSxFQUFBLENBQUcsRUFBQSxFQUFRLFVBQVg7Q0FBeUMsQ0FBUyxJQUFGLFVBQUEsV0FBQTtvQkFBaEQ7Q0FBQSxFQUVPLENBQVAsSUFBZSxVQUFmO0NBRkEsRUFJRSxDQURGLGNBQUE7Q0FDRSxDQUFXLEVBQVgsS0FBQSxXQUFBO0NBQUEsQ0FDTyxHQUFQLGVBQUE7Q0FMRixtQkFBQTtDQU9BLEVBQWMsQ0FBWCxDQUFzQixHQUF0QixNQUFzQixJQUF6QjtDQUNFO0NBQ0UsQ0FBcUIsRUFBckIsRUFBQSxDQUFPLENBQWMsY0FBckI7TUFERixnQkFBQTtDQUdFLEtBQUEsZ0JBREk7Q0FDSixHQUFBLElBQVEsY0FBUixpQkFBQTtzQkFKSjtvQkFQQTtDQUFBLEVBYW1CLENBQWYsRUFBbUMsS0FBdkMsQ0FBNkUsTUFBN0UsUUFBd0M7Q0FFeEM7Q0FBQSxlQUFBLE9BQUE7MkNBQUE7Q0FDRSxHQUFPLENBQVksR0FBWixNQUFQLE1BQUE7Q0FDRSxHQUFJLENBQU0saUJBQVY7Q0FDRSxDQUFVLE1BQVYsZ0JBQUE7Q0FBQSxDQUNTLEVBQUksR0FBYixpQkFBQTtDQUZGLHVCQUFBO3NCQUZKO0NBQUEsa0JBZkE7Q0FxQlEsR0FBUixFQUFBLENBQU8sa0JBQVA7Q0F0Qk8sQ0F1QlAsQ0FBQSxFQUFBLElBQUMsUUF2Qm1CO0NBd0JwQixDQUFrQyxDQUFsQyxFQUFBLEVBQU8sV0FBUCxFQUFBO0NBRUcsQ0FBRCxJQUFGLGVBQUEsSUFBQTtDQTFCTyxnQkF1QlA7Q0FLSyxFQUFLLENBQVosRUFBTSxHQUFPLGNBQWI7Q0FDRSxFQUFBLG1CQUFBO0NBQUEsRUFBa0MsQ0FBbEMsRUFBTSxDQUFRLEVBQVUsU0FBeEI7Q0FBQSxHQUNBLENBQUEsQ0FBTSxZQUFOO0NBREEsRUFFNEIsQ0FBQSxFQUF0QixNQUE0QixFQUFsQyxJQUFBO0NBQ1MsRUFBd0IsR0FBakMsQ0FBQSxDQUFRLElBQXFDLElBQTNCLFNBQWxCO0NBSkYsQ0FLRSxDQUFBLE1BQUMsUUFMUztDQU1WLENBQUEsSUFBTSxRQUFOLElBQUE7Q0FDUyxJQUFULEdBQVEsQ0FBUixnQkFBQTtDQVBGLGdCQUtFO0NBeENRLGNBQXdIO2NBRHBJO1lBREY7VUFGRjtDQXBEbUQsT0FtRHJEO0NBbkRZLElBQXlDO0NBL0N2RCxHQStDQTs7Q0EvQ0EsQ0FxSkEsSUFBTSxJQUFOLFNBQUE7RUFBa0QsQ0FBVyxFQUFyQixDQUFxQixDQUFBLENBQXRCLENBQUE7Q0FDckMsS0FBQSxJQUFBO0NBQUEsRUFBaUIsR0FBakIsQ0FBQSxLQUEwQixPQUFBO0NBQTFCLEVBRWlCLEdBQWpCLENBQUEsRUFBaUI7Q0FDZixPQUFBLElBQUE7Q0FBQSxFQUFjLENBQVgsRUFBVyxFQUFkLEdBQWM7Q0FDWixLQUFNLEVBQU4sRUFBQTtDQUNPLEtBQUQsRUFBTixLQUFBLElBQUE7VUFIYTtDQUZqQixNQUVpQjtDQUZqQixFQU9vQixHQUFwQixHQUFxQixDQUFyQixFQUFvQjtDQUNsQixPQUFBLElBQUE7Q0FBQSxDQUFtRSxDQUFwQixDQUE1QyxFQUFNLENBQU4sQ0FBSCxHQUErQyxDQUE1QztDQUNNLENBQXlCLElBQTFCLEVBQU4sRUFBQSxFQUFBLEtBQUE7VUFGZ0I7Q0FQcEIsTUFPb0I7Q0FQcEIsRUFXb0IsR0FBcEIsRUFBb0IsQ0FBQyxDQUFyQjtDQUNFLEVBQWdGLENBQTdFLEVBQU0sQ0FBTixDQUFILGdDQUF5QztDQUNoQyxLQUFELEVBQU4sRUFBQSxPQUFBO1VBRmdCO0NBWHBCLE1BV29CO0NBSWIsRUFBUyxHQUFWLEVBQVUsQ0FBQyxJQUFqQjtDQUNTLEtBQUQsRUFBTixLQUFBLEVBQUE7Q0FqQnlELE1BZ0IzQztDQWhCcUIsSUFBc0I7Q0FySjdELEdBcUpBOztDQXJKQSxDQTBLQSxJQUFNLElBQU4sUUFBQTtFQUFpRCxDQUFVLEVBQXBCLENBQW9CLEVBQXJCLENBQXNCO0NBQzFELEVBQWdCLEdBQWhCO0NBQ08sRUFBb0IsR0FBckIsR0FBcUIsSUFBM0IsSUFBQTtBQUM0QixDQUFuQixFQUFrQixHQUFuQixTQUFOO0NBSHVELE1BRTlCO0NBRlMsSUFBcUI7Q0ExSzNELEdBMEtBO0NBMUtBOzs7OztBQ0FBO0NBQUEsS0FBQSxrQkFBQTtLQUFBLGFBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0IsVUFBUDs7Q0FBVCxDQUdBLENBQVcsRUFBQSxHQUFYLENBQVk7Q0FDVixPQUFBLENBQUE7Q0FBQSxFQUFZLENBQVosQ0FBQSxJQUFBO0dBQ0EsTUFBQSxFQUFBO0NBQ0UsR0FBVSxFQUFWLEdBQUE7Q0FBQSxhQUFBO1FBQUE7Q0FBQSxFQUVZLENBRlosRUFFQSxHQUFBO0NBRkEsRUFHVyxHQUFYLEdBQVcsQ0FBWDtDQUFXLEVBQ0csTUFBWixNQUFBO0NBREYsQ0FFRSxHQUZGLEVBQVc7Q0FJUixDQUFELEVBQUYsS0FBVyxFQUFILEVBQVI7Q0FWTyxJQUVUO0NBTEYsRUFHVzs7Q0FIWCxDQWVNO0NBQ1MsQ0FBYyxDQUFkLENBQUEsQ0FBQSxDQUFBLFVBQUU7Q0FDYixFQURhLENBQUEsRUFBRDtDQUNaLEVBRHlCLENBQUEsRUFBRDtDQUN4QixFQUFBLENBQUMsRUFBRDtDQUFBLEVBQ1MsQ0FBUixDQUFELENBQUE7Q0FEQSxFQUVVLENBQVQsRUFBRDtDQUZBLEVBR1EsQ0FBUCxFQUFEO0NBSkYsSUFBYTs7Q0FBYixDQU02QixDQUFkLEdBQUEsR0FBQyxFQUFELEVBQWY7Q0FDRSxTQUFBLHNCQUFBOztHQURvQyxLQUFUO1FBQzNCO0NBQUEsRUFBUSxDQUFDLENBQVQsQ0FBQSxDQUFRLElBQUE7Q0FBUixFQUNZLENBQUMsRUFBYixHQUFBLEVBQVksS0FBQTtDQUVaLEdBQUcsRUFBSCxDQUFVLENBQVA7Q0FDRCxHQUFHLEVBQUEsRUFBSDtDQUFvQixHQUFXLENBQUosQ0FBQSxXQUFBO1VBQTNCO0NBQ0EsR0FBRyxFQUFBLEVBQUg7Q0FBb0IsRUFBMkIsQ0FBaEIsQ0FBSixDQUFXLFdBQVg7VUFEM0I7Q0FHQSxjQUFPO1FBUFQ7Q0FBQSxDQVVpQyxDQUF4QixHQUFULENBQVM7Q0FHVCxFQUFZLENBQVQsQ0FBQyxDQUFKO0NBQStDLENBQW1DLENBQWlCLENBQTVDLENBQWdDLE1BQWpDLEVBQUEsRUFBQTtRQWJ0RDtDQWNBLEVBQVksQ0FBVCxDQUFDLENBQUo7Q0FBK0MsQ0FBbUMsQ0FBaUIsQ0FBNUMsQ0FBZ0MsTUFBakMsRUFBQSxFQUFBO1FBZHREO0NBZ0JBLEVBQWEsQ0FBVixDQUFVLENBQWIsQ0FBRyxJQUFVO0NBQThCLENBQTRCLEtBQUosQ0FBakIsT0FBQTtRQWhCbEQ7Q0FpQkEsRUFBYSxDQUFWLENBQVUsQ0FBYixDQUFHLGFBQVU7Q0FBdUMsRUFBOEIsQ0FBbkIsQ0FBSixFQUEwQyxFQUEvQixDQUFZLEtBQXZCO1FBakIzRDtDQWtCQSxFQUFhLENBQVYsQ0FBVSxDQUFiLENBQUcsYUFBVTtDQUF1QyxFQUEwQixDQUFmLENBQUosRUFBc0MsR0FBbkIsS0FBbkI7UUFsQjNEO0NBb0JBLEVBQW9DLENBQTFCLENBQUEsQ0FBQSxNQUFBLFFBQU87Q0EzQm5CLElBTWU7O0NBTmYsQ0E2QmtCLENBQVQsQ0FBQSxFQUFBLENBQVQsRUFBVTtDQUNSLElBQUEsS0FBQTs7R0FEdUIsS0FBUDtRQUNoQjtDQUFBLEtBQUEsUUFBTztDQUFQLE1BQUEsTUFDTztDQUNILEVBQVEsRUFBUixLQUFBO0NBQVEsQ0FBTyxDQUFMLENBQVEsUUFBUjtDQUFGLENBQTJCLENBQUUsQ0FBQyxDQUFWLE9BQUE7Q0FBcEIsQ0FBZ0QsQ0FBRSxDQUFSLFFBQUE7Q0FBMUMsQ0FBc0UsQ0FBRSxDQUFGLEVBQVIsTUFBQTtDQUF0RSxXQUFBO0NBQUEsRUFDQSxDQUFDLE1BQUQ7Q0FGRztDQURQLEtBQUEsT0FJTztDQUNILEVBQVEsRUFBUixLQUFBO0NBQVEsQ0FBTyxDQUFMLENBQVEsUUFBUjtDQUFGLENBQTJCLENBQUUsQ0FBQyxDQUFWLE9BQUE7Q0FBcEIsQ0FBa0QsQ0FBRSxDQUFDLEVBQVgsTUFBQTtDQUExQyxDQUF5RSxDQUFFLENBQUYsQ0FBUCxPQUFBO0NBQTFFLFdBQUE7Q0FBQSxHQUNDLENBQUQsS0FBQTtDQUZHO0NBSlAsTUFBQSxNQU9PO0NBQ0gsRUFBUSxFQUFSLEtBQUE7Q0FBUSxDQUFTLENBQUUsQ0FBQyxDQUFWLE9BQUE7Q0FBRixDQUFnQyxDQUFFLENBQUMsRUFBWCxNQUFBO0NBQXhCLENBQXNELENBQUUsQ0FBUixRQUFBO0NBQWhELENBQTRFLENBQUUsQ0FBRixFQUFSLE1BQUE7Q0FBNUUsV0FBQTtDQUFBLEdBQ0MsRUFBRCxJQUFBO0NBRkc7Q0FQUCxLQUFBLE9BVU87Q0FDSCxFQUFRLEVBQVIsS0FBQTtDQUFRLENBQU8sQ0FBTCxDQUFRLFFBQVI7Q0FBRixDQUE0QixDQUFFLENBQUMsRUFBWCxNQUFBO0NBQXBCLENBQWtELENBQUUsQ0FBUixRQUFBO0NBQTVDLENBQXVFLENBQUUsQ0FBRixDQUFQLE9BQUE7Q0FBeEUsV0FBQTtDQUFBLEdBQ0MsTUFBRDtDQVpKLE1BQUE7Q0FETyxZQWVQO0NBNUNGLElBNkJTOztDQTdCVCxFQThDZ0IsTUFBQSxLQUFoQjtDQUNhLENBQXlCLENBQWhCLENBQWhCLENBQU8sQ0FBUCxPQUFBO0NBL0NOLElBOENnQjs7Q0E5Q2hCLEVBaURTLElBQVQsRUFBVSxFQUFEO0NBQ1AsVUFBQSxHQUFPO0NBQVAsU0FBQSxHQUNPO0NBQWlCLEdBQUEsYUFBRDtDQUR2QixXQUFBLENBRU87Q0FBbUIsR0FBQSxhQUFEO0NBRnpCLE1BRE87Q0FqRFQsSUFpRFM7O0NBakRULEVBc0RrQixNQUFDLEVBQUQsS0FBbEI7Q0FDRSxVQUFBLEdBQU87Q0FBUCxTQUFBLEdBQ087Q0FBaUIsRUFBUyxDQUFULEVBQUQsV0FBQTtDQUR2QixXQUFBLENBRU87Q0FBbUIsRUFBUSxDQUFSLENBQUQsWUFBQTtDQUZ6QixNQURnQjtDQXREbEIsSUFzRGtCOztDQXREbEI7O0NBaEJGOztDQUFBLENBNkVBLElBQU0sR0FBTjtHQUEyQixFQUFBLElBQUE7YUFDekI7Q0FBQSxDQUFVLENBQVYsS0FBQTtDQUFBLENBQ1MsRUFEVCxHQUNBLENBQUE7Q0FEQSxDQUVTLElBQUEsQ0FBVCxDQUFBLE9BQVM7Q0FGVCxDQUdZLEVBSFosSUFHQSxFQUFBO0NBSEEsQ0FJTyxFQUpQLENBSUEsR0FBQTtDQUpBLENBS1UsTUFBVix5U0FMQTtDQUFBLENBWVksTUFBWixFQUFBO0VBQXVCLENBQXNCLEdBQUEsRUFBakMsQ0FBa0MsQ0FBbEMsQ0FBQztDQUNYLGVBQUEsd0JBQUE7Q0FBQSxFQUFPLENBQVAsUUFBQTtDQUFBLENBRUMsS0FBZ0MsQ0FBUSxJQUF6QztDQUZBLENBSThCLENBQUEsR0FBeEIsQ0FBTixFQUErQixDQUFELEVBQTlCO0NBQ0UsR0FBRyxHQUFILE9BQUE7Q0FDRSxFQUFjLENBQVYsRUFBSixDQUFxQixDQUFyQixRQUFBO0NBQUEsRUFDbUIsQ0FBZixFQUFlLEtBQW5CLEdBQW1CLEVBQW5CO0NBREEsRUFFYyxDQUFWLEVBQUosQ0FBcUIsU0FBckI7Q0FGQSxFQUdBLENBQUksRUFBNEIsQ0FBZCxFQUhsQixPQUdBO0NBSEEsRUFJQSxDQUFJLEdBQWMsU0FBbEI7QUFDYSxDQUxiLEVBS1ksQ0FBUixFQUxKLENBS29CLFNBQXBCO0NBTEEsQ0FNMEMsQ0FBN0IsQ0FBVCxDQUFKLEVBQTZCLENBQWhCLFFBQWI7Q0FOQSxDQU9nRCxDQUE5QixDQUFkLEVBQXVCLENBQU8sQ0FBaEIsRUFBbEIsTUFBQTtDQUVLLEdBQUQsRUFBTyxpQkFBWDtnQkFYMEI7Q0FBOUIsQ0FZRSxFQVpGLFNBQThCO0NBSjlCLENBQUEsQ0FrQlksQ0FBWCxJQUFELElBQUE7Q0FsQkEsRUFtQlksQ0FBWCxJQUFELElBQUE7Q0FuQkEsRUFxQmUsQ0FBZCxDQUFjLElBQUMsRUFBaEIsQ0FBQTtDQUEyQixHQUFBLENBQUQsR0FBUyxhQUFUO0NBckIxQixZQXFCZTtDQXJCZixFQXVCa0IsQ0FBakIsRUFBaUIsR0FBQyxHQUFuQixFQUFBOztDQUFpQyxFQUFMLENBQUksWUFBYjtnQkFDakI7Q0FBQSxLQUFBLGdCQUFPO0NBQVAsTUFBQSxjQUNPO0NBRFAsTUFBQSxjQUNnQjtDQURoQix3QkFDNkI7Q0FEN0IsS0FBQSxlQUVPO0NBRlAsS0FBQSxlQUVlO0NBRmYsd0JBRTJCO0NBRjNCLGNBRGdCO0NBdkJsQixZQXVCa0I7Q0F2QmxCLENBNEI0QixDQUFULENBQWxCLEVBQWtCLEdBQUMsQ0FBRCxFQUFuQixHQUFBO0NBQ0UsSUFBQSxhQUFBO0NBQUEsRUFDRSxFQURGLFNBQUE7Q0FDRSxDQUFLLENBQUwsYUFBQTtDQUFBLENBQ08sR0FBUCxXQUFBO0NBREEsQ0FFUSxJQUFSLFVBQUE7Q0FGQSxDQUdNLEVBQU4sWUFBQTtDQUpGLGVBQUE7Q0FNQSxLQUFBLGdCQUFPO0NBQVAsTUFBQSxjQUNPO0NBQWEsQ0FBZSxDQUFBLENBQWYsQ0FBSyxDQUFMLElBQWUsUUFBZjtDQUFiO0NBRFAsS0FBQSxlQUVPO0NBQVksQ0FBYSxDQUFBLENBQWIsQ0FBSyxLQUFRLFFBQWI7Q0FBWjtDQUZQLE1BQUEsY0FHTztDQUFhLENBQVksQ0FBWixDQUFBLENBQUssS0FBTyxRQUFaO0NBQWI7Q0FIUCxLQUFBLGVBSU87Q0FBWSxDQUFjLENBQUEsQ0FBZCxDQUFLLEtBQVMsUUFBZDtDQUpuQixjQU5BO0NBRGlCLG9CQWFqQjtDQXpDRixZQTRCbUI7Q0E1Qm5CLENBMkMyQixDQUFULENBQWpCLEVBQWlCLEdBQUMsQ0FBRCxFQUFsQixFQUFBO0NBRUUsS0FBQSxnQkFBTztDQUFQLE1BQUEsY0FDTzt5QkFDSDtDQUFBLENBQVEsQ0FBRSxDQUFWLEVBQUEsSUFBVSxHQUFBLE9BQVY7Q0FBQSxDQUNPLEdBQVAsZUFBQTtDQURBLENBRU0sRUFBTixnQkFBQTtDQUZBLENBR1EsSUFBUixjQUFBO0NBTEo7Q0FBQSxNQUFBLGNBTU87eUJBQ0g7Q0FBQSxDQUFRLENBQUUsQ0FBVixFQUFBLElBQVUsR0FBQSxPQUFWO0NBQUEsQ0FDTyxHQUFQLGVBQUE7Q0FEQSxDQUVNLEVBQU4sZ0JBQUE7Q0FGQSxDQUdLLENBQUwsaUJBQUE7Q0FWSjtDQUFBLEtBQUEsZUFXTzt5QkFDSDtDQUFBLENBQU8sQ0FBRSxDQUFULENBQUEsQ0FBZSxJQUFOLEVBQUEsQ0FBQSxPQUFUO0NBQUEsQ0FDSyxDQUFMLGlCQUFBO0NBREEsQ0FFUSxJQUFSLGNBQUE7Q0FGQSxDQUdNLEVBQU4sZ0JBQUE7Q0FmSjtDQUFBLEtBQUEsZUFnQk87eUJBQ0g7Q0FBQSxDQUFPLENBQUUsQ0FBVCxDQUFBLENBQWUsSUFBTixFQUFBLENBQUEsT0FBVDtDQUFBLENBQ0ssQ0FBTCxpQkFBQTtDQURBLENBRVEsSUFBUixjQUFBO0NBRkEsQ0FHTyxHQUFQLGVBQUE7Q0FwQko7Q0FBQSxjQUZnQjtDQTNDbEIsWUEyQ2tCO0NBM0NsQixFQW1FZ0IsQ0FBZixLQUFlLEdBQWhCO0NBQ0UsT0FBUSxNQUFSO0NBQ0MsR0FBQSxFQUFNLE1BQVAsU0FBQTtDQXJFRixZQW1FZ0I7Q0FuRWhCLEVBc0VjLENBQWIsS0FBYSxDQUFkLEVBQUE7Q0FDRSxPQUFRLEdBQVIsR0FBQTtDQUNDLEdBQUEsRUFBTSxJQUFQLFdBQUE7Q0F4RUYsWUFzRWM7Q0F0RWQsRUEwRVUsQ0FBVCxFQUFELEdBQVcsR0FBWDs7QUFBbUIsQ0FBRCxFQUFBLENBQUssWUFBWjtnQkFDVDtDQUFBLEVBQVksQ0FBUixVQUFKO0FBRUksQ0FBSixHQUFHLFVBQUg7Q0FBYyxFQUFZLENBQVgsSUFBRCxRQUFBO01BQWQsVUFBQTtDQUNLLEVBQVEsQ0FBUCxJQUFELFFBQUE7Z0JBSEw7Q0FLQSxHQUFHLFVBQUg7Q0FBYSxPQUFRLEdBQVIsS0FBQTtNQUFiLFVBQUE7Q0FDSyxPQUFRLFFBQVI7Z0JBTkw7Q0FRQyxHQUFBLEVBQU0sZUFBUDtDQW5GRixZQTBFVTtDQTFFVixDQXFGbUIsQ0FBVCxDQUFULEVBQUQsR0FBVyxHQUFYO0NBQ0UsaUJBQUEsNkZBQUE7O0NBRCtCLEVBQUwsQ0FBSSxZQUFiO2dCQUNqQjtDQUFBLEVBQVMsQ0FBSSxFQUFiLFFBQUE7Q0FFQSxHQUFHLFVBQUg7Q0FBYSxPQUFRLEdBQVIsS0FBQTtNQUFiLFVBQUE7Q0FDSyxPQUFRLFFBQVI7Z0JBSEw7Q0FLQSxHQUFHLENBQVUsQ0FBVixFQUFILE1BQUE7Q0FDRSxFQUFBLEtBQVEsUUFBUjtDQUNFLENBQUssQ0FBTCxDQUFBLEVBQWEsWUFBYjtDQUFBLENBQ08sQ0FBRSxDQURULENBQ0EsQ0FBZSxZQUFmO0NBREEsQ0FFUSxDQUFFLENBRlYsRUFFQSxZQUFBO0NBRkEsQ0FHTSxDQUFFLENBQVIsRUFBYyxZQUFkO0NBSkYsaUJBQUE7SUFLTSxDQUFXLENBTm5CLENBTVEsU0FOUjtDQU9FLEVBQWMsQ0FBQyxFQUFELEtBQWQsR0FBYyxFQUFkO0NBQUEsQ0FDK0MsQ0FBbEMsQ0FBc0MsRUFBaEMsSUFBbkIsQ0FBYSxFQUFBLEdBQWI7QUFFSSxDQUFKLEdBQUcsWUFBSDtDQUNFLEVBQU8sQ0FBUCxNQUFBLFFBQUE7TUFERixZQUFBO0NBR0UsQ0FBeUMsQ0FBbEMsQ0FBUCxFQUFhLEtBQU4sRUFBQSxLQUFQO0NBQUEsQ0FFc0IsQ0FBZixDQUFQLEVBQTRCLEtBQU4sRUFBQSxLQUF0QjtDQUZBLENBR3NCLENBQWYsQ0FBUCxFQUE0QixLQUFOLEVBQUEsS0FBdEI7Q0FIQSxDQUlzQixDQUFmLENBQVAsRUFBNEIsS0FBTixLQUFBLEVBQXRCO0NBSkEsQ0FLc0IsQ0FBZixDQUFQLE1BQXNCLFFBQXRCO2tCQVhGO0NBQUEsRUFhUSxDQUFQLFlBQUQ7Q0FiQSxDQWV3QyxDQUF2QixDQUFBLEVBQU0sQ0FBTixPQUFqQixFQUFBO0NBZkEsQ0FnQndDLENBQXpCLENBQUMsRUFBRCxJQUFBLEVBQWYsR0FBZSxDQUFmO0NBaEJBLENBaUJzQyxDQUF4QixDQUFDLEVBQUQsSUFBQSxDQUFkLEdBQWMsRUFBZDtDQWpCQSxDQW1CdUIsQ0FBdkIsQ0FBQSxHQUFBLENBQVEsTUFBUixFQUFBO0NBbkJBLENBcUJ3QyxDQUF4QyxDQUFBLEdBQU8sQ0FBUCxJQUFBLElBQUE7Q0FyQkEsQ0FzQnlDLENBQXpDLENBQUEsR0FBTyxFQUFQLEdBQUEsSUFBQTtDQXRCQSxDQXVCdUMsQ0FBdkMsQ0FBQSxHQUFPLElBQVAsS0FBQTtnQkFuQ0Y7Q0FxQ0EsR0FBRyxFQUFILEVBQVksTUFBWjtDQUNFLEVBQVEsRUFBUixDQUFjLFFBQU4sRUFBUjtDQUNBO0NBQUEsb0JBQUEsdUJBQUE7cUNBQUE7Q0FBQSxFQUFRLEVBQVIsQ0FBUSxZQUFSO0NBQUEsZ0JBRkY7Z0JBckNBO0NBeUNBLEtBQUEsZUFBTztDQS9IVCxZQXFGVTtDQTRDVCxFQUFTLENBQVQsRUFBRCxHQUFXLFVBQVg7Q0FDRSxFQUFjLENBQVYsRUFBSixRQUFBO0NBRUMsR0FBQSxFQUFNLGVBQVA7Q0FySXlDLFlBa0lqQztDQWxJQSxVQUFpQztVQVo3QztDQUFBLENBb0pNLENBQUEsQ0FBTixFQUFNLEVBQU4sQ0FBTztDQUNMLFdBQUEsRUFBQTtDQUFBLENBRGlDLFFBQU47Q0FDM0IsRUFBYyxDQUFWLEVBQUosSUFBQTtDQUFBLEdBQ0EsRUFBTSxJQUFOLENBQUE7Q0FEQSxFQUc0QixDQUE1QixFQUFNLElBQU4sR0FBb0I7Q0FFYixDQUFzQixDQUFBLEdBQXZCLEdBQXdCLEVBQUQsRUFBN0IsSUFBQTtDQUNFLEdBQUcsT0FBSCxDQUFBO0NBQXdCLEVBQUQsS0FBSCxhQUFBLE1BQUE7TUFBcEIsUUFBQTtDQUNTLEVBQUQsUUFBSCxVQUFBLE1BQUE7Y0FGc0I7Q0FBN0IsVUFBNkI7Q0ExSi9CLFFBb0pNO0NBckptQjtDQUFGLElBQUU7Q0E3RTNCLEdBNkVBOztDQTdFQSxDQTZPQSxJQUFNLEdBQU4sS0FBQTtFQUE4QyxDQUFBLEVBQVgsRUFBVyxFQUFiO2FBQy9CO0NBQUEsQ0FBVSxDQUFWLEtBQUE7Q0FBQSxDQUNTLEtBQVQsQ0FBQSxRQUFTO0NBRFQsQ0FFTSxDQUFBLENBQU4sRUFBTSxFQUFOLENBQU87Q0FDTCxhQUFBLDBCQUFBO0NBQUEsQ0FEc0MsUUFBTjtBQUNsQixDQUFkLEdBQUEsTUFBQTtDQUFBLGlCQUFBO1lBQUE7Q0FBQSxDQUVBLENBQUssS0FBUyxFQUFkO0NBRkEsRUFJYyxPQUFkLENBQUE7Q0FKQSxFQUtZLE1BQVosQ0FBQTtDQUxBLEVBT2dCLEdBQVYsR0FBVSxDQUFoQjtDQUF3QixHQUFELFVBQUosS0FBQTtDQUFMLENBQThCLENBQUEsTUFBQyxFQUE3QjtDQUNkLE9BQVEsRUFBUixDQUFBLENBQUE7Q0FBQSxPQUNRLEdBQVIsQ0FBQTtDQUNBLFVBQUEsU0FBTztDQUFQLFNBQUEsU0FDTztDQUF5QixPQUFELEVBQVIsYUFBQTtDQUR2QixXQUFBLE9BRU87Q0FBMkIsT0FBRCxJQUFSLFdBQUE7Q0FGekIsWUFIMEM7Q0FBNUMsVUFBNEM7Q0FPekMsQ0FBRCxDQUErQixNQUFDLEVBQWxDLEtBQUEsQ0FBQTtDQUNFLGVBQUEsdUhBQUE7Q0FBQSxHQUFjLENBQVksQ0FBWixNQUFkO0NBQUEsbUJBQUE7Y0FBQTtDQUFBLEVBRVMsQ0FBSSxFQUFiLE1BQUE7Q0FFQSxHQUFHLENBQVcsQ0FBWCxDQUFBLEtBQUg7Q0FBcUMsRUFBUSxFQUFSLElBQUEsS0FBQTtJQUM3QixDQUFXLENBRG5CLFFBQUE7Q0FDd0MsRUFBUSxFQUFSLElBQUEsS0FBQTtjQUx4QztDQU9BLEdBQUcsQ0FBVyxDQUFYLENBQUEsS0FBSDtDQUFvQyxFQUFRLEVBQVIsU0FBQTtJQUM1QixDQUFXLENBRG5CLENBQ1EsT0FEUjtBQUNrRCxDQUFULEVBQVEsRUFBUixTQUFBO2NBUnpDO0NBQUEsRUFVVyxLQUFYLElBQUE7Q0FBVyxDQUFJLEtBQUosT0FBQztDQUFELENBQWtCLEtBQWxCLE9BQWU7Q0FWMUIsYUFBQTtDQUFBLEVBV2EsRUFBRSxLQUFmLEVBQUE7Q0FYQSxFQVlZLENBQUksS0FBaEIsR0FBQTtDQVpBLEVBYVksQ0FBSSxLQUFoQixHQUFBO0NBYkEsR0FlSSxRQUFKO0NBZkEsQ0FrQkUsQ0FBZ0IsQ0FsQmxCLFFBa0JBO0NBbEJBLENBbUJFLENBQWlCLE1BQUEsR0FBbkIsQ0FBQTtDQUFtQixvQkFBRztDQW5CdEIsWUFtQm1CO0NBbkJuQixDQW9CRSxDQUFvQixFQUFkLENBcEJSLElBb0JBLEVBQUEsQ0FBc0I7Q0FwQnRCLFdBd0JBLEVBQUE7Q0F4QkEsRUF5QnFCLENBekJyQixRQXlCQSxJQUFBO0NBekJBLEVBMEJJLENBMUJKLFFBMEJBO0NBMUJBLEVBNEJjLE1BQUMsRUFBZixDQUFBO0NBQ1MsRUFBTyxHQUFSLEdBQVEsWUFBZDtDQUFzQixHQUFELEVBQUosaUJBQUE7Q0FBakIsY0FBYztDQTdCaEIsWUE0QmM7Q0E1QmQsRUErQmtCLE1BQUMsR0FBbkIsR0FBQTtDQUNFLE9BQVEsTUFBUixhQUFBO0NBQUEsRUFLYyxHQUFSLEdBQVEsS0FBZDtDQUFpQixTQUFBLFVBQUE7Q0FBSyxFQUFvQixDQUFyQixDQUFpQyxDQUFyQyxHQUF5QixDQUFiLGFBQVo7Q0FBakIsY0FBYztDQUxkLGFBU0E7Q0FUQSxFQVVxQixDQVZyQixVQVVBLEVBQUE7Q0FDQSxFQUFJLGtCQUFKO0NBM0NGLFlBK0JrQjtDQS9CbEIsRUE2Q2dCLE1BQUMsR0FBakIsQ0FBQTtDQUNFLGlCQUFBLGtCQUFBO0NBQUEsQ0FBa0QsQ0FBakMsQ0FBSSxHQUFLLENBQW9CLE1BQTlDO0NBQUEsRUFDYyxDQUFJLEtBRGxCLEVBQ0EsR0FBQTtDQURBLENBR3lDLEVBQXpDLEdBQU8sSUFBUCxHQUFBLEtBQUEsS0FBQTtDQUhBLENBSXVDLEVBQXZDLEdBQU8sRUFBUCxJQUFBLENBQUEsS0FBQTtDQUpBLEVBTVUsSUFBVixFQUFVLEtBQVY7Q0FHRSxhQUFBLEVBQUE7Q0FBQSxFQUNxQixDQURyQixZQUNBO0NBREEsRUFFSSxDQUZKLFlBRUE7Q0FFSyxHQUFELE1BQUosYUFBQTtDQWJGLGNBTVU7Q0FVVixDQUEyQyxDQUF0QixDQUFsQixLQUFILEVBQXFCLEdBQXJCO0NBQ0UsVUFBQSxLQUFBO0NBQUEsTUFDQSxTQUFBO0NBQ0EscUJBQUE7Z0JBbkJGO0NBQUEsYUFzQkEsQ0FBQTtDQUVBLE1BQUEsY0FBQTtDQXRFRixZQTZDZ0I7Q0E3Q2hCLENBMEUyQixDQUFBLEtBQUEsSUFBM0IsR0FBMkIsU0FBM0I7Q0ExRUEsQ0E0RXNDLEVBQXRDLEdBQU8sSUFBUCxDQUFBLElBQUEsUUFBQTtDQUNRLENBQTRCLEVBQXBDLEdBQU8sRUFBUCxJQUFBLEdBQUEsR0FBQTtDQTlFRixVQUFpQztDQWpCbkMsUUFFTTtDQUhzQztDQUFiLElBQWE7Q0E3TzlDLEdBNk9BOztDQTdPQSxDQWtWQSxJQUFNLEdBQU4sS0FBQTtFQUE4QyxDQUFZLEVBQXZCLEVBQXVCLENBQUEsQ0FBekIsQ0FBQTthQUMvQjtDQUFBLENBQVUsQ0FBVixLQUFBO0NBQUEsQ0FDUyxFQURULEdBQ0EsQ0FBQTtDQURBLENBRVMsS0FBVCxDQUFBLE1BQVM7Q0FGVCxDQUdZLEVBSFosSUFHQSxFQUFBO0NBSEEsQ0FJVSxNQUFWLDZDQUpBO0NBQUEsQ0FRWSxNQUFaLEVBQUE7RUFBdUIsQ0FBc0IsR0FBQSxFQUFqQyxDQUFrQyxDQUFsQyxDQUFDO0NBQ1gsS0FBQSxVQUFBO0NBQUEsRUFBUyxDQUFULEVBQUEsTUFBQTtDQUFBLENBQUEsQ0FFWSxDQUFYLElBQUQsSUFBQTtDQUZBLEVBSWUsQ0FBZCxDQUFjLElBQUMsRUFBaEIsQ0FBQTtDQUNHLEdBQUEsQ0FBRCxHQUFTLGFBQVQ7Q0FMRixZQUllO0NBSmYsRUFPZ0IsQ0FBZixLQUFlLEdBQWhCO0NBQTRCLE9BQUQsYUFBUjtDQVBuQixZQU9nQjtDQVBoQixFQVFjLENBQWIsS0FBYSxDQUFkLEVBQUE7Q0FDRSxPQUFRLEdBQVIsR0FBQTtDQUNPLEtBQUQsSUFBTixXQUFBLENBQUE7Q0FWRixZQVFjO0NBSWIsRUFBUyxDQUFULEVBQUQsR0FBVyxVQUFYO0NBQ0UsaUJBQUEsa0JBQUE7Q0FBQSxHQUFVLEVBQU0sR0FBaEIsS0FBQTtDQUFBLHFCQUFBO2dCQUFBO0NBQUEsRUFFbUIsQ0FGbkIsRUFFTSxHQUFOLEtBQUE7Q0FGQSxFQUlRLEVBQVIsR0FBaUIsR0FKakIsR0FJQTtDQUpBLEVBS1MsR0FBVCxFQUFrQixJQUxsQixFQUtBO0NBTEEsQ0FPNkIsQ0FBZCxDQUFBLENBQUEsQ0FBQSxRQUFmO0NBUEEsQ0FTbUIsQ0FBSixDQUFkLElBQVEsQ0FBTyxLQUFoQjtDQUEwQixFQUFTLEVBQVYsa0JBQUE7Q0FBekIsY0FBZTtDQUVmO0NBQUEsa0JBQUEsd0JBQUE7a0NBQUE7Q0FBQSxFQUFTLEVBQUssQ0FBZCxVQUFBO0NBQUEsY0FYQTtDQUFBLENBYTBDLENBQUEsQ0FBSSxFQUF4QyxJQUFOLElBQUEsUUFBQTtDQUVPLEVBQVksR0FBYixHQUFOLFlBQUE7Q0E3QnlDLFlBYWpDO0NBYkEsVUFBaUM7VUFSN0M7Q0FBQSxDQXdDTSxDQUFBLENBQU4sRUFBTSxFQUFOLENBQU87Q0FDTCxhQUFBO0NBQUEsQ0FEbUMsUUFBUjtDQUMzQixHQUE4QixFQUE5QixJQUFBO0NBQUEsS0FBTSxLQUFOLENBQUE7WUFBQTtDQUFBLENBRW1DLENBQW5DLEdBQU0sR0FBNkIsQ0FBbkMsWUFBQTtBQUN5QixDQUF2QixHQUFBLEVBQUEsTUFBQTtDQUFPLEtBQUQsZUFBTjtjQURpQztDQUFuQyxVQUFtQztDQUZuQyxDQUttQyxDQUFBLElBQTVCLENBQVAsQ0FBb0MsQ0FBcEMsTUFBQTtDQUNFLFdBQUEsR0FBQTtDQUNPLEVBQU8sR0FBUixHQUFRLFVBQWQ7Q0FBd0IsS0FBRCxlQUFOO0NBQWpCLFlBQWM7Q0FGaEIsVUFBbUM7Q0FJMUIsRUFBQSxLQUFULENBQVMsUUFBVDtBQUFtQyxDQUF2QixHQUFBLEVBQUEsTUFBQTtDQUFPLEtBQUQsZUFBTjtjQUFIO0NBQVQsVUFBUztDQWxEWCxRQXdDTTtDQXpDa0Q7Q0FBekIsSUFBeUI7Q0FsVjFELEdBa1ZBO0NBbFZBOzs7OztBQ0FBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLEtBQUEscUJBQUE7O0NBQUEsQ0FDQSxLQUFBLG1CQUFBOztDQURBLENBRUEsS0FBQSxzQkFBQTs7Q0FGQSxDQUdBLEtBQUEseUJBQUE7O0NBSEEsQ0FLQSxDQUFTLEdBQVQsQ0FBZ0IsZ0JBQXdDLEVBQUEsQ0FBQSxHQUFBLENBQS9DOztDQUxULENBWUEsSUFBTSxHQUFOLEdBQUE7RUFBK0MsQ0FBMkQsRUFBekUsRUFBRixDQUEyRSxDQUEzRSxDQUFBLENBQTJFLENBQTNFLENBQUE7Q0FDN0IsU0FBQSxrREFBQTtDQUFBLEVBQVksR0FBWixDQUFZLEVBQVosR0FBWTtDQUFaLEVBQ1csR0FBWCxDQUFXLENBQVgsT0FEQSxPQUNXO0NBRFgsRUFFYyxHQUFkLENBQWMsSUFBZCxPQUFjO0NBRmQsRUFHYyxHQUFkLENBQWMsSUFBZCxNQUFjO0NBSGQsRUFJUSxFQUFSLENBQUEsQ0FBUSxJQUFBO0NBSlIsRUFNUyxHQUFULENBQVMsS0FBQTthQUVUO0NBQUEsQ0FBVSxDQUFWLEtBQUE7Q0FBQSxDQUNTLEVBRFQsR0FDQSxDQUFBO0NBREEsQ0FHRSxHQURGLEdBQUE7Q0FDRSxDQUFRLENBQVIsR0FBQSxJQUFBO1VBSEY7Q0FBQSxDQUlVLE1BQVYsNkJBSkE7Q0FBQSxDQVFNLENBQUEsQ0FBTixDQUFNLENBQUEsRUFBTixDQUFPO0NBQ0wsYUFBQSwySEFBQTtDQUFBLENBQTZDLENBQWhDLENBQUEsQ0FBYyxDQUEzQixFQUEyQixDQUFkLENBQWIsRUFBNkM7Q0FBN0MsRUFDUyxHQUFULENBQWdCLEdBQWhCLEVBQVMsQ0FBQTtDQURULEVBRWlCLENBRmpCLE1BRUEsSUFBQTtDQUZBLENBQUEsQ0FHVSxJQUFWLEdBQUE7Q0FIQSxDQUtnRCxDQUE3QyxHQUFPLEdBQXNDLENBQWhELGNBQUE7Q0FDRSxLQUFNLElBQU4sRUFBQTtDQUNFLENBQTJCLEVBQTNCLFVBQUEsV0FBQTtDQUFBLENBQ2dCLEVBRGhCLFVBQ0E7Q0FGRixhQUFBO0NBSXFCLEVBQUosSUFBQSxPQUFqQixLQUFBO0NBTEYsVUFBZ0Q7Q0FMaEQsRUFZZ0IsR0FBVixHQUFVLENBQWhCO0NBQTRCLEtBQU0sRUFBUCxXQUFSO0NBQUwsQ0FBOEIsQ0FBQSxFQUFBLElBQUMsRUFBN0I7Q0FDZCxHQUF5QyxDQUF6QyxPQUFBO0NBQU8sRUFBcUIsRUFBNUIsQ0FBTSxFQUFOLElBQWlCLFNBQWpCO2NBRDBDO0NBQTVDLFVBQTRDO0NBWjVDLEVBZ0JZLEtBQUEsQ0FBWixDQUFBO0NBQThDLEVBQU4sRUFBSyxHQUFMLEdBQWQsRUFBYyxNQUFkO0NBaEIxQixVQWdCWTtDQWhCWixFQWtCaUIsRUFBQSxJQUFDLENBQWxCLElBQUE7Q0FDRSxJQUEwQixDQUFwQixDQUFvQixHQUExQixFQUFBO0NBQ08sSUFBUCxDQUFNLGFBQU47Q0FwQkYsVUFrQmlCO0NBbEJqQixFQXNCYSxHQUFBLEdBQUMsQ0FBZDtDQUNFLEVBQUEsYUFBQTtDQUFBLEVBQUEsR0FBWSxDQUFRLEtBQXBCO0NBQ08sRUFBd0IsR0FBekIsU0FBc0IsSUFBNUIsQ0FBQTtDQXhCRixVQXNCYTtDQXRCYixDQTBCd0IsQ0FBUixDQUFBLENBQUEsSUFBQyxDQUFqQixHQUFBO0NBQ0UsZUFBQSwrQ0FBQTtDQUFBLENBQWlCLENBQUEsQ0FBQSxHQUFZLEdBQTdCLENBQWlCLENBQWpCO0NBQUEsR0FDOEIsTUFBcEIsQ0FBb0IsQ0FBOUIsRUFBQTtDQURBLEdBRUEsTUFBVSxFQUFWO0NBRkEsS0FHcUMsRUFBUCxFQUFwQixFQUFWO0FBQzJCLENBSjNCLEdBSWdELEVBQUwsQ0FBM0MsQ0FBb0MsRUFBMUIsRUFBVixFQUFBO0NBSkEsQ0FLNkQsQ0FBN0QsQ0FBaUQsQ0FBTSxDQUFYLEVBQVAsRUFBM0IsRUFBVixLQUFBO0NBTEEsR0FNaUMsR0FBakMsQ0FBbUIsQ0FBQSxDQUFULEVBQVY7Q0FOQSxFQVNBLE9BQWdCLENBQVYsQ0FBTjtDQVRBLEVBV29CLE1BQUMsR0FBckIsS0FBQTtBQUNTLENBQVAsR0FBQSxHQUFBLEdBQWlCLElBQWpCO0NBQXNDLEVBQU8sR0FBUixHQUFRLGNBQWQ7Q0FDN0IsQ0FBQSxvQkFBQTtDQUFBLENBQUEsQ0FBSyxlQUFMLENBQUs7Q0FFTCxHQUFhLEVBQWIsb0JBQU87Q0FBUCxXQUFBLGFBQ087Q0FBeUIsQ0FBMEIsQ0FBRyxDQUFkLENBQTJDLENBQTNELEVBQU4sRUFBQSxLQUFpQyxjQUFqQztDQUR6QixZQUFBLFlBRU87Q0FBMEIsQ0FBMEIsQ0FBRyxDQUFkLENBQTJDLENBQTNELEVBQU4sRUFBQSxLQUFpQyxjQUFqQztDQUYxQixXQUFBLGFBR087Q0FBeUIsQ0FBMEIsQ0FBRyxDQUFkLENBQTJDLENBQTNELEVBQU4sRUFBQSxLQUFpQyxjQUFqQztDQUh6QixZQUFBLFlBSU87Q0FBMEIsQ0FBMEIsQ0FBRyxDQUFkLENBQTJDLENBQTNELEVBQU4sRUFBQSxLQUFpQyxjQUFqQztDQUoxQixrQkFIMkM7Q0FBZCxnQkFBYztnQkFEM0I7Q0FYcEIsWUFXb0I7Q0FYcEIsRUFxQjhCLE1BQUMsR0FBL0IsZUFBQTtBQUNTLENBQVAsR0FBQSxHQUFBLEdBQWlCLElBQWpCO0NBQXNDLEVBQU8sR0FBUixHQUFRLGNBQWQ7Q0FDN0IsRUFBQSxtQkFBQTtDQUFBLEVBQUksQ0FBRCxFQUFhLEVBQU4sSUFBQSxNQUFWO0NBQ0UsRUFBMkQsQ0FBakQsQ0FBQSxHQUFBLGtCQUFBLGlCQUFPO29CQURuQjtDQUFBLENBR2tDLEVBQVgsRUFBdkIsRUFBQSxFQUE0QyxDQUFqQyxHQUF1QixJQUFsQztDQUVXLENBQWdDLEVBQTNDLE1BQVUsSUFBdUMsS0FBakQsTUFBQTtDQU42QixnQkFBYztnQkFEakI7Q0FyQjlCLFlBcUI4QjtDQXJCOUIsRUE4QmlCLEVBQVQsRUFBQSxHQTlCUixFQThCQTtDQTlCQSxDQWdDa0MsRUFBWCxFQUF2QixFQUFBLEVBQTRDLENBQWpDLENBQVgsRUFBa0M7Q0FoQ2xDLENBa0NBLE1BQUEsRUFBVSxFQUFWLEtBQUE7Q0FsQ0EsQ0FtQ0EsUUFBVSxFQUFWLE1BQUEsU0FBQTtDQUVXLEVBQVUsSUFBckIsRUFBcUIsQ0FBWCxTQUFWO0NBQ0UsQ0FBeUIsQ0FBekIsS0FBQSxFQUFVLElBQVYsR0FBQTtDQUNXLENBQXdCLENBQW5DLE9BQVUsUUFBVixHQUFBLE1BQUE7Q0F4Q1ksWUFzQ087Q0FoRXZCLFVBMEJnQjtDQTFCaEIsRUFvRW1CLEVBQUEsSUFBQyxDQUFwQixNQUFBO0NBQ0UsR0FBQSxZQUFBO0FBQU8sQ0FBUCxHQUFBLENBQWUsRUFBQSxLQUFmO0NBQTJCLHNCQUEzQjtjQUFBO0NBQUEsSUFDUSxFQUFBLEtBQVI7Q0FEQSxDQUVzQixHQUF0QixDQUFBLENBQU8sS0FBUDtDQUVBLEVBQVUsQ0FBUCxDQUFPLENBQU0sTUFBaEIsRUFBVTtDQUNJLEdBQVcsRUFBdkIsRUFBQSxHQUFXLFVBQVg7Y0FOZTtDQXBFbkIsVUFvRW1CO0NBcEVuQixFQTRFUSxFQUFSLEdBQVEsQ0FBQyxDQUFUO0NBQ0UsZUFBQSxvQkFBQTtBQUFBLENBQUEsRUFBQSxjQUFpQyw0Q0FBakM7Q0FBQSxFQUFBLFdBQUEsRUFBQTtDQUFBLFlBQUE7Q0FDQTtDQUFBLGdCQUFBLHVDQUFBO2lDQUFBO0NBQUEsQ0FBbUIsQ0FBbkIsQ0FBQSxTQUFBLENBQUE7Q0FBQSxZQURBO0NBR2UsS0FBZSxFQUFQLENBQXZCLEtBQUEsS0FBQTtDQWhGRixVQTRFUTtDQTVFUixDQWtGNEIsQ0FBUixFQUFBLEdBQUEsQ0FBQyxDQUFyQixPQUFBO0NBQ0UsS0FBQSxVQUFBO0NBQUEsRUFBZ0QsQ0FBVCxDQUFpQixDQUFqQixDQUFpQixLQUF4RDtDQUFPLEtBQUQsQ0FBTixDQUFlLENBQUEsWUFBZjtjQURrQjtDQWxGcEIsVUFrRm9CO0NBbEZwQixDQXFGQSxDQUFtQixHQUFiLENBQU4sQ0FBbUIsQ0FBQyxDQUFwQjtDQUEwQyxJQUFOLEdBQUEsV0FBQTtDQUFwQyxVQUFtQjtDQXJGbkIsQ0F1RkEsQ0FBMkIsR0FBckIsRUFBcUIsQ0FBQyxDQUE1QixLQUFBO0NBQ2lCLElBQWYsU0FBQSxLQUFBO0NBREYsVUFBMkI7Q0F2RjNCLENBMEZBLENBQTZCLEdBQXZCLEVBQXVCLENBQUMsQ0FBOUIsT0FBQTtDQUNhLEtBQVgsSUFBQSxTQUFBO0NBREYsVUFBNkI7Q0ExRjdCLENBNkZBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUNnQixDQUFTLEdBQXZCLEdBQStCLEtBQS9CLE1BQUE7Q0FERixVQUF3QjtDQTdGeEIsQ0FnR0EsQ0FBd0IsR0FBbEIsRUFBa0IsQ0FBQyxDQUF6QixFQUFBO0NBQ0UsSUFBQSxPQUFBLElBQUE7Q0FDWSxLQUFaLEVBQUEsR0FBVyxRQUFYO0NBRkYsVUFBd0I7Q0FoR3hCLENBb0dBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUNFLENBQTJCLEdBQTNCLEdBQUEsSUFBQSxLQUFBO0NBQ1ksQ0FBbUIsSUFBL0IsRUFBQSxHQUFXLENBQVgsT0FBQTtDQUZGLFVBQXdCO0NBcEd4QixDQXdHQSxDQUF3QixHQUFsQixFQUFrQixDQUFDLENBQXpCLEVBQUE7Q0FDRSxTQUFBLE1BQUE7QUFBaUYsQ0FBakYsRUFBOEYsQ0FBOUYsQ0FBc0csRUFBQSxHQUFyQixFQUFqRjtDQUFBLEdBQVUsQ0FBQSxlQUFBLG9DQUFBO2NBQVY7Q0FDVyxDQUFxRCxDQUFsRCxDQUFkLEVBQUEsSUFBVSxLQUFZLElBQXRCO0NBRkYsVUFBd0I7Q0F4R3hCLENBNEdBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUNFLFNBQUEsTUFBQTtBQUFpRixDQUFqRixFQUE4RixDQUE5RixDQUFzRyxFQUFBLEdBQXJCLEVBQWpGO0NBQUEsR0FBVSxDQUFBLGVBQUEsb0NBQUE7Y0FBVjtDQUNXLENBQXNFLENBQW5FLENBQW1ILENBQXRHLENBQTNCLElBQVUsS0FBNkIsSUFBdkM7Q0FGRixVQUF3QjtDQTVHeEIsSUFnSEEsQ0FBWSxJQUFaLENBQU07Q0FoSE4sS0FpSHFCLElBQXJCLElBQUEsSUFBZTtDQWpIZixLQWtIaUIsSUFBakIsU0FBVztDQWxIWCxDQXFIbUMsQ0FBbkMsR0FBTSxHQUE2QixDQUFuQyxZQUFBO0NBQTZDLEtBQUQsYUFBTjtDQUF0QyxVQUFtQztDQUUxQixFQUFBLEtBQVQsQ0FBUyxRQUFUO0NBQ1MsS0FBRCxhQUFOO0NBREYsQ0FFRSxDQUZGLFFBQVM7Q0FoSVgsUUFRTTtDQWpCa0c7Q0FBM0UsSUFBMkU7Q0FaMUcsR0FZQTtDQVpBOzs7OztBQ0FBO0NBQUEsS0FBQSxpQkFBQTs7Q0FBQSxDQUFBLENBQVEsRUFBUixFQUFROztDQUFSLENBQ0EsQ0FBVyxJQUFBLENBQVgsU0FBVzs7Q0FEWCxDQUdBLEtBQUEsb0JBQUE7O0NBSEEsQ0FLQSxLQUFBLHFCQUFBOztDQUxBLENBTUEsS0FBQSxtQkFBQTs7Q0FOQSxDQU9BLEtBQUEsaUJBQUE7O0NBUEEsQ0FRQSxLQUFBLHNCQUFBOztDQVJBLENBU0EsS0FBQSx5QkFBQTs7Q0FUQSxDQVVBLEtBQUEsb0JBQUE7O0NBVkEsQ0FZQSxDQUFTLEdBQVQsQ0FBZ0IsY0FBdUMsR0FBQSxDQUFBLENBQUEsR0FBOUM7O0NBWlQsQ0FvQkEsSUFBTSxHQUFOLEVBQUE7RUFBNEMsQ0FBdUQsRUFBbkUsQ0FBbUUsQ0FBQSxDQUFyRSxDQUFBLENBQUEsQ0FBcUUsRUFBckU7YUFDNUI7Q0FBQSxDQUFVLENBQVYsS0FBQTtDQUFBLENBQ1MsRUFEVCxHQUNBLENBQUE7Q0FEQSxDQUdFLEdBREYsR0FBQTtDQUNFLENBQVMsQ0FBVCxJQUFBLEdBQUE7VUFIRjtDQUFBLENBSVUsTUFBVixrZUFKQTtDQUFBLENBZU0sQ0FBQSxDQUFOLENBQU0sQ0FBQSxFQUFOLENBQU87Q0FDTCxhQUFBLDJEQUFBO0NBQUEsQ0FBc0IsQ0FBQSxFQUFhLENBQTdCLElBQU47Q0FBQSxFQUVXLEtBQVgsRUFBQSxJQUFXLFFBQUE7Q0FGWCxFQUlTLEdBQVQsQ0FBZ0IsR0FBaEIsQ0FBUyxDQUFBO0NBSlQsRUFLWSxDQUxaLEtBS0EsQ0FBQTtDQUxBLEVBT1UsSUFBVixDQUFVLENBQUMsQ0FBWDtDQUNFLGVBQUEsMkJBQUE7Q0FBQSxHQUFVLEVBQU0sQ0FBUSxLQUF4QjtDQUFBLG1CQUFBO2NBQUE7Q0FFQSxFQUFjLENBQVgsSUFBQSxHQUFzQixDQUF6QjtDQUNFLEVBQWtCLEdBQVosQ0FBTixDQUFBLE1BQUEseUNBQWtCO0NBQ2xCLG1CQUFBO01BRkYsUUFBQTtDQUlFLENBQUEsQ0FBaUIsR0FBWCxDQUFOLE9BQUE7Y0FORjtDQUFBLEVBUU8sQ0FBUCxFQUFPLEVBQVEsSUFBZixDQUFPO0NBUlAsRUFTcUIsQ0FBakIsQ0FBTSxDQVRWLENBU0EsS0FBQTtDQVRBLENBVTRCLEVBQXhCLEVBQUosRUFBQSxJQUFBO0NBVkEsQ0FXNEIsRUFBeEIsRUFBOEIsRUFBbEMsRUFBQSxFQUFBO0NBWEEsQ0FZNEIsRUFBeEIsSUFBSixJQUFBLFVBQUE7Q0FFQTtDQUFBLGdCQUFBLDBCQUFBOytCQUFBO0NBQ0UsRUFBUSxFQUFSLEVBQVEsQ0FBUSxLQUFSLENBQVI7Q0FBQSxDQUMyQixHQUF0QixDQUFMLEVBQUEsSUFBQSxFQUFBO0NBREEsQ0FFNEIsQ0FBTyxDQUFJLENBQWxDLENBQUwsRUFBNEIsSUFBNUIsRUFBQTtDQUZBLENBRzRCLEVBQUksQ0FBM0IsRUFBTCxLQUFBLEVBQUE7Q0FIQSxHQUtJLENBQUosTUFBQSxHQUFBO0NBTkYsWUFkQTtDQUFBLEdBc0JhLElBQUwsR0FBUixDQUFBO0NBdEJBLEdBd0JJLEVBQUosTUFBQTtDQUVTLEdBQUksSUFBTCxHQUFSLFFBQUE7Q0FsQ0YsVUFPVTtDQVBWLEVBb0NlLE1BQUEsQ0FBZixFQUFBO0NBQXlCLEVBQU8sR0FBUixHQUFRLFVBQWQ7Q0FBeUIsS0FBTSxDQUFkLElBQVEsVUFBUjtDQUFqQixZQUFjO0NBcENoQyxVQW9DZTtDQXBDZixDQXFDK0MsQ0FBdkIsRUFBQSxHQUFBLENBQXlDLENBQWpFLEVBQXdCLFNBQXhCO0NBckNBLEVBdUNnQixHQUFWLEdBQVUsQ0FBaEI7Q0FBNEIsT0FBRCxDQUFVLFVBQWxCO0NBQUwsQ0FBZ0MsQ0FBQSxFQUFBLEdBQUEsQ0FBQyxFQUEvQjtDQUNkLEdBQUcsQ0FBQSxHQUFILElBQUE7Q0FDbUMsQ0FBdUIsQ0FBaEMsRUFBQSxHQUFBLGFBQXhCO2NBRjBDO0NBQTlDLFVBQThDO0NBdkM5QyxFQTJDZ0IsR0FBVixHQUFVLENBQWhCO0NBQTBCLEtBQUQsQ0FBUSxZQUFkO0NBQUwsQ0FBcUMsQ0FBQSxHQUFBLEdBQUMsRUFBcEM7Q0FDZCxHQUFHLEVBQUgsTUFBQTtDQUNFLEVBQWtDLEtBQTFCLEtBQWMsQ0FBdEI7SUFDTSxFQUZSLEdBRVEsS0FGUjtDQUdFLEtBQWMsQ0FBZCxJQUFRLEdBQVI7Y0FIRjtDQURpRCxFQU1yQyxNQUFaLFVBQUE7Q0FORixVQUFtRDtDQTNDbkQsQ0FtREEsSUFBTSxDQUFOLEdBQUEsV0FBQTtDQW5EQSxDQXFEQSxJQUFNLElBQU4sRUFBQSxTQUFBO0NBckRBLENBc0RBLElBQU0sSUFBTixFQUFBLFNBQUE7Q0F0REEsQ0F1REEsSUFBTSxJQUFOLEVBQUEsU0FBQTtDQXZEQSxDQXlEQSxJQUFNLElBQU4sRUFBQSxTQUFBO0NBekRBLENBMERBLElBQU0sSUFBTixFQUFBLFNBQUE7Q0FFTyxDQUFnQixDQUF2QixHQUFNLEdBQWlCLENBQXZCLE9BQUE7Q0FDRSxDQUFvQixDQUFwQixHQUFNLENBQU4sS0FBQSxTQUFBO0NBQUEsQ0FFeUIsQ0FBekIsR0FBTSxNQUFOLFNBQUE7Q0FGQSxDQUd5QixDQUF6QixHQUFNLE1BQU4sU0FBQTtDQUhBLENBSXlCLENBQXpCLEdBQU0sTUFBTixTQUFBO0NBSkEsQ0FNeUIsQ0FBekIsR0FBTSxNQUFOLFNBQUE7Q0FDTyxDQUFrQixDQUF6QixHQUFNLE1BQU4sT0FBQSxFQUFBO0NBUkYsVUFBdUI7Q0E1RXpCLFFBZU07Q0FoQjJGO0NBQXJFLElBQXFFO0NBcEJuRyxHQW9CQTtDQXBCQTs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxLQUFBLCtCQUFBOztDQUFBLENBRUEsS0FBQSxzQkFBQTs7Q0FGQSxDQUdBLEtBQUEsb0JBQUE7O0NBSEEsQ0FLQSxDQUFTLEdBQVQsQ0FBZ0IsT0FBcUMsVUFBQSxFQUFBLENBQTVDOztDQUxULENBWUEsSUFBTSxHQUFOLE9BQUE7RUFBK0MsQ0FBaUMsRUFBM0MsQ0FBMkMsQ0FBQSxDQUE3QyxDQUFBLENBQUE7YUFDakM7Q0FBQSxDQUFVLENBQVYsS0FBQTtDQUFBLENBQ1MsRUFEVCxHQUNBLENBQUE7Q0FEQSxDQUVPLEVBRlAsQ0FFQSxHQUFBO0NBRkEsQ0FHVSxNQUFWLHkxQkFIQTtDQUFBLENBMEJNLENBQUEsQ0FBTixFQUFNLEVBQU4sQ0FBTztDQUNMLEtBQUEsUUFBQTtDQUFBLEVBQVMsR0FBVCxDQUFnQixHQUFoQixFQUFTLE9BQUE7Q0FFRixFQUFPLENBQWQsRUFBTSxHQUFRLFFBQWQ7Q0FDVyxHQUFULElBQVEsV0FBUixVQUFBO0NBSkUsVUFHVTtDQTdCaEIsUUEwQk07Q0EzQndFO0NBQTdDLElBQTZDO0NBWmhGLEdBWUE7Q0FaQTs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0Isc0JBQVA7O0NBQVQsQ0FFQSxDQUE4QixHQUF4QixDQUFOLEVBQThCLElBQTlCO1dBQ0U7Q0FBQSxDQUFhLElBQWIsS0FBQTtDQUFBLENBRVEsQ0FBQSxHQUFSLEVBQVEsQ0FBQyxFQUFEO0NBQ04sSUFBQSxPQUFBOztHQUQrQixPQUFkO1VBQ2pCO0NBQVEsQ0FBa0IsQ0FBQyxDQUEzQixDQUF3QyxFQUFqQyxDQUFpQyxHQUF4QyxJQUFBO0NBSEYsTUFFUTtDQUZSLENBS1EsQ0FBQSxHQUFSLEdBQVMsR0FBRDtDQUNOLENBQUEsQ0FBNkIsQ0FBNUIsSUFBRCxHQUFhLENBQUE7QUFDYixDQUFBLEdBQVEsRUFBUixLQUFvQixDQUFBLEdBQXBCO0NBUEYsTUFLUTtDQUxSLENBU1EsQ0FBQSxHQUFSLEVBQVEsQ0FBQztBQUNQLENBQUEsR0FBUSxFQUFSLEVBQW9CLEdBQUEsSUFBcEI7Q0FWRixNQVNRO0NBVFIsQ0FZVSxDQUFBLEdBQVYsRUFBQSxDQUFVO0NBQ1IsV0FBQSxxQ0FBQTtDQUFBO0NBQUEsWUFBQSxHQUFBO3dDQUFBO0FBRUUsQ0FBQSxjQUFBLG1DQUFBOzBDQUFBO0NBQThELEdBQVgsQ0FBbUIsS0FBVDtDQUE3RCxPQUFBLGFBQU87Y0FBUDtDQUFBLFVBRkY7Q0FBQSxRQUFBO0NBSUEsSUFBQSxVQUFPO0NBakJULE1BWVU7Q0Fia0I7Q0FBOUIsRUFBOEI7Q0FGOUI7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsQ0FBUyxHQUFULENBQWdCLG9CQUFQOztDQUFULENBRUEsR0FBQSxDQUFNLEtBQU47Q0FDRSxDQUFPLEVBQVAsQ0FBQTtPQUNFO0NBQUEsQ0FBVSxNQUFWLElBQUE7Q0FBQSxDQUNTLEtBQVQsQ0FBQSx1ZEFEQTtFQWtCQSxNQW5CSztDQW1CTCxDQUFVLE1BQVY7Q0FBQSxDQUNTLEtBQVQsQ0FBQSxtSEFEQTtFQVNBLE1BNUJLO0NBNEJMLENBQVUsTUFBVixHQUFBO0NBQUEsQ0FDUyxLQUFULENBQUEsZUFEQTtRQTVCSztNQUFQO0NBSEYsR0FFQTtDQUZBOzs7OztBQ0FBO0NBQUEsS0FBQSxnQkFBQTtLQUFBLGFBQUE7O0NBQUEsQ0FBQSxDQUFpQixJQUFBLE9BQWpCLCtCQUFpQjs7Q0FBakIsQ0FDQSxLQUFBLG1DQUFBOztDQURBLENBR0EsS0FBQSxxQkFBQTs7Q0FIQSxDQU1BLENBQVMsR0FBVCxDQUFnQixpQkFBUCxDQUF5Qzs7Q0FObEQsQ0FVQSxJQUFNLENBQU4sQ0FBQTtFQUF5QyxDQUFpQixDQUFqQyxDQUFFLEVBQStCLEVBQWpDLENBQWlDLEVBQWpDO0NBQ3ZCLFNBQUEsV0FBQTtDQUFBLENBQThCLENBQTlCLEdBQUEsQ0FBTyxPQUFQLEVBQUE7Q0FBQSxDQUV1QyxDQUE5QixDQUFBLEVBQVQsRUFBUyxNQUFjO0NBQWdCLENBQVksRUFBWixJQUFDLENBQUE7Q0FGeEMsT0FFUztDQUZULEVBR1ksQ0FBQSxDQUFaLENBQUEsQ0FBMEIsR0FBZDtDQUhaLEVBSVMsR0FBVCxDQUFnQixLQUFQO2FBRVQ7Q0FBQSxDQUFTLENBQUEsSUFBVCxDQUFBLENBQVU7Q0FDUixPQUFBLE1BQUE7Q0FBQSxDQUFRLENBQVIsRUFBTSxLQUFOO0NBQUEsQ0FDcUMsQ0FBckMsRUFBVyxJQUFMLENBQU4sQ0FBTTtDQUROLEVBR0csTUFBSCxDQUFBO0NBSEEsRUFLRyxNQUFILENBQUE7Q0FBNEIsRUFBTyxHQUFsQixHQUFrQixDQUFSLFNBQVY7Q0FDZixPQUFBLFVBQUE7QUFBTyxDQUFQLEVBQVUsQ0FBVixVQUFBO0NBQ0UsQ0FBb0IsQ0FBakIsR0FBSCxDQUFBLENBQW9CLENBQWlDLEVBQXRCLEtBQS9CO0NBQ00sRUFBRCxJQUFILENBQUEsaUJBQUE7Q0FERixnQkFBcUQ7TUFEdkQsVUFBQTtDQUlFLEVBQXdCLEVBQXhCLENBQU0sRUFBTyxHQUFXLEtBQXhCO0NBQUEsRUFDRyxJQUFILENBQUEsUUFBQTtnQkFMRjtDQU9PLENBQVAsQ0FBc0IsR0FBaEIsR0FBaUIsQ0FBdkIsV0FBQTtDQUVNLENBQUosQ0FBRyxLQUFILGVBQUE7Q0FGRixjQUFzQjtDQVJQLFlBQWtCO0NBQW5DLFVBQWM7Q0FMZCxDQWlCQSxDQUFHLENBQUgsS0FBYyxDQUFkO0FBQ1MsQ0FBUCxHQUFBLEdBQUEsR0FBaUIsRUFBakI7Q0FBMEMsRUFBTyxHQUFsQixHQUFrQixDQUFSLFdBQVY7Q0FDN0IsRUFBQSxJQUFPLEVBQWlCLENBQUEsR0FBQSxHQUF4QjtDQUNPLENBQVAsSUFBTSxHQUFOLGNBQUE7Q0FGNkIsY0FBa0I7Y0FEdEM7Q0FBYixVQUFhO0NBS1QsRUFBRCxjQUFIO0NBdkJGLFFBQVM7Q0FQK0M7Q0FBakMsSUFBaUM7Q0FWMUQsR0FVQTtDQVZBOzs7OztBQ0FBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLENBQVMsR0FBVCxDQUFnQixtQkFBUDs7Q0FBVCxDQUVBLElBQU0sR0FBTixRQUFBO0VBQWlELENBQUEsRUFBWixHQUFZLENBQUMsQ0FBZDthQUNsQztDQUFBLENBQU0sQ0FBQSxDQUFOLEVBQU0sRUFBTixDQUFPO0NBQ0wsR0FBQSxVQUFBO0NBQUEsRUFBTyxDQUFQLEdBQWMsR0FBZCw4QkFBTztDQUlBLEVBQVMsR0FBVixHQUFVLFFBQWhCO0NBQTRCLElBQU0sQ0FBTSxFQUFiLE9BQU8sSUFBZjtDQUFMLENBQThDLENBQUEsQ0FBQSxDQUFBLElBQUMsRUFBN0M7Q0FDZCxHQUFHLENBQUgsT0FBQTtDQUF1QixHQUFULEVBQUEsRUFBUSxhQUFSO01BQWQsUUFBQTtDQUNVLEdBQUQsRUFBSixlQUFBO2NBRnFEO0NBQTVELFVBQTREO0NBTDlELFFBQU07Q0FEeUM7Q0FBYixJQUFhO0NBRmpELEdBRUE7O0NBRkEsQ0FhQSxJQUFNLENBQU4sR0FBQTtFQUFtQyxDQUFBLENBQVIsQ0FBRSxJQUFPO0NBQ2xDLEtBQUEsSUFBQTtDQUFBLENBQUEsQ0FBUyxHQUFUO0NBQUEsQ0FBQSxDQUVTLENBQVIsQ0FBRCxDQUFBO0NBQ0MsQ0FBaUIsQ0FBUCxDQUFWLEdBQUQsRUFBWSxJQUFaLENBQVc7Q0FDVCxPQUFBLElBQUE7Q0FBQSxFQUFXLENBQVgsSUFBQTtDQUFBLEVBRXVCLENBQVIsQ0FBQSxHQUFmO0NBQ0csQ0FBRCxDQUE4QixDQUFoQyxLQUF1QixLQUF2QixDQUFBO0NBQ1csRUFBYyxDQUFSLENBQUEsR0FBUCxTQUFSO0NBREYsUUFBZ0M7Q0FSRCxNQUl0QjtDQUpjLElBQVE7Q0FibkMsR0FhQTtDQWJBOzs7OztBQ0FBO0NBQUEsS0FBQSxZQUFBOztDQUFBLENBQUEsQ0FBYSxJQUFBLEdBQWIsMEJBQWE7O0NBQWIsQ0FHQSxDQUFTLEdBQVQsQ0FBZ0IsbUJBQVA7O0NBSFQsQ0FNQSxJQUFNLENBQU4sR0FBQTtFQUFtQyxDQUFBLENBQVIsQ0FBRSxJQUFPO0NBQ2xDLE9BQUEsRUFBQTtDQUFBLEtBQU07Q0FDUyxFQUFBLEdBQUEsRUFBQSxVQUFFO0NBQ2IsRUFEYSxDQUFBLEVBQ2IsSUFEWTtDQUNaLENBQU8sQ0FBUCxDQUFDLEVBQVksRUFBUyxFQUF0QixJQUFxQyxJQUE5QjtDQUFQLEVBQ0ksQ0FBSCxNQUFEO0NBREEsRUFFSSxDQUFILENBQUQsQ0FBQSxJQUFBO0NBSEYsUUFBYTs7Q0FBYixFQUtVLEtBQVYsQ0FBVTtDQUFjLEVBQVgsQ0FBc0IsS0FBdEIsQ0FBVSxPQUFWO0NBTGIsUUFLVTs7Q0FMVjs7Q0FERjthQVFBO0NBQUEsQ0FBTyxDQUFBLEVBQVAsQ0FBTyxFQUFQLENBQVE7Q0FBd0IsR0FBVCxFQUFBLEVBQUEsU0FBQTtDQUF2QixRQUFPO0NBQVAsQ0FDUSxDQUFBLEdBQVIsRUFBQSxDQUFTO0NBQ1AsRUFBQSxXQUFBO0NBQUEsQ0FBUSxDQUFSLEVBQU0sS0FBTjtDQUFBLEVBRUcsQ0FBVSxDQUFELENBQUEsQ0FBWixDQUFZLEVBQVo7Q0FFSSxFQUFELGNBQUg7Q0FORixRQUNRO0NBVnlCO0NBQVIsSUFBUTtDQU5uQyxHQU1BO0NBTkE7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsQ0FBUyxHQUFULENBQWdCLGlCQUFQOztDQUFULENBR0EsSUFBTSxDQUFOLENBQUE7RUFBd0MsQ0FBQSxFQUFkLElBQWUsQ0FBRCxFQUFmO0NBQ3ZCLFNBQUEsTUFBQTtDQUFBLEVBQVUsR0FBVixDQUFBO1NBQ0U7Q0FBQSxDQUFNLEVBQU4sTUFBQSxZQUFBO0NBQUEsQ0FFRSxJQURGLElBQUE7Q0FDRSxDQUNFLEtBREYsS0FBQTtDQUNFLENBQVEsSUFBUixDQUFBLE9BQUE7Q0FBQSxDQUNNLEVBQU4sRUFEQSxRQUNBO0NBREEsQ0FFTyxHQUFQLFNBQUE7Y0FIRjtDQUFBLENBS0UsS0FERixLQUFBO0NBQ0UsQ0FBUSxJQUFSLFFBQUE7Q0FBQSxDQUNPLEdBQVAsU0FBQTtDQURBLENBRU0sRUFBTixPQUZBLEdBRUE7Q0FGQSxDQUdRLElBQVIsUUFBQTtjQVJGO0NBQUEsQ0FVRSxPQURGLEdBQUE7Q0FDRSxDQUFRLElBQVIsUUFBQTtDQUFBLENBQ08sR0FBUCxTQUFBO0NBREEsQ0FFTSxFQUFOLEdBRkEsT0FFQTtjQVpGO1lBRkY7RUFnQkEsUUFqQlE7Q0FpQlIsQ0FBTSxFQUFOLE1BQUEsYUFBQTtDQUFBLENBRUUsSUFERixJQUFBO0NBQ0UsQ0FDRSxLQURGLEtBQUE7Q0FDRSxDQUFRLElBQVIsQ0FBQSxPQUFBO0NBQUEsQ0FDTSxFQUFOLEVBREEsUUFDQTtDQURBLENBRU8sR0FBUCxTQUFBO2NBSEY7Q0FBQSxDQUtFLEtBREYsS0FBQTtDQUNFLENBQVEsSUFBUixDQUFBLE9BQUE7Q0FBQSxDQUNPLEdBQVAsU0FBQTtDQURBLENBRU0sRUFBTixPQUZBLEdBRUE7Q0FGQSxDQUdRLElBQVIsUUFBQTtjQVJGO0NBQUEsQ0FVRSxPQURGLEdBQUE7Q0FDRSxDQUFRLElBQVIsUUFBQTtDQUFBLENBQ08sR0FBUCxTQUFBO0NBREEsQ0FFTSxFQUFOLEdBRkEsT0FFQTtjQVpGO1lBRkY7VUFqQlE7Q0FBVixPQUFBO0NBQUEsRUFtQ0UsR0FERixDQUFBO0NBQ0UsQ0FBUyxLQUFULENBQUE7Q0FBQSxDQUNTLEtBQVQsQ0FBQTtDQURBLENBRVEsQ0FBQSxHQUFSLEVBQUEsQ0FBUztDQUFXLFVBQUEsR0FBQTtDQUFrQixJQUFBLENBQUE7Q0FGdEMsUUFFUTtDQUZSLENBR1EsQ0FBQSxHQUFSLEVBQUEsQ0FBUztDQUFXLFVBQUEsR0FBQTtBQUFrQyxDQUFoQixFQUFlLENBQWpDLENBQWtCLENBQUEsQ0FBd0I7Q0FIOUQsUUFHUTtDQUhSLENBS1csQ0FBQSxLQUFYLENBQUE7Q0FDRSxhQUFBLFlBQUE7Q0FBQSxFQUFZLENBQVQsRUFBQSxDQUFpQixHQUFwQjtDQUNFO0NBQUEsV0FBQSxLQUFBO21DQUFBO0NBQUEsQ0FBaUIsQ0FBQSxDQUFoQixFQUFnQixDQUFSLE9BQVQ7Q0FBQSxZQUFBO0NBQUEsT0FDQSxFQUFVLEVBQVY7WUFGRjtDQUdDLEdBQUEsYUFBRDtDQVRGLFFBS1c7Q0F4Q2IsT0FBQTtDQUFBLEtBOENBLENBQU8sRUFBUDtDQS9Dc0MsWUFpRHRDO0NBakR1QixJQUFlO0NBSHhDLEdBR0E7Q0FIQTs7Ozs7QUNBQTtDQUFBLEtBQUE7S0FBQSxhQUFBOztDQUFBLENBQUEsS0FBQSxtQ0FBQTs7Q0FBQSxDQUdBLENBQVMsR0FBVCxDQUFnQixRQUFvQyxXQUEzQzs7Q0FIVCxDQU9BLElBQU07RUFBMEIsQ0FBQSxFQUFqQixJQUFrQixJQUFELEVBQWxCO0NBQ0ksR0FBZCxTQUFBLEdBQUE7Q0FEVSxJQUFrQjtDQVBoQyxHQU9BOztDQVBBLENBV0EsSUFBTSxDQUFOLEdBQUE7RUFBcUMsQ0FBQSxFQUFULEVBQUQsRUFBVzthQUNwQztDQUFBLENBQU8sQ0FBQSxFQUFQLEVBQU8sQ0FBUCxDQUFRO0NBQ04sRUFBQSxJQUFPLEVBQWMsQ0FBckIsR0FBcUIsR0FBVDtDQUNOLElBQUQsRUFBTCxRQUFBLEVBQUE7Q0FGRixRQUFPO0NBQVAsQ0FHTSxDQUFBLENBQU4sR0FBTSxDQUFOLENBQU87Q0FDTCxFQUFBLElBQU8sQ0FBZSxDQUFBLENBQXRCLEdBQXNCLEdBQVY7Q0FDTixJQUFELEVBQUwsT0FBQSxHQUFBO0NBTEYsUUFHTTtDQUhOLENBTVMsQ0FBQSxJQUFULENBQUEsQ0FBVTtDQUNSLEVBQUEsR0FBb0IsQ0FBYixFQUFhLENBQXBCLEdBQW9CLEdBQVI7Q0FDTixJQUFELEVBQUwsVUFBQTtDQVJGLFFBTVM7Q0FQMEI7Q0FBVixJQUFVO0NBWHJDLEdBV0E7Q0FYQTs7Ozs7QUNBQTtDQUFBLEtBQUEsU0FBQTs7Q0FBQSxDQUFBLEtBQUEsZ0NBQUE7O0NBQUEsQ0FHQSxDQUFTLEdBQVQsQ0FBZ0Isa0JBQVA7O0NBSFQsQ0FNQSxJQUFNLENBQU4sRUFBQTtDQUVFLE9BQUEsS0FBQTs7Q0FBQSxHQUFNO0NBQ1MsQ0FBUyxDQUFULENBQUEsRUFBQSxDQUFBLGdCQUFFO0NBQ2IsRUFEYSxDQUFBLElBQUQ7Q0FDWixFQURvQixDQUFBLEdBQ3BCLENBRG1CO0NBQ25CLENBQUEsQ0FBYSxDQUFaLElBQUQsQ0FBQTtDQURGLE1BQWE7O0NBQWIsQ0FHQSxDQUFJLEtBQUEsQ0FBQztDQUF3QixJQUFBLE9BQUE7Q0FBRSxFQUFELENBQUMsQ0FBVSxHQUFaLENBQVksTUFBWjtDQUg3QixNQUdJOztDQUhKLENBSWlCLENBQWpCLEtBQUssQ0FBQztDQUF3QixFQUFBLFNBQUE7QUFBQSxDQUFBLEVBQTBFLENBQTFFLEdBQWlGLENBQWpGLENBQXdEO0NBQXZELENBQWlDLENBQWxDLENBQUMsRUFBRCxHQUFXLFFBQVg7VUFBekI7Q0FKTCxNQUlLOztDQUpMLENBTVUsQ0FBQSxLQUFWLENBQVc7Q0FBUSxDQUFVLEVBQVYsS0FBRCxNQUFBO0NBTmxCLE1BTVU7O0NBTlYsRUFPVyxNQUFYO0NBQXFCLENBQXdCLENBQXpCLENBQUMsR0FBTyxDQUFSLE9BQUE7Q0FQcEIsTUFPVzs7Q0FQWCxDQVM4QixDQUFuQixLQUFBLENBQVgsT0FBVztDQUNULE9BQUEsSUFBQTtDQUFBLENBQUssRUFBRixDQUFlLENBQWYsRUFBSDtDQUNFLEVBQUEsSUFBTyxHQUFQO0NBQUEsQ0FFRSxFQURELENBQUQsRUFBQSxHQUFBO0NBQ0UsQ0FBVSxNQUFWLElBQUE7Q0FBQSxDQUNjLFVBQWQ7Q0FIRixXQUNBO01BRkYsSUFBQTtDQU1FLENBQVMsZ0JBQUY7Q0FBUCxPQUFBLFNBQ087Q0FDSCxDQUFLLEVBQUYsQ0FBVyxNQUFkLEdBQUE7Q0FBK0IsQ0FDN0IsRUFEOEIsQ0FBRCxVQUFBLENBQUE7Q0FDN0IsQ0FBVSxHQUFlLEdBQXpCLFVBQUE7Q0FBQSxDQUNlLEdBQWUsR0FBUCxLQUF2QixLQUFBO0NBREEsQ0FFTyxHQUFQLGFBQUE7Q0FGQSxDQUdZLFFBQVosUUFBQTtDQUo2QixpQkFBQTtDQUtwQixDQUFELEVBQUYsQ0FBVyxDQUxuQixNQUFBLElBQUE7Q0FLcUMsQ0FDbkMsRUFEb0MsQ0FBRCxXQUFBLENBQUE7Q0FDbkMsQ0FBUSxJQUFSLFlBQUE7Q0FBQSxDQUNhLFNBQWIsT0FBQTtDQUZtQyxpQkFBQTtnQkFQekM7Q0FDTztDQURQLFlBQUEsSUFVTztDQUVILENBQWdCLEVBQUYsQ0FBVyxTQUF6QjtDQUFBLHFCQUFBO2dCQUFBO0FBQ0EsQ0FBQSxDQUFnQixFQUFoQixVQUFBO0NBQUEscUJBQUE7Z0JBREE7Q0FBQSxDQUlFLEVBREQsQ0FBRCxTQUFBLEVBQUE7Q0FDRSxDQUFhLFNBQWIsS0FBQTtDQUFBLENBQ2lCLGFBQWpCLENBQUE7Q0FMRixlQUdBO0NBTEc7Q0FWUCxLQUFBLFdBa0JPO0FBQ0gsQ0FBQSxDQUFnQixFQUFoQixVQUFBO0NBQUEscUJBQUE7Z0JBQUE7Q0FDQSxDQUFZLEVBQUYsQ0FBZSxDQUFmLFFBQVY7Q0FBQSxxQkFBQTtnQkFEQTtDQUdBLENBQUssRUFBRixVQUFIO0NBQWMsQ0FDWixFQURhLENBQUQsR0FBQSxRQUFBO0NBQ1osQ0FBUyxLQUFULFdBQUE7Q0FBQSxDQUNPLEdBQVAsYUFBQTtDQUZZLGlCQUFBO0NBR0gsQ0FBRCxFQUFGLEVBSFIsVUFBQTtDQUdtQixDQUNqQixFQURrQixDQUFELE1BQUEsS0FBQTtDQUNqQixDQUFTLEtBQVQsV0FBQTtDQUFBLENBQ08sR0FBUCxhQUFBO0NBRmlCLGlCQUFBO2dCQXpCdkI7Q0FrQk87Q0FsQlAsTUFBQSxVQTRCTztDQUVILENBQUssRUFBRixDQUFlLENBQWYsUUFBSDtDQUNFLENBQUssRUFBRixZQUFIO0NBQWMsQ0FDWixFQURhLENBQUQsT0FBQSxNQUFBO0NBQ1osQ0FBVSxNQUFWLFlBQUE7Q0FBQSxDQUNPLEdBQVAsZUFBQTtDQURBLENBRVMsS0FBVCxhQUFBO0NBSFksbUJBQUE7Q0FJSCxDQUFELEVBQUYsRUFKUixZQUFBO0NBSW1CLENBQ2pCLEVBRGtCLENBQUQsT0FBQSxNQUFBO0NBQ2pCLENBQVUsTUFBVixZQUFBO0NBQUEsQ0FDTyxHQUFQLGVBQUE7Q0FEQSxDQUVTLEtBQVQsYUFBQTtDQUhpQixtQkFBQTtrQkFMckI7Q0FVVyxDQUFELEVBQUYsQ0FBVyxDQVZuQixJQUFBLE1BQUE7Q0FXRSxDQUNFLEVBREQsQ0FBRCxPQUFBLElBQUE7Q0FDRSxDQUFVLE1BQVYsVUFBQTtDQUFBLENBQ08sR0FBUCxhQUFBO0NBREEsQ0FFYyxVQUFkLE1BQUE7Q0FIRixpQkFBQTtDQUtTLENBQUQsRUFBRixDQUFXLENBaEJuQixHQUFBLE9BQUE7Q0FpQkUsQ0FBNEIsQ0FBakIsRUFBZSxHQUExQixRQUFBO0NBRUEsQ0FBSyxFQUFGLFlBQUg7Q0FBYyxDQUNaLEVBRGEsQ0FBRCxPQUFBLE1BQUE7Q0FDWixDQUFVLE1BQVYsWUFBQTtDQUFBLENBQ08sR0FBUCxlQUFBO0NBREEsQ0FFTSxFQUFOLGdCQUFBO0NBRkEsQ0FHUSxJQUFSLGNBQUE7Q0FKWSxtQkFBQTtrQkFGZDtDQU9BLENBQUssRUFBRixZQUFIO0NBQWMsQ0FDWixFQURhLENBQUQsT0FBQSxNQUFBO0NBQ1osQ0FBVSxNQUFWLFlBQUE7Q0FBQSxDQUNPLEdBQVAsZUFBQTtDQURBLENBRU0sRUFBTixnQkFBQTtDQUZBLENBR1EsSUFBUixjQUFBO0NBSlksbUJBQUE7a0JBeEJoQjtnQkE5Qko7Q0FBQSxVQU5GO1VBQUE7Q0FrRUMsQ0FBa0IsRUFBbEIsQ0FBRCxLQUFBLEtBQUE7Q0FBbUIsQ0FBQyxRQUFBO0NBQUQsQ0FBSyxNQUFMLEVBQUs7Q0FuRWYsU0FtRVQ7Q0E1RUYsTUFTVzs7Q0FUWCxDQThFbUIsQ0FBWixFQUFQLElBQVE7Q0FDTixXQUFBLGdDQUFBO0NBQUEsRUFBVyxDQUFDLElBQVosR0FBVztDQUFYLEVBQ2MsS0FBZCxDQUFBO0NBRUEsR0FBK0QsSUFBL0QsQ0FBMEU7Q0FBMUU7Q0FBQTtnQkFBQSwyQkFBQTtpQ0FBQTtDQUFBLENBQVksTUFBWjtDQUFBOzJCQUFBO1VBSks7Q0E5RVAsTUE4RU87O0NBOUVQLEVBb0ZvQixNQUFBLFNBQXBCO0NBQXdCLEdBQUEsRUFBdUIsQ0FBaEIsQ0FBUyxPQUFqQjtDQXBGdkIsTUFvRm9COztDQXBGcEIsRUFzRnFCLE1BQUEsVUFBckI7Q0FBeUIsR0FBQSxFQUF1QixDQUFoQixDQUFTLE9BQWpCO0NBdEZ4QixNQXNGcUI7O0NBdEZyQixFQXdGZ0IsTUFBQSxLQUFoQjtDQUFvQixHQUFBLEdBQU8sQ0FBUyxPQUFqQjtDQXhGbkIsTUF3RmdCOztDQXhGaEIsRUEyRmMsS0FBQSxDQUFDLEdBQWY7Q0FDRSxXQUFBLGFBQUE7Q0FBQTtDQUFBLFlBQUEsMENBQUE7NEJBQUE7Q0FBOEQsR0FBTCxDQUFpQixHQUFqQjtDQUF6RCxFQUFBLGdCQUFPO1lBQVA7Q0FBQSxRQUFBO0FBQ1EsQ0FBUixjQUFPO0NBN0ZULE1BMkZjOztDQTNGZCxFQStGZ0IsTUFBQyxLQUFqQjtDQUNFLEVBQUcsQ0FBQSxHQUFPLENBQVY7Q0FBOEIsRUFBQSxDQUFPLE1BQVAsRUFBTTtVQUFwQztDQUVDLEVBQXVCLENBQXZCLENBQXVCLEVBQWhCLENBQVMsT0FBakI7Q0FsR0YsTUErRmdCOztDQS9GaEIsRUFvR1MsSUFBVCxDQUFTLENBQUM7Q0FDUixXQUFBLFFBQUE7Q0FBQTtDQUFBLFlBQUEsOEJBQUE7MkJBQUE7Q0FBMEQsR0FBTCxDQUFpQixHQUFqQjtDQUFyRCxHQUFBLGVBQU87WUFBUDtDQUFBLFFBRE87Q0FwR1QsTUFvR1M7O0NBcEdULEVBdUdhLE1BQUEsRUFBYjtDQUFnQixHQUFBLFFBQUE7Q0FBQSxHQUE4QjtDQXZHOUMsTUF1R2E7O0NBdkdiLEVBeUdZLE1BQUEsQ0FBWjtDQUFlLEdBQUEsUUFBQTtDQUFBLEdBQTZCO0NBekc1QyxNQXlHWTs7Q0F6R1osRUEyR2EsTUFBQSxFQUFiO0NBQWdCLEdBQVEsR0FBTyxDQUFmLE9BQU87Q0EzR3ZCLE1BMkdhOztDQTNHYixFQThHYSxJQUFBLEVBQUMsRUFBZDtDQUNFLFdBQUEsWUFBQTtDQUFBO0NBQUEsWUFBQSwwQ0FBQTsyQkFBQTtHQUF1RCxDQUFBLENBQU87Q0FBOUQsRUFBQSxnQkFBTztZQUFQO0NBQUEsUUFBQTtBQUNRLENBQVIsY0FBTztDQWhIVCxNQThHYTs7Q0E5R2IsRUFrSFMsSUFBVCxDQUFTLENBQUM7Q0FBYSxHQUFRLElBQUQsSUFBQSxHQUFBO0NBbEg5QixNQWtIUzs7Q0FsSFQsRUFvSGMsTUFBQyxHQUFmO0NBQXVCLGNBQU8saUJBQVA7Q0FwSHZCLE1Bb0hjOztDQXBIZCxFQXNIUSxHQUFSLENBQVEsRUFBQztDQUFZLEdBQVEsR0FBRCxJQUFBLElBQUE7Q0F0SDVCLE1Bc0hROztDQXRIUixFQXdIWSxJQUFBLEVBQUMsQ0FBYjtDQUF5QixHQUFPLEdBQUEsUUFBQSxPQUFzQjtDQXhIdEQsTUF3SFk7O0NBeEhaLEVBMEhhLENBQUEsS0FBQyxFQUFkO0NBQXVCLEdBQVEsR0FBeUMsQ0FBMUMsT0FBQTtDQTFIOUIsTUEwSGE7O0NBMUhiLEVBNEhpQixLQUFBLENBQUMsTUFBbEI7Q0FBK0IsR0FBTyxJQUFBLE9BQUEsT0FBc0I7Q0E1SDVELE1BNEhpQjs7Q0E1SGpCLEVBZ0lPLENBQUEsQ0FBUCxJQUFRO0NBQ04sV0FBQSxtQ0FBQTs7R0FEYSxPQUFQO1VBQ047Q0FBQSxFQUFxQixDQUFqQixJQUFKO0NBQUEsRUFDYyxDQUFWLElBQUo7Q0FEQSxFQUVnQixDQUFaLElBQUo7Q0FBZ0IsQ0FBYSxPQUFYLENBQUE7Q0FBRixDQUE0QixRQUFaO0NBRmhDO0FBSXNFLENBQXRFLEdBQUEsR0FBNkUsQ0FBN0UsR0FBc0U7Q0FBdEUsR0FBVSxDQUFBLFdBQUEsNkJBQUE7VUFKVjtBQUsrRCxDQUEvRCxHQUFBLEdBQXNFLENBQXRFO0NBQUEsR0FBVSxDQUFBLFdBQUEsc0JBQUE7VUFMVjtDQU1BO0NBQUEsWUFBQSw4QkFBQTs4QkFBQTtBQUF5RixDQUFELEdBQUEsR0FBQyxHQUFBO0NBQXpGLEVBQTZDLENBQW5DLENBQUEsRUFBTyxXQUFQLFdBQU87WUFBakI7Q0FBQSxRQU5BO0FBT2dFLENBQWhFLEdBQUEsQ0FBZ0UsRUFBTyxDQUF2RTtDQUFBLEdBQVUsQ0FBQSxXQUFBLHVCQUFBO1VBUFY7Q0FRQTtDQUFBLFlBQUEsaUNBQUE7NEJBQUE7QUFBcUcsQ0FBRCxHQUFBLE9BQUM7Q0FBckcsRUFBOEMsQ0FBcEMsQ0FBQSxJQUFvQyxTQUFwQyxZQUFPO1lBQWpCO0NBQUEsUUFSQTtBQVN5RSxDQUF6RSxHQUFBLENBQW1GLENBQW5GLEVBQUE7Q0FBQSxHQUFVLENBQUEsV0FBQSxnQ0FBQTtVQVRWO0NBV0MsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLFFBQUg7Q0FBQSxDQUNBLEVBQUksR0FBTyxHQUFYLENBQWlCO0NBRGpCLENBRUEsRUFGQSxNQUVBO0NBZkcsU0FZTDtDQTVJRixNQWdJTzs7Q0FoSVAsRUFpSmUsS0FBQSxDQUFDLElBQWhCO0NBQ0UsRUFBQSxTQUFBO0FBQXVGLENBQXZGLEdBQUEsR0FBdUYsQ0FBdkY7Q0FBQSxFQUFtRSxDQUF6RCxDQUFBLEdBQUEsUUFBQSxtQ0FBTztVQUFqQjtDQUFBLEVBRUEsQ0FBTyxJQUFQLElBQU07Q0FFTCxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsTUFBQSxFQUFILENBQUc7Q0FBSCxDQUNBLEVBQUssTUFBTCxRQUFJO0NBREosQ0FFQSxDQUZBLE9BRUE7Q0FSVyxTQUtiO0NBdEpGLE1BaUplOztDQWpKZixFQTJKZ0IsTUFBQyxLQUFqQjtBQUNvRixDQUFsRixFQUFrRixDQUFsRixJQUFBLElBQWtGO0NBQWxGLEVBQW1FLENBQXpELENBQUEsV0FBQSxtQ0FBTztVQUFqQjtDQUVDLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxNQUFBLEVBQUgsQ0FBRztDQUFILENBQ0EsRUFBSyxNQUFMLFFBQUk7Q0FESixDQUVBLENBRkEsT0FFQTtDQU5ZLFNBR2Q7Q0E5SkYsTUEySmdCOztDQTNKaEIsRUFtS2lCLEdBQUEsR0FBQyxNQUFsQjtDQUNHLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxNQUFBLEVBQUgsRUFBRztDQUFILENBQ0EsRUFBSyxNQUFMLFNBQUk7Q0FESixDQUVBLElBRkEsSUFFQTtDQUphLFNBQ2Y7Q0FwS0YsTUFtS2lCOztDQW5LakIsRUF5S2dCLE1BQUMsRUFBRCxHQUFoQjs7R0FBK0IsT0FBZDtVQUNmO0NBQUMsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLFFBQUgsR0FBRztDQUFILENBQ0EsRUFBSyxNQUFMLElBQUk7Q0FESixDQUVBLFFBQUEsQ0FGQTtDQUZZLFNBQ2Q7Q0ExS0YsTUF5S2dCOztDQXpLaEIsQ0FpTHVCLENBQVgsSUFBQSxDQUFBLENBQUMsQ0FBYjtDQUNFLEVBQUEsU0FBQTs7R0FEK0IsT0FBVjtVQUNyQjtBQUErRSxDQUEvRSxHQUFBLElBQUEsT0FBK0U7Q0FBL0UsRUFBMkQsQ0FBakQsQ0FBQSxHQUFBLFFBQUEsMkJBQU87VUFBakI7Q0FDQSxHQUE4RSxHQUFBLENBQTlFO0NBQUEsRUFBOEQsQ0FBcEQsQ0FBQSxHQUFBLFFBQUEsOEJBQU87VUFEakI7Q0FBQSxFQUdBLENBQU8sSUFBUCxHQUFNO0NBRUwsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLENBQUEsSUFBQSxHQUFIO0NBQUEsQ0FDQSxRQUFBO0NBQUksQ0FBQyxNQUFELElBQUM7Q0FBRCxDQUFXLEtBQVgsS0FBVztZQURmO0NBUFEsU0FNVjtDQXZMRixNQWlMWTs7Q0FqTFosQ0EyTHVCLENBQVgsS0FBQSxDQUFDLENBQWIsRUFBWTtDQUNWLEVBQUEsU0FBQTtBQUFtRixDQUFuRixHQUFBLElBQUEsSUFBbUYsR0FBQTtDQUFuRixFQUEyRCxDQUFqRCxDQUFBLE9BQUEsSUFBQSwyQkFBTztVQUFqQjtBQUNrRixDQUFsRixHQUFBLEdBQWtGLENBQWxGO0NBQUEsRUFBOEQsQ0FBcEQsQ0FBQSxHQUFBLFFBQUEsOEJBQU87VUFEakI7Q0FFQSxHQUEwRixHQUFBLENBQTFGLElBQTBGO0NBQTFGLEVBQXNFLENBQTVELENBQUEsT0FBQSxJQUFBLHNDQUFPO1VBRmpCO0NBQUEsRUFJQSxDQUFPLElBQVAsSUFBTTtDQUVMLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxDQUFBLElBQUEsR0FBSDtDQUFBLENBQ0EsTUFEQSxFQUNBO0NBREEsQ0FFQSxRQUFBLEVBRkE7Q0FSUSxTQU9WO0NBbE1GLE1BMkxZOztDQTNMWixFQXVNWSxLQUFBLENBQUMsQ0FBYjtDQUNFLEVBQUEsU0FBQTtBQUFrRixDQUFsRixHQUFBLEdBQWtGLENBQWxGO0NBQUEsRUFBOEQsQ0FBcEQsQ0FBQSxHQUFBLFFBQUEsOEJBQU87VUFBakI7Q0FDQSxHQUEyRSxJQUEzRSxHQUEyRTtDQUEzRSxHQUFVLENBQUEsV0FBQSxzQ0FBQTtVQURWO0NBQUEsRUFHQSxDQUFPLElBQVAsSUFBTTtDQUhOLEdBS0MsSUFBRCxNQUFBO0NBRUMsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLENBQUEsSUFBQSxHQUFIO0NBQUEsQ0FDQSxFQUFLLEdBQUQsQ0FBQSxFQUFKO0NBVlEsU0FRVjtDQS9NRixNQXVNWTs7Q0F2TVosQ0FxTnVCLENBQVgsQ0FBQSxFQUFBLEVBQUEsQ0FBQyxDQUFiO0NBQ0UsRUFBQSxTQUFBO0FBQWtGLENBQWxGLEdBQUEsR0FBa0YsQ0FBbEY7Q0FBQSxFQUE4RCxDQUFwRCxDQUFBLEdBQUEsUUFBQSw4QkFBTztVQUFqQjtDQUFBLEVBRUEsQ0FBTyxJQUFQLElBQU07Q0FFTCxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsQ0FBQSxHQUFBLENBQUEsRUFBQSxDQUFIO0NBQUEsQ0FDQSxFQURBLE1BQ0E7Q0FQUSxTQUtWO0NBMU5GLE1BcU5ZOztDQXJOWixDQThOdUIsQ0FBWCxDQUFBLEVBQUEsRUFBQSxDQUFDLENBQWI7Q0FDRSxFQUFBLFNBQUE7QUFBa0YsQ0FBbEYsR0FBQSxHQUFrRixDQUFsRjtDQUFBLEVBQThELENBQXBELENBQUEsR0FBQSxRQUFBLDhCQUFPO1VBQWpCO0NBQUEsRUFFQSxDQUFPLElBQVAsSUFBTTtDQUVMLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxDQUFBLEdBQUEsQ0FBQSxFQUFBLENBQUg7Q0FBQSxDQUNBLEVBREEsTUFDQTtDQVBRLFNBS1Y7Q0FuT0YsTUE4Tlk7O0NBOU5aLEVBeU9RLEdBQVIsQ0FBUSxFQUFDO0NBQ1AsRUFBQSxTQUFBO0FBQXFFLENBQXJFLEdBQUEsR0FBcUUsQ0FBckUsRUFBcUU7Q0FBckUsRUFBa0QsQ0FBeEMsQ0FBQSxFQUFBLFNBQUEsa0JBQU87VUFBakI7Q0FDQSxHQUF3RSxFQUFBLENBQUEsQ0FBeEU7Q0FBQSxFQUF5RCxDQUEvQyxDQUFBLEVBQUEsU0FBQSx5QkFBTztVQURqQjtDQUFBLEVBR0EsQ0FBTyxJQUFQLEVBQU07Q0FFTCxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsQ0FBQSxHQUFBLElBQUg7Q0FBQSxDQUNBLEtBREEsR0FDQTtDQVJJLFNBTU47Q0EvT0YsTUF5T1E7O0NBek9SLEVBbVBXLElBQUEsRUFBWDtDQUNFLEVBQUEsU0FBQTtBQUEwRSxDQUExRSxHQUFBLEVBQTBFLENBQUEsQ0FBMUU7Q0FBQSxFQUF1RCxDQUE3QyxDQUFBLEVBQUEsU0FBQSx1QkFBTztVQUFqQjtDQUFBLEVBRUEsQ0FBTyxHQUFELENBQU4sR0FBTTtDQUVMLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxDQUFBLEdBQUEsSUFBSDtDQUFBLENBQ0EsS0FEQSxHQUNBO0NBUE8sU0FLVDtDQXhQRixNQW1QVzs7Q0FuUFg7O0NBREY7O0NBOFBhLEVBQUEsQ0FBQSxhQUFBO0NBQ1gsQ0FBQSxDQUFZLENBQVgsRUFBRCxFQUFBO0NBQUEsQ0FBQSxDQUVZLENBQVgsRUFBRCxFQUFBO0NBRkEsRUFHUyxDQUFSLENBQUQsQ0FBQSxHQUFTLEdBQUE7Q0FIVCxHQUtDLENBQUssQ0FBTjtDQUNFLENBQU8sR0FBUCxHQUFBO1dBQ0U7Q0FBQSxDQUFVLE1BQVYsSUFBQTtDQUFBLENBQ1MsS0FBVCxLQUFBO1lBRks7VUFBUDtDQU5GLE9BS0E7Q0FwUUYsSUE4UGE7O0NBOVBiLEVBMFFjLE1BQUMsQ0FBRCxFQUFkO0NBR0UsU0FBQSxJQUFBO0NBQUEsRUFBVSxDQUFWLEVBQUEsQ0FBQTtDQUVDLENBQXVELENBQXhELENBQUMsQ0FBUyxFQUFvQixHQUFwQixHQUFvQjtDQS9RaEMsSUEwUWM7O0NBMVFkLENBaVI2QixDQUFuQixLQUFWLENBQVcsT0FBRDtDQUNSLFNBQUEsb0RBQUE7Q0FBQSxDQUE4QyxDQUEvQixDQUFxQixDQUFSLENBQTVCLENBQXNCLENBQVAsSUFBZjtBQUVBLENBQUEsVUFBQSwrQkFBQTtzQkFBQTtDQUFBLENBQXVCLENBQXZCLElBQU8sQ0FBUCxDQUFBO0NBQUEsTUFGQTtDQUFBLENBRzZCLENBQTdCLENBQTZCLEVBQTdCLENBQU8sQ0FBc0IsT0FBN0I7Q0FFQSxHQUE0QyxDQUFhLENBQXpELEVBQTRDLElBQTVDO0NBQUEsQ0FBMkIsRUFBM0IsR0FBTyxDQUFQLElBQUE7UUFMQTtDQU9BO0NBQUE7WUFBQSxNQUFBO21DQUFBO0lBQXlDLENBQWMsS0FBZDtDQUN2Qzs7QUFBQSxDQUFBO2tCQUFBLDBCQUFBOzRCQUFBO0NBQUEsQ0FBbUMsRUFBSyxFQUFsQyxFQUFOLENBQUEsT0FBQTtDQUFBOztDQUFBO1VBREY7Q0FBQTt1QkFSUTtDQWpSVixJQWlSVTs7Q0FqUlY7O0NBRkY7Q0FOQTs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0IsbUJBQVA7O0NBQVQsQ0FFQSxJQUFNLENBQU4sR0FBQTtHQUE2QixFQUFBLElBQUE7Q0FFM0IsU0FBQSxRQUFBO0NBQUEsRUFDRSxHQURGLEVBQUE7Q0FDRSxDQUNFLE1BREYsQ0FBQTtDQUNFLENBQU8sRUFBUCxDQUFBLEtBQUE7Q0FBQSxDQUNjLEVBRGQsTUFDQSxFQUFBO1VBRkY7Q0FBQSxDQUlFLElBREYsRUFBQTtDQUNFLENBQVUsTUFBVixFQUFBO0NBQUEsQ0FDVyxFQURYLEtBQ0EsQ0FBQTtDQURBLENBRU8sR0FBUCxLQUFBO0NBRkEsQ0FJRSxFQURGLE1BQUE7Q0FDRSxDQUNFLEdBREYsT0FBQTtDQUNFLENBQUssQ0FBTCxXQUFBO0NBQUEsQ0FDSyxDQUFMLFdBQUE7Y0FGRjtDQUFBLENBR1MsR0FIVCxFQUdBLEtBQUE7WUFQRjtVQUpGO0NBREYsT0FBQTtDQWdCQSxHQUFHLEVBQUgsc0RBQUE7Q0FDRSxFQUFXLENBQVIsQ0FBQSxFQUFRLENBQVgsSUFBdUIsSUFBWjtDQUNUO0NBQ0UsRUFBUSxDQUFJLENBQVosT0FBQTtNQURGLE1BQUE7Q0FHRSxLQUFBLE1BREk7Q0FDSixDQUFBLENBQVEsRUFBUixPQUFBO1lBSko7VUFBQTtDQUFBLEVBTVksS0FBWixDQUFZLEVBQVo7Q0FDZSxDQUEwQixFQUFJLEdBQTNDLENBQXVDLENBQUEsR0FBM0IsSUFBWixDQUFBO0NBREYsQ0FFRSxFQUZGLEtBQVk7UUF2QmQ7Q0EyQlEsQ0FBaUIsR0FBekIsQ0FBQSxDQUFPLENBQVAsS0FBQTtDQTdCeUIsSUFBRTtDQUY3QixHQUVBO0NBRkE7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsQ0FBUyxHQUFULENBQWdCLGdCQUFQOztDQUFULENBSUEsQ0FBd0IsR0FBbEIsQ0FBTixFQUF3QjtDQUN0QixPQUFBLFNBQUE7Q0FBQSxFQUNFLENBREYsQ0FBQTtDQUNFLENBQ0UsRUFERixFQUFBO0NBQ0UsQ0FBTyxHQUFQLEdBQUEsRUFBQTtDQUFBLENBQ00sRUFBTixJQUFBLEdBREE7UUFERjtDQUFBLENBSUUsSUFERixJQUFBO0NBQ0UsQ0FBTyxHQUFQLEdBQUE7Q0FBQSxDQUNNLEVBQU4sSUFBQSxTQURBO1FBSkY7Q0FBQSxDQU9FLElBREY7Q0FDRSxDQUFPLEdBQVAsR0FBQSxJQUFBO0NBQUEsQ0FDTSxFQUFOLElBQUEsS0FEQTtRQVBGO0NBQUEsQ0FVRSxDQURGLEdBQUE7Q0FDRSxDQUFPLEdBQVAsR0FBQSxDQUFBO0NBQUEsQ0FDTSxFQUFOLElBQUEsRUFEQTtRQVZGO0NBQUEsQ0FhRSxFQURGLEVBQUE7Q0FDRSxDQUFPLEdBQVAsR0FBQTtDQUFBLENBQ00sRUFBTixJQUFBLElBREE7UUFiRjtDQURGLEtBQUE7QUFpQkEsQ0FBQSxRQUFBLElBQUE7MEJBQUE7Q0FDRSxFQUFZLENBQVIsRUFBSjtDQURGLElBakJBO1dBb0JBO0NBQUEsQ0FBTyxHQUFQLENBQUE7Q0FBQSxDQUNlLENBQUEsR0FBZixFQUFlLENBQUMsSUFBaEI7Q0FDRSxHQUFBLFFBQUE7QUFBQSxDQUFBLFlBQUE7OEJBQUE7Q0FDRSxHQUFHLENBQVUsR0FBVixFQUFIO0NBQWtDLEdBQUEsZUFBTztZQUQzQztDQUFBLFFBQUE7Q0FHQSxHQUFBLENBQVksVUFBTDtDQUxULE1BQ2U7Q0F0Qk87Q0FBeEIsRUFBd0I7Q0FKeEI7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsS0FBQSxzQkFBQTs7Q0FBQSxDQUdBLENBQVMsR0FBVCxDQUFnQixrQkFBUCxDQUEwQzs7Q0FIbkQsQ0FPQSxJQUFNLENBQU4sRUFBQTtFQUFrQyxDQUFZLENBQXBCLENBQUUsR0FBa0IsQ0FBQyxDQUFyQjthQUN4QjtDQUFBLENBQVEsQ0FBQSxDQUFBLEVBQVIsRUFBQSxDQUFTO0NBQ1AsYUFBQSxxQkFBQTtBQUFBLENBQUEsR0FBQSxDQUE2RSxDQUE3RSxJQUFBO0NBQUEsR0FBVSxDQUFBLGFBQUEsa0NBQUE7WUFBVjtDQUFBLENBQUEsQ0FFVyxLQUFYLEVBQUE7Q0FFQTtDQUFBLEVBQStCLENBQUEsS0FBQztDQUM5QixHQUFHLENBQUEsR0FBYSxFQUFiLEVBQUg7Q0FDVyxFQUF3QyxDQUFqRCxFQUFjLENBQUEsQ0FBTixDQUEwQyxZQUFsRDtDQUNPLEVBQVUsQ0FBWCxHQUFKLGdCQUFBO0NBRFksY0FBbUM7Y0FGdEI7Q0FBL0IsVUFBK0I7Q0FBL0IsY0FBQSw0QkFBQTs2QkFBQTtDQUE0QjtDQUE1QixVQUpBO0NBU0csQ0FBRCxDQUFGLENBQUEsSUFBQSxDQUFzQixRQUF0QjtDQUFzQixrQkFBRztDQUF6QixVQUFzQjtDQVZ4QixRQUFRO0NBRG9DO0NBQXBCLElBQW9CO0NBUDlDLEdBT0E7Q0FQQTs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0IsY0FBUDs7Q0FBVCxDQUVBLENBQUEsRUFBQSxDQUFNLEVBQU47Q0FGQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm1qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNucEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgXCIuLi8uLi92ZW5kb3IvYW5ndWxhci9hbmd1bGFyXCJcclxucmVxdWlyZSBcIi4uLy4uL3ZlbmRvci9hbmd1bGFyL2FuZ3VsYXItY29va2llc1wiXHJcbnJlcXVpcmUgXCIuLi8uLi92ZW5kb3IvYW5ndWxhci11aS91aS1ib290c3RyYXBcIlxyXG5yZXF1aXJlIFwiLi4vLi4vdmVuZG9yL2FuZ3VsYXItdWkvdWktcm91dGVyXCJcclxuXHJcblxyXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvc2Vzc2lvbi5jb2ZmZWVcIlxyXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvbm90aWZpZXIuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL2Rpc2FibGVyLmNvZmZlZVwiXHJcbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9iYXNlUGx1bmsuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL2xheW91dC5jb2ZmZWVcIlxyXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvdXBkYXRlci5jb2ZmZWVcIlxyXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvY29sbGFiLmNvZmZlZVwiXHJcblxyXG5yZXF1aXJlIFwiLi4vZGlyZWN0aXZlcy9ib3JkZXJMYXlvdXQuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL2RpcmVjdGl2ZXMvY29kZUVkaXRvci5jb2ZmZWVcIlxyXG5yZXF1aXJlIFwiLi4vZGlyZWN0aXZlcy9wcmV2aWV3ZXIuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL2RpcmVjdGl2ZXMvdG9vbGJhci5jb2ZmZWVcIlxyXG5cclxuXHJcbm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5hcHAuZWRpdG9yXCIsIFtcclxuICBcInVpLmJvb3RzdHJhcFwiXHJcbiAgXCJ1aS5yb3V0ZXJcIlxyXG4gIFxyXG4gIFwiZmEuYm9yZGVyTGF5b3V0XCJcclxuICBcclxuICBcInBsdW5rZXIuc2VydmljZS5zZXNzaW9uXCJcclxuICBcInBsdW5rZXIuc2VydmljZS5ub3RpZmllclwiXHJcbiAgXCJwbHVua2VyLnNlcnZpY2UuZGlzYWJsZXJcIlxyXG4gIFwicGx1bmtlci5zZXJ2aWNlLmJhc2VQbHVua1wiXHJcbiAgXCJwbHVua2VyLnNlcnZpY2UubGF5b3V0XCJcclxuICBcInBsdW5rZXIuc2VydmljZS51cGRhdGVyXCJcclxuICBcInBsdW5rZXIuc2VydmljZS5jb2xsYWJcIlxyXG4gIFxyXG4gIFwicGx1bmtlci5kaXJlY3RpdmUuY29kZUVkaXRvclwiXHJcbiAgXCJwbHVua2VyLmRpcmVjdGl2ZS5wcmV2aWV3ZXJcIlxyXG4gIFwicGx1bmtlci5kaXJlY3RpdmUudG9vbGJhclwiXHJcbl1cclxuXHJcbm1vZHVsZS5jb25maWcgW1wiJHN0YXRlUHJvdmlkZXJcIiwgXCIkdXJsUm91dGVyUHJvdmlkZXJcIiwgXCIkbG9jYXRpb25Qcm92aWRlclwiLCAoJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlciwgJGxvY2F0aW9uUHJvdmlkZXIpIC0+XHJcbiAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlIHRydWVcclxuICBcclxuICAkdXJsUm91dGVyUHJvdmlkZXIud2hlbiBcIi9lZGl0XCIsIFwiL2VkaXQvXCJcclxuICBcclxuICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKFwiL2VkaXQvXCIpXHJcbl1cclxuXHJcbm1vZHVsZS5jb25maWcgW1wiJHN0YXRlUHJvdmlkZXJcIiwgXCIkdXJsUm91dGVyUHJvdmlkZXJcIiwgKCRzdGF0ZVByb3ZpZGVyLCAkdXJsUm91dGVyUHJvdmlkZXIpIC0+XHJcbiAgXHJcbiAgJHN0YXRlUHJvdmlkZXIuc3RhdGUgXCJlZGl0b3JcIixcclxuICAgIHVybDogXCIvZWRpdFwiXHJcbiAgICBhYnN0cmFjdDogdHJ1ZVxyXG4gICAgdGVtcGxhdGU6IFwiXCJcIlxyXG4gICAgICA8ZGl2IHVpLXZpZXc9XCJib2R5XCI+PC9kaXY+XHJcbiAgICBcIlwiXCJcclxuXHJcbiAgJHN0YXRlUHJvdmlkZXIuc3RhdGUgXCJlZGl0b3IuYmxhbmtcIixcclxuICAgIHVybDogXCIvXCJcclxuICAgIHZpZXdzOlxyXG4gICAgICBcImJvZHlcIjogXHJcbiAgICAgICAgY29udHJvbGxlcjogW1wiJHN0YXRlXCIsIFwiJHNjb3BlXCIsIFwibGF5b3V0XCIsICgkc3RhdGUsICRzY29wZSwgbGF5b3V0KSAtPlxyXG4gICAgICAgICAgJHN0YXRlLmdvIFwiZWRpdG9yLm5ld1wiXHJcbiAgICAgICAgXVxyXG4gICAgXHJcbiAgJHN0YXRlUHJvdmlkZXIuc3RhdGUgXCJlZGl0b3IubmV3XCIsXHJcbiAgICB1cmw6IFwiL25ld1wiXHJcbiAgICB2aWV3czpcclxuICAgICAgXCJib2R5XCI6IFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOiBcIi9wYXJ0aWFscy9lZGl0b3IuaHRtbFwiXHJcbiAgICAgICAgY29udHJvbGxlcjogW1wiJHNjb3BlXCIsIFwic2Vzc2lvblwiLCBcImJhc2VQbHVua1wiLCBcIm5vdGlmaWVyXCIsIFwibGF5b3V0XCIsIFwidXBkYXRlclwiLCBcImRpc2FibGVyXCIsICgkc2NvcGUsIHNlc3Npb24sIGJhc2VQbHVuaywgbm90aWZpZXIsIGxheW91dCwgdXBkYXRlciwgZGlzYWJsZXIpIC0+XHJcbiAgICAgICAgICBsYXlvdXQuY3VycmVudC50ZW1wbGF0ZXMuY2xvc2VkID0gZmFsc2VcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY2xpZW50ID0gc2Vzc2lvbi5jcmVhdGVDbGllbnQoXCJlZGl0LmJsYW5rXCIpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGRpc2FibGVyLmVucXVldWUgXCJlZGl0b3JcIiwgdXBkYXRlci51cGRhdGUoYmFzZVBsdW5rKS50aGVuIChqc29uKSAtPlxyXG4gICAgICAgICAgICBjbGllbnQucmVzZXQganNvblxyXG4gICAgICAgICAgICBjbGllbnQuY3Vyc29yU2V0SW5kZXggKDAgPD0gaWR4ID0gY2xpZW50LmdldEZpbGVJbmRleChcImluZGV4Lmh0bWxcIikpIGFuZCBpZHggb3IgMFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbm90aWZpZXIuc3VjY2VzcyBcIlBsdW5rIHJlc2V0XCJcclxuICAgICAgICBdXHJcblxyXG5cclxuICAkc3RhdGVQcm92aWRlci5zdGF0ZSBcImVkaXRvci5zdHJlYW1cIixcclxuICAgIHVybDogXCIvc3RyZWFtOntzdHJlYW1JZDpbYS16MC05XSt9XCJcclxuICAgIHZpZXdzOlxyXG4gICAgICBcImJvZHlcIjogXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6IFwiL3BhcnRpYWxzL2VkaXRvci5odG1sXCJcclxuICAgICAgICBjb250cm9sbGVyOiBbXCIkc3RhdGVQYXJhbXNcIiwgXCIkcVwiLCBcIiRodHRwXCIsIFwiJHNjb3BlXCIsIFwiJHN0YXRlXCIsIFwiJHRpbWVvdXRcIiwgXCJjb2xsYWJcIiwgXCJub3RpZmllclwiLCBcImRpc2FibGVyXCIsIFwibGF5b3V0XCIsIFwidXBkYXRlclwiLCAoJHN0YXRlUGFyYW1zLCAkcSwgJGh0dHAsICRzY29wZSwgJHN0YXRlLCAkdGltZW91dCwgY29sbGFiLCBub3RpZmllciwgZGlzYWJsZXIsIGxheW91dCwgdXBkYXRlcikgLT5cclxuICAgICAgICAgIGxheW91dC5jdXJyZW50LnRlbXBsYXRlcy5jbG9zZWQgPSB0cnVlXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGRpc2FibGVyLmVucXVldWUgXCJlZGl0b3JcIiwgY29sbGFiLmNvbm5lY3QoJHN0YXRlUGFyYW1zLnN0cmVhbUlkKS50aGVuIChqc29uKSAtPlxyXG4gICAgICAgICAgICBub3RpZmllci5zdWNjZXNzIFwiQ29ubmVjdGVkIHRvIHN0cmVhbVwiXHJcbiAgICAgICAgICAsIC0+XHJcbiAgICAgICAgICAgIG5vdGlmaWVyLmVycm9yIFwiRmFpbGVkIHRvIGNvbm5lY3QgdG8gc3RyZWFtXCJcclxuICAgICAgICAgIFxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgICAgXHJcbiAgJHN0YXRlUHJvdmlkZXIuc3RhdGUgXCJlZGl0b3IuZ2lzdFwiLFxyXG4gICAgdXJsOiBcIi9naXN0OntnaXN0SWQ6WzAtOV0rfFswLTlhLXpdezIwfX1cIlxyXG4gICAgdmlld3M6XHJcbiAgICAgIFwiYm9keVwiOiBcclxuICAgICAgICB0ZW1wbGF0ZVVybDogXCIvcGFydGlhbHMvZWRpdG9yLmh0bWxcIlxyXG4gICAgICAgIGNvbnRyb2xsZXI6IFtcIiRzdGF0ZVBhcmFtc1wiLCBcIiRxXCIsIFwiJGh0dHBcIiwgXCIkc2NvcGVcIiwgXCIkc3RhdGVcIiwgXCIkdGltZW91dFwiLCBcInNlc3Npb25cIiwgXCJub3RpZmllclwiLCBcImRpc2FibGVyXCIsIFwibGF5b3V0XCIsIFwidXBkYXRlclwiLCAoJHN0YXRlUGFyYW1zLCAkcSwgJGh0dHAsICRzY29wZSwgJHN0YXRlLCAkdGltZW91dCwgc2Vzc2lvbiwgbm90aWZpZXIsIGRpc2FibGVyLCBsYXlvdXQsIHVwZGF0ZXIpIC0+XHJcbiAgICAgICAgICBsYXlvdXQuY3VycmVudC50ZW1wbGF0ZXMuY2xvc2VkID0gdHJ1ZVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcImVkaXQuZ2lzdFwiKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBkaXNhYmxlci5lbnF1ZXVlIFwiZWRpdG9yXCIsIHJlcXVlc3QgPSAkaHR0cC5qc29ucChcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vZ2lzdHMvI3skc3RhdGVQYXJhbXMuZ2lzdElkfT9jYWxsYmFjaz1KU09OX0NBTExCQUNLXCIpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHBhcnNlciA9IHJlcXVlc3QudGhlbiAocmVzcG9uc2UpIC0+XHJcbiAgICAgICAgICAgIGlmIHJlc3BvbnNlLmRhdGEubWV0YS5zdGF0dXMgPj0gNDAwIHRoZW4gcmV0dXJuICRxLnJlamVjdChcIkdpc3Qgbm90IGZvdW5kXCIpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnaXN0ID0gcmVzcG9uc2UuZGF0YS5kYXRhXHJcbiAgICAgICAgICAgIGpzb24gPSBcclxuICAgICAgICAgICAgICAncHJpdmF0ZSc6IHRydWVcclxuICAgICAgICAgICAgICBmaWxlczogW11cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIG1hbmlmZXN0ID0gZ2lzdC5maWxlc1tcInBsdW5rZXIuanNvblwiXVxyXG4gICAgICAgICAgICAgIHRyeVxyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5leHRlbmQganNvbiwgYW5ndWxhci5mcm9tSnNvbihtYW5pZmVzdC5jb250ZW50KVxyXG4gICAgICAgICAgICAgIGNhdGNoIGVcclxuICAgICAgICAgICAgICAgIG5vdGlmaWVyLndhcm4gXCJVbmFibGUgdG8gcGFyc2UgdGhlIHBsdW5rZXIuanNvbiBmaWxlXCJcclxuICAgIFxyXG4gICAgICAgICAgICBqc29uLmRlc2NyaXB0aW9uID0gZ2lzdC5kZXNjcmlwdGlvbiBvciBcImh0dHBzOi8vZ2lzdC5naXRodWIuY29tLyN7JHN0YXRlUGFyYW1zLmdpc3RJZH1cIlxyXG4gIFxyXG4gICAgICAgICAgICBmb3IgZmlsZW5hbWUsIGZpbGUgb2YgZ2lzdC5maWxlc1xyXG4gICAgICAgICAgICAgIHVubGVzcyBmaWxlbmFtZSA9PSBcInBsdW5rZXIuanNvblwiXHJcbiAgICAgICAgICAgICAgICBqc29uLmZpbGVzLnB1c2hcclxuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpbGUuY29udGVudCBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHVwZGF0ZXIudXBkYXRlKGpzb24pXHJcbiAgICAgICAgICAsIChlcnJvcikgLT5cclxuICAgICAgICAgICAgY29uc29sZS5sb2cgXCJbRVJSXSBQdWxsaW5nIGdpc3RcIiwgZXJyb3JcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICRxLnJlamVjdChcIlVuYWJsZSB0byBsb2FkIGdpc3RcIilcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICBwYXJzZXIudGhlbiAoanNvbikgLT5cclxuICAgICAgICAgICAgbGF5b3V0LmN1cnJlbnQudGVtcGxhdGVzLmNsb3NlZCA9IHRydWVcclxuICAgICAgICAgICAgY2xpZW50LnJlc2V0IGpzb25cclxuICAgICAgICAgICAgY2xpZW50LmN1cnNvclNldEluZGV4ICgwIDw9IGlkeCA9IGNsaWVudC5nZXRGaWxlSW5kZXgoXCJpbmRleC5odG1sXCIpKSBhbmQgaWR4IG9yIDBcclxuICAgICAgICAgICAgbm90aWZpZXIuc3VjY2VzcyBcIkltcG9ydGVkIGdpc3QgI3skc3RhdGVQYXJhbXMuZ2lzdElkfVwiXHJcbiAgICAgICAgICAsIChlcnJvclRleHQpIC0+XHJcbiAgICAgICAgICAgICRzdGF0ZS5nbyBcImVkaXRvci5ibGFua1wiXHJcbiAgICAgICAgICAgIG5vdGlmaWVyLmVycm9yIGVycm9yVGV4dFxyXG4gICAgICAgIF1cclxuXVxyXG5cclxubW9kdWxlLmNvbnRyb2xsZXIgXCJTaWRlYmFyQ29udHJvbGxlclwiLCBbXCIkc2NvcGVcIiwgXCJzZXNzaW9uXCIsICgkc2NvcGUsIHNlc3Npb24pIC0+XHJcbiAgJHNjb3BlLnNlc3Npb24gPSBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcIlNpZGViYXJDb250cm9sbGVyXCIpXHJcbiAgXHJcbiAgJHNjb3BlLmFkZEZpbGUgPSAtPlxyXG4gICAgaWYgZmlsZW5hbWUgPSBwcm9tcHQoXCJGaWxlbmFtZT9cIilcclxuICAgICAgY2xpZW50LmZpbGVDcmVhdGUoZmlsZW5hbWUpXHJcbiAgICAgIGNsaWVudC5jdXJzb3JTZXRGaWxlKGZpbGVuYW1lKVxyXG4gIFxyXG4gICRzY29wZS5yZW5hbWVGaWxlID0gKG9sZF9maWxlbmFtZSkgLT5cclxuICAgIGlmIGNsaWVudC5oYXNGaWxlKG9sZF9maWxlbmFtZSkgYW5kIGZpbGVuYW1lID0gcHJvbXB0KFwiRmlsZW5hbWU/XCIsIG9sZF9maWxlbmFtZSlcclxuICAgICAgY2xpZW50LmZpbGVSZW5hbWUob2xkX2ZpbGVuYW1lLCBmaWxlbmFtZSkgICAgXHJcbiAgXHJcbiAgJHNjb3BlLnJlbW92ZUZpbGUgPSAoZmlsZW5hbWUpIC0+XHJcbiAgICBpZiBjbGllbnQuaGFzRmlsZShmaWxlbmFtZSkgYW5kIGNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlICN7ZmlsZW5hbWV9P1wiKVxyXG4gICAgICBjbGllbnQuZmlsZVJlbW92ZShmaWxlbmFtZSlcclxuICBcclxuICAkc2NvcGUubW92ZVRvID0gKGZpbGVuYW1lKSAtPlxyXG4gICAgY2xpZW50LmN1cnNvclNldEZpbGUoZmlsZW5hbWUpXHJcbl1cclxuXHJcblxyXG5tb2R1bGUuY29udHJvbGxlciBcIkxheW91dENvbnRyb2xsZXJcIiwgW1wiJHNjb3BlXCIsIFwibGF5b3V0XCIsICgkc2NvcGUsIGxheW91dCkgLT5cclxuICAkc2NvcGUubGF5b3V0ID0gbGF5b3V0XHJcbiAgJHNjb3BlLnRvZ2dsZVByZXZpZXdQYW5lID0gLT5cclxuICAgICRzY29wZS5zaG93UHJldmlld1BhbmUgPSAhJHNjb3BlLnNob3dQcmV2aWV3UGFuZVxyXG5dIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJmYS5ib3JkZXJMYXlvdXRcIiwgW1xuXVxuXG50aHJvdHRsZSA9IChkZWxheSwgZm4pIC0+XG4gIHRocm90dGxlZCA9IGZhbHNlXG4gIC0+XG4gICAgcmV0dXJuIGlmIHRocm90dGxlZFxuICAgIFxuICAgIHRocm90dGxlZCA9IHRydWVcbiAgICBzZXRUaW1lb3V0IC0+XG4gICAgICB0aHJvdHRsZWQgPSBmYWxzZVxuICAgICwgZGVsYXlcbiAgICBcbiAgICBmbi5jYWxsKEAsIGFyZ3VtZW50cy4uLilcblxuY2xhc3MgUmVnaW9uXG4gIGNvbnN0cnVjdG9yOiAoQHdpZHRoID0gMCwgQGhlaWdodCA9IDApIC0+XG4gICAgQHRvcCA9IDBcbiAgICBAcmlnaHQgPSAwXG4gICAgQGJvdHRvbSA9IDBcbiAgICBAbGVmdCA9IDBcbiAgICBcbiAgY2FsY3VsYXRlU2l6ZTogKG9yaWVudGF0aW9uLCB0YXJnZXQgPSAwKSAtPlxuICAgIHRvdGFsID0gQGdldFNpemUob3JpZW50YXRpb24pXG4gICAgYXZhaWxhYmxlID0gQGdldEF2YWlsYWJsZVNpemUob3JpZW50YXRpb24pXG4gICAgXG4gICAgaWYgYW5ndWxhci5pc051bWJlcih0YXJnZXQpXG4gICAgICBpZiB0YXJnZXQgPj0gMSB0aGVuIHJldHVybiBNYXRoLnJvdW5kKHRhcmdldClcbiAgICAgIGlmIHRhcmdldCA+PSAwIHRoZW4gcmV0dXJuIE1hdGgucm91bmQodGFyZ2V0ICogdG90YWwpXG4gICAgICBcbiAgICAgIHJldHVybiAwXG4gICAgXG4gICAgIyBLaWxsIHdoaXRlc3BhY2VcbiAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZSAvXFxzKy9tZywgXCJcIlxuICAgIFxuICAgICMgQWxsb3cgZm9yIGNvbXBsZXggc2l6ZXMsIGUuZy46IDUwJSAtIDRweFxuICAgIGlmICh0ZXJtcyA9IHRhcmdldC5zcGxpdChcIi1cIikpLmxlbmd0aCA+IDEgdGhlbiByZXR1cm4gQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLnNoaWZ0KCkpIC0gQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLmpvaW4oXCIrXCIpKVxuICAgIGlmICh0ZXJtcyA9IHRhcmdldC5zcGxpdChcIitcIikpLmxlbmd0aCA+IDEgdGhlbiByZXR1cm4gQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLnNoaWZ0KCkpICsgQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLmpvaW4oXCIrXCIpKVxuICAgICAgXG4gICAgaWYgbWF0Y2hlcyA9IHRhcmdldC5tYXRjaCAvXihcXGQrKXB4JC8gdGhlbiByZXR1cm4gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApXG4gICAgaWYgbWF0Y2hlcyA9IHRhcmdldC5tYXRjaCAvXihcXGQrKD86XFwuXFxkKyk/KSYkLyB0aGVuIHJldHVybiBNYXRoLnJvdW5kKGF2YWlsYWJsZSAqIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgLyAxMDApXG4gICAgaWYgbWF0Y2hlcyA9IHRhcmdldC5tYXRjaCAvXihcXGQrKD86XFwuXFxkKyk/KSUkLyB0aGVuIHJldHVybiBNYXRoLnJvdW5kKHRvdGFsICogcGFyc2VGbG9hdChtYXRjaGVzWzFdKSAvIDEwMClcbiAgICBcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzaXplOiAje3RhcmdldH1cIilcbiAgXG4gIGNvbnN1bWU6IChhbmNob3IsIHNpemUgPSAwKSAtPlxuICAgIHN3aXRjaCBhbmNob3JcbiAgICAgIHdoZW4gXCJub3J0aFwiXG4gICAgICAgIHN0eWxlID0geyB0b3A6IFwiI3tAdG9wfXB4XCIsIHJpZ2h0OiBcIiN7QHJpZ2h0fXB4XCIsIGxlZnQ6IFwiI3tAbGVmdH1weFwiLCBoZWlnaHQ6IFwiI3tzaXplfXB4XCIgfVxuICAgICAgICBAdG9wICs9IHNpemVcbiAgICAgIHdoZW4gXCJlYXN0XCJcbiAgICAgICAgc3R5bGUgPSB7IHRvcDogXCIje0B0b3B9cHhcIiwgcmlnaHQ6IFwiI3tAcmlnaHR9cHhcIiwgYm90dG9tOiBcIiN7QGJvdHRvbX1weFwiLCB3aWR0aDogXCIje3NpemV9cHhcIiB9XG4gICAgICAgIEByaWdodCArPSBzaXplXG4gICAgICB3aGVuIFwic291dGhcIlxuICAgICAgICBzdHlsZSA9IHsgcmlnaHQ6IFwiI3tAcmlnaHR9cHhcIiwgYm90dG9tOiBcIiN7QGJvdHRvbX1weFwiLCBsZWZ0OiBcIiN7QGxlZnR9cHhcIiwgaGVpZ2h0OiBcIiN7c2l6ZX1weFwiIH1cbiAgICAgICAgQGJvdHRvbSArPSBzaXplXG4gICAgICB3aGVuIFwid2VzdFwiXG4gICAgICAgIHN0eWxlID0geyB0b3A6IFwiI3tAdG9wfXB4XCIsIGJvdHRvbTogXCIje0Bib3R0b219cHhcIiwgbGVmdDogXCIje0BsZWZ0fXB4XCIsIHdpZHRoOiBcIiN7c2l6ZX1weFwiIH1cbiAgICAgICAgQGxlZnQgKz0gc2l6ZVxuICAgICAgXG4gICAgc3R5bGVcbiAgICBcbiAgZ2V0SW5uZXJSZWdpb246IC0+XG4gICAgbmV3IFJlZ2lvbiBAd2lkdGggLSBAcmlnaHQgLSBAbGVmdCwgQGhlaWdodCAtIEB0b3AgLSBAYm90dG9tXG4gIFxuICBnZXRTaXplOiAob3JpZW50YXRpb24pIC0+XG4gICAgc3dpdGNoIG9yaWVudGF0aW9uXG4gICAgICB3aGVuIFwidmVydGljYWxcIiB0aGVuIEBoZWlnaHRcbiAgICAgIHdoZW4gXCJob3Jpem9udGFsXCIgdGhlbiBAd2lkdGhcbiAgXG4gIGdldEF2YWlsYWJsZVNpemU6IChvcmllbnRhdGlvbikgLT5cbiAgICBzd2l0Y2ggb3JpZW50YXRpb25cbiAgICAgIHdoZW4gXCJ2ZXJ0aWNhbFwiIHRoZW4gQGhlaWdodCAtIEB0b3AgLSBAYm90dG9tXG4gICAgICB3aGVuIFwiaG9yaXpvbnRhbFwiIHRoZW4gQHdpZHRoIC0gQHJpZ2h0IC0gQGxlZnRcbiAgXG4gIFxuXG5tb2R1bGUuZGlyZWN0aXZlIFwicGFuZVwiLCBbIC0+XG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHJlcXVpcmU6IFtcInBhbmVcIiwgXCJeYm9yZGVyTGF5b3V0XCJdXG4gIHRyYW5zY2x1ZGU6IHRydWVcbiAgc2NvcGU6IHRydWVcbiAgdGVtcGxhdGU6IFwiXCJcIlxuICAgIDxkaXYgY2xhc3M9XCJib3JkZXItbGF5b3V0LXBhbmVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJib3JkZXItbGF5b3V0LXBhbmUtb3ZlcmxheVwiIG5nLXN0eWxlPVwic3R5bGVDb250ZW50XCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiYm9yZGVyLWxheW91dC1wYW5lLWhhbmRsZVwiIGxheW91dC1oYW5kbGUgbmctc3R5bGU9XCJzdHlsZUhhbmRsZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImJvcmRlci1sYXlvdXQtcGFuZS1zY3JvbGxlclwiIG5nLXN0eWxlPVwic3R5bGVDb250ZW50XCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgXCJcIlwiXG4gIGNvbnRyb2xsZXI6IFtcIiRzY29wZVwiLCBcIiRlbGVtZW50XCIsIFwiJGF0dHJzXCIsICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIC0+XG4gICAgcGFuZSA9IEBcbiAgICBcbiAgICBbJG92ZXJsYXksICRoYW5kbGUsICRzY3JvbGxlcl0gPSAkZWxlbWVudC5jaGlsZHJlbigpXG4gICAgXG4gICAgJHNjb3BlLiR3YXRjaCAkYXR0cnMub3B0aW9ucywgKG9wdGlvbnMsIG9sZE9wdGlvbnMpIC0+XG4gICAgICBpZiBvcHRpb25zXG4gICAgICAgIHBhbmUuYW5jaG9yID0gb3B0aW9ucy5hbmNob3Igb3IgXCJjZW50ZXJcIlxuICAgICAgICBwYW5lLm9yaWVudGF0aW9uID0gcGFuZS5nZXRPcmllbnRhdGlvbihwYW5lLmFuY2hvcilcbiAgICAgICAgcGFuZS50YXJnZXQgPSBvcHRpb25zLnNpemVcbiAgICAgICAgcGFuZS5tYXggPSBvcHRpb25zLm1heCB8fCBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICAgIHBhbmUubWluID0gb3B0aW9ucy5taW4gfHwgMFxuICAgICAgICBwYW5lLm9wZW4gPSAhb3B0aW9ucy5jbG9zZWRcbiAgICAgICAgcGFuZS5vcmRlciA9IHBhcnNlSW50KG9wdGlvbnMub3JkZXIgb3IgMCwgMTApXG4gICAgICAgIHBhbmUuaGFuZGxlU2l6ZSA9IHBhcnNlSW50KG9wdGlvbnMuaGFuZGxlIG9yIDAsIDEwKVxuICAgICAgICBcbiAgICAgICAgcGFuZS5sYXlvdXQucmVmbG93KClcbiAgICAsIHRydWVcbiAgICAgIFxuICAgIEBjaGlsZHJlbiA9IFtdXG4gICAgQG9wZW5TaXplID0gMFxuICAgIFxuICAgIEBhdHRhY2hDaGlsZCA9IChjaGlsZCkgLT4gQGNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgXG4gICAgQGdldE9yaWVudGF0aW9uID0gKGFuY2hvciA9IHBhbmUuYW5jaG9yKSAtPlxuICAgICAgc3dpdGNoIGFuY2hvclxuICAgICAgICB3aGVuIFwibm9ydGhcIiwgXCJzb3V0aFwiIHRoZW4gXCJ2ZXJ0aWNhbFwiXG4gICAgICAgIHdoZW4gXCJlYXN0XCIsIFwid2VzdFwiIHRoZW4gXCJob3Jpem9udGFsXCJcbiAgICBcbiAgICBAZ2V0Q29udGVudFN0eWxlID0gKGFuY2hvciwgaGFuZGxlU2l6ZSkgLT5cbiAgICAgIHN0eWxlID1cbiAgICAgICAgdG9wOiAwXG4gICAgICAgIHJpZ2h0OiAwXG4gICAgICAgIGJvdHRvbTogMFxuICAgICAgICBsZWZ0OiAwXG4gICAgICAgIFxuICAgICAgc3dpdGNoIGFuY2hvclxuICAgICAgICB3aGVuIFwibm9ydGhcIiB0aGVuIHN0eWxlLmJvdHRvbSA9IFwiI3toYW5kbGVTaXplfXB4XCJcbiAgICAgICAgd2hlbiBcImVhc3RcIiB0aGVuIHN0eWxlLmxlZnQgPSBcIiN7aGFuZGxlU2l6ZX1weFwiXG4gICAgICAgIHdoZW4gXCJzb3V0aFwiIHRoZW4gc3R5bGUudG9wID0gXCIje2hhbmRsZVNpemV9cHhcIlxuICAgICAgICB3aGVuIFwid2VzdFwiIHRoZW4gc3R5bGUucmlnaHQgPSBcIiN7aGFuZGxlU2l6ZX1weFwiXG4gICAgICBcbiAgICAgIHN0eWxlXG4gICAgICAgIFxuICAgIEBnZXRIYW5kbGVTdHlsZSA9IChhbmNob3IsIHJlZ2lvbiwgaGFuZGxlU2l6ZSkgLT5cbiAgICAgIFxuICAgICAgc3dpdGNoIGFuY2hvclxuICAgICAgICB3aGVuIFwibm9ydGhcIlxuICAgICAgICAgIGhlaWdodDogXCIje3JlZ2lvbi5jYWxjdWxhdGVTaXplKCd2ZXJ0aWNhbCcsIGhhbmRsZVNpemUpfXB4XCJcbiAgICAgICAgICByaWdodDogMFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgd2hlbiBcInNvdXRoXCIgXG4gICAgICAgICAgaGVpZ2h0OiBcIiN7cmVnaW9uLmNhbGN1bGF0ZVNpemUoJ3ZlcnRpY2FsJywgaGFuZGxlU2l6ZSl9cHhcIlxuICAgICAgICAgIHJpZ2h0OiAwXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICAgIHRvcDogMFxuICAgICAgICB3aGVuIFwiZWFzdFwiXG4gICAgICAgICAgd2lkdGg6IFwiI3tyZWdpb24uY2FsY3VsYXRlU2l6ZSgnaG9yaXpvbnRhbCcsIGhhbmRsZVNpemUpfXB4XCJcbiAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIHdoZW4gXCJ3ZXN0XCIgXG4gICAgICAgICAgd2lkdGg6IFwiI3tyZWdpb24uY2FsY3VsYXRlU2l6ZSgnaG9yaXpvbnRhbCcsIGhhbmRsZVNpemUpfXB4XCJcbiAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgICByaWdodDogMFxuICAgIFxuICAgIEBvbkhhbmRsZURvd24gPSAtPlxuICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoXCJhY3RpdmVcIilcbiAgICAgIEBsYXlvdXQub25IYW5kbGVEb3duKClcbiAgICBAb25IYW5kbGVVcCA9IC0+XG4gICAgICAkZWxlbWVudC5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKVxuICAgICAgQGxheW91dC5vbkhhbmRsZVVwKClcbiAgICBcbiAgICBAdG9nZ2xlID0gKG9wZW4gPSAhcGFuZS5vcGVuKSAtPlxuICAgICAgcGFuZS5vcGVuID0gb3BlblxuICAgICAgXG4gICAgICBpZiAhb3BlbiB0aGVuIEBvcGVuU2l6ZSA9IEBzaXplXG4gICAgICBlbHNlIEBzaXplID0gQG9wZW5TaXplXG4gICAgICBcbiAgICAgIGlmIG9wZW4gdGhlbiAkZWxlbWVudC5yZW1vdmVDbGFzcyhcImNsb3NlZFwiKVxuICAgICAgZWxzZSAkZWxlbWVudC5hZGRDbGFzcyhcImNsb3NlZFwiKVxuICAgICAgXG4gICAgICBAbGF5b3V0LnJlZmxvdygpXG4gICAgXG4gICAgQHJlZmxvdyA9IChyZWdpb24sIHRhcmdldCA9IHBhbmUudGFyZ2V0KSAtPlxuICAgICAgYW5jaG9yID0gcGFuZS5hbmNob3JcbiAgICAgIFxuICAgICAgaWYgb3BlbiB0aGVuICRlbGVtZW50LnJlbW92ZUNsYXNzKFwiY2xvc2VkXCIpXG4gICAgICBlbHNlICRlbGVtZW50LmFkZENsYXNzKFwiY2xvc2VkXCIpXG4gICAgICBcbiAgICAgIGlmIGFuY2hvciBpcyBcImNlbnRlclwiXG4gICAgICAgICRlbGVtZW50LmNzc1xuICAgICAgICAgIHRvcDogXCIje3JlZ2lvbi50b3B9cHhcIlxuICAgICAgICAgIHJpZ2h0OiBcIiN7cmVnaW9uLnJpZ2h0fXB4XCJcbiAgICAgICAgICBib3R0b206IFwiI3tyZWdpb24uYm90dG9tfXB4XCJcbiAgICAgICAgICBsZWZ0OiBcIiN7cmVnaW9uLmxlZnR9cHhcIlxuICAgICAgZWxzZSBpZiBhbmNob3IgaW4gW1wibm9ydGhcIiwgXCJlYXN0XCIsIFwic291dGhcIiwgXCJ3ZXN0XCJdXG4gICAgICAgIG9yaWVudGF0aW9uID0gQGdldE9yaWVudGF0aW9uKGFuY2hvcilcbiAgICAgICAgaGFuZGxlU2l6ZSA9IHJlZ2lvbi5jYWxjdWxhdGVTaXplKG9yaWVudGF0aW9uLCBwYW5lLmhhbmRsZVNpemUgfHwgMClcblxuICAgICAgICBpZiAhcGFuZS5vcGVuXG4gICAgICAgICAgc2l6ZSA9IGhhbmRsZVNpemVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNpemUgPSByZWdpb24uY2FsY3VsYXRlU2l6ZShvcmllbnRhdGlvbiwgdGFyZ2V0KVxuICAgICAgICAgIFxuICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCByZWdpb24uY2FsY3VsYXRlU2l6ZShvcmllbnRhdGlvbiwgcGFuZS5tYXgpKVxuICAgICAgICAgIHNpemUgPSBNYXRoLm1heChzaXplLCByZWdpb24uY2FsY3VsYXRlU2l6ZShvcmllbnRhdGlvbiwgcGFuZS5taW4pKVxuICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCByZWdpb24uZ2V0QXZhaWxhYmxlU2l6ZShvcmllbnRhdGlvbikpXG4gICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIGhhbmRsZVNpemUgKyAyKSAjIFdoeSBkb2VzIDEuNSB3b3JrIT9cbiAgICAgICAgXG4gICAgICAgIEBzaXplID0gc2l6ZVxuICAgICAgICBcbiAgICAgICAgc3R5bGVDb250YWluZXIgPSByZWdpb24uY29uc3VtZShhbmNob3IsIHNpemUpXG4gICAgICAgIHN0eWxlQ29udGVudCA9IEBnZXRDb250ZW50U3R5bGUoYW5jaG9yLCBoYW5kbGVTaXplKVxuICAgICAgICBzdHlsZUhhbmRsZSA9IEBnZXRIYW5kbGVTdHlsZShhbmNob3IsIHJlZ2lvbiwgaGFuZGxlU2l6ZSlcbiAgICAgICAgXG4gICAgICAgICRlbGVtZW50LmF0dHIoXCJzdHlsZVwiLCBcIlwiKS5jc3Moc3R5bGVDb250YWluZXIpXG4gICAgICAgIFxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJG92ZXJsYXkpLmF0dHIoXCJzdHlsZVwiLCBcIlwiKS5jc3Moc3R5bGVDb250ZW50KVxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHNjcm9sbGVyKS5hdHRyKFwic3R5bGVcIiwgXCJcIikuY3NzKHN0eWxlQ29udGVudClcbiAgICAgICAgYW5ndWxhci5lbGVtZW50KCRoYW5kbGUpLmF0dHIoXCJzdHlsZVwiLCBcIlwiKS5jc3Moc3R5bGVIYW5kbGUpXG4gICAgICAgIFxuICAgICAgaWYgQGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICBpbm5lciA9IHJlZ2lvbi5nZXRJbm5lclJlZ2lvbigpXG4gICAgICAgIGlubmVyID0gY2hpbGQucmVmbG93KGlubmVyKSBmb3IgY2hpbGQgaW4gQGNoaWxkcmVuXG5cbiAgICAgIHJldHVybiByZWdpb25cbiAgICBcbiAgICBAcmVzaXplID0gKHRhcmdldCkgLT5cbiAgICAgIHBhbmUudGFyZ2V0ID0gdGFyZ2V0IHx8IDBcbiAgICAgIFxuICAgICAgQGxheW91dC5yZWZsb3coKVxuICAgICAgXG4gIF1cbiAgbGluazogKCRzY29wZSwgJGVsLCAkYXR0cnMsIFtwYW5lLCBwYXJlbnRdKSAtPlxuICAgIHBhbmUubGF5b3V0ID0gcGFyZW50XG4gICAgcGFyZW50LmF0dGFjaENoaWxkKHBhbmUpXG4gICAgXG4gICAgJHNjb3BlLiQkbmV4dFNpYmxpbmcucGFuZSA9IHBhbmVcbiAgICBcbiAgICAkc2NvcGUuJHdhdGNoIFwiY29uc3RyYWluZWRcIiwgKGNvbnN0cmFpbmVkKSAtPlxuICAgICAgaWYgY29uc3RyYWluZWQgdGhlbiAkZWwuYWRkQ2xhc3MoXCJib3JkZXItbGF5b3V0LWNvbnN0cmFpbmVkXCIpXG4gICAgICBlbHNlICRlbC5yZW1vdmVDbGFzcyhcImJvcmRlci1sYXlvdXQtY29uc3RyYWluZWRcIilcbl1cblxubW9kdWxlLmRpcmVjdGl2ZSBcImxheW91dEhhbmRsZVwiLCBbIFwiJHdpbmRvd1wiLCAoJHdpbmRvdykgLT5cbiAgcmVzdHJpY3Q6IFwiQVwiXG4gIHJlcXVpcmU6IFtcIj9ecGFuZVwiLCBcIl4/Ym9yZGVyTGF5b3V0XCJdXG4gIGxpbms6ICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsIFtwYW5lLCBsYXlvdXRdKSAtPlxuICAgIHJldHVybiB1bmxlc3MgcGFuZVxuICAgIFxuICAgIGVsID0gJGVsZW1lbnRbMF1cbiAgICBcbiAgICBjbGlja1JhZGl1cyA9IDVcbiAgICBjbGlja1RpbWUgPSAzMDBcbiAgICBcbiAgICAkc2NvcGUuJHdhdGNoICggLT4gcGFuZS5nZXRPcmllbnRhdGlvbigpICksIChvcmllbnRhdGlvbikgLT5cbiAgICAgICRlbGVtZW50LnJlbW92ZUNsYXNzKFwidmVydGljYWxcIilcbiAgICAgICRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaG9yaXpvbnRhbFwiKVxuICAgICAgc3dpdGNoIG9yaWVudGF0aW9uXG4gICAgICAgIHdoZW4gXCJ2ZXJ0aWNhbFwiIHRoZW4gJGVsZW1lbnQuYWRkQ2xhc3MoXCJ2ZXJ0aWNhbFwiKVxuICAgICAgICB3aGVuIFwiaG9yaXpvbnRhbFwiIHRoZW4gJGVsZW1lbnQuYWRkQ2xhc3MoXCJob3Jpem9udGFsXCIpXG4gICAgXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lciBcIm1vdXNlZG93blwiLCAoZSkgLT5cbiAgICAgIHJldHVybiB1bmxlc3MgZS5idXR0b24gaXMgMFxuICAgICAgXG4gICAgICBhbmNob3IgPSBwYW5lLmFuY2hvclxuICAgICAgXG4gICAgICBpZiBhbmNob3IgaW4gW1wibm9ydGhcIiwgXCJzb3V0aFwiXSB0aGVuIGNvb3JkID0gXCJzY3JlZW5ZXCJcbiAgICAgIGVsc2UgaWYgYW5jaG9yIGluIFtcIndlc3RcIiwgXCJlYXN0XCJdIHRoZW4gY29vcmQgPSBcInNjcmVlblhcIlxuXG4gICAgICBpZiBhbmNob3IgaW4gW1wibm9ydGhcIiwgXCJ3ZXN0XCJdIHRoZW4gc2NhbGUgPSAxXG4gICAgICBlbHNlIGlmIGFuY2hvciBpbiBbXCJzb3V0aFwiLCBcImVhc3RcIl0gdGhlbiBzY2FsZSA9IC0xXG4gICAgXG4gICAgICBzdGFydFBvcyA9IHt4OiBlLnNjcmVlblgsIHk6IGUuc2NyZWVuWX1cbiAgICAgIHN0YXJ0Q29vcmQgPSBlW2Nvb3JkXVxuICAgICAgc3RhcnRTaXplID0gcGFuZS5zaXplXG4gICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgICBcbiAgICAgIHBhbmUub25IYW5kbGVEb3duKClcbiAgICAgIFxuICAgICAgIyBOb3Qgc3VyZSBpZiB0aGlzIHJlYWxseSBhZGRzIHZhbHVlLCBidXQgYWRkZWQgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgIGVsLnVuc2VsZWN0YWJsZSA9IFwib25cIlxuICAgICAgZWwub25zZWxlY3RzdGFydCA9IC0+IGZhbHNlXG4gICAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gZWwuc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiXG4gICAgICBcbiAgICAgICMgTnVsbCBvdXQgdGhlIGV2ZW50IHRvIHJlLXVzZSBlIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgI2Uuc2V0Q2FwdHVyZSgpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuZGVmYXVsdFByZXZlbnRlZCA9IHRydWVcbiAgICAgIGUgPSBudWxsXG4gICAgICBcbiAgICAgIGhhbmRsZUNsaWNrID0gKGUpIC0+XG4gICAgICAgICRzY29wZS4kYXBwbHkgLT4gcGFuZS50b2dnbGUoKVxuICAgICAgICAgIFxuICAgICAgaGFuZGxlTW91c2VNb3ZlID0gKGUpIC0+XG4gICAgICAgICRlbGVtZW50LmFkZENsYXNzKFwiYm9yZGVyLWxheW91dC1wYW5lLW1vdmluZ1wiKVxuICAgICAgXG4gICAgICAgICMgSW5zaWRlIEFuZ3VsYXIncyBkaWdlc3QsIGRldGVybWluZSB0aGUgaWRlYWwgc2l6ZSBvZiB0aGUgZWxlbWVudFxuICAgICAgICAjIGFjY29yZGluZyB0byBtb3ZlbWVudHMgdGhlbiBkZXRlcm1pbmUgaWYgdGhvc2UgbW92ZW1lbnRzIGhhdmUgYmVlblxuICAgICAgICAjIGNvbnN0cmFpbmVkIGJ5IGJvdW5kYXJpZXMsIG90aGVyIHBhbmVzIG9yIG1pbi9tYXggY2xhdXNlc1xuICAgICAgICAkc2NvcGUuJGFwcGx5IC0+IHBhbmUucmVzaXplIHRhcmdldFNpemUgPSBzdGFydFNpemUgKyBzY2FsZSAqIChlW2Nvb3JkXSAtIHN0YXJ0Q29vcmQpXG5cbiAgICAgICAgIyBOdWxsIG91dCB0aGUgZXZlbnQgaW4gY2FzZSBvZiBtZW1vcnkgbGVha3NcbiAgICAgICAgI2Uuc2V0Q2FwdHVyZSgpXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlXG4gICAgICAgIGUgPSBudWxsXG4gICAgICAgIFxuICAgICAgaGFuZGxlTW91c2VVcCA9IChlKSAtPlxuICAgICAgICBkaXNwbGFjZW1lbnRTcSA9IE1hdGgucG93KGUuc2NyZWVuWCAtIHN0YXJ0UG9zLngsIDIpICsgTWF0aC5wb3coZS5zY3JlZW5ZIC0gc3RhcnRQb3MueSwgMilcbiAgICAgICAgdGltZUVsYXBzZWQgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG5cbiAgICAgICAgJHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZVRocm90dGxlZCwgdHJ1ZVxuICAgICAgICAkd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgXCJtb3VzZXVwXCIsIGhhbmRsZU1vdXNlVXAsIHRydWVcbiAgICAgICAgXG4gICAgICAgIGNsZWFudXAgPSAtPlxuICAgICAgICAgICMgTnVsbCBvdXQgdGhlIGV2ZW50IGluIGNhc2Ugb2YgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgI2UucmVsZWFzZUNhcHR1cmUoKVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGUuZGVmYXVsdFByZXZlbnRlZCA9IHRydWVcbiAgICAgICAgICBlID0gbnVsbFxuXG4gICAgICAgICAgcGFuZS5vbkhhbmRsZVVwKClcbiAgICAgICAgXG4gXG4gICAgICAgIGlmIGRpc3BsYWNlbWVudFNxIDw9IE1hdGgucG93KGNsaWNrUmFkaXVzLCAyKSBhbmQgdGltZUVsYXBzZWQgPD0gY2xpY2tUaW1lXG4gICAgICAgICAgaGFuZGxlQ2xpY2soZSlcbiAgICAgICAgICBjbGVhbnVwKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgICBcbiAgICAgICAgIyBJbiBjYXNlIHRoZSBtb3VzZSBpcyByZWxlYXNlZCBhdCB0aGUgZW5kIG9mIGEgdGhyb3R0bGUgcGVyaW9kXG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZShlKVxuICAgICAgICBcbiAgICAgICAgY2xlYW51cCgpXG5cbiAgICAgIFxuICAgICAgIyBQcmV2ZW50IHRoZSByZWZsb3cgbG9naWMgZnJvbSBoYXBwZW5pbmcgdG9vIG9mdGVuXG4gICAgICBoYW5kbGVNb3VzZU1vdmVUaHJvdHRsZWQgPSB0aHJvdHRsZSgxMCwgaGFuZGxlTW91c2VNb3ZlKVxuICAgIFxuICAgICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZVRocm90dGxlZCwgdHJ1ZVxuICAgICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIFwibW91c2V1cFwiLCBoYW5kbGVNb3VzZVVwLCB0cnVlXG5cbl1cblxuXG5tb2R1bGUuZGlyZWN0aXZlIFwiYm9yZGVyTGF5b3V0XCIsIFsgXCIkd2luZG93XCIsIFwiJHRpbWVvdXRcIiwgKCR3aW5kb3csICR0aW1lb3V0KS0+XG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHJlcXVpcmU6IFtcImJvcmRlckxheW91dFwiLCBcIl4/cGFuZVwiXVxuICB0cmFuc2NsdWRlOiB0cnVlXG4gIHRlbXBsYXRlOiBcIlwiXCJcbiAgICA8ZGl2IGNsYXNzPVwiYm9yZGVyLWxheW91dFwiIG5nLXRyYW5zY2x1ZGU+XG4gICAgPC9kaXY+XG4gIFwiXCJcIlxuICBjb250cm9sbGVyOiBbXCIkc2NvcGVcIiwgXCIkZWxlbWVudFwiLCBcIiRhdHRyc1wiLCAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSAtPlxuICAgIGxheW91dCA9IEBcbiAgICBcbiAgICBAY2hpbGRyZW4gPSBbXVxuICAgIFxuICAgIEBhdHRhY2hDaGlsZCA9IChjaGlsZCkgLT5cbiAgICAgIEBjaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgIFxuICAgIEBvbkhhbmRsZURvd24gPSAtPiAkZWxlbWVudC5hZGRDbGFzcyhcImFjdGl2ZVwiKVxuICAgIEBvbkhhbmRsZVVwID0gLT5cbiAgICAgICRlbGVtZW50LnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpXG4gICAgICAkc2NvcGUuJGJyb2FkY2FzdCBcImJvcmRlci1sYXlvdXQtcmVmbG93XCJcbiAgICBcbiAgICBAcmVmbG93ID0gKHJlZ2lvbikgLT5cbiAgICAgIHJldHVybiBpZiBsYXlvdXQucmVmbG93aW5nXG4gICAgICBcbiAgICAgIGxheW91dC5yZWZsb3dpbmcgPSB0cnVlXG4gICAgICBcbiAgICAgIHdpZHRoID0gJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGhcbiAgICAgIGhlaWdodCA9ICRlbGVtZW50WzBdLm9mZnNldEhlaWdodFxuICAgICAgXG4gICAgICByZWdpb24gfHw9IG5ldyBSZWdpb24od2lkdGgsIGhlaWdodClcbiAgICAgIFxuICAgICAgQGNoaWxkcmVuLnNvcnQgKGEsIGIpIC0+IGIub3JkZXIgLSBhLm9yZGVyXG4gICAgICBcbiAgICAgIHJlZ2lvbiA9IGNoaWxkLnJlZmxvdyhyZWdpb24pIGZvciBjaGlsZCBpbiBAY2hpbGRyZW5cblxuICAgICAgJHNjb3BlLiRicm9hZGNhc3QgXCJib3JkZXItbGF5b3V0LXJlZmxvd1wiLCBEYXRlLm5vdygpXG4gICAgICBcbiAgICAgIGxheW91dC5yZWZsb3dpbmcgPSBmYWxzZVxuICAgICAgXG4gIF1cbiAgbGluazogKCRzY29wZSwgJGVsLCAkYXR0cnMsIFtsYXlvdXQsIHBhcmVudF0pIC0+XG4gICAgcGFyZW50LmF0dGFjaENoaWxkKGxheW91dCkgaWYgcGFyZW50XG4gICAgXG4gICAgJHNjb3BlLiRvbiBcImJvcmRlci1sYXlvdXQtcmVmbG93XCIsIC0+XG4gICAgICBsYXlvdXQucmVmbG93KCkgdW5sZXNzIHBhcmVudFxuICAgIFxuICAgICR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBcInJlc2l6ZVwiLCAoZSkgLT5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICRzY29wZS4kYXBwbHkgLT4gbGF5b3V0LnJlZmxvdygpXG4gICAgXG4gICAgJHRpbWVvdXQgLT4gbGF5b3V0LnJlZmxvdygpIHVubGVzcyBwYXJlbnRcbl0iLCJyZXF1aXJlIFwiLi4vc2VydmljZXMvc2Vzc2lvbi5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL3R5cGVzLmNvZmZlZVwiXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvc2V0dGluZ3MuY29mZmVlXCJcbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9hbm5vdGF0aW9ucy5jb2ZmZWVcIlxuXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuZGlyZWN0aXZlLmNvZGVFZGl0b3JcIiwgW1xuICBcInBsdW5rZXIuc2VydmljZS5zZXNzaW9uXCJcbiAgXCJwbHVua2VyLnNlcnZpY2UudHlwZXNcIlxuICBcInBsdW5rZXIuc2VydmljZS5zZXR0aW5nc1wiXG4gIFwicGx1bmtlci5zZXJ2aWNlLmFubm90YXRpb25zXCJcbl1cblxubW9kdWxlLmRpcmVjdGl2ZSBcImNvZGVFZGl0b3JcIiwgWyBcIiRyb290U2NvcGVcIiwgXCIkdGltZW91dFwiLCBcInNlc3Npb25cIiwgXCJ0eXBlc1wiLCBcInNldHRpbmdzXCIsIFwiYW5ub3RhdGlvbnNcIiwgKCRyb290U2NvcGUsICR0aW1lb3V0LCBzZXNzaW9uLCB0eXBlcywgc2V0dGluZ3MsIGFubm90YXRpb25zKSAtPlxuICBBY2VFZGl0b3IgPSBhY2UucmVxdWlyZShcImFjZS9lZGl0b3JcIikuRWRpdG9yXG4gIFJlbmRlcmVyID0gYWNlLnJlcXVpcmUoXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiKS5WaXJ0dWFsUmVuZGVyZXJcbiAgRWRpdFNlc3Npb24gPSBhY2UucmVxdWlyZShcImFjZS9lZGl0X3Nlc3Npb25cIikuRWRpdFNlc3Npb25cbiAgVW5kb01hbmFnZXIgPSBhY2UucmVxdWlyZShcImFjZS91bmRvbWFuYWdlclwiKS5VbmRvTWFuYWdlclxuICBSYW5nZSA9IGFjZS5yZXF1aXJlKFwiYWNlL3JhbmdlXCIpLlJhbmdlXG4gIFxuICBjb25maWcgPSBhY2UucmVxdWlyZShcImFjZS9jb25maWdcIilcbiAgXG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHNjb3BlOlxuICAgIGFjdGl2ZTogXCI9XCJcbiAgdGVtcGxhdGU6IFwiXCJcIlxuICAgIDxkaXYgY2xhc3M9XCJjb2RlLWVkaXRvclwiPlxuICAgIDwvZGl2PlxuICBcIlwiXCJcbiAgbGluazogKCRzY29wZSwgJGVsLCBhdHRycykgLT5cbiAgICBlZGl0b3IgPSBuZXcgQWNlRWRpdG9yKG5ldyBSZW5kZXJlcigkZWxbMF0sIFwiYWNlL3RoZW1lLyN7c2V0dGluZ3MuZWRpdG9yLnRoZW1lfVwiKSlcbiAgICBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcImNvZGUtZWRpdG9yXCIpXG4gICAgc25pcHBldE1hbmFnZXIgPSBudWxsXG4gICAgYnVmZmVycyA9IFtdXG4gICAgXG4gICAgYWNlLmNvbmZpZy5sb2FkTW9kdWxlIFwiYWNlL2V4dC9sYW5ndWFnZV90b29sc1wiLCAtPlxuICAgICAgZWRpdG9yLnNldE9wdGlvbnNcbiAgICAgICAgZW5hYmxlQmFzaWNBdXRvY29tcGxldGlvbjogdHJ1ZVxuICAgICAgICBlbmFibGVTbmlwcGV0czogdHJ1ZVxuICBcbiAgICAgIHNuaXBwZXRNYW5hZ2VyID0gYWNlLnJlcXVpcmUoXCJhY2Uvc25pcHBldHNcIikuc25pcHBldE1hbmFnZXJcbiAgICAgIFxuICAgICRzY29wZS4kd2F0Y2ggKCAtPiBzZXR0aW5ncy5lZGl0b3IudGhlbWUgKSwgKHRoZW1lKSAtPlxuICAgICAgZWRpdG9yLnNldFRoZW1lKFwiYWNlL3RoZW1lLyN7dGhlbWV9XCIpIGlmIHRoZW1lXG4gICAgXG5cbiAgICBndWVzc01vZGUgPSAoZmlsZW5hbWUpIC0+IFwiYWNlL21vZGUvXCIgKyB0eXBlcy5nZXRCeUZpbGVuYW1lKGZpbGVuYW1lKS5uYW1lXG4gICAgXG4gICAgYWN0aXZhdGVCdWZmZXIgPSAoaW5kZXgpIC0+XG4gICAgICBlZGl0b3Iuc2V0U2Vzc2lvbihidWZmZXJzW2luZGV4XSlcbiAgICAgIGVkaXRvci5mb2N1cygpXG4gICAgXG4gICAgbW92ZUN1cnNvciA9IChvZmZzZXQpIC0+XG4gICAgICBkb2MgPSBlZGl0b3Iuc2Vzc2lvbi5kb2NcbiAgICAgIGVkaXRvci5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihkb2MuaW5kZXhUb1Bvc2l0aW9uKG9mZnNldCkpXG4gICAgXG4gICAgYWRkQWNlU2Vzc2lvbiA9IChpbmRleCwgZmlsZSkgLT5cbiAgICAgIGFjZVNlc3Npb24gPSBuZXcgRWRpdFNlc3Npb24oZmlsZS5jb250ZW50IG9yIFwiXCIpXG4gICAgICBhY2VTZXNzaW9uLnNldFVuZG9NYW5hZ2VyKG5ldyBVbmRvTWFuYWdlcigpKVxuICAgICAgYWNlU2Vzc2lvbi5zZXRVc2VXb3JrZXIodHJ1ZSlcbiAgICAgIGFjZVNlc3Npb24uc2V0VGFiU2l6ZShzZXR0aW5ncy5lZGl0b3IudGFiX3NpemUpXG4gICAgICBhY2VTZXNzaW9uLnNldFVzZVdyYXBNb2RlKCEhc2V0dGluZ3MuZWRpdG9yLndyYXAuZW5hYmxlZClcbiAgICAgIGFjZVNlc3Npb24uc2V0V3JhcExpbWl0UmFuZ2Uoc2V0dGluZ3MuZWRpdG9yLndyYXAucmFuZ2UubWluLCBzZXR0aW5ncy5lZGl0b3Iud3JhcC5yYW5nZS5tYXgpXG4gICAgICBhY2VTZXNzaW9uLnNldE1vZGUoZ3Vlc3NNb2RlKGZpbGUuZmlsZW5hbWUpKVxuXG4gICAgICBcbiAgICAgIGRvYyA9IGFjZVNlc3Npb24uZ2V0RG9jdW1lbnQoKVxuICAgICAgICAgIFxuICAgICAgaGFuZGxlQ2hhbmdlRXZlbnQgPSAoZSkgLT5cbiAgICAgICAgdW5sZXNzICRyb290U2NvcGUuJCRwaGFzZSB0aGVuICRzY29wZS4kYXBwbHkgLT5cbiAgICAgICAgICBubCA9IGRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKClcbiAgICAgICAgICBcbiAgICAgICAgICBzd2l0Y2ggZS5kYXRhLmFjdGlvblxuICAgICAgICAgICAgd2hlbiBcImluc2VydFRleHRcIiB0aGVuIGNsaWVudC50ZXh0SW5zZXJ0IGZpbGUuZmlsZW5hbWUsIGRvYy5wb3NpdGlvblRvSW5kZXgoZS5kYXRhLnJhbmdlLnN0YXJ0KSwgZS5kYXRhLnRleHRcbiAgICAgICAgICAgIHdoZW4gXCJpbnNlcnRMaW5lc1wiIHRoZW4gY2xpZW50LnRleHRJbnNlcnQgZmlsZS5maWxlbmFtZSwgZG9jLnBvc2l0aW9uVG9JbmRleChlLmRhdGEucmFuZ2Uuc3RhcnQpLCBlLmRhdGEubGluZXMuam9pbihubCkgKyBubFxuICAgICAgICAgICAgd2hlbiBcInJlbW92ZVRleHRcIiB0aGVuIGNsaWVudC50ZXh0UmVtb3ZlIGZpbGUuZmlsZW5hbWUsIGRvYy5wb3NpdGlvblRvSW5kZXgoZS5kYXRhLnJhbmdlLnN0YXJ0KSwgZS5kYXRhLnRleHRcbiAgICAgICAgICAgIHdoZW4gXCJyZW1vdmVMaW5lc1wiIHRoZW4gY2xpZW50LnRleHRSZW1vdmUgZmlsZS5maWxlbmFtZSwgZG9jLnBvc2l0aW9uVG9JbmRleChlLmRhdGEucmFuZ2Uuc3RhcnQpLCBlLmRhdGEubGluZXMuam9pbihubCkgKyBubFxuICAgICAgXG4gICAgICBoYW5kbGVDaGFuZ2VBbm5vdGF0aW9uRXZlbnQgPSAoZSkgLT5cbiAgICAgICAgdW5sZXNzICRyb290U2NvcGUuJCRwaGFzZSB0aGVuICRzY29wZS4kYXBwbHkgLT5cbiAgICAgICAgICBpZiAoaWR4ID0gY2xpZW50LmdldEZpbGVJbmRleChmaWxlLmZpbGVuYW1lKSkgPCAwXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJzIGFuZCBzZXNzaW9uIGFyZSBvdXQgb2Ygc3luYyBmb3I6ICN7ZmlsZS5maWxlbmFtZX1cIilcbiAgICAgICAgICBcbiAgICAgICAgICBhbm5vdGF0aW9ucy51cGRhdGUoZmlsZS5maWxlbmFtZSwgYWNlU2Vzc2lvbi5nZXRBbm5vdGF0aW9ucygpKVxuICAgICAgICAgIFxuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCBcInVwZGF0ZUFubm90YXRpbm9zXCIsIGZpbGUsIGFjZVNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKVxuXG4gICAgICBidWZmZXJzW2luZGV4XSA9IGFjZVNlc3Npb25cbiAgICAgIFxuICAgICAgYW5ub3RhdGlvbnMudXBkYXRlIGZpbGUuZmlsZW5hbWUsIGFjZVNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKVxuXG4gICAgICBhY2VTZXNzaW9uLm9uIFwiY2hhbmdlXCIsIGhhbmRsZUNoYW5nZUV2ZW50XG4gICAgICBhY2VTZXNzaW9uLm9uIFwiY2hhbmdlQW5ub3RhdGlvblwiLCBoYW5kbGVDaGFuZ2VBbm5vdGF0aW9uRXZlbnRcblxuICAgICAgYWNlU2Vzc2lvbi5kZXN0cm95ID0gLT5cbiAgICAgICAgYWNlU2Vzc2lvbi5vZmYgXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlRXZlbnRcbiAgICAgICAgYWNlU2Vzc2lvbi5vZmYgXCJjaGFuZ2VBbm5vdGF0aW9uXCIsIGhhbmRsZUNoYW5nZUFubm90YXRpb25FdmVudFxuXG4gICAgcmVtb3ZlQWNlU2Vzc2lvbiA9IChpbmRleCkgLT5cbiAgICAgIHVubGVzcyBidWZmZXJzW2luZGV4XSB0aGVuIGRlYnVnZ2VyXG4gICAgICBidWZmZXJzW2luZGV4XS5kZXN0cm95KClcbiAgICAgIGJ1ZmZlcnMuc3BsaWNlIGluZGV4LCAxXG4gICAgICBcbiAgICAgIGlmIGZpbGUgPSBjbGllbnQuZ2V0RmlsZUJ5SW5kZXgoaW5kZXgpXG4gICAgICAgIGFubm90YXRpb25zLnJlbW92ZShmaWxlLmZpbGVuYW1lKVxuICAgICAgXG4gICAgcmVzZXQgPSAoc25hcHNob3QpIC0+XG4gICAgICByZW1vdmVBY2VTZXNzaW9uKGlkeCkgZm9yIGlkeCBpbiBbYnVmZmVycy5sZW5ndGggLSAxLi4wXSBieSAtMVxuICAgICAgYWRkQWNlU2Vzc2lvbihpZHgsIGZpbGUpIGZvciBmaWxlLCBpZHggaW4gc25hcHNob3QuZmlsZXNcbiAgICAgIFxuICAgICAgYWN0aXZhdGVCdWZmZXIoc25hcHNob3QuY3Vyc29yLmZpbGVJbmRleClcbiAgICBcbiAgICBjaGFuZ2VTZXNzaW9uTW9kZSA9IChpbmRleCwgZmlsZW5hbWUpIC0+XG4gICAgICBidWZmZXIuc2V0TW9kZShndWVzc01vZGUoZmlsZW5hbWUpKSBpZiBidWZmZXIgPSBidWZmZXJzW2luZGV4XVxuICAgICAgICBcbiAgICBjbGllbnQub24gXCJyZXNldFwiLCAoZSwgc25hcHNob3QpIC0+IHJlc2V0KGUuc25hcHNob3QpXG4gICAgXG4gICAgY2xpZW50Lm9uIFwiY3Vyc29yU2V0RmlsZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBhY3RpdmF0ZUJ1ZmZlcihlLmluZGV4KVxuICAgIFxuICAgIGNsaWVudC5vbiBcImN1cnNvclNldE9mZnNldFwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBtb3ZlQ3Vyc29yKGUub2Zmc2V0KVxuICAgICAgXG4gICAgY2xpZW50Lm9uIFwiZmlsZUNyZWF0ZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBhZGRBY2VTZXNzaW9uKGUuaW5kZXgsIHNuYXBzaG90LmZpbGVzW2UuaW5kZXhdKVxuICAgIFxuICAgIGNsaWVudC5vbiBcImZpbGVSZW1vdmVcIiwgKGUsIHNuYXBzaG90KSAtPlxuICAgICAgcmVtb3ZlQWNlU2Vzc2lvbihlLmluZGV4KVxuICAgICAgYW5ub3RhdGlvbnMucmVtb3ZlKGUuZmlsZW5hbWUpXG4gICAgXG4gICAgY2xpZW50Lm9uIFwiZmlsZVJlbmFtZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBjaGFuZ2VTZXNzaW9uTW9kZShlLmluZGV4LCBlLmZpbGVuYW1lKVxuICAgICAgYW5ub3RhdGlvbnMucmVuYW1lKGUuZmlsZW5hbWUsIGUub2xkX2ZpbGVuYW1lKVxuICAgIFxuICAgIGNsaWVudC5vbiBcInRleHRJbnNlcnRcIiwgKGUsIHNuYXBzaG90KSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgdGV4dEluc2VydCBldmVudCBmb3IgYSBmaWxlIG5vdCBiZWluZyB0cmFja2VkXCIpIHVubGVzcyBhY2VTZXNzaW9uID0gYnVmZmVyc1tlLmluZGV4XVxuICAgICAgYWNlU2Vzc2lvbi5kb2MuaW5zZXJ0IGFjZVNlc3Npb24uZG9jLmluZGV4VG9Qb3NpdGlvbihlLm9mZnNldCksIGUudGV4dFxuICAgICAgXG4gICAgY2xpZW50Lm9uIFwidGV4dFJlbW92ZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlZCB0ZXh0SW5zZXJ0IGV2ZW50IGZvciBhIGZpbGUgbm90IGJlaW5nIHRyYWNrZWRcIikgdW5sZXNzIGFjZVNlc3Npb24gPSBidWZmZXJzW2UuaW5kZXhdXG4gICAgICBhY2VTZXNzaW9uLmRvYy5yZW1vdmUgUmFuZ2UuZnJvbVBvaW50cyhhY2VTZXNzaW9uLmRvYy5pbmRleFRvUG9zaXRpb24oZS5vZmZzZXQpLCBhY2VTZXNzaW9uLmRvYy5pbmRleFRvUG9zaXRpb24oZS5vZmZzZXQgKyBlLnRleHQubGVuZ3RoKSlcbiAgICBcbiAgICByZXNldChjbGllbnQuZ2V0U25hcHNob3QoKSlcbiAgICBhY3RpdmF0ZUJ1ZmZlcihjbGllbnQuZ2V0Q3Vyc29yRmlsZUluZGV4KCkpXG4gICAgbW92ZUN1cnNvcihjbGllbnQuZ2V0Q3Vyc29yVGV4dE9mZnNldCgpKVxuICAgIFxuICAgICMgUmVzaXplIHRoZSBhY2UgY29tcG9uZW50IHdoZW5ldmVyIHdlIGdldCBhIHJlZmxvdyBldmVudCBmcm9tIGJvcmRlci1sYXlvdXRcbiAgICAkc2NvcGUuJG9uIFwiYm9yZGVyLWxheW91dC1yZWZsb3dcIiwgLT4gZWRpdG9yLnJlc2l6ZSgpXG5cbiAgICAkdGltZW91dCAtPlxuICAgICAgZWRpdG9yLnJlc2l6ZSgpXG4gICAgLCAxMDBcblxuXSIsImdlbmlkID0gcmVxdWlyZShcImdlbmlkXCIpXG5kZWJvdW5jZSA9IHJlcXVpcmUoXCJsb2Rhc2guZGVib3VuY2VcIilcblxucmVxdWlyZSBcIi4uLy4uL3ZlbmRvci9vcGVyYXRpdmUuanNcIlxuXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvc2Vzc2lvbi5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL3R5cGVzLmNvZmZlZVwiXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvdXJsLmNvZmZlZVwiXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvc2V0dGluZ3MuY29mZmVlXCJcbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9hbm5vdGF0aW9ucy5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL2xheW91dC5jb2ZmZWVcIlxuXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuZGlyZWN0aXZlLnByZXZpZXdlclwiLCBbXG4gIFwicGx1bmtlci5zZXJ2aWNlLnNlc3Npb25cIlxuICBcInBsdW5rZXIuc2VydmljZS51cmxcIlxuICBcInBsdW5rZXIuc2VydmljZS5zZXR0aW5nc1wiXG4gIFwicGx1bmtlci5zZXJ2aWNlLmFubm90YXRpb25zXCJcbiAgXCJwbHVua2VyLnNlcnZpY2UubGF5b3V0XCJcbl1cblxubW9kdWxlLmRpcmVjdGl2ZSBcInByZXZpZXdlclwiLCBbIFwiJHRpbWVvdXRcIiwgXCJzZXNzaW9uXCIsIFwidXJsXCIsIFwic2V0dGluZ3NcIiwgXCJhbm5vdGF0aW9uc1wiLCBcImxheW91dFwiLCAoJHRpbWVvdXQsIHNlc3Npb24sIHVybCwgc2V0dGluZ3MsIGFubm90YXRpb25zLCBsYXlvdXQpIC0+XG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHNjb3BlOlxuICAgIHNlc3Npb246IFwiPVwiXG4gIHRlbXBsYXRlOiBcIlwiXCJcbiAgICA8ZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBsdW5rZXItcHJldmlldy1jb250YWluZXJcIiBuZy1jbGFzcz1cInttZXNzYWdlOiBtZXNzYWdlfVwiPlxuICAgICAgICA8aWZyYW1lIGlkPVwicGx1bmtlclByZXZpZXdUYXJnZXRcIiBuYW1lPVwicGx1bmtlclByZXZpZXdUYXJnZXRcIiBzcmM9XCJhYm91dDpibGFua1wiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBsdW5rZXItcHJldmlldy1tZXNzYWdlIGFsZXJ0IGFsZXJ0LWRhbmdlclwiIG5nLXNob3c9XCJtZXNzYWdlXCI+XG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBuZy1jbGljaz1cIm1lc3NhZ2U9JydcIiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9idXR0b24+XG4gICAgICAgIDxzcGFuIG5nLWJpbmQ9XCJtZXNzYWdlXCI+PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIFwiXCJcIlxuICBsaW5rOiAoJHNjb3BlLCAkZWwsIGF0dHJzKSAtPlxuICAgICRzY29wZS5wcmV2aWV3VXJsIHx8PSBcIiN7dXJsLnJ1bn0vI3tnZW5pZCgpfS9cIlxuICAgIFxuICAgIGlmcmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbHVua2VyUHJldmlld1RhcmdldFwiKVxuICAgIFxuICAgIGNsaWVudCA9IHNlc3Npb24uY3JlYXRlQ2xpZW50KFwicHJldmlld2VyXCIpXG4gICAgZmlyc3RPcGVuID0gdHJ1ZVxuICAgIFxuICAgIHJlZnJlc2ggPSAoc25hcHNob3QpIC0+XG4gICAgICByZXR1cm4gaWYgbGF5b3V0LmN1cnJlbnQucHJldmlldy5jbG9zZWRcbiAgICAgIFxuICAgICAgaWYgZmlsZW5hbWUgPSBhbm5vdGF0aW9ucy5oYXNFcnJvcigpXG4gICAgICAgICRzY29wZS5tZXNzYWdlID0gXCJQcmV2aWV3IGhhcyBub3QgYmVlbiB1cGRhdGVkIGR1ZSB0byBzeW50YXggZXJyb3JzIGluICN7ZmlsZW5hbWV9XCJcbiAgICAgICAgcmV0dXJuXG4gICAgICBlbHNlXG4gICAgICAgICRzY29wZS5tZXNzYWdlID0gXCJcIlxuICAgICAgXG4gICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIilcbiAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgICBmb3JtLnNldEF0dHJpYnV0ZSBcIm1ldGhvZFwiLCBcInBvc3RcIlxuICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUgXCJhY3Rpb25cIiwgJHNjb3BlLnByZXZpZXdVcmxcbiAgICAgIGZvcm0uc2V0QXR0cmlidXRlIFwidGFyZ2V0XCIsIFwicGx1bmtlclByZXZpZXdUYXJnZXRcIlxuICAgICAgXG4gICAgICBmb3IgZmlsZSBpbiBzbmFwc2hvdC5maWxlc1xuICAgICAgICBmaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKVxuICAgICAgICBmaWVsZC5zZXRBdHRyaWJ1dGUgXCJ0eXBlXCIsIFwiaGlkZGVuXCJcbiAgICAgICAgZmllbGQuc2V0QXR0cmlidXRlIFwibmFtZVwiLCBcImZpbGVzWyN7ZmlsZS5maWxlbmFtZX1dW2NvbnRlbnRdXCJcbiAgICAgICAgZmllbGQuc2V0QXR0cmlidXRlIFwidmFsdWVcIiwgZmlsZS5jb250ZW50XG4gICAgICAgIFxuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGZpZWxkKVxuICAgICAgXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pXG4gICAgICBcbiAgICAgIGZvcm0uc3VibWl0KClcbiAgICAgIFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChmb3JtKVxuICAgIFxuICAgIGFwcGx5UmVmcmVzaCA9IC0+ICRzY29wZS4kYXBwbHkgLT4gcmVmcmVzaChjbGllbnQuZ2V0U25hcHNob3QoKSlcbiAgICBkZWJvdW5jZWRBcHBseVJlZnJlc2ggPSBkZWJvdW5jZSBhcHBseVJlZnJlc2gsIHNldHRpbmdzLnByZXZpZXdlci5kZWxheVxuICAgIFxuICAgICRzY29wZS4kd2F0Y2ggKCAtPiBzZXR0aW5ncy5wcmV2aWV3ZXIuZGVsYXkpLCAoZGVsYXksIG9sZERlbGF5KSAtPlxuICAgICAgaWYgZGVsYXkgIT0gb2xkRGVsYXlcbiAgICAgICAgZGVib3VuY2VkQXBwbHlSZWZyZXNoID0gZGVib3VuY2UgZGVib3VuY2VkQXBwbHlSZWZyZXNoLCBkZWxheVxuXG4gICAgJHNjb3BlLiR3YXRjaCAoIC0+IGxheW91dC5jdXJyZW50LnByZXZpZXcuY2xvc2VkKSwgKGNsb3NlZCwgd2FzQ2xvc2VkKSAtPlxuICAgICAgaWYgY2xvc2VkXG4gICAgICAgIGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cubG9jYXRpb24gPSBcImFib3V0OmJsYW5rXCJcbiAgICAgIGVsc2UgaWYgZmlyc3RPcGVuIG9yIHdhc0Nsb3NlZFxuICAgICAgICByZWZyZXNoKGNsaWVudC5nZXRTbmFwc2hvdCgpKVxuICAgICAgXG4gICAgICBmaXJzdE9wZW4gPSBmYWxzZVxuICAgIFxuICAgIGNsaWVudC5vbiBcInJlc2V0XCIsIGRlYm91bmNlZEFwcGx5UmVmcmVzaFxuXG4gICAgY2xpZW50Lm9uIFwiZmlsZUNyZWF0ZVwiLCBkZWJvdW5jZWRBcHBseVJlZnJlc2hcbiAgICBjbGllbnQub24gXCJmaWxlUmVuYW1lXCIsIGRlYm91bmNlZEFwcGx5UmVmcmVzaFxuICAgIGNsaWVudC5vbiBcImZpbGVSZW1vdmVcIiwgZGVib3VuY2VkQXBwbHlSZWZyZXNoXG5cbiAgICBjbGllbnQub24gXCJ0ZXh0SW5zZXJ0XCIsIGRlYm91bmNlZEFwcGx5UmVmcmVzaFxuICAgIGNsaWVudC5vbiBcInRleHRSZW1vdmVcIiwgZGVib3VuY2VkQXBwbHlSZWZyZXNoXG4gICAgXG4gICAgJHNjb3BlLiRvbiBcIiRkZXN0cm95XCIsIC0+XG4gICAgICBjbGllbnQub2ZmIFwicmVzZXRcIiwgZGVib3VuY2VkQXBwbHlSZWZyZXNoXG4gIFxuICAgICAgY2xpZW50Lm9mZiBcImZpbGVDcmVhdGVcIiwgZGVib3VuY2VkQXBwbHlSZWZyZXNoXG4gICAgICBjbGllbnQub2ZmIFwiZmlsZVJlbmFtZVwiLCBkZWJvdW5jZWRBcHBseVJlZnJlc2hcbiAgICAgIGNsaWVudC5vZmYgXCJmaWxlUmVtb3ZlXCIsIGRlYm91bmNlZEFwcGx5UmVmcmVzaFxuICBcbiAgICAgIGNsaWVudC5vZmYgXCJ0ZXh0SW5zZXJ0XCIsIGRlYm91bmNlZEFwcGx5UmVmcmVzaFxuICAgICAgY2xpZW50Lm9mZiBcInRleHRSZW1vdmVcIiwgZGVib3VuY2VkQXBwbHlSZWZyZXNoXG5dIiwicmVxdWlyZSBcIi4uLy4uL3ZlbmRvci9hbmd1bGFyLXVpL3VpLWJvb3RzdHJhcFwiXG5cbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9ub3RpZmllci5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL2xheW91dC5jb2ZmZWVcIlxuXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuZGlyZWN0aXZlLnRvb2xiYXJcIiwgW1xuICBcInVpLmJvb3RzdHJhcFwiXG4gIFxuICBcInBsdW5rZXIuc2VydmljZS5ub3RpZmllclwiXG4gIFwicGx1bmtlci5zZXJ2aWNlLmxheW91dFwiXG5dXG5cbm1vZHVsZS5kaXJlY3RpdmUgXCJwbHVua2VyVG9vbGJhclwiLCBbIFwiJHN0YXRlXCIsIFwic2Vzc2lvblwiLCBcIm5vdGlmaWVyXCIsIFwibGF5b3V0XCIsICgkc3RhdGUsIHNlc3Npb24sIG5vdGlmaWVyLCBsYXlvdXQpIC0+XG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHNjb3BlOiB0cnVlXG4gIHRlbXBsYXRlOiBcIlwiXCJcbiAgICA8ZGl2IGNsYXNzPVwicGx1bmtlci1lZGl0b3ItdG9vbGJhclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInB1bGwtbGVmdFwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tcHJpbWFyeVwiIG5nLWNsaWNrPVwic2F2ZSgpXCI+XG4gICAgICAgICAgU2F2ZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzXCIgdWktc3JlZj1cImVkaXRvci5ibGFua1wiPlxuICAgICAgICAgIE5ld1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1pbmZvXCIgbmctY2xhc3M9XCJ7YWN0aXZlOiAhbGF5b3V0LmN1cnJlbnQucHJldmlldy5jbG9zZWR9XCIgbmctY2xpY2s9XCJsYXlvdXQuY3VycmVudC5wcmV2aWV3LmNsb3NlZCA9ICEhIWxheW91dC5jdXJyZW50LnByZXZpZXcuY2xvc2VkXCI+XG4gICAgICAgICAgUHJldmlld1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInB1bGwtcmlnaHRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tc21cIiBuZy1jb250cm9sbGVyPVwiTGF5b3V0Q29udHJvbGxlclwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJsYXlvdXQuc2V0TGF5b3V0KCRpbmRleClcIiBuZy1yZXBlYXQ9XCJwcmVzZXQgaW4gbGF5b3V0LnByZXNldHNcIiBuZy1iaW5kPVwiJGluZGV4XCIgdG9vbHRpcD1cInt7cHJlc2V0Lm5hbWV9fVwiIHRvb2x0aXAtYXBwZW5kLXRvLWJvZHk9XCJ0cnVlXCIgdG9vbHRpcC1wbGFjZW1lbnQ9XCJib3R0b21cIj48L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgXCJcIlwiXG4gIFxuICBsaW5rOiAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSAtPlxuICAgIGNsaWVudCA9IHNlc3Npb24uY3JlYXRlQ2xpZW50KFwiZGlyZWN0aXZlLnRvb2xiYXJcIilcbiAgICBcbiAgICAkc2NvcGUuc2F2ZSA9IC0+XG4gICAgICBub3RpZmllci53YXJuIFwiU2F2ZSBub3QgaW1wbGVtZW50ZWQuLi4geWV0XCJcbl0iLCJtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS5hbm5vdGF0aW9uc1wiLCBbXVxuXG5tb2R1bGUuZmFjdG9yeSBcImFubm90YXRpb25zXCIsIC0+XG4gIGFubm90YXRpb25zOiB7fVxuICBcbiAgdXBkYXRlOiAoZmlsZW5hbWUsIGFubm90YXRpb25zID0gW10pIC0+XG4gICAgYW5ndWxhci5jb3B5IGFubm90YXRpb25zLCAoQGFubm90YXRpb25zW2ZpbGVuYW1lXSB8fD0gW10pXG4gIFxuICByZW5hbWU6IChvbGRfZmlsZW5hbWUsIG5ld19maWxlbmFtZSkgLT5cbiAgICBAYW5ub3RhdGlvbnNbbmV3X2ZpbGVuYW1lXSA9IEBhbm5vdGF0aW9uc1tvbGRfZmlsZW5hbWVdIG9yIFtdXG4gICAgZGVsZXRlIEBhbm5vdGF0aW9uc1tvbGRfZmlsZW5hbWVdXG4gIFxuICByZW1vdmU6IChmaWxlbmFtZSkgLT5cbiAgICBkZWxldGUgQGFubm90YXRpb25zW2ZpbGVuYW1lXVxuICAgIFxuICBoYXNFcnJvcjogLT5cbiAgICBmb3IgZmlsZW5hbWUsIGFubm90YXRpb25zIG9mIEBhbm5vdGF0aW9uc1xuICAgICAgXG4gICAgICByZXR1cm4gZmlsZW5hbWUgZm9yIGFubm90YXRpb24gaW4gYW5ub3RhdGlvbnMgd2hlbiBhbm5vdGF0aW9uLnR5cGUgaXMgXCJlcnJvclwiXG4gICAgXG4gICAgcmV0dXJuIGZhbHNlIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UuYmFzZVBsdW5rXCIsIFtdXG5cbm1vZHVsZS52YWx1ZSBcImJhc2VQbHVua1wiLFxuICBmaWxlczogW1xuICAgIGZpbGVuYW1lOiBcImluZGV4Lmh0bWxcIlxuICAgIGNvbnRlbnQ6IFwiXCJcIlxuICAgICAgPCFkb2N0eXBlIGh0bWw+XG4gICAgICA8aHRtbCBuZy1hcHA9XCJwbHVua2VyXCIgPlxuICAgICAgPGhlYWQ+XG4gICAgICAgIDxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuICAgICAgICA8dGl0bGU+QW5ndWxhckpTIFBsdW5rZXI8L3RpdGxlPlxuICAgICAgICA8c2NyaXB0PmRvY3VtZW50LndyaXRlKCc8YmFzZSBocmVmPVwiJyArIGRvY3VtZW50LmxvY2F0aW9uICsgJ1wiIC8+Jyk7PC9zY3JpcHQ+XG4gICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwic3R5bGUuY3NzXCI+XG4gICAgICAgIDxzY3JpcHQgZGF0YS1yZXF1aXJlPVwiYW5ndWxhci5qc0AxLjEueFwiIHNyYz1cImh0dHA6Ly9jb2RlLmFuZ3VsYXJqcy5vcmcvMS4xLjQvYW5ndWxhci5qc1wiPjwvc2NyaXB0PlxuICAgICAgICA8c2NyaXB0IHNyYz1cImFwcC5qc1wiPjwvc2NyaXB0PlxuICAgICAgPC9oZWFkPlxuICAgICAgPGJvZHkgbmctY29udHJvbGxlcj1cIk1haW5DdHJsXCI+XG4gICAgICAgIDxwPkhlbGxvIHt7bmFtZX19ITwvcD5cbiAgICAgIDwvYm9keT5cbiAgICAgIDwvaHRtbD4gXG4gICAgXCJcIlwiXG4gICxcbiAgICBmaWxlbmFtZTogXCJhcHAuanNcIlxuICAgIGNvbnRlbnQ6IFwiXCJcIlxuICAgICAgdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdwbHVua2VyJywgW10pO1xuICAgICAgIFxuICAgICAgYXBwLmNvbnRyb2xsZXIoJ01haW5DdHJsJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICRzY29wZS5uYW1lID0gJ1dvcmxkJztcbiAgICAgIH0pO1xuICAgIFwiXCJcIlxuICAsXG4gICAgZmlsZW5hbWU6IFwic3R5bGUuY3NzXCJcbiAgICBjb250ZW50OiBcIlwiXCJcbiAgICAgIHAge1xuICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgfVxuICAgIFwiXCJcIlxuICBdIiwiYnJvd3NlcmNoYW5uZWwgPSByZXF1aXJlIFwiLi4vLi4vdmVuZG9yL3NoYXJlL2Jjc29ja2V0LXVuY29tcHJlc3NlZC5qc1wiXG5yZXF1aXJlIFwiLi4vLi4vdmVuZG9yL3NoYXJlL3NoYXJlLnVuY29tcHJlc3NlZC5qc1wiXG5cbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9zZXNzaW9uLmNvZmZlZVwiXG5cblxubW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UuY29sbGFiXCIsIFtcbiAgXCJwbHVua2VyLnNlcnZpY2Uuc2Vzc2lvblwiXG5dXG5cbm1vZHVsZS5mYWN0b3J5IFwiY29sbGFiXCIsIFsgXCIkcm9vdFNjb3BlXCIsIFwiJHFcIiwgXCJzZXNzaW9uXCIsICgkcm9vdFNjb3BlLCAkcSwgc2Vzc2lvbikgLT5cbiAgY29uc29sZS5sb2cgXCJCcm93c2VyY2hhbm5lbFwiLCBicm93c2VyY2hhbm5lbFxuICBcbiAgc29ja2V0ID0gYnJvd3NlcmNoYW5uZWwuQkNTb2NrZXQobnVsbCwge3JlY29ubmVjdDogdHJ1ZX0pXG4gIHNoYXJlID0gbmV3IHdpbmRvdy5zaGFyZWpzLkNvbm5lY3Rpb24oc29ja2V0KVxuICBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcInNoYXJlXCIpXG5cbiAgY29ubmVjdDogKHNlc3Npb25JZCkgLT5cbiAgICBkZmQgPSAkcS5kZWZlcigpXG4gICAgZG9jID0gc2hhcmUuZ2V0T3JDcmVhdGUoXCJqc29uX3Rlc3RcIiwgc2Vzc2lvbklkKVxuICAgIFxuICAgIGRvYy5zdWJzY3JpYmUoKVxuICAgIFxuICAgIGRvYy53aGVuUmVhZHkgLT4gJHJvb3RTY29wZS4kYXBwbHkgLT4gXG4gICAgICB1bmxlc3MgZG9jLnR5cGVcbiAgICAgICAgZG9jLmNyZWF0ZSBcImpzb24wXCIsIHNuYXBzaG90ID0gY2xpZW50LmdldFNuYXBzaG90KCksIC0+XG4gICAgICAgICAgZGZkLnJlc29sdmUgc25hcHNob3RcbiAgICAgIGVsc2VcbiAgICAgICAgY2xpZW50LnJlc2V0IHNuYXBzaG90ID0gZG9jLmdldFNuYXBzaG90KClcbiAgICAgICAgZGZkLnJlc29sdmUgc25hcHNob3RcbiAgICAgICAgXG4gICAgICBjbGllbnQub24gXCJyZW1vdGVPcFwiLCAoZSkgLT5cbiAgICAgICAgXG4gICAgICAgIGRvYy5zdWJtaXRPcCBlLm9wXG4gICAgICAgIFxuICAgIGRvYy5vbiBcIm9wXCIsIChvcCkgLT5cbiAgICAgIHVubGVzcyAkcm9vdFNjb3BlLiQkcGhhc2UgdGhlbiAkcm9vdFNjb3BlLiRhcHBseSAtPlxuICAgICAgICBjb25zb2xlLmxvZyBcIlJlbW90ZW9wXCIsIGFyZ3VtZW50cy4uLlxuICAgICAgICBjbGllbnQuX2FwcGx5T3BzKG9wKVxuICAgIFxuICAgIGRmZC5wcm9taXNlXG4gICAgXG5cbl0iLCJtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS5kaXNhYmxlclwiLCBbXVxuXG5tb2R1bGUuZGlyZWN0aXZlIFwicGx1bmtlckRpc2FibGVyXCIsIFtcImRpc2FibGVyXCIsIChkaXNhYmxlcikgLT5cbiAgbGluazogKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykgLT5cbiAgICBtYXNrID0gYW5ndWxhci5lbGVtZW50IFwiXCJcIlxuICAgICAgPGRpdiBjbGFzcz1cInBsdW5rZXItZGlzYWJsZXJcIj48L2Rpdj5cbiAgICBcIlwiXCJcblxuICAgICRzY29wZS4kd2F0Y2ggKCAtPiBkaXNhYmxlci5zdGF0ZVskYXR0cnMucGx1bmtlckRpc2FibGVyXSksIChzdGF0ZSwgcHJldikgLT5cbiAgICAgIGlmIHN0YXRlIHRoZW4gJGVsZW1lbnQuYXBwZW5kKG1hc2spXG4gICAgICBlbHNlIG1hc2sucmVtb3ZlKClcbl1cblxubW9kdWxlLnNlcnZpY2UgXCJkaXNhYmxlclwiLCBbIFwiJHFcIiwgKCRxKSAtPlxuICBxdWV1ZXMgPSB7fVxuICBcbiAgQHN0YXRlID0ge31cbiAgQGVucXVldWUgPSAobmFtZSwgdmFsdWVPclByb21pc2UpIC0+XG4gICAgZGlzYWJsZXIgPSBAXG4gICAgXG4gICAgZGlzYWJsZXIuc3RhdGVbbmFtZV0gPSB0cnVlXG4gICAgJHEud2hlbih2YWx1ZU9yUHJvbWlzZSkuZmluYWxseSAtPlxuICAgICAgZGlzYWJsZXIuc3RhdGVbbmFtZV0gPSBmYWxzZVxuXSIsImRvbWluYXRyaXggPSByZXF1aXJlIFwiLi4vLi4vdmVuZG9yL2RvbWluYXRyaXgvZG9taW5hdHJpeFwiXG5cblxubW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UuaHRtbEZpbGVcIiwgW1xuXVxuXG5tb2R1bGUuZmFjdG9yeSBcImh0bWxGaWxlXCIsIFsgXCIkcVwiLCAoJHEpIC0+XG4gIGNsYXNzIEh0bWxGaWxlXG4gICAgY29uc3RydWN0b3I6IChAbWFya3VwKSAtPlxuICAgICAgQGRvYyA9IHdpbmRvdy5kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIilcbiAgICAgIEBkb2Mub3BlbigpXG4gICAgICBAZG9jLndyaXRlKEBtYXJrdXApXG4gICAgXG4gICAgdG9TdHJpbmc6IC0+IGRvbWluYXRyaXguZG9tVG9IdG1sKEBkb2MpXG4gIFxuICBwYXJzZTogKG1hcmt1cCkgLT4gbmV3IEh0bWxGaWxlKG1hcmt1cClcbiAgdXBkYXRlOiAobWFya3VwKSAtPlxuICAgIGRmZCA9ICRxLmRlZmVyKClcbiAgICBcbiAgICBkZmQucmVzb2x2ZShAcGFyc2UobWFya3VwKS50b1N0cmluZygpKVxuICAgIFxuICAgIGRmZC5wcm9taXNlXG5dIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UubGF5b3V0XCIsIFtcbl1cblxubW9kdWxlLmZhY3RvcnkgXCJsYXlvdXRcIiwgW1wiJHJvb3RTY29wZVwiLCAoJHJvb3RTY29wZSkgLT5cbiAgcHJlc2V0cyA9IFtcbiAgICBuYW1lOiBcIlByZXZpZXcgb24gdGhlIHJpZ2h0XCJcbiAgICBsYXlvdXQ6XG4gICAgICB0b29sYmFyOlxuICAgICAgICBhbmNob3I6IFwibm9ydGhcIlxuICAgICAgICBzaXplOiBcIjQxcHhcIlxuICAgICAgICBvcmRlcjogOVxuICAgICAgcHJldmlldzpcbiAgICAgICAgYW5jaG9yOiBcImVhc3RcIlxuICAgICAgICBvcmRlcjogMFxuICAgICAgICBzaXplOiBcIjUwJiAtIDRweFwiXG4gICAgICAgIGhhbmRsZTogNFxuICAgICAgdGVtcGxhdGVzOlxuICAgICAgICBhbmNob3I6IFwid2VzdFwiXG4gICAgICAgIG9yZGVyOiAyXG4gICAgICAgIHNpemU6IFwiMzAwcHhcIlxuICAsXG4gICAgbmFtZTogXCJQcmV2aWV3IGF0IHRoZSBib3R0b21cIlxuICAgIGxheW91dDpcbiAgICAgIHRvb2xiYXI6XG4gICAgICAgIGFuY2hvcjogXCJub3J0aFwiXG4gICAgICAgIHNpemU6IFwiNDFweFwiXG4gICAgICAgIG9yZGVyOiA5XG4gICAgICBwcmV2aWV3OlxuICAgICAgICBhbmNob3I6IFwic291dGhcIlxuICAgICAgICBvcmRlcjogMlxuICAgICAgICBzaXplOiBcIjQwJSAtIDRweFwiXG4gICAgICAgIGhhbmRsZTogNFxuICAgICAgdGVtcGxhdGVzOlxuICAgICAgICBhbmNob3I6IFwid2VzdFwiXG4gICAgICAgIG9yZGVyOiAyXG4gICAgICAgIHNpemU6IFwiMzAwcHhcIlxuICBdXG4gIFxuICBzZXJ2aWNlID1cbiAgICBjdXJyZW50OiB7fVxuICAgIHByZXNldHM6IHByZXNldHNcbiAgICBpc09wZW46IChwYW5lSWQpIC0+IEBjdXJyZW50Py5sYXlvdXQ/W3BhbmVJZF0ub3BlblxuICAgIHRvZ2dsZTogKHBhbmVJZCkgLT4gQGN1cnJlbnQ/LmxheW91dD9bcGFuZUlkXS5vcGVuID0gIUBjdXJyZW50LmxheW91dFtwYW5lSWRdLm9wZW5cbiAgICAgIFxuICAgIHNldExheW91dDogKGlkeCkgLT5cbiAgICAgIGlmIHByZXNldCA9IHByZXNldHNbaWR4XVxuICAgICAgICBAY3VycmVudFtpdGVtXSA9IGFuZ3VsYXIuZXh0ZW5kKEBjdXJyZW50W2l0ZW1dIG9yIHt9LCBjb25maWcpIGZvciBpdGVtLCBjb25maWcgb2YgcHJlc2V0LmxheW91dFxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QgXCJyZWZsb3dcIlxuICAgICAgQGN1cnJlbnRcbiAgXG4gIHNlcnZpY2Uuc2V0TGF5b3V0KDApICMgRGVmYXVsdFxuXG4gIHNlcnZpY2Vcbl0iLCJyZXF1aXJlIFwiLi4vLi4vdmVuZG9yL2FuZ3VsYXItZ3Jvd2wvYW5ndWxhci1ncm93bFwiXG5cblxubW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2Uubm90aWZpZXJcIiwgW1xuICBcImFuZ3VsYXItZ3Jvd2xcIlxuXVxuXG5tb2R1bGUuY29uZmlnIFtcImdyb3dsUHJvdmlkZXJcIiwgKGdyb3dsUHJvdmlkZXIpIC0+XG4gICAgZ3Jvd2xQcm92aWRlci5nbG9iYWxUaW1lVG9MaXZlKDMwMDApXG5dXG5cbm1vZHVsZS5mYWN0b3J5IFwibm90aWZpZXJcIiwgW1wiZ3Jvd2xcIiwgKGdyb3dsKSAtPlxuICBlcnJvcjogKG1lc3NhZ2UpIC0+XG4gICAgY29uc29sZS5sb2cgXCJbRVJSXVwiLCBhcmd1bWVudHMuLi5cbiAgICBncm93bC5hZGRFcnJvck1lc3NhZ2UgbWVzc2FnZVxuICB3YXJuOiAobWVzc2FnZSkgLT5cbiAgICBjb25zb2xlLmxvZyBcIltXQVJOXVwiLCBhcmd1bWVudHMuLi5cbiAgICBncm93bC5hZGRXYXJuTWVzc2FnZSBtZXNzYWdlXG4gIHN1Y2Nlc3M6IChtZXNzYWdlKSAtPlxuICAgIGNvbnNvbGUubG9nIFwiW09LXVwiLCBhcmd1bWVudHMuLi5cbiAgICBncm93bC5hZGRTdWNjZXNzTWVzc2FnZSBtZXNzYWdlXG5dIiwicmVxdWlyZSBcInNoYXJlL3dlYmNsaWVudC9zaGFyZS51bmNvbXByZXNzZWQuanNcIlxuXG5cbm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5zZXJ2aWNlLnNlc3Npb25cIiwgW1xuXVxuXG5tb2R1bGUuc2VydmljZSBcInNlc3Npb25cIiwgY2xhc3MgU2Vzc2lvblxuICAjIFNlc3Npb25DbGllbnQgaXMgdGhlIGludGVyZmFjZSB0aHJvdWdoLXdoaWNoIHN1YnNjcmliZXJzIGNhbiBpc3N1ZSBvcGVyYXRpb25zIG9uIHRoZSBzZXNzaW9uXG4gIGNsYXNzIFNlc3Npb25DbGllbnRcbiAgICBjb25zdHJ1Y3RvcjogKEBuYW1lLCBAc2Vzc2lvbikgLT5cbiAgICAgIEBsaXN0ZW5lcnMgPSB7fVxuICAgICAgXG4gICAgb246IChldmVudE5hbWUsIGxpc3RlbmVyKSAtPiAoQGxpc3RlbmVyc1tldmVudE5hbWVdIHx8PSBbXSkucHVzaChsaXN0ZW5lcilcbiAgICBvZmY6IChldmVudE5hbWUsIGxpc3RlbmVyKSAtPiBAbGlzdGVuZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGlkeCwgMSkgdW5sZXNzICFAbGlzdGVuZXJzW2V2ZW50TmFtZV0gb3IgMCA+IChpZHggPSBAbGlzdGVuZXJzW2V2ZW50TmFtZV0uaW5kZXhPZihsaXN0ZW5lcikpXG4gICAgXG4gICAgX2FwcGx5T3A6IChvcCkgLT4gQF9hcHBseU9wcyBbb3BdXG4gICAgX2FwcGx5T3BzOiAob3BzKSAtPiBAc2Vzc2lvbi5hcHBseU9wcyBAbmFtZSwgb3BzXG4gICAgXG4gICAgX2hhbmRsZU9wOiAoc291cmNlQ2xpZW50TmFtZSwgb3AsIHNuYXBzaG90KSAtPlxuICAgICAgaWYgb3AucC5sZW5ndGggaXMgMFxuICAgICAgICBjb25zb2xlLmxvZyBcIlJlc2V0XCJcbiAgICAgICAgQF9lbWl0IFwicmVzZXRcIixcbiAgICAgICAgICBzbmFwc2hvdDogb3Aub2lcbiAgICAgICAgICBvbGRfc25hcHNob3Q6IG9wLm9kXG4gICAgICBlbHNlXG4gICAgICAgIHN3aXRjaCBvcC5wWzBdXG4gICAgICAgICAgd2hlbiBcImN1cnNvclwiXG4gICAgICAgICAgICBpZiBvcC5wWzFdIGlzIFwiZmlsZUluZGV4XCIgdGhlbiBAX2VtaXQgXCJjdXJzb3JTZXRGaWxlXCIsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBzbmFwc2hvdC5maWxlc1tvcC5vaV0uZmlsZW5hbWVcbiAgICAgICAgICAgICAgcHJldl9maWxlbmFtZTogc25hcHNob3QuZmlsZXNbb3Aub2RdLmZpbGVuYW1lXG4gICAgICAgICAgICAgIGluZGV4OiBvcC5vaVxuICAgICAgICAgICAgICBwcmV2X2luZGV4OiBvcC5vZFxuICAgICAgICAgICAgZWxzZSBpZiBvcC5wWzFdIGlzIFwidGV4dE9mZnNldFwiIHRoZW4gQF9lbWl0IFwiY3Vyc29yU2V0T2Zmc2V0XCIsXG4gICAgICAgICAgICAgIG9mZnNldDogb3Aub2lcbiAgICAgICAgICAgICAgcHJldl9vZmZzZXQ6IG9wLm9kXG4gICAgICAgICAgd2hlbiBcImRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICMgQXNzdW1lIHNpL3NkIG9wcyBhdCBvZmZzZXQgPSAwXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIG9wLnBbMV0gaXMgMFxuICAgICAgICAgICAgcmV0dXJuIHVubGVzcyBvcC5zaSBhbmQgb3Auc2RcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQF9lbWl0IFwic2V0RGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wLnNpXG4gICAgICAgICAgICAgIG9sZF9kZXNjcmlwdGlvbjogb3Auc2RcbiAgICAgICAgICB3aGVuIFwidGFnc1wiXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIG9wLmxpIG9yIG9wLmxkXG4gICAgICAgICAgICByZXR1cm4gaWYgb3AucC5sZW5ndGggIT0gMlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiBvcC5saSB0aGVuIEBfZW1pdCBcInRhZ0FkZFwiLFxuICAgICAgICAgICAgICB0YWdOYW1lOiBvcC5saVxuICAgICAgICAgICAgICBpbmRleDogb3AucFsxXVxuICAgICAgICAgICAgZWxzZSBpZiBvcC5sZCB0aGVuIEBfZW1pdCBcInRhZ1JlbW92ZVwiLFxuICAgICAgICAgICAgICB0YWdOYW1lOiBvcC5sZFxuICAgICAgICAgICAgICBpbmRleDogb3AucFsyXVxuICAgICAgICAgIHdoZW4gXCJmaWxlc1wiXG4gICAgICAgICAgICAjIFRoaXMgaXMgYSBmaWxlIGNyZWF0aW9uL3JlbW92YWxcbiAgICAgICAgICAgIGlmIG9wLnAubGVuZ3RoIGlzIDJcbiAgICAgICAgICAgICAgaWYgb3AubGkgdGhlbiBAX2VtaXQgXCJmaWxlQ3JlYXRlXCIsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IG9wLmxpLmZpbGVuYW1lXG4gICAgICAgICAgICAgICAgaW5kZXg6IG9wLnBbMV1cbiAgICAgICAgICAgICAgICBjb250ZW50OiBvcC5saS5jb250ZW50XG4gICAgICAgICAgICAgIGVsc2UgaWYgb3AubGQgdGhlbiBAX2VtaXQgXCJmaWxlUmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IG9wLmxkLmZpbGVuYW1lXG4gICAgICAgICAgICAgICAgaW5kZXg6IG9wLnBbMV1cbiAgICAgICAgICAgICAgICBjb250ZW50OiBvcC5sZC5jb250ZW50XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVsc2UgaWYgb3AucFsyXSBpcyBcImZpbGVuYW1lXCJcbiAgICAgICAgICAgICAgQF9lbWl0IFwiZmlsZVJlbmFtZVwiLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBvcC5vaVxuICAgICAgICAgICAgICAgIGluZGV4OiBvcC5wWzFdXG4gICAgICAgICAgICAgICAgb2xkX2ZpbGVuYW1lOiBvcC5vZFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZWxzZSBpZiBvcC5wWzJdIGlzIFwiY29udGVudFwiXG4gICAgICAgICAgICAgIGZpbGVuYW1lID0gc25hcHNob3QuZmlsZXNbb3AucFsxXV0uZmlsZW5hbWVcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIG9wLnNpIHRoZW4gQF9lbWl0IFwidGV4dEluc2VydFwiLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgICAgICAgICAgIGluZGV4OiBvcC5wWzFdXG4gICAgICAgICAgICAgICAgdGV4dDogb3Auc2lcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9wLnBbM11cbiAgICAgICAgICAgICAgaWYgb3Auc2QgdGhlbiBAX2VtaXQgXCJ0ZXh0UmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgaW5kZXg6IG9wLnBbMV1cbiAgICAgICAgICAgICAgICB0ZXh0OiBvcC5zZFxuICAgICAgICAgICAgICAgIG9mZnNldDogb3AucFszXVxuICAgICAgICAgICAgICAgIFxuICAgICAgQF9lbWl0IFwicmVtb3RlT3BcIiwge29wLCBzbmFwc2hvdH1cblxuICAgIF9lbWl0OiAoZXZlbnROYW1lLCBlKSAtPlxuICAgICAgc25hcHNob3QgPSBAZ2V0U25hcHNob3QoKVxuICAgICAgZS5ldmVudE5hbWUgPSBldmVudE5hbWVcbiAgICAgIFxuICAgICAgbGlzdGVuZXIoZSwgc25hcHNob3QpIGZvciBsaXN0ZW5lciBpbiBAbGlzdGVuZXJzW2V2ZW50TmFtZV0gaWYgQGxpc3RlbmVyc1tldmVudE5hbWVdXG4gICAgXG4gICAgZ2V0Q3Vyc29yRmlsZUluZGV4OiAtPiBAc2Vzc2lvbi5zbmFwc2hvdC5jdXJzb3IuZmlsZUluZGV4XG4gICAgXG4gICAgZ2V0Q3Vyc29yVGV4dE9mZnNldDogLT4gQHNlc3Npb24uc25hcHNob3QuY3Vyc29yLnRleHRPZmZzZXRcbiAgICBcbiAgICBnZXREZXNjcmlwdGlvbjogLT4gQHNlc3Npb24uc25hcHNob3QuZGVzY3JpcHRpb25cbiAgICBcbiAgICAjIFJldHVybiB2YWx1ZSBpcyBqdXN0IGxpa2UgaW5kZXhPZiAoPj0gMCBtZWFucyBmb3VuZCwgLTEgbWVhbnMgbm90IGZvdW5kKVxuICAgIGdldEZpbGVJbmRleDogKGZpbGVuYW1lKSAtPlxuICAgICAgcmV0dXJuIGlkeCBmb3IgZmlsZSwgaWR4IGluIEBzZXNzaW9uLnNuYXBzaG90LmZpbGVzIHdoZW4gZmlsZS5maWxlbmFtZSBpcyBmaWxlbmFtZVxuICAgICAgcmV0dXJuIC0xXG4gICAgXG4gICAgZ2V0RmlsZUJ5SW5kZXg6IChpZHgpIC0+XG4gICAgICBpZiBhbmd1bGFyLmlzU3RyaW5nKGlkeCkgdGhlbiBpZHggPSBAZ2V0RmlsZUluZGV4KGlkeClcbiAgICAgIFxuICAgICAgQHNlc3Npb24uc25hcHNob3QuZmlsZXNbaWR4XVxuICAgIFxuICAgIGdldEZpbGU6IChmaWxlbmFtZSkgLT5cbiAgICAgIHJldHVybiBmaWxlIGZvciBmaWxlIGluIEBzZXNzaW9uLnNuYXBzaG90LmZpbGVzIHdoZW4gZmlsZS5maWxlbmFtZSBpcyBmaWxlbmFtZVxuICAgIFxuICAgIGdldE51bUZpbGVzOiAtPiByZXR1cm4gQHNlc3Npb24uc25hcHNob3QuZmlsZXM/Lmxlbmd0aCBvciAwXG4gICAgXG4gICAgZ2V0TnVtVGFnczogLT4gcmV0dXJuIEBzZXNzaW9uLnNuYXBzaG90LnRhZ3M/Lmxlbmd0aCBvciAwXG4gICAgXG4gICAgZ2V0U25hcHNob3Q6IC0+IHJldHVybiBAc2Vzc2lvbi5zbmFwc2hvdFxuICAgIFxuICAgICMgUmV0dXJuIHZhbHVlIGlzIGp1c3QgbGlrZSBpbmRleE9mICg+PSAwIG1lYW5zIGZvdW5kLCAtMSBtZWFucyBub3QgZm91bmQpXG4gICAgZ2V0VGFnSW5kZXg6ICh0YWdOYW1lKSAtPlxuICAgICAgcmV0dXJuIGlkeCBmb3IgdGFnLCBpZHggaW4gQHNlc3Npb24uc25hcHNob3QudGFncyB3aGVuIHRhZyBpcyB0YWdOYW1lXG4gICAgICByZXR1cm4gLTFcbiAgICBcbiAgICBoYXNGaWxlOiAoZmlsZW5hbWUpIC0+IHJldHVybiBAZ2V0RmlsZUluZGV4KGZpbGVuYW1lKSA+PSAwXG5cbiAgICBoYXNGaWxlSW5kZXg6IChpZHgpIC0+IHJldHVybiBAZ2V0RmlsZUJ5SW5kZXgoaWR4KT9cbiAgICBcbiAgICBoYXNUYWc6ICh0YWdOYW1lKSAtPiByZXR1cm4gQGdldFRhZ0luZGV4KHRhZ05hbWUpID49IDBcbiAgICBcbiAgICBpc1ZhbGlkVGFnOiAodGFnTmFtZSkgLT4gcmV0dXJuIC9eWy1fYS16MC05XFwuXFxbXFxdXSskL2kudGVzdCh0YWdOYW1lKVxuICAgIFxuICAgIGlzVmFsaWRGaWxlOiAoZmlsZSkgLT4gcmV0dXJuIEBpc1ZhbGlkRmlsZW5hbWUoZmlsZS5maWxlbmFtZSkgJiYgYW5ndWxhci5pc1N0cmluZyhmaWxlLmNvbnRlbnQpXG4gICAgXG4gICAgaXNWYWxpZEZpbGVuYW1lOiAoZmlsZW5hbWUpIC0+IHJldHVybiAvXlstX2EtejAtOVxcLlxcW1xcXV0rJC9pLnRlc3QoZmlsZW5hbWUpXG4gICAgXG4gICAgXG4gICAgXG4gICAgcmVzZXQ6IChqc29uID0ge30pIC0+XG4gICAgICBqc29uLmRlc2NyaXB0aW9uIHx8PSBcIlwiXG4gICAgICBqc29uLnRhZ3MgfHw9IFtdXG4gICAgICBqc29uLmN1cnNvciB8fD0geyBmaWxlSW5kZXg6IDAsIHRleHRPZmZzZXQ6IDAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNldCBmYWlsZWQuIERlc2NyaXB0aW9uIG11c3QgYmUgYSBzdHJpbmcuXCIpIHVubGVzcyBhbmd1bGFyLmlzU3RyaW5nKGpzb24uZGVzY3JpcHRpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNldCBmYWlsZWQuIFRhZ3MgbXVzdCBiZSBhbiBhcnJheS5cIikgdW5sZXNzIGFuZ3VsYXIuaXNBcnJheShqc29uLnRhZ3MpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNldCBmYWlsZWQuIEludmFsaWQgdGFnOiAje3RhZ05hbWV9LlwiKSBmb3IgdGFnTmFtZSBpbiBqc29uLnRhZ3Mgd2hlbiAhQGlzVmFsaWRUYWcodGFnTmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc2V0IGZhaWxlZC4gRmlsZXMgbXVzdCBiZSBhbiBhcnJheS5cIikgdW5sZXNzIGFuZ3VsYXIuaXNBcnJheShqc29uLmZpbGVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZXQgZmFpbGVkLiBJbnZhbGlkIGZpbGU6ICN7SlNPTi5zdHJpbmdpZnkoZmlsZSl9LlwiKSBmb3IgZmlsZSBpbiBqc29uLmZpbGVzIHdoZW4gIUBpc1ZhbGlkRmlsZShmaWxlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZXQgZmFpbGVkLiBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBmaWxlLlwiKSB1bmxlc3MganNvbi5maWxlcy5sZW5ndGhcbiAgICBcbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXVxuICAgICAgICBvZDogYW5ndWxhci5jb3B5KEBnZXRTbmFwc2hvdCgpKVxuICAgICAgICBvaToganNvblxuICAgIFxuICAgIGN1cnNvclNldEZpbGU6IChmaWxlbmFtZSkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSBzZXQgdGhlIGFjdGl2ZSBmaWxlLiBGaWxlIGRvZXMgbm90IGV4aXN0OiAje2ZpbGVuYW1lfVwiKSB1bmxlc3MgQGhhc0ZpbGUoZmlsZW5hbWUpXG4gICAgICBcbiAgICAgIGlkeCA9IEBnZXRGaWxlSW5kZXgoZmlsZW5hbWUpXG4gICAgICBcbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXCJjdXJzb3JcIiwgXCJmaWxlSW5kZXhcIl1cbiAgICAgICAgb2Q6IEBnZXRDdXJzb3JGaWxlSW5kZXgoKVxuICAgICAgICBvaTogaWR4XG4gICAgXG4gICAgY3Vyc29yU2V0SW5kZXg6IChpZHgpIC0+XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgc2V0IHRoZSBhY3RpdmUgZmlsZS4gRmlsZSBkb2VzIG5vdCBleGlzdDogI3tpZHh9XCIpIHVubGVzcyBAaGFzRmlsZUluZGV4KGlkeClcbiAgICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcImN1cnNvclwiLCBcImZpbGVJbmRleFwiXVxuICAgICAgICBvZDogQGdldEN1cnNvckZpbGVJbmRleCgpXG4gICAgICAgIG9pOiBpZHhcbiAgICBcbiAgICBjdXJzb3JTZXRPZmZzZXQ6IChvZmZzZXQpIC0+XG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiY3Vyc29yXCIsIFwidGV4dE9mZnNldFwiXVxuICAgICAgICBvZDogQGdldEN1cnNvclRleHRPZmZzZXQoKVxuICAgICAgICBvaTogb2Zmc2V0XG4gICAgXG4gICAgc2V0RGVzY3JpcHRpb246IChkZXNjcmlwdGlvbiA9IFwiXCIpIC0+XG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiZGVzY3JpcHRpb25cIiwgMF1cbiAgICAgICAgc2Q6IEBnZXREZXNjcmlwdGlvbigpXG4gICAgICAgIHNpOiBkZXNjcmlwdGlvblxuICAgIFxuICAgIFxuICAgIFxuICAgIGZpbGVDcmVhdGU6IChmaWxlbmFtZSwgY29udGVudCA9IFwiXCIpIC0+XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGZpbGUuIEludmFsaWQgZmlsZW5hbWU6ICN7ZmlsZW5hbWV9XCIpIHVubGVzcyBAaXNWYWxpZEZpbGVuYW1lKGZpbGVuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBmaWxlLiBGaWxlIGFscmVhZHkgZXhpc3RzOiAje2ZpbGVuYW1lfVwiKSBpZiBAaGFzRmlsZShmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgaWR4ID0gQGdldE51bUZpbGVzKClcbiAgICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcImZpbGVzXCIsIGlkeF1cbiAgICAgICAgbGk6IHtmaWxlbmFtZSwgY29udGVudH1cbiAgICBcbiAgICBmaWxlUmVuYW1lOiAoZmlsZW5hbWUsIG5ld19maWxlbmFtZSkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgZmlsZS4gSW52YWxpZCBmaWxlbmFtZTogI3tuZXdfZmlsZW5hbWV9XCIpIHVubGVzcyBAaXNWYWxpZEZpbGVuYW1lKG5ld19maWxlbmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZW5hbWUgZmlsZS4gRmlsZSBkb2VzIG5vdCBleGlzdDogI3tmaWxlbmFtZX1cIikgdW5sZXNzIEBoYXNGaWxlKGZpbGVuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlbmFtZSBmaWxlLiBBIGZpbGUgYWxyZWFkeSBleGlzdHMgbmFtZWQ6ICN7bmV3X2ZpbGVuYW1lfVwiKSBpZiBAaGFzRmlsZShuZXdfZmlsZW5hbWUpXG5cbiAgICAgIGlkeCA9IEBnZXRGaWxlSW5kZXgoZmlsZW5hbWUpXG4gICAgICBcbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXCJmaWxlc1wiLCBpZHgsIFwiZmlsZW5hbWVcIl1cbiAgICAgICAgb2Q6IGZpbGVuYW1lXG4gICAgICAgIG9pOiBuZXdfZmlsZW5hbWVcblxuICAgIGZpbGVSZW1vdmU6IChmaWxlbmFtZSkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZW1vdmUgZmlsZS4gRmlsZSBkb2VzIG5vdCBleGlzdDogI3tmaWxlbmFtZX1cIikgdW5sZXNzIEBoYXNGaWxlKGZpbGVuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlbW92ZSBmaWxlLiBZb3UgY2FuIG5vdCByZW1vdmUgYWxsIGZpbGVzLlwiKSBpZiBAZ2V0TnVtRmlsZXMoKSA8PSAxXG5cbiAgICAgIGlkeCA9IEBnZXRGaWxlSW5kZXgoZmlsZW5hbWUpXG4gICAgICBcbiAgICAgIEBjdXJzb3JTZXRJbmRleCgwKVxuICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcImZpbGVzXCIsIGlkeF1cbiAgICAgICAgbGQ6IEBnZXRGaWxlKGZpbGVuYW1lKVxuICAgICAgICBcbiAgICBcbiAgICBcbiAgICB0ZXh0SW5zZXJ0OiAoZmlsZW5hbWUsIG9mZnNldCwgdGV4dCkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBpbnNlcnQgdGV4dC4gRmlsZSBkb2VzIG5vdCBleGlzdDogI3tmaWxlbmFtZX1cIikgdW5sZXNzIEBoYXNGaWxlKGZpbGVuYW1lKVxuICAgICAgXG4gICAgICBpZHggPSBAZ2V0RmlsZUluZGV4KGZpbGVuYW1lKVxuXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiZmlsZXNcIiwgaWR4LCBcImNvbnRlbnRcIiwgb2Zmc2V0XVxuICAgICAgICBzaTogdGV4dFxuXG4gICAgdGV4dFJlbW92ZTogKGZpbGVuYW1lLCBvZmZzZXQsIHRleHQpIC0+XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVtb3ZlIHRleHQuIEZpbGUgZG9lcyBub3QgZXhpc3Q6ICN7ZmlsZW5hbWV9XCIpIHVubGVzcyBAaGFzRmlsZShmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgaWR4ID0gQGdldEZpbGVJbmRleChmaWxlbmFtZSlcblxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcImZpbGVzXCIsIGlkeCwgXCJjb250ZW50XCIsIG9mZnNldF1cbiAgICAgICAgc2Q6IHRleHRcbiAgICBcbiAgICBcbiAgICBcbiAgICB0YWdBZGQ6ICh0YWdOYW1lKSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGFkZCB0YWcuIEludmFsaWQgdGFnOiAje3RhZ05hbWV9XCIpIHVubGVzcyBAaXNWYWxpZFRhZyh0YWdOYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGFkZCB0YWcuIFRhZyBhbHJlYWR5IGV4aXN0czogI3t0YWdOYW1lfVwiKSBpZiBAaGFzVGFnKHRhZ05hbWUpXG4gICAgICBcbiAgICAgIGlkeCA9IEBnZXROdW1UYWdzKClcbiAgICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcInRhZ3NcIiwgaWR4XVxuICAgICAgICBsaTogdGFnTmFtZVxuXG4gICAgdGFnUmVtb3ZlOiAodGFnTmFtZSkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZW1vdmUgdGFnLiBUYWcgbm90IGZvdW5kOiAje3RhZ05hbWV9XCIpIHVubGVzcyBAaGFzVGFnKHRhZ05hbWUpXG4gICAgICBcbiAgICAgIGlkeCA9IEBnZXRUYWdJbmRleCh0YWdOYW1lKVxuICAgICAgXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1widGFnc1wiLCBpZHhdXG4gICAgICAgIGxkOiB0YWdOYW1lXG4gIFxuICBcbiAgY29uc3RydWN0b3I6IC0+XG4gICAgQCRjbGllbnRzID0ge31cbiAgICBcbiAgICBAc25hcHNob3QgPSB7fVxuICAgIEBpZmFjZSA9IEBjcmVhdGVDbGllbnQoXCJzZXNzaW9uXCIpXG4gICAgXG4gICAgQGlmYWNlLnJlc2V0XG4gICAgICBmaWxlczogW1xuICAgICAgICBmaWxlbmFtZTogXCJpbmRleC5odG1sXCJcbiAgICAgICAgY29udGVudDogXCJcIlxuICAgICAgXVxuICBcbiAgY3JlYXRlQ2xpZW50OiAoY2xpZW50TmFtZSkgLT5cbiAgICAjdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBjbGllbnQuIENsaWVudCBhbHJlYWR5IGNyZWF0ZWQ6ICN7Y2xpZW50TmFtZX0uXCIpIGlmIEAkY2xpZW50c1tjbGllbnROYW1lXVxuICAgIFxuICAgIHNlc3Npb24gPSBAXG4gICAgXG4gICAgQCRjbGllbnRzW2NsaWVudE5hbWVdIHx8PSBuZXcgU2Vzc2lvbkNsaWVudChjbGllbnROYW1lLCBzZXNzaW9uKVxuICBcbiAgYXBwbHlPcHM6IChzb3VyY2VDbGllbnROYW1lLCBvcHMpIC0+XG4gICAgcG9zdFNuYXBzaG90ID0gb3R0eXBlcy5qc29uMC5hcHBseSBAc25hcHNob3QsIG9wc1xuICAgIFxuICAgIGNvbnNvbGUubG9nIFwiW09UXSBvcFwiLCBvcCBmb3Igb3AgaW4gb3BzXG4gICAgY29uc29sZS5sb2cgXCJbT1RdIHNuYXBzaG90XCIsIGFuZ3VsYXIuY29weShAc25hcHNob3QpXG4gICAgXG4gICAgYW5ndWxhci5jb3B5IHBvc3RTbmFwc2hvdCwgQHNuYXBzaG90IHVubGVzcyBAc25hcHNob3QgPT0gcG9zdFNuYXBzaG90XG4gICAgXG4gICAgZm9yIGNsaWVudE5hbWUsIGNsaWVudCBvZiBAJGNsaWVudHMgd2hlbiBjbGllbnROYW1lICE9IHNvdXJjZUNsaWVudE5hbWVcbiAgICAgIGNsaWVudC5faGFuZGxlT3Aoc291cmNlQ2xpZW50TmFtZSwgb3AsIEBzbmFwc2hvdCkgZm9yIG9wIGluIG9wc1xuICAgICAgXG4iLCJtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS5zZXR0aW5nc1wiLCBbXVxyXG5cclxubW9kdWxlLnNlcnZpY2UgXCJzZXR0aW5nc1wiLCBbICgpIC0+XHJcbiAgXHJcbiAgc2V0dGluZ3MgPVxyXG4gICAgcHJldmlld2VyOlxyXG4gICAgICBkZWxheTogMTAwMFxyXG4gICAgICBhdXRvX3JlZnJlc2g6IHRydWVcclxuICAgIGVkaXRvcjpcclxuICAgICAgdGFiX3NpemU6IDJcclxuICAgICAgc29mdF90YWJzOiB0cnVlXHJcbiAgICAgIHRoZW1lOiBcInRleHRtYXRlXCJcclxuICAgICAgd3JhcDpcclxuICAgICAgICByYW5nZTpcclxuICAgICAgICAgIG1pbjogMFxyXG4gICAgICAgICAgbWF4OiA4MFxyXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgXHJcbiAgXHJcbiAgXHJcbiAgaWYgbG9jYWxTdG9yYWdlP1xyXG4gICAgaWYgc2F2ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInBsbmtyX3NldHRpbmdzXCIpXHJcbiAgICAgIHRyeVxyXG4gICAgICAgIHNhdmVkID0gSlNPTi5wYXJzZShzYXZlZClcclxuICAgICAgY2F0Y2ggZVxyXG4gICAgICAgIHNhdmVkID0ge31cclxuICAgICAgXHJcbiAgICBzZXRJbnRlcnZhbCAtPlxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSBcInBsbmtyX3NldHRpbmdzXCIsIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKVxyXG4gICAgLCAyMDAwXHJcbiAgXHJcbiAgYW5ndWxhci5leHRlbmQgc2V0dGluZ3MsIHNhdmVkXHJcbiAgXHJcbl0iLCJtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS50eXBlc1wiLCBbXG5dXG5cblxubW9kdWxlLmZhY3RvcnkgXCJ0eXBlc1wiLCAtPlxuICB0eXBlcyA9XG4gICAgaHRtbDpcbiAgICAgIHJlZ2V4OiAvXFwuaHRtbCQvaVxuICAgICAgbWltZTogXCJ0ZXh0L2h0bWxcIlxuICAgIGphdmFzY3JpcHQ6XG4gICAgICByZWdleDogL1xcLmpzJC9pXG4gICAgICBtaW1lOiBcInRleHQvamF2YXNjcmlwdFwiXG4gICAgY29mZmVlOlxuICAgICAgcmVnZXg6IC9cXC5jb2ZmZWUkL2lcbiAgICAgIG1pbWU6IFwidGV4dC9jb2ZmZWVcIlxuICAgIGNzczpcbiAgICAgIHJlZ2V4OiAvXFwuY3NzJC9pXG4gICAgICBtaW1lOiBcInRleHQvY3NzXCJcbiAgICB0ZXh0OlxuICAgICAgcmVnZXg6IC9cXC50eHQkL1xuICAgICAgbWltZTogXCJ0ZXh0L3BsYWluXCJcbiAgXG4gIGZvciBuYW1lLCB0eXBlIG9mIHR5cGVzXG4gICAgdHlwZS5uYW1lID0gbmFtZVxuICBcbiAgdHlwZXM6IHR5cGVzXG4gIGdldEJ5RmlsZW5hbWU6IChmaWxlbmFtZSkgLT5cbiAgICBmb3IgbmFtZSwgbW9kZSBvZiB0eXBlc1xuICAgICAgaWYgbW9kZS5yZWdleC50ZXN0KGZpbGVuYW1lKSB0aGVuIHJldHVybiBtb2RlXG4gICAgXG4gICAgcmV0dXJuIHR5cGVzLnRleHRcblxuXG4iLCJyZXF1aXJlIFwiLi4vc2VydmljZXMvaHRtbEZpbGUuY29mZmVlXCJcblxuXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS51cGRhdGVyXCIsIFtcbiAgXCJwbHVua2VyLnNlcnZpY2UuaHRtbEZpbGVcIlxuXVxuXG5tb2R1bGUuZmFjdG9yeSBcInVwZGF0ZXJcIiwgWyBcIiRxXCIsIFwiaHRtbEZpbGVcIiwgKCRxLCBodG1sRmlsZSkgLT5cbiAgdXBkYXRlOiAoanNvbikgLT5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gdXBkYXRlIGludmFsaWQganNvbjogbWlzc2luZyBmaWxlcyBhcnJheVwiKSB1bmxlc3MganNvbi5maWxlcyBhbmQganNvbi5maWxlcy5sZW5ndGhcbiAgICBcbiAgICBwcm9taXNlcyA9IFtdXG4gICAgXG4gICAgZm9yIGZpbGUgaW4ganNvbi5maWxlcyB0aGVuIGRvIChmaWxlKSAtPlxuICAgICAgaWYgZmlsZS5maWxlbmFtZS5tYXRjaCAvXFwuaHRtbCQvaVxuICAgICAgICBwcm9taXNlcy5wdXNoIGh0bWxGaWxlLnVwZGF0ZShmaWxlLmNvbnRlbnQpLnRoZW4gKG1hcmt1cCkgLT5cbiAgICAgICAgICBmaWxlLmNvbnRlbnQgPSBtYXJrdXBcbiAgICBcbiAgICAkcS5hbGwocHJvbWlzZXMpLnRoZW4gLT4ganNvblxuXG5dIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UudXJsXCIsIFtdXG5cbm1vZHVsZS5jb25zdGFudCBcInVybFwiLCBfcGx1bmtlci51cmwiLCIvKipcclxuICogYW5ndWxhci1ncm93bCAtIHYwLjMuMCAtIDIwMTMtMDktMjZcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNvcmluY2svYW5ndWxhci1ncm93bFxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgTWFyY28gUmluY2s7IExpY2Vuc2VkIE1JVFxyXG4gKi9cclxuYW5ndWxhci5tb2R1bGUoJ2FuZ3VsYXItZ3Jvd2wnLCBbXSk7XHJcbmFuZ3VsYXIubW9kdWxlKCdhbmd1bGFyLWdyb3dsJykuZGlyZWN0aXZlKCdncm93bCcsIFtcclxuICAnJHJvb3RTY29wZScsXHJcbiAgZnVuY3Rpb24gKCRyb290U2NvcGUpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cImdyb3dsXCI+JyArICdcXHQ8ZGl2IGNsYXNzPVwiZ3Jvd2wtaXRlbSBhbGVydFwiIG5nLXJlcGVhdD1cIm1lc3NhZ2UgaW4gbWVzc2FnZXNcIiBuZy1jbGFzcz1cImNvbXB1dGVDbGFzc2VzKG1lc3NhZ2UpXCI+JyArICdcXHRcXHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgbmctY2xpY2s9XCJkZWxldGVNZXNzYWdlKG1lc3NhZ2UpXCI+JnRpbWVzOzwvYnV0dG9uPicgKyAnICAgICAgICAgICAge3sgbWVzc2FnZS50ZXh0fX0nICsgJ1xcdDwvZGl2PicgKyAnPC9kaXY+JyxcclxuICAgICAgcmVwbGFjZTogZmFsc2UsXHJcbiAgICAgIHNjb3BlOiB0cnVlLFxyXG4gICAgICBjb250cm9sbGVyOiBbXHJcbiAgICAgICAgJyRzY29wZScsXHJcbiAgICAgICAgJyR0aW1lb3V0JyxcclxuICAgICAgICBmdW5jdGlvbiAoJHNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgICAgJHNjb3BlLm1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAkcm9vdFNjb3BlLiRvbignZ3Jvd2xNZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50dGwgJiYgbWVzc2FnZS50dGwgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlbGV0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgfSwgbWVzc2FnZS50dGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgICRzY29wZS5kZWxldGVNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gJHNjb3BlLm1lc3NhZ2VzLmluZGV4T2YobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLm1lc3NhZ2VzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAkc2NvcGUuY29tcHV0ZUNsYXNzZXMgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICdhbGVydC1zdWNjZXNzJzogbWVzc2FnZS5pc1N1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgJ2FsZXJ0LWRhbmdlcic6IG1lc3NhZ2UuaXNFcnJvcixcclxuICAgICAgICAgICAgICAnYWxlcnQtd2FybmluZyc6IG1lc3NhZ2UuaXNXYXJuLFxyXG4gICAgICAgICAgICAgICdhbGVydC1pbmZvJzogbWVzc2FnZS5pc0luZm9cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxuXSk7XHJcbmFuZ3VsYXIubW9kdWxlKCdhbmd1bGFyLWdyb3dsJykucHJvdmlkZXIoJ2dyb3dsJywgZnVuY3Rpb24gKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuICB2YXIgX3R0bCA9IG51bGwsIF9tZXNzYWdlc0tleSA9ICdtZXNzYWdlcycsIF9tZXNzYWdlVGV4dEtleSA9ICd0ZXh0JywgX21lc3NhZ2VTZXZlcml0eUtleSA9ICdzZXZlcml0eSc7XHJcbiAgdGhpcy5nbG9iYWxUaW1lVG9MaXZlID0gZnVuY3Rpb24gKHR0bCkge1xyXG4gICAgX3R0bCA9IHR0bDtcclxuICB9O1xyXG4gIHRoaXMubWVzc2FnZXNLZXkgPSBmdW5jdGlvbiAobWVzc2FnZXNLZXkpIHtcclxuICAgIF9tZXNzYWdlc0tleSA9IG1lc3NhZ2VzS2V5O1xyXG4gIH07XHJcbiAgdGhpcy5tZXNzYWdlVGV4dEtleSA9IGZ1bmN0aW9uIChtZXNzYWdlVGV4dEtleSkge1xyXG4gICAgX21lc3NhZ2VUZXh0S2V5ID0gbWVzc2FnZVRleHRLZXk7XHJcbiAgfTtcclxuICB0aGlzLm1lc3NhZ2VTZXZlcml0eUtleSA9IGZ1bmN0aW9uIChtZXNzYWdlU2V2ZXJpdHlLZXkpIHtcclxuICAgIF9tZXNzYWdlU2V2ZXJpdHlLZXkgPSBtZXNzYWdlU2V2ZXJpdHlLZXk7XHJcbiAgfTtcclxuICB0aGlzLnNlcnZlck1lc3NhZ2VzSW50ZXJjZXB0b3IgPSBbXHJcbiAgICAnJHEnLFxyXG4gICAgJ2dyb3dsJyxcclxuICAgIGZ1bmN0aW9uICgkcSwgZ3Jvd2wpIHtcclxuICAgICAgZnVuY3Rpb24gY2hlY2tSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhW19tZXNzYWdlc0tleV0gJiYgcmVzcG9uc2UuZGF0YVtfbWVzc2FnZXNLZXldLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGdyb3dsLmFkZFNlcnZlck1lc3NhZ2VzKHJlc3BvbnNlLmRhdGFbX21lc3NhZ2VzS2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MocmVzcG9uc2UpIHtcclxuICAgICAgICBjaGVja1Jlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZXJyb3IocmVzcG9uc2UpIHtcclxuICAgICAgICBjaGVja1Jlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlc3BvbnNlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHByb21pc2UpIHtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICBdO1xyXG4gIHRoaXMuJGdldCA9IFtcclxuICAgICckcm9vdFNjb3BlJyxcclxuICAgICckZmlsdGVyJyxcclxuICAgIGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkZmlsdGVyKSB7XHJcbiAgICAgIHZhciB0cmFuc2xhdGU7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdHJhbnNsYXRlID0gJGZpbHRlcigndHJhbnNsYXRlJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBicm9hZGNhc3RNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAodHJhbnNsYXRlKSB7XHJcbiAgICAgICAgICBtZXNzYWdlID0gdHJhbnNsYXRlKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2dyb3dsTWVzc2FnZScsIG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHNlbmRNZXNzYWdlKHRleHQsIGNvbmZpZywgc2V2ZXJpdHkpIHtcclxuICAgICAgICB2YXIgX2NvbmZpZyA9IGNvbmZpZyB8fCB7fSwgbWVzc2FnZTtcclxuICAgICAgICBtZXNzYWdlID0ge1xyXG4gICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgIGlzV2Fybjogc2V2ZXJpdHkuaXNXYXJuLFxyXG4gICAgICAgICAgaXNFcnJvcjogc2V2ZXJpdHkuaXNFcnJvcixcclxuICAgICAgICAgIGlzSW5mbzogc2V2ZXJpdHkuaXNJbmZvLFxyXG4gICAgICAgICAgaXNTdWNjZXNzOiBzZXZlcml0eS5pc1N1Y2Nlc3MsXHJcbiAgICAgICAgICB0dGw6IF9jb25maWcudHRsIHx8IF90dGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyb2FkY2FzdE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gYWRkV2Fybk1lc3NhZ2UodGV4dCwgY29uZmlnKSB7XHJcbiAgICAgICAgc2VuZE1lc3NhZ2UodGV4dCwgY29uZmlnLCB7IGlzV2FybjogdHJ1ZSB9KTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBhZGRFcnJvck1lc3NhZ2UodGV4dCwgY29uZmlnKSB7XHJcbiAgICAgICAgc2VuZE1lc3NhZ2UodGV4dCwgY29uZmlnLCB7IGlzRXJyb3I6IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gYWRkSW5mb01lc3NhZ2UodGV4dCwgY29uZmlnKSB7XHJcbiAgICAgICAgc2VuZE1lc3NhZ2UodGV4dCwgY29uZmlnLCB7IGlzSW5mbzogdHJ1ZSB9KTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBhZGRTdWNjZXNzTWVzc2FnZSh0ZXh0LCBjb25maWcpIHtcclxuICAgICAgICBzZW5kTWVzc2FnZSh0ZXh0LCBjb25maWcsIHsgaXNTdWNjZXNzOiB0cnVlIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGFkZFNlcnZlck1lc3NhZ2VzKG1lc3NhZ2VzKSB7XHJcbiAgICAgICAgdmFyIGksIG1lc3NhZ2UsIHNldmVyaXR5LCBsZW5ndGg7XHJcbiAgICAgICAgbGVuZ3RoID0gbWVzc2FnZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xyXG4gICAgICAgICAgaWYgKG1lc3NhZ2VbX21lc3NhZ2VUZXh0S2V5XSAmJiBtZXNzYWdlW19tZXNzYWdlU2V2ZXJpdHlLZXldKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZVtfbWVzc2FnZVNldmVyaXR5S2V5XSkge1xyXG4gICAgICAgICAgICBjYXNlICd3YXJuJzpcclxuICAgICAgICAgICAgICBzZXZlcml0eSA9IHsgaXNXYXJuOiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxyXG4gICAgICAgICAgICAgIHNldmVyaXR5ID0geyBpc1N1Y2Nlc3M6IHRydWUgfTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaW5mbyc6XHJcbiAgICAgICAgICAgICAgc2V2ZXJpdHkgPSB7IGlzSW5mbzogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgICAgICAgc2V2ZXJpdHkgPSB7IGlzRXJyb3I6IHRydWUgfTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZW5kTWVzc2FnZShtZXNzYWdlW19tZXNzYWdlVGV4dEtleV0sIHVuZGVmaW5lZCwgc2V2ZXJpdHkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZFdhcm5NZXNzYWdlOiBhZGRXYXJuTWVzc2FnZSxcclxuICAgICAgICBhZGRFcnJvck1lc3NhZ2U6IGFkZEVycm9yTWVzc2FnZSxcclxuICAgICAgICBhZGRJbmZvTWVzc2FnZTogYWRkSW5mb01lc3NhZ2UsXHJcbiAgICAgICAgYWRkU3VjY2Vzc01lc3NhZ2U6IGFkZFN1Y2Nlc3NNZXNzYWdlLFxyXG4gICAgICAgIGFkZFNlcnZlck1lc3NhZ2VzOiBhZGRTZXJ2ZXJNZXNzYWdlc1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIF07XHJcbn0pOyIsImFuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwXCIsIFtcInVpLmJvb3RzdHJhcC50cGxzXCIsIFwidWkuYm9vdHN0cmFwLnRyYW5zaXRpb25cIixcInVpLmJvb3RzdHJhcC5jb2xsYXBzZVwiLFwidWkuYm9vdHN0cmFwLmFjY29yZGlvblwiLFwidWkuYm9vdHN0cmFwLmFsZXJ0XCIsXCJ1aS5ib290c3RyYXAuYmluZEh0bWxcIixcInVpLmJvb3RzdHJhcC5idXR0b25zXCIsXCJ1aS5ib290c3RyYXAuY2Fyb3VzZWxcIixcInVpLmJvb3RzdHJhcC5wb3NpdGlvblwiLFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJcIixcInVpLmJvb3RzdHJhcC5kcm9wZG93blRvZ2dsZVwiLFwidWkuYm9vdHN0cmFwLm1vZGFsXCIsXCJ1aS5ib290c3RyYXAucGFnaW5hdGlvblwiLFwidWkuYm9vdHN0cmFwLnRvb2x0aXBcIixcInVpLmJvb3RzdHJhcC5wb3BvdmVyXCIsXCJ1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXJcIixcInVpLmJvb3RzdHJhcC5yYXRpbmdcIixcInVpLmJvb3RzdHJhcC50YWJzXCIsXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFwiXSk7XHJcbmFuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwLnRwbHNcIiwgW1widGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIixcInRlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcInRlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIixcInRlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIixcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIixcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIixcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFwidGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsXCJ0ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC10aXRsZXMuaHRtbFwiLFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLFwidGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCJdKTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50cmFuc2l0aW9uJywgW10pXHJcblxyXG4vKipcclxuICogJHRyYW5zaXRpb24gc2VydmljZSBwcm92aWRlcyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIHRvIHRyaWdnZXIgQ1NTIDMgdHJhbnNpdGlvbnMgYW5kIHRvIGJlIGluZm9ybWVkIHdoZW4gdGhleSBjb21wbGV0ZS5cclxuICogQHBhcmFtICB7RE9NRWxlbWVudH0gZWxlbWVudCAgVGhlIERPTUVsZW1lbnQgdGhhdCB3aWxsIGJlIGFuaW1hdGVkLlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fGZ1bmN0aW9ufSB0cmlnZ2VyICBUaGUgdGhpbmcgdGhhdCB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHN0YXJ0OlxyXG4gKiAgIC0gQXMgYSBzdHJpbmcsIGl0IHJlcHJlc2VudHMgdGhlIGNzcyBjbGFzcyB0byBiZSBhZGRlZCB0byB0aGUgZWxlbWVudC5cclxuICogICAtIEFzIGFuIG9iamVjdCwgaXQgcmVwcmVzZW50cyBhIGhhc2ggb2Ygc3R5bGUgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxyXG4gKiAgIC0gQXMgYSBmdW5jdGlvbiwgaXQgcmVwcmVzZW50cyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0aGF0IHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gb2NjdXIuXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9ICBBIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzLlxyXG4gKi9cclxuLmZhY3RvcnkoJyR0cmFuc2l0aW9uJywgWyckcScsICckdGltZW91dCcsICckcm9vdFNjb3BlJywgZnVuY3Rpb24oJHEsICR0aW1lb3V0LCAkcm9vdFNjb3BlKSB7XHJcblxyXG4gIHZhciAkdHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGVsZW1lbnQsIHRyaWdnZXIsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcclxuICAgIHZhciBlbmRFdmVudE5hbWUgPSAkdHJhbnNpdGlvbltvcHRpb25zLmFuaW1hdGlvbiA/IFwiYW5pbWF0aW9uRW5kRXZlbnROYW1lXCIgOiBcInRyYW5zaXRpb25FbmRFdmVudE5hbWVcIl07XHJcblxyXG4gICAgdmFyIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZWxlbWVudC51bmJpbmQoZW5kRXZlbnROYW1lLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XHJcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShlbGVtZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChlbmRFdmVudE5hbWUpIHtcclxuICAgICAgZWxlbWVudC5iaW5kKGVuZEV2ZW50TmFtZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdyYXAgaW4gYSB0aW1lb3V0IHRvIGFsbG93IHRoZSBicm93c2VyIHRpbWUgdG8gdXBkYXRlIHRoZSBET00gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGlzIHRvIG9jY3VyXHJcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCBhbmd1bGFyLmlzU3RyaW5nKHRyaWdnZXIpICkge1xyXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3ModHJpZ2dlcik7XHJcbiAgICAgIH0gZWxzZSBpZiAoIGFuZ3VsYXIuaXNGdW5jdGlvbih0cmlnZ2VyKSApIHtcclxuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2UgaWYgKCBhbmd1bGFyLmlzT2JqZWN0KHRyaWdnZXIpICkge1xyXG4gICAgICAgIGVsZW1lbnQuY3NzKHRyaWdnZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vSWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRyYW5zaXRpb25zLCBpbnN0YW50bHkgcmVzb2x2ZVxyXG4gICAgICBpZiAoICFlbmRFdmVudE5hbWUgKSB7XHJcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIG91ciBjdXN0b20gY2FuY2VsIGZ1bmN0aW9uIHRvIHRoZSBwcm9taXNlIHRoYXQgaXMgcmV0dXJuZWRcclxuICAgIC8vIFdlIGNhbiBjYWxsIHRoaXMgaWYgd2UgYXJlIGFib3V0IHRvIHJ1biBhIG5ldyB0cmFuc2l0aW9uLCB3aGljaCB3ZSBrbm93IHdpbGwgcHJldmVudCB0aGlzIHRyYW5zaXRpb24gZnJvbSBlbmRpbmcsXHJcbiAgICAvLyBpLmUuIGl0IHdpbGwgdGhlcmVmb3JlIG5ldmVyIHJhaXNlIGEgdHJhbnNpdGlvbkVuZCBldmVudCBmb3IgdGhhdCB0cmFuc2l0aW9uXHJcbiAgICBkZWZlcnJlZC5wcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIGVuZEV2ZW50TmFtZSApIHtcclxuICAgICAgICBlbGVtZW50LnVuYmluZChlbmRFdmVudE5hbWUsIHRyYW5zaXRpb25FbmRIYW5kbGVyKTtcclxuICAgICAgfVxyXG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ1RyYW5zaXRpb24gY2FuY2VsbGVkJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gIH07XHJcblxyXG4gIC8vIFdvcmsgb3V0IHRoZSBuYW1lIG9mIHRoZSB0cmFuc2l0aW9uRW5kIGV2ZW50XHJcbiAgdmFyIHRyYW5zRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyYW5zJyk7XHJcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudE5hbWVzID0ge1xyXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXHJcbiAgICAnTW96VHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcclxuICAgICdPVHJhbnNpdGlvbic6ICdvVHJhbnNpdGlvbkVuZCcsXHJcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJ1xyXG4gIH07XHJcbiAgdmFyIGFuaW1hdGlvbkVuZEV2ZW50TmFtZXMgPSB7XHJcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxyXG4gICAgJ01velRyYW5zaXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcclxuICAgICdPVHJhbnNpdGlvbic6ICdvQW5pbWF0aW9uRW5kJyxcclxuICAgICd0cmFuc2l0aW9uJzogJ2FuaW1hdGlvbmVuZCdcclxuICB9O1xyXG4gIGZ1bmN0aW9uIGZpbmRFbmRFdmVudE5hbWUoZW5kRXZlbnROYW1lcykge1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBlbmRFdmVudE5hbWVzKXtcclxuICAgICAgaWYgKHRyYW5zRWxlbWVudC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuZEV2ZW50TmFtZXNbbmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgJHRyYW5zaXRpb24udHJhbnNpdGlvbkVuZEV2ZW50TmFtZSA9IGZpbmRFbmRFdmVudE5hbWUodHJhbnNpdGlvbkVuZEV2ZW50TmFtZXMpO1xyXG4gICR0cmFuc2l0aW9uLmFuaW1hdGlvbkVuZEV2ZW50TmFtZSA9IGZpbmRFbmRFdmVudE5hbWUoYW5pbWF0aW9uRW5kRXZlbnROYW1lcyk7XHJcbiAgcmV0dXJuICR0cmFuc2l0aW9uO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNvbGxhcHNlJyxbJ3VpLmJvb3RzdHJhcC50cmFuc2l0aW9uJ10pXHJcblxyXG4vLyBUaGUgY29sbGFwc2libGUgZGlyZWN0aXZlIGluZGljYXRlcyBhIGJsb2NrIG9mIGh0bWwgdGhhdCB3aWxsIGV4cGFuZCBhbmQgY29sbGFwc2VcclxuLmRpcmVjdGl2ZSgnY29sbGFwc2UnLCBbJyR0cmFuc2l0aW9uJywgZnVuY3Rpb24oJHRyYW5zaXRpb24pIHtcclxuICAvLyBDU1MgdHJhbnNpdGlvbnMgZG9uJ3Qgd29yayB3aXRoIGhlaWdodDogYXV0bywgc28gd2UgaGF2ZSB0byBtYW51YWxseSBjaGFuZ2UgdGhlIGhlaWdodCB0byBhXHJcbiAgLy8gc3BlY2lmaWMgdmFsdWUgYW5kIHRoZW4gb25jZSB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcywgd2UgY2FuIHJlc2V0IHRoZSBoZWlnaHQgdG8gYXV0by5cclxuICAvLyBVbmZvcnR1bmF0ZWx5IGlmIHlvdSBkbyB0aGlzIHdoaWxlIHRoZSBDU1MgdHJhbnNpdGlvbnMgYXJlIHNwZWNpZmllZCAoaS5lLiBpbiB0aGUgQ1NTIGNsYXNzXHJcbiAgLy8gXCJjb2xsYXBzZVwiKSB0aGVuIHlvdSB0cmlnZ2VyIGEgY2hhbmdlIHRvIGhlaWdodCAwIGluIGJldHdlZW4uXHJcbiAgLy8gVGhlIGZpeCBpcyB0byByZW1vdmUgdGhlIFwiY29sbGFwc2VcIiBDU1MgY2xhc3Mgd2hpbGUgY2hhbmdpbmcgdGhlIGhlaWdodCBiYWNrIHRvIGF1dG8gLSBwaGV3IVxyXG4gIHZhciBmaXhVcEhlaWdodCA9IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBoZWlnaHQpIHtcclxuICAgIC8vIFdlIHJlbW92ZSB0aGUgY29sbGFwc2UgQ1NTIGNsYXNzIHRvIHByZXZlbnQgYSB0cmFuc2l0aW9uIHdoZW4gd2UgY2hhbmdlIHRvIGhlaWdodDogYXV0b1xyXG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKTtcclxuICAgIGVsZW1lbnQuY3NzKHsgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICAvLyBJdCBhcHBlYXJzIHRoYXQgIHJlYWRpbmcgb2Zmc2V0V2lkdGggbWFrZXMgdGhlIGJyb3dzZXIgcmVhbGlzZSB0aGF0IHdlIGhhdmUgY2hhbmdlZCB0aGVcclxuICAgIC8vIGhlaWdodCBhbHJlYWR5IDotL1xyXG4gICAgdmFyIHggPSBlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xyXG4gICAgZWxlbWVudC5hZGRDbGFzcygnY29sbGFwc2UnKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcblxyXG4gICAgICB2YXIgaXNDb2xsYXBzZWQ7XHJcbiAgICAgIHZhciBpbml0aWFsQW5pbVNraXAgPSB0cnVlO1xyXG4gICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCl7IHJldHVybiBlbGVtZW50WzBdLnNjcm9sbEhlaWdodDsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgLy9UaGUgbGlzdGVuZXIgaXMgY2FsbGVkIHdoZW4gc2NvbGxIZWlnaHQgY2hhbmdlc1xyXG4gICAgICAgIC8vSXQgYWN0dWFsbHkgZG9lcyBvbiAyIHNjZW5hcmlvczogXHJcbiAgICAgICAgLy8gMS4gUGFyZW50IGlzIHNldCB0byBkaXNwbGF5IG5vbmVcclxuICAgICAgICAvLyAyLiBhbmd1bGFyIGJpbmRpbmdzIGluc2lkZSBhcmUgcmVzb2x2ZWRcclxuICAgICAgICAvL1doZW4gd2UgaGF2ZSBhIGNoYW5nZSBvZiBzY3JvbGxIZWlnaHQgd2UgYXJlIHNldHRpbmcgYWdhaW4gdGhlIGNvcnJlY3QgaGVpZ2h0IGlmIHRoZSBncm91cCBpcyBvcGVuZWRcclxuICAgICAgICBpZiAoZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgIT09IDApIHtcclxuICAgICAgICAgIGlmICghaXNDb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxBbmltU2tpcCkge1xyXG4gICAgICAgICAgICAgIGZpeFVwSGVpZ2h0KHNjb3BlLCBlbGVtZW50LCBlbGVtZW50WzBdLnNjcm9sbEhlaWdodCArICdweCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGZpeFVwSGVpZ2h0KHNjb3BlLCBlbGVtZW50LCAnYXV0bycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHNjb3BlLiR3YXRjaChhdHRycy5jb2xsYXBzZSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgIGNvbGxhcHNlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGV4cGFuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG5cclxuICAgICAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uO1xyXG4gICAgICB2YXIgZG9UcmFuc2l0aW9uID0gZnVuY3Rpb24oY2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKCBjdXJyZW50VHJhbnNpdGlvbiApIHtcclxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9ICR0cmFuc2l0aW9uKGVsZW1lbnQsY2hhbmdlKTtcclxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi50aGVuKFxyXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IGN1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkOyB9LFxyXG4gICAgICAgICAgZnVuY3Rpb24oKSB7IGN1cnJlbnRUcmFuc2l0aW9uID0gdW5kZWZpbmVkOyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gY3VycmVudFRyYW5zaXRpb247XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZXhwYW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGluaXRpYWxBbmltU2tpcCkge1xyXG4gICAgICAgICAgaW5pdGlhbEFuaW1Ta2lwID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoICFpc0NvbGxhcHNlZCApIHtcclxuICAgICAgICAgICAgZml4VXBIZWlnaHQoc2NvcGUsIGVsZW1lbnQsICdhdXRvJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRvVHJhbnNpdGlvbih7IGhlaWdodCA6IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4JyB9KVxyXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSB1cGRhdGUgdGhlIGhlaWdodCBpZiB0aGUgdXNlciBoYXMgY2xvc2VkXHJcbiAgICAgICAgICAgIC8vIHRoZSBncm91cCB3aGlsZSB0aGUgYW5pbWF0aW9uIHdhcyBzdGlsbCBydW5uaW5nXHJcbiAgICAgICAgICAgIGlmICggIWlzQ29sbGFwc2VkICkge1xyXG4gICAgICAgICAgICAgIGZpeFVwSGVpZ2h0KHNjb3BlLCBlbGVtZW50LCAnYXV0bycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNDb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIHZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlzQ29sbGFwc2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaW5pdGlhbEFuaW1Ta2lwKSB7XHJcbiAgICAgICAgICBpbml0aWFsQW5pbVNraXAgPSBmYWxzZTtcclxuICAgICAgICAgIGZpeFVwSGVpZ2h0KHNjb3BlLCBlbGVtZW50LCAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZml4VXBIZWlnaHQoc2NvcGUsIGVsZW1lbnQsIGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4Jyk7XHJcbiAgICAgICAgICBkb1RyYW5zaXRpb24oeydoZWlnaHQnOicwJ30pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmFjY29yZGlvbicsIFsndWkuYm9vdHN0cmFwLmNvbGxhcHNlJ10pXHJcblxyXG4uY29uc3RhbnQoJ2FjY29yZGlvbkNvbmZpZycsIHtcclxuICBjbG9zZU90aGVyczogdHJ1ZVxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ0FjY29yZGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnYWNjb3JkaW9uQ29uZmlnJywgZnVuY3Rpb24gKCRzY29wZSwgJGF0dHJzLCBhY2NvcmRpb25Db25maWcpIHtcclxuICBcclxuICAvLyBUaGlzIGFycmF5IGtlZXBzIHRyYWNrIG9mIHRoZSBhY2NvcmRpb24gZ3JvdXBzXHJcbiAgdGhpcy5ncm91cHMgPSBbXTtcclxuXHJcbiAgLy8gRW5zdXJlIHRoYXQgYWxsIHRoZSBncm91cHMgaW4gdGhpcyBhY2NvcmRpb24gYXJlIGNsb3NlZCwgdW5sZXNzIGNsb3NlLW90aGVycyBleHBsaWNpdGx5IHNheXMgbm90IHRvXHJcbiAgdGhpcy5jbG9zZU90aGVycyA9IGZ1bmN0aW9uKG9wZW5Hcm91cCkge1xyXG4gICAgdmFyIGNsb3NlT3RoZXJzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmNsb3NlT3RoZXJzKSA/ICRzY29wZS4kZXZhbCgkYXR0cnMuY2xvc2VPdGhlcnMpIDogYWNjb3JkaW9uQ29uZmlnLmNsb3NlT3RoZXJzO1xyXG4gICAgaWYgKCBjbG9zZU90aGVycyApIHtcclxuICAgICAgYW5ndWxhci5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICBpZiAoIGdyb3VwICE9PSBvcGVuR3JvdXAgKSB7XHJcbiAgICAgICAgICBncm91cC5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gVGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSB0byBhZGQgaXRzZWxmIHRvIHRoZSBhY2NvcmRpb25cclxuICB0aGlzLmFkZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXBTY29wZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdGhpcy5ncm91cHMucHVzaChncm91cFNjb3BlKTtcclxuXHJcbiAgICBncm91cFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgdGhhdC5yZW1vdmVHcm91cChncm91cFNjb3BlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgd2hlbiB0byByZW1vdmUgaXRzZWxmXHJcbiAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdyb3Vwcy5pbmRleE9mKGdyb3VwKTtcclxuICAgIGlmICggaW5kZXggIT09IC0xICkge1xyXG4gICAgICB0aGlzLmdyb3Vwcy5zcGxpY2UodGhpcy5ncm91cHMuaW5kZXhPZihncm91cCksIDEpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG59XSlcclxuXHJcbi8vIFRoZSBhY2NvcmRpb24gZGlyZWN0aXZlIHNpbXBseSBzZXRzIHVwIHRoZSBkaXJlY3RpdmUgY29udHJvbGxlclxyXG4vLyBhbmQgYWRkcyBhbiBhY2NvcmRpb24gQ1NTIGNsYXNzIHRvIGl0c2VsZiBlbGVtZW50LlxyXG4uZGlyZWN0aXZlKCdhY2NvcmRpb24nLCBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OidFQScsXHJcbiAgICBjb250cm9sbGVyOidBY2NvcmRpb25Db250cm9sbGVyJyxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICByZXBsYWNlOiBmYWxzZSxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sJ1xyXG4gIH07XHJcbn0pXHJcblxyXG4vLyBUaGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSBpbmRpY2F0ZXMgYSBibG9jayBvZiBodG1sIHRoYXQgd2lsbCBleHBhbmQgYW5kIGNvbGxhcHNlIGluIGFuIGFjY29yZGlvblxyXG4uZGlyZWN0aXZlKCdhY2NvcmRpb25Hcm91cCcsIFsnJHBhcnNlJywgJyR0cmFuc2l0aW9uJywgJyR0aW1lb3V0JywgZnVuY3Rpb24oJHBhcnNlLCAkdHJhbnNpdGlvbiwgJHRpbWVvdXQpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTonXmFjY29yZGlvbicsICAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGRpcmVjdGl2ZSB0byBiZSBpbnNpZGUgYW4gYWNjb3JkaW9uXHJcbiAgICByZXN0cmljdDonRUEnLFxyXG4gICAgdHJhbnNjbHVkZTp0cnVlLCAgICAgICAgICAgICAgLy8gSXQgdHJhbnNjbHVkZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJlY3RpdmUgaW50byB0aGUgdGVtcGxhdGVcclxuICAgIHJlcGxhY2U6IHRydWUsICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHRlbXBsYXRlXHJcbiAgICB0ZW1wbGF0ZVVybDondGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sJyxcclxuICAgIHNjb3BlOnsgaGVhZGluZzonQCcgfSwgICAgICAgIC8vIENyZWF0ZSBhbiBpc29sYXRlZCBzY29wZSBhbmQgaW50ZXJwb2xhdGUgdGhlIGhlYWRpbmcgYXR0cmlidXRlIG9udG8gdGhpcyBzY29wZVxyXG4gICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgdGhpcy5zZXRIZWFkaW5nID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuaGVhZGluZyA9IGVsZW1lbnQ7XHJcbiAgICAgIH07XHJcbiAgICB9XSxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgYWNjb3JkaW9uQ3RybCkge1xyXG4gICAgICB2YXIgZ2V0SXNPcGVuLCBzZXRJc09wZW47XHJcblxyXG4gICAgICBhY2NvcmRpb25DdHJsLmFkZEdyb3VwKHNjb3BlKTtcclxuXHJcbiAgICAgIHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xyXG4gICAgICBcclxuICAgICAgaWYgKCBhdHRycy5pc09wZW4gKSB7XHJcbiAgICAgICAgZ2V0SXNPcGVuID0gJHBhcnNlKGF0dHJzLmlzT3Blbik7XHJcbiAgICAgICAgc2V0SXNPcGVuID0gZ2V0SXNPcGVuLmFzc2lnbjtcclxuXHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKFxyXG4gICAgICAgICAgZnVuY3Rpb24gd2F0Y2hJc09wZW4oKSB7IHJldHVybiBnZXRJc09wZW4oc2NvcGUuJHBhcmVudCk7IH0sXHJcbiAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVPcGVuKHZhbHVlKSB7IHNjb3BlLmlzT3BlbiA9IHZhbHVlOyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBzY29wZS5pc09wZW4gPSBnZXRJc09wZW4gPyBnZXRJc09wZW4oc2NvcGUuJHBhcmVudCkgOiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICggdmFsdWUgKSB7XHJcbiAgICAgICAgICBhY2NvcmRpb25DdHJsLmNsb3NlT3RoZXJzKHNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCBzZXRJc09wZW4gKSB7XHJcbiAgICAgICAgICBzZXRJc09wZW4oc2NvcGUuJHBhcmVudCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4vLyBVc2UgYWNjb3JkaW9uLWhlYWRpbmcgYmVsb3cgYW4gYWNjb3JkaW9uLWdyb3VwIHRvIHByb3ZpZGUgYSBoZWFkaW5nIGNvbnRhaW5pbmcgSFRNTFxyXG4vLyA8YWNjb3JkaW9uLWdyb3VwPlxyXG4vLyAgIDxhY2NvcmRpb24taGVhZGluZz5IZWFkaW5nIGNvbnRhaW5pbmcgSFRNTCAtIDxpbWcgc3JjPVwiLi4uXCI+PC9hY2NvcmRpb24taGVhZGluZz5cclxuLy8gPC9hY2NvcmRpb24tZ3JvdXA+XHJcbi5kaXJlY3RpdmUoJ2FjY29yZGlvbkhlYWRpbmcnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLCAgIC8vIEdyYWIgdGhlIGNvbnRlbnRzIHRvIGJlIHVzZWQgYXMgdGhlIGhlYWRpbmdcclxuICAgIHRlbXBsYXRlOiAnJywgICAgICAgLy8gSW4gZWZmZWN0IHJlbW92ZSB0aGlzIGVsZW1lbnQhXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgcmVxdWlyZTogJ15hY2NvcmRpb25Hcm91cCcsXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBhY2NvcmRpb25Hcm91cEN0cmwpIHtcclxuICAgICAgICAvLyBQYXNzIHRoZSBoZWFkaW5nIHRvIHRoZSBhY2NvcmRpb24tZ3JvdXAgY29udHJvbGxlclxyXG4gICAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIHRyYW5zY2x1ZGVkIGludG8gdGhlIHJpZ2h0IHBsYWNlIGluIHRoZSB0ZW1wbGF0ZVxyXG4gICAgICAgIC8vIFtUaGUgc2Vjb25kIHBhcmFtZXRlciB0byB0cmFuc2NsdWRlIGNhdXNlcyB0aGUgZWxlbWVudHMgdG8gYmUgY2xvbmVkIHNvIHRoYXQgdGhleSB3b3JrIGluIG5nLXJlcGVhdF1cclxuICAgICAgICBhY2NvcmRpb25Hcm91cEN0cmwuc2V0SGVhZGluZyh0cmFuc2NsdWRlKHNjb3BlLCBmdW5jdGlvbigpIHt9KSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufSlcclxuXHJcbi8vIFVzZSBpbiB0aGUgYWNjb3JkaW9uLWdyb3VwIHRlbXBsYXRlIHRvIGluZGljYXRlIHdoZXJlIHlvdSB3YW50IHRoZSBoZWFkaW5nIHRvIGJlIHRyYW5zY2x1ZGVkXHJcbi8vIFlvdSBtdXN0IHByb3ZpZGUgdGhlIHByb3BlcnR5IG9uIHRoZSBhY2NvcmRpb24tZ3JvdXAgY29udHJvbGxlciB0aGF0IHdpbGwgaG9sZCB0aGUgdHJhbnNjbHVkZWQgZWxlbWVudFxyXG4vLyA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uLWdyb3VwXCI+XHJcbi8vICAgPGRpdiBjbGFzcz1cImFjY29yZGlvbi1oZWFkaW5nXCIgPjxhIC4uLiBhY2NvcmRpb24tdHJhbnNjbHVkZT1cImhlYWRpbmdcIj4uLi48L2E+PC9kaXY+XHJcbi8vICAgLi4uXHJcbi8vIDwvZGl2PlxyXG4uZGlyZWN0aXZlKCdhY2NvcmRpb25UcmFuc2NsdWRlJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uR3JvdXAnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGNvbnRyb2xsZXIpIHtcclxuICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udHJvbGxlclthdHRyLmFjY29yZGlvblRyYW5zY2x1ZGVdOyB9LCBmdW5jdGlvbihoZWFkaW5nKSB7XHJcbiAgICAgICAgaWYgKCBoZWFkaW5nICkge1xyXG4gICAgICAgICAgZWxlbWVudC5odG1sKCcnKTtcclxuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKGhlYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcC5hbGVydFwiLCBbXSkuZGlyZWN0aXZlKCdhbGVydCcsIGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6J0VBJyxcclxuICAgIHRlbXBsYXRlVXJsOid0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sJyxcclxuICAgIHRyYW5zY2x1ZGU6dHJ1ZSxcclxuICAgIHJlcGxhY2U6dHJ1ZSxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIHR5cGU6ICc9JyxcclxuICAgICAgY2xvc2U6ICcmJ1xyXG4gICAgfSxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBpRWxlbWVudCwgaUF0dHJzLCBjb250cm9sbGVyKSB7XHJcbiAgICAgIHNjb3BlLmNsb3NlYWJsZSA9IFwiY2xvc2VcIiBpbiBpQXR0cnM7XHJcbiAgICB9XHJcbiAgfTtcclxufSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJpbmRIdG1sJywgW10pXHJcblxyXG4gIC5kaXJlY3RpdmUoJ2JpbmRIdG1sVW5zYWZlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgICBlbGVtZW50LmFkZENsYXNzKCduZy1iaW5kaW5nJykuZGF0YSgnJGJpbmRpbmcnLCBhdHRyLmJpbmRIdG1sVW5zYWZlKTtcclxuICAgICAgc2NvcGUuJHdhdGNoKGF0dHIuYmluZEh0bWxVbnNhZmUsIGZ1bmN0aW9uIGJpbmRIdG1sVW5zYWZlV2F0Y2hBY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBlbGVtZW50Lmh0bWwodmFsdWUgfHwgJycpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYnV0dG9ucycsIFtdKVxyXG5cclxuICAuY29uc3RhbnQoJ2J1dHRvbkNvbmZpZycsIHtcclxuICAgIGFjdGl2ZUNsYXNzOidhY3RpdmUnLFxyXG4gICAgdG9nZ2xlRXZlbnQ6J2NsaWNrJ1xyXG4gIH0pXHJcblxyXG4gIC5kaXJlY3RpdmUoJ2J0blJhZGlvJywgWydidXR0b25Db25maWcnLCBmdW5jdGlvbiAoYnV0dG9uQ29uZmlnKSB7XHJcbiAgdmFyIGFjdGl2ZUNsYXNzID0gYnV0dG9uQ29uZmlnLmFjdGl2ZUNsYXNzIHx8ICdhY3RpdmUnO1xyXG4gIHZhciB0b2dnbGVFdmVudCA9IGJ1dHRvbkNvbmZpZy50b2dnbGVFdmVudCB8fCAnY2xpY2snO1xyXG5cclxuICByZXR1cm4ge1xyXG5cclxuICAgIHJlcXVpcmU6J25nTW9kZWwnLFxyXG4gICAgbGluazpmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsQ3RybCkge1xyXG5cclxuICAgICAgLy9tb2RlbCAtPiBVSVxyXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBzY29wZS4kZXZhbChhdHRycy5idG5SYWRpbykpKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vdWktPm1vZGVsXHJcbiAgICAgIGVsZW1lbnQuYmluZCh0b2dnbGVFdmVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghZWxlbWVudC5oYXNDbGFzcyhhY3RpdmVDbGFzcykpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoc2NvcGUuJGV2YWwoYXR0cnMuYnRuUmFkaW8pKTtcclxuICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgnYnRuQ2hlY2tib3gnLCBbJ2J1dHRvbkNvbmZpZycsIGZ1bmN0aW9uIChidXR0b25Db25maWcpIHtcclxuXHJcbiAgdmFyIGFjdGl2ZUNsYXNzID0gYnV0dG9uQ29uZmlnLmFjdGl2ZUNsYXNzIHx8ICdhY3RpdmUnO1xyXG4gIHZhciB0b2dnbGVFdmVudCA9IGJ1dHRvbkNvbmZpZy50b2dnbGVFdmVudCB8fCAnY2xpY2snO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTonbmdNb2RlbCcsXHJcbiAgICBsaW5rOmZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDdHJsKSB7XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRUcnVlVmFsdWUoKSB7XHJcbiAgICAgICAgdmFyIHRydWVWYWx1ZSA9IHNjb3BlLiRldmFsKGF0dHJzLmJ0bkNoZWNrYm94VHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKHRydWVWYWx1ZSkgPyB0cnVlVmFsdWUgOiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRGYWxzZVZhbHVlKCkge1xyXG4gICAgICAgIHZhciBmYWxzZVZhbHVlID0gc2NvcGUuJGV2YWwoYXR0cnMuYnRuQ2hlY2tib3hGYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKGZhbHNlVmFsdWUpID8gZmFsc2VWYWx1ZSA6IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL21vZGVsIC0+IFVJXHJcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyhhY3RpdmVDbGFzcywgYW5ndWxhci5lcXVhbHMobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUsIGdldFRydWVWYWx1ZSgpKSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvL3VpLT5tb2RlbFxyXG4gICAgICBlbGVtZW50LmJpbmQodG9nZ2xlRXZlbnQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShlbGVtZW50Lmhhc0NsYXNzKGFjdGl2ZUNsYXNzKSA/IGdldEZhbHNlVmFsdWUoKSA6IGdldFRydWVWYWx1ZSgpKTtcclxuICAgICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG4vKipcclxuKiBAbmdkb2Mgb3ZlcnZpZXdcclxuKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWxcclxuKlxyXG4qIEBkZXNjcmlwdGlvblxyXG4qIEFuZ3VsYXJKUyB2ZXJzaW9uIG9mIGFuIGltYWdlIGNhcm91c2VsLlxyXG4qXHJcbiovXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuY2Fyb3VzZWwnLCBbJ3VpLmJvb3RzdHJhcC50cmFuc2l0aW9uJ10pXHJcbi5jb250cm9sbGVyKCdDYXJvdXNlbENvbnRyb2xsZXInLCBbJyRzY29wZScsICckdGltZW91dCcsICckdHJhbnNpdGlvbicsICckcScsIGZ1bmN0aW9uICgkc2NvcGUsICR0aW1lb3V0LCAkdHJhbnNpdGlvbiwgJHEpIHtcclxuICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICBzbGlkZXMgPSBzZWxmLnNsaWRlcyA9IFtdLFxyXG4gICAgY3VycmVudEluZGV4ID0gLTEsXHJcbiAgICBjdXJyZW50VGltZW91dCwgaXNQbGF5aW5nO1xyXG4gIHNlbGYuY3VycmVudFNsaWRlID0gbnVsbDtcclxuXHJcbiAgLyogZGlyZWN0aW9uOiBcInByZXZcIiBvciBcIm5leHRcIiAqL1xyXG4gIHNlbGYuc2VsZWN0ID0gZnVuY3Rpb24obmV4dFNsaWRlLCBkaXJlY3Rpb24pIHtcclxuICAgIHZhciBuZXh0SW5kZXggPSBzbGlkZXMuaW5kZXhPZihuZXh0U2xpZGUpO1xyXG4gICAgLy9EZWNpZGUgZGlyZWN0aW9uIGlmIGl0J3Mgbm90IGdpdmVuXHJcbiAgICBpZiAoZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZGlyZWN0aW9uID0gbmV4dEluZGV4ID4gY3VycmVudEluZGV4ID8gXCJuZXh0XCIgOiBcInByZXZcIjtcclxuICAgIH1cclxuICAgIGlmIChuZXh0U2xpZGUgJiYgbmV4dFNsaWRlICE9PSBzZWxmLmN1cnJlbnRTbGlkZSkge1xyXG4gICAgICBpZiAoJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xyXG4gICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24uY2FuY2VsKCk7XHJcbiAgICAgICAgLy9UaW1lb3V0IHNvIG5nLWNsYXNzIGluIHRlbXBsYXRlIGhhcyB0aW1lIHRvIGZpeCBjbGFzc2VzIGZvciBmaW5pc2hlZCBzbGlkZVxyXG4gICAgICAgICR0aW1lb3V0KGdvTmV4dCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ29OZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdvTmV4dCgpIHtcclxuICAgICAgLy9JZiB3ZSBoYXZlIGEgc2xpZGUgdG8gdHJhbnNpdGlvbiBmcm9tIGFuZCB3ZSBoYXZlIGEgdHJhbnNpdGlvbiB0eXBlIGFuZCB3ZSdyZSBhbGxvd2VkLCBnb1xyXG4gICAgICBpZiAoc2VsZi5jdXJyZW50U2xpZGUgJiYgYW5ndWxhci5pc1N0cmluZyhkaXJlY3Rpb24pICYmICEkc2NvcGUubm9UcmFuc2l0aW9uICYmIG5leHRTbGlkZS4kZWxlbWVudCkge1xyXG4gICAgICAgIC8vV2Ugc2hvdWxkbid0IGRvIGNsYXNzIG1hbmlwIGluIGhlcmUsIGJ1dCBpdCdzIHRoZSBzYW1lIHdlaXJkIHRoaW5nIGJvb3RzdHJhcCBkb2VzLiBuZWVkIHRvIGZpeCBzb21ldGltZVxyXG4gICAgICAgIG5leHRTbGlkZS4kZWxlbWVudC5hZGRDbGFzcyhkaXJlY3Rpb24pO1xyXG4gICAgICAgIHZhciByZWZsb3cgPSBuZXh0U2xpZGUuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7IC8vZm9yY2UgcmVmbG93XHJcblxyXG4gICAgICAgIC8vU2V0IGFsbCBvdGhlciBzbGlkZXMgdG8gc3RvcCBkb2luZyB0aGVpciBzdHVmZiBmb3IgdGhlIG5ldyB0cmFuc2l0aW9uXHJcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNsaWRlcywgZnVuY3Rpb24oc2xpZGUpIHtcclxuICAgICAgICAgIGFuZ3VsYXIuZXh0ZW5kKHNsaWRlLCB7ZGlyZWN0aW9uOiAnJywgZW50ZXJpbmc6IGZhbHNlLCBsZWF2aW5nOiBmYWxzZSwgYWN0aXZlOiBmYWxzZX0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFuZ3VsYXIuZXh0ZW5kKG5leHRTbGlkZSwge2RpcmVjdGlvbjogZGlyZWN0aW9uLCBhY3RpdmU6IHRydWUsIGVudGVyaW5nOiB0cnVlfSk7XHJcbiAgICAgICAgYW5ndWxhci5leHRlbmQoc2VsZi5jdXJyZW50U2xpZGV8fHt9LCB7ZGlyZWN0aW9uOiBkaXJlY3Rpb24sIGxlYXZpbmc6IHRydWV9KTtcclxuXHJcbiAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9ICR0cmFuc2l0aW9uKG5leHRTbGlkZS4kZWxlbWVudCwge30pO1xyXG4gICAgICAgIC8vV2UgaGF2ZSB0byBjcmVhdGUgbmV3IHBvaW50ZXJzIGluc2lkZSBhIGNsb3N1cmUgc2luY2UgbmV4dCAmIGN1cnJlbnQgd2lsbCBjaGFuZ2VcclxuICAgICAgICAoZnVuY3Rpb24obmV4dCxjdXJyZW50KSB7XHJcbiAgICAgICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uLnRoZW4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCl7IHRyYW5zaXRpb25Eb25lKG5leHQsIGN1cnJlbnQpOyB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbigpeyB0cmFuc2l0aW9uRG9uZShuZXh0LCBjdXJyZW50KTsgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KG5leHRTbGlkZSwgc2VsZi5jdXJyZW50U2xpZGUpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cmFuc2l0aW9uRG9uZShuZXh0U2xpZGUsIHNlbGYuY3VycmVudFNsaWRlKTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLmN1cnJlbnRTbGlkZSA9IG5leHRTbGlkZTtcclxuICAgICAgY3VycmVudEluZGV4ID0gbmV4dEluZGV4O1xyXG4gICAgICAvL2V2ZXJ5IHRpbWUgeW91IGNoYW5nZSBzbGlkZXMsIHJlc2V0IHRoZSB0aW1lclxyXG4gICAgICByZXN0YXJ0VGltZXIoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb25Eb25lKG5leHQsIGN1cnJlbnQpIHtcclxuICAgICAgYW5ndWxhci5leHRlbmQobmV4dCwge2RpcmVjdGlvbjogJycsIGFjdGl2ZTogdHJ1ZSwgbGVhdmluZzogZmFsc2UsIGVudGVyaW5nOiBmYWxzZX0pO1xyXG4gICAgICBhbmd1bGFyLmV4dGVuZChjdXJyZW50fHx7fSwge2RpcmVjdGlvbjogJycsIGFjdGl2ZTogZmFsc2UsIGxlYXZpbmc6IGZhbHNlLCBlbnRlcmluZzogZmFsc2V9KTtcclxuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyogQWxsb3cgb3V0c2lkZSBwZW9wbGUgdG8gY2FsbCBpbmRleE9mIG9uIHNsaWRlcyBhcnJheSAqL1xyXG4gIHNlbGYuaW5kZXhPZlNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcclxuICAgIHJldHVybiBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLm5leHQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBuZXdJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIHNsaWRlcy5sZW5ndGg7XHJcblxyXG4gICAgLy9QcmV2ZW50IHRoaXMgdXNlci10cmlnZ2VyZWQgdHJhbnNpdGlvbiBmcm9tIG9jY3VycmluZyBpZiB0aGVyZSBpcyBhbHJlYWR5IG9uZSBpbiBwcm9ncmVzc1xyXG4gICAgaWYgKCEkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgIHJldHVybiBzZWxmLnNlbGVjdChzbGlkZXNbbmV3SW5kZXhdLCAnbmV4dCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRzY29wZS5wcmV2ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbmV3SW5kZXggPSBjdXJyZW50SW5kZXggLSAxIDwgMCA/IHNsaWRlcy5sZW5ndGggLSAxIDogY3VycmVudEluZGV4IC0gMTtcclxuXHJcbiAgICAvL1ByZXZlbnQgdGhpcyB1c2VyLXRyaWdnZXJlZCB0cmFuc2l0aW9uIGZyb20gb2NjdXJyaW5nIGlmIHRoZXJlIGlzIGFscmVhZHkgb25lIGluIHByb2dyZXNzXHJcbiAgICBpZiAoISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24pIHtcclxuICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0KHNsaWRlc1tuZXdJbmRleF0sICdwcmV2Jyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKHNsaWRlKSB7XHJcbiAgICBzZWxmLnNlbGVjdChzbGlkZSk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24oc2xpZGUpIHtcclxuICAgICByZXR1cm4gc2VsZi5jdXJyZW50U2xpZGUgPT09IHNsaWRlO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5zbGlkZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBzbGlkZXM7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgnaW50ZXJ2YWwnLCByZXN0YXJ0VGltZXIpO1xyXG4gIGZ1bmN0aW9uIHJlc3RhcnRUaW1lcigpIHtcclxuICAgIGlmIChjdXJyZW50VGltZW91dCkge1xyXG4gICAgICAkdGltZW91dC5jYW5jZWwoY3VycmVudFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ28oKSB7XHJcbiAgICAgIGlmIChpc1BsYXlpbmcpIHtcclxuICAgICAgICAkc2NvcGUubmV4dCgpO1xyXG4gICAgICAgIHJlc3RhcnRUaW1lcigpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICRzY29wZS5wYXVzZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xyXG4gICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWw+PTApIHtcclxuICAgICAgY3VycmVudFRpbWVvdXQgPSAkdGltZW91dChnbywgaW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICAkc2NvcGUucGxheSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCFpc1BsYXlpbmcpIHtcclxuICAgICAgaXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgcmVzdGFydFRpbWVyKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICAkc2NvcGUucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghJHNjb3BlLm5vUGF1c2UpIHtcclxuICAgICAgaXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgIGlmIChjdXJyZW50VGltZW91dCkge1xyXG4gICAgICAgICR0aW1lb3V0LmNhbmNlbChjdXJyZW50VGltZW91dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzZWxmLmFkZFNsaWRlID0gZnVuY3Rpb24oc2xpZGUsIGVsZW1lbnQpIHtcclxuICAgIHNsaWRlLiRlbGVtZW50ID0gZWxlbWVudDtcclxuICAgIHNsaWRlcy5wdXNoKHNsaWRlKTtcclxuICAgIC8vaWYgdGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGUgb3IgdGhlIHNsaWRlIGlzIHNldCB0byBhY3RpdmUsIHNlbGVjdCBpdFxyXG4gICAgaWYoc2xpZGVzLmxlbmd0aCA9PT0gMSB8fCBzbGlkZS5hY3RpdmUpIHtcclxuICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW3NsaWRlcy5sZW5ndGgtMV0pO1xyXG4gICAgICBpZiAoc2xpZGVzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgJHNjb3BlLnBsYXkoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2xpZGUuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5yZW1vdmVTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XHJcbiAgICAvL2dldCB0aGUgaW5kZXggb2YgdGhlIHNsaWRlIGluc2lkZSB0aGUgY2Fyb3VzZWxcclxuICAgIHZhciBpbmRleCA9IHNsaWRlcy5pbmRleE9mKHNsaWRlKTtcclxuICAgIHNsaWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgaWYgKHNsaWRlcy5sZW5ndGggPiAwICYmIHNsaWRlLmFjdGl2ZSkge1xyXG4gICAgICBpZiAoaW5kZXggPj0gc2xpZGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tpbmRleC0xXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2luZGV4XSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY3VycmVudEluZGV4ID4gaW5kZXgpIHtcclxuICAgICAgY3VycmVudEluZGV4LS07XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOmNhcm91c2VsXHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ2Fyb3VzZWwgaXMgdGhlIG91dGVyIGNvbnRhaW5lciBmb3IgYSBzZXQgb2YgaW1hZ2UgJ3NsaWRlcycgdG8gc2hvd2Nhc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaW50ZXJ2YWwgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdGhhdCBpdCB3aWxsIHRha2UgdGhlIGNhcm91c2VsIHRvIGdvIHRvIHRoZSBuZXh0IHNsaWRlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1RyYW5zaXRpb24gV2hldGhlciB0byBkaXNhYmxlIHRyYW5zaXRpb25zIG9uIHRoZSBjYXJvdXNlbC5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbm9QYXVzZSBXaGV0aGVyIHRvIGRpc2FibGUgcGF1c2luZyBvbiB0aGUgY2Fyb3VzZWwgKGJ5IGRlZmF1bHQsIHRoZSBjYXJvdXNlbCBpbnRlcnZhbCBwYXVzZXMgb24gaG92ZXIpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cclxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgPGNhcm91c2VsPlxyXG4gICAgICA8c2xpZGU+XHJcbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzE1MC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XHJcbiAgICAgICAgICA8cD5CZWF1dGlmdWwhPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L3NsaWRlPlxyXG4gICAgICA8c2xpZGU+XHJcbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzEwMC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XHJcbiAgICAgICAgICA8cD5EJ2F3dyE8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvc2xpZGU+XHJcbiAgICA8L2Nhcm91c2VsPlxyXG4gIDwvZmlsZT5cclxuICA8ZmlsZSBuYW1lPVwiZGVtby5jc3NcIj5cclxuICAgIC5jYXJvdXNlbC1pbmRpY2F0b3JzIHtcclxuICAgICAgdG9wOiBhdXRvO1xyXG4gICAgICBib3R0b206IDE1cHg7XHJcbiAgICB9XHJcbiAgPC9maWxlPlxyXG48L2V4YW1wbGU+XHJcbiAqL1xyXG4uZGlyZWN0aXZlKCdjYXJvdXNlbCcsIFtmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIGNvbnRyb2xsZXI6ICdDYXJvdXNlbENvbnRyb2xsZXInLFxyXG4gICAgcmVxdWlyZTogJ2Nhcm91c2VsJyxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbCcsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBpbnRlcnZhbDogJz0nLFxyXG4gICAgICBub1RyYW5zaXRpb246ICc9JyxcclxuICAgICAgbm9QYXVzZTogJz0nXHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOnNsaWRlXHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIHNsaWRlIGluc2lkZSBhIHtAbGluayB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOmNhcm91c2VsIGNhcm91c2VsfS4gIE11c3QgYmUgcGxhY2VkIGFzIGEgY2hpbGQgb2YgYSBjYXJvdXNlbCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBhY3RpdmUgTW9kZWwgYmluZGluZywgd2hldGhlciBvciBub3QgdGhpcyBzbGlkZSBpcyBjdXJyZW50bHkgYWN0aXZlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cclxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG48ZGl2IG5nLWNvbnRyb2xsZXI9XCJDYXJvdXNlbERlbW9DdHJsXCI+XHJcbiAgPGNhcm91c2VsPlxyXG4gICAgPHNsaWRlIG5nLXJlcGVhdD1cInNsaWRlIGluIHNsaWRlc1wiIGFjdGl2ZT1cInNsaWRlLmFjdGl2ZVwiPlxyXG4gICAgICA8aW1nIG5nLXNyYz1cInt7c2xpZGUuaW1hZ2V9fVwiIHN0eWxlPVwibWFyZ2luOmF1dG87XCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XHJcbiAgICAgICAgPGg0PlNsaWRlIHt7JGluZGV4fX08L2g0PlxyXG4gICAgICAgIDxwPnt7c2xpZGUudGV4dH19PC9wPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvc2xpZGU+XHJcbiAgPC9jYXJvdXNlbD5cclxuICA8ZGl2IGNsYXNzPVwicm93LWZsdWlkXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwic3BhbjZcIj5cclxuICAgICAgPHVsPlxyXG4gICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJzbGlkZSBpbiBzbGlkZXNcIj5cclxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW1pbmlcIiBuZy1jbGFzcz1cInsnYnRuLWluZm8nOiAhc2xpZGUuYWN0aXZlLCAnYnRuLXN1Y2Nlc3MnOiBzbGlkZS5hY3RpdmV9XCIgbmctZGlzYWJsZWQ9XCJzbGlkZS5hY3RpdmVcIiBuZy1jbGljaz1cInNsaWRlLmFjdGl2ZSA9IHRydWVcIj5zZWxlY3Q8L2J1dHRvbj5cclxuICAgICAgICAgIHt7JGluZGV4fX06IHt7c2xpZGUudGV4dH19XHJcbiAgICAgICAgPC9saT5cclxuICAgICAgPC91bD5cclxuICAgICAgPGEgY2xhc3M9XCJidG5cIiBuZy1jbGljaz1cImFkZFNsaWRlKClcIj5BZGQgU2xpZGU8L2E+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJzcGFuNlwiPlxyXG4gICAgICBJbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5nLW1vZGVsPVwibXlJbnRlcnZhbFwiPlxyXG4gICAgICA8YnIgLz5FbnRlciBhIG5lZ2F0aXZlIG51bWJlciB0byBzdG9wIHRoZSBpbnRlcnZhbC5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuICA8L2ZpbGU+XHJcbiAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxyXG5mdW5jdGlvbiBDYXJvdXNlbERlbW9DdHJsKCRzY29wZSkge1xyXG4gICRzY29wZS5teUludGVydmFsID0gNTAwMDtcclxuICB2YXIgc2xpZGVzID0gJHNjb3BlLnNsaWRlcyA9IFtdO1xyXG4gICRzY29wZS5hZGRTbGlkZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5ld1dpZHRoID0gMjAwICsgKChzbGlkZXMubGVuZ3RoICsgKDI1ICogc2xpZGVzLmxlbmd0aCkpICUgMTUwKTtcclxuICAgIHNsaWRlcy5wdXNoKHtcclxuICAgICAgaW1hZ2U6ICdodHRwOi8vcGxhY2VraXR0ZW4uY29tLycgKyBuZXdXaWR0aCArICcvMjAwJyxcclxuICAgICAgdGV4dDogWydNb3JlJywnRXh0cmEnLCdMb3RzIG9mJywnU3VycGx1cyddW3NsaWRlcy5sZW5ndGggJSA0XSArICcgJ1xyXG4gICAgICAgIFsnQ2F0cycsICdLaXR0eXMnLCAnRmVsaW5lcycsICdDdXRlcyddW3NsaWRlcy5sZW5ndGggJSA0XVxyXG4gICAgfSk7XHJcbiAgfTtcclxuICBmb3IgKHZhciBpPTA7IGk8NDsgaSsrKSAkc2NvcGUuYWRkU2xpZGUoKTtcclxufVxyXG4gIDwvZmlsZT5cclxuICA8ZmlsZSBuYW1lPVwiZGVtby5jc3NcIj5cclxuICAgIC5jYXJvdXNlbC1pbmRpY2F0b3JzIHtcclxuICAgICAgdG9wOiBhdXRvO1xyXG4gICAgICBib3R0b206IDE1cHg7XHJcbiAgICB9XHJcbiAgPC9maWxlPlxyXG48L2V4YW1wbGU+XHJcbiovXHJcblxyXG4uZGlyZWN0aXZlKCdzbGlkZScsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6ICdeY2Fyb3VzZWwnLFxyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbCcsXHJcbiAgICBzY29wZToge1xyXG4gICAgfSxcclxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNhcm91c2VsQ3RybCkge1xyXG4gICAgICAvL1NldCB1cCBvcHRpb25hbCAnYWN0aXZlJyA9IGJpbmRpbmdcclxuICAgICAgaWYgKGF0dHJzLmFjdGl2ZSkge1xyXG4gICAgICAgIHZhciBnZXRBY3RpdmUgPSAkcGFyc2UoYXR0cnMuYWN0aXZlKTtcclxuICAgICAgICB2YXIgc2V0QWN0aXZlID0gZ2V0QWN0aXZlLmFzc2lnbjtcclxuICAgICAgICB2YXIgbGFzdFZhbHVlID0gc2NvcGUuYWN0aXZlID0gZ2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQpO1xyXG4gICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbiBwYXJlbnRBY3RpdmVXYXRjaCgpIHtcclxuICAgICAgICAgIHZhciBwYXJlbnRBY3RpdmUgPSBnZXRBY3RpdmUoc2NvcGUuJHBhcmVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKHBhcmVudEFjdGl2ZSAhPT0gc2NvcGUuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGFyZSBvdXQgb2Ygc3luYyBhbmQgbmVlZCB0byBjb3B5XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRBY3RpdmUgIT09IGxhc3RWYWx1ZSkge1xyXG4gICAgICAgICAgICAgIC8vIHBhcmVudCBjaGFuZ2VkIGFuZCBpdCBoYXMgcHJlY2VkZW5jZVxyXG4gICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHNjb3BlLmFjdGl2ZSA9IHBhcmVudEFjdGl2ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGNhbiBiZSBhc3NpZ25lZCB0aGVuIGRvIHNvXHJcbiAgICAgICAgICAgICAgc2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQsIHBhcmVudEFjdGl2ZSA9IGxhc3RWYWx1ZSA9IHNjb3BlLmFjdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBwYXJlbnRBY3RpdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhcm91c2VsQ3RybC5hZGRTbGlkZShzY29wZSwgZWxlbWVudCk7XHJcbiAgICAgIC8vd2hlbiB0aGUgc2NvcGUgaXMgZGVzdHJveWVkIHRoZW4gcmVtb3ZlIHRoZSBzbGlkZSBmcm9tIHRoZSBjdXJyZW50IHNsaWRlcyBhcnJheVxyXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2Fyb3VzZWxDdHJsLnJlbW92ZVNsaWRlKHNjb3BlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzY29wZS4kd2F0Y2goJ2FjdGl2ZScsIGZ1bmN0aW9uKGFjdGl2ZSkge1xyXG4gICAgICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgICAgIGNhcm91c2VsQ3RybC5zZWxlY3Qoc2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsIFtdKVxyXG5cclxuLyoqXHJcbiAqIEEgc2V0IG9mIHV0aWxpdHkgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2UgdG8gcmV0cmlldmUgcG9zaXRpb24gb2YgRE9NIGVsZW1lbnRzLlxyXG4gKiBJdCBpcyBtZWFudCB0byBiZSB1c2VkIHdoZXJlIHdlIG5lZWQgdG8gYWJzb2x1dGUtcG9zaXRpb24gRE9NIGVsZW1lbnRzIGluXHJcbiAqIHJlbGF0aW9uIHRvIG90aGVyLCBleGlzdGluZyBlbGVtZW50cyAodGhpcyBpcyB0aGUgY2FzZSBmb3IgdG9vbHRpcHMsIHBvcG92ZXJzLFxyXG4gKiB0eXBlYWhlYWQgc3VnZ2VzdGlvbnMgZXRjLikuXHJcbiAqL1xyXG4gIC5mYWN0b3J5KCckcG9zaXRpb24nLCBbJyRkb2N1bWVudCcsICckd2luZG93JywgZnVuY3Rpb24gKCRkb2N1bWVudCwgJHdpbmRvdykge1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBjc3Nwcm9wKSB7XHJcbiAgICAgIGlmIChlbC5jdXJyZW50U3R5bGUpIHsgLy9JRVxyXG4gICAgICAgIHJldHVybiBlbC5jdXJyZW50U3R5bGVbY3NzcHJvcF07XHJcbiAgICAgIH0gZWxzZSBpZiAoJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XHJcbiAgICAgICAgcmV0dXJuICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClbY3NzcHJvcF07XHJcbiAgICAgIH1cclxuICAgICAgLy8gZmluYWxseSB0cnkgYW5kIGdldCBpbmxpbmUgc3R5bGVcclxuICAgICAgcmV0dXJuIGVsLnN0eWxlW2Nzc3Byb3BdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBzdGF0aWNhbGx5IHBvc2l0aW9uZWRcclxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gcmF3IERPTSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiAoZ2V0U3R5bGUoZWxlbWVudCwgXCJwb3NpdGlvblwiKSB8fCAnc3RhdGljJyApID09PSAnc3RhdGljJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIGNsb3Nlc3QsIG5vbi1zdGF0aWNhbGx5IHBvc2l0aW9uZWQgcGFyZW50T2Zmc2V0IG9mIGEgZ2l2ZW4gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgdmFyIHBhcmVudE9mZnNldEVsID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIGRvY0RvbUVsID0gJGRvY3VtZW50WzBdO1xyXG4gICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgZG9jRG9tRWw7XHJcbiAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBkb2NEb21FbCAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSApIHtcclxuICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRG9tRWw7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBwb3NpdGlvbiBmdW5jdGlvbjpcclxuICAgICAgICogaHR0cDovL2FwaS5qcXVlcnkuY29tL3Bvc2l0aW9uL1xyXG4gICAgICAgKi9cclxuICAgICAgcG9zaXRpb246IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGVsQkNSID0gdGhpcy5vZmZzZXQoZWxlbWVudCk7XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEJDUiA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEVsID0gcGFyZW50T2Zmc2V0RWwoZWxlbWVudFswXSk7XHJcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudEVsICE9ICRkb2N1bWVudFswXSkge1xyXG4gICAgICAgICAgb2Zmc2V0UGFyZW50QkNSID0gdGhpcy5vZmZzZXQoYW5ndWxhci5lbGVtZW50KG9mZnNldFBhcmVudEVsKSk7XHJcbiAgICAgICAgICBvZmZzZXRQYXJlbnRCQ1IudG9wICs9IG9mZnNldFBhcmVudEVsLmNsaWVudFRvcCAtIG9mZnNldFBhcmVudEVsLnNjcm9sbFRvcDtcclxuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi5sZWZ0ICs9IG9mZnNldFBhcmVudEVsLmNsaWVudExlZnQgLSBvZmZzZXRQYXJlbnRFbC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHdpZHRoOiBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXHJcbiAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXHJcbiAgICAgICAgICB0b3A6IGVsQkNSLnRvcCAtIG9mZnNldFBhcmVudEJDUi50b3AsXHJcbiAgICAgICAgICBsZWZ0OiBlbEJDUi5sZWZ0IC0gb2Zmc2V0UGFyZW50QkNSLmxlZnRcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBlcXVpdmFsZW50IG9mIGpRdWVyeSdzIG9mZnNldCBmdW5jdGlvbjpcclxuICAgICAgICogaHR0cDovL2FwaS5qcXVlcnkuY29tL29mZnNldC9cclxuICAgICAgICovXHJcbiAgICAgIG9mZnNldDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgd2lkdGg6IGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSxcclxuICAgICAgICAgIGhlaWdodDogZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKSxcclxuICAgICAgICAgIHRvcDogYm91bmRpbmdDbGllbnRSZWN0LnRvcCArICgkd2luZG93LnBhZ2VZT2Zmc2V0IHx8ICRkb2N1bWVudFswXS5ib2R5LnNjcm9sbFRvcCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXHJcbiAgICAgICAgICBsZWZ0OiBib3VuZGluZ0NsaWVudFJlY3QubGVmdCArICgkd2luZG93LnBhZ2VYT2Zmc2V0IHx8ICRkb2N1bWVudFswXS5ib2R5LnNjcm9sbExlZnQgIHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdClcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlcicsIFsndWkuYm9vdHN0cmFwLnBvc2l0aW9uJ10pXHJcblxyXG4uY29uc3RhbnQoJ2RhdGVwaWNrZXJDb25maWcnLCB7XHJcbiAgZGF5Rm9ybWF0OiAnZGQnLFxyXG4gIG1vbnRoRm9ybWF0OiAnTU1NTScsXHJcbiAgeWVhckZvcm1hdDogJ3l5eXknLFxyXG4gIGRheUhlYWRlckZvcm1hdDogJ0VFRScsXHJcbiAgZGF5VGl0bGVGb3JtYXQ6ICdNTU1NIHl5eXknLFxyXG4gIG1vbnRoVGl0bGVGb3JtYXQ6ICd5eXl5JyxcclxuICBzaG93V2Vla3M6IHRydWUsXHJcbiAgc3RhcnRpbmdEYXk6IDAsXHJcbiAgeWVhclJhbmdlOiAyMCxcclxuICBtaW5EYXRlOiBudWxsLFxyXG4gIG1heERhdGU6IG51bGxcclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdEYXRlcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICdkYXRlRmlsdGVyJywgJ2RhdGVwaWNrZXJDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgZGF0ZUZpbHRlciwgZHRDb25maWcpIHtcclxuICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgZGF5OiAgICAgICAgZ2V0VmFsdWUoJGF0dHJzLmRheUZvcm1hdCwgICAgICAgIGR0Q29uZmlnLmRheUZvcm1hdCksXHJcbiAgICBtb250aDogICAgICBnZXRWYWx1ZSgkYXR0cnMubW9udGhGb3JtYXQsICAgICAgZHRDb25maWcubW9udGhGb3JtYXQpLFxyXG4gICAgeWVhcjogICAgICAgZ2V0VmFsdWUoJGF0dHJzLnllYXJGb3JtYXQsICAgICAgIGR0Q29uZmlnLnllYXJGb3JtYXQpLFxyXG4gICAgZGF5SGVhZGVyOiAgZ2V0VmFsdWUoJGF0dHJzLmRheUhlYWRlckZvcm1hdCwgIGR0Q29uZmlnLmRheUhlYWRlckZvcm1hdCksXHJcbiAgICBkYXlUaXRsZTogICBnZXRWYWx1ZSgkYXR0cnMuZGF5VGl0bGVGb3JtYXQsICAgZHRDb25maWcuZGF5VGl0bGVGb3JtYXQpLFxyXG4gICAgbW9udGhUaXRsZTogZ2V0VmFsdWUoJGF0dHJzLm1vbnRoVGl0bGVGb3JtYXQsIGR0Q29uZmlnLm1vbnRoVGl0bGVGb3JtYXQpXHJcbiAgfSxcclxuICBzdGFydGluZ0RheSA9IGdldFZhbHVlKCRhdHRycy5zdGFydGluZ0RheSwgICAgICBkdENvbmZpZy5zdGFydGluZ0RheSksXHJcbiAgeWVhclJhbmdlID0gICBnZXRWYWx1ZSgkYXR0cnMueWVhclJhbmdlLCAgICAgICAgZHRDb25maWcueWVhclJhbmdlKTtcclxuXHJcbiAgdGhpcy5taW5EYXRlID0gZHRDb25maWcubWluRGF0ZSA/IG5ldyBEYXRlKGR0Q29uZmlnLm1pbkRhdGUpIDogbnVsbDtcclxuICB0aGlzLm1heERhdGUgPSBkdENvbmZpZy5tYXhEYXRlID8gbmV3IERhdGUoZHRDb25maWcubWF4RGF0ZSkgOiBudWxsO1xyXG5cclxuICBmdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQodmFsdWUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoIHllYXIsIG1vbnRoICkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAwKS5nZXREYXRlKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXREYXRlcyhzdGFydERhdGUsIG4pIHtcclxuICAgIHZhciBkYXRlcyA9IG5ldyBBcnJheShuKTtcclxuICAgIHZhciBjdXJyZW50ID0gc3RhcnREYXRlLCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgbikge1xyXG4gICAgICBkYXRlc1tpKytdID0gbmV3IERhdGUoY3VycmVudCk7XHJcbiAgICAgIGN1cnJlbnQuc2V0RGF0ZSggY3VycmVudC5nZXREYXRlKCkgKyAxICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtYWtlRGF0ZShkYXRlLCBmb3JtYXQsIGlzU2VsZWN0ZWQsIGlzU2Vjb25kYXJ5KSB7XHJcbiAgICByZXR1cm4geyBkYXRlOiBkYXRlLCBsYWJlbDogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQpLCBzZWxlY3RlZDogISFpc1NlbGVjdGVkLCBzZWNvbmRhcnk6ICEhaXNTZWNvbmRhcnkgfTtcclxuICB9XHJcblxyXG4gIHRoaXMubW9kZXMgPSBbXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdkYXknLFxyXG4gICAgICBnZXRWaXNpYmxlRGF0ZXM6IGZ1bmN0aW9uKGRhdGUsIHNlbGVjdGVkKSB7XHJcbiAgICAgICAgdmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpLCBmaXJzdERheU9mTW9udGggPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XHJcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBzdGFydGluZ0RheSAtIGZpcnN0RGF5T2ZNb250aC5nZXREYXkoKSxcclxuICAgICAgICBudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCA9IChkaWZmZXJlbmNlID4gMCkgPyA3IC0gZGlmZmVyZW5jZSA6IC0gZGlmZmVyZW5jZSxcclxuICAgICAgICBmaXJzdERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mTW9udGgpLCBudW1EYXRlcyA9IDA7XHJcblxyXG4gICAgICAgIGlmICggbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggPiAwICkge1xyXG4gICAgICAgICAgZmlyc3REYXRlLnNldERhdGUoIC0gbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggKyAxICk7XHJcbiAgICAgICAgICBudW1EYXRlcyArPSBudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aDsgLy8gUHJldmlvdXNcclxuICAgICAgICB9XHJcbiAgICAgICAgbnVtRGF0ZXMgKz0gZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGggKyAxKTsgLy8gQ3VycmVudFxyXG4gICAgICAgIG51bURhdGVzICs9ICg3IC0gbnVtRGF0ZXMgJSA3KSAlIDc7IC8vIE5leHRcclxuXHJcbiAgICAgICAgdmFyIGRheXMgPSBnZXREYXRlcyhmaXJzdERhdGUsIG51bURhdGVzKSwgbGFiZWxzID0gbmV3IEFycmF5KDcpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0ZXM7IGkgKyspIHtcclxuICAgICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKGRheXNbaV0pO1xyXG4gICAgICAgICAgZGF5c1tpXSA9IG1ha2VEYXRlKGR0LCBmb3JtYXQuZGF5LCAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZ2V0RGF0ZSgpID09PSBkdC5nZXREYXRlKCkgJiYgc2VsZWN0ZWQuZ2V0TW9udGgoKSA9PT0gZHQuZ2V0TW9udGgoKSAmJiBzZWxlY3RlZC5nZXRGdWxsWWVhcigpID09PSBkdC5nZXRGdWxsWWVhcigpKSwgZHQuZ2V0TW9udGgoKSAhPT0gbW9udGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDc7IGorKykge1xyXG4gICAgICAgICAgbGFiZWxzW2pdID0gZGF0ZUZpbHRlcihkYXlzW2pdLmRhdGUsIGZvcm1hdC5kYXlIZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBvYmplY3RzOiBkYXlzLCB0aXRsZTogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQuZGF5VGl0bGUpLCBsYWJlbHM6IGxhYmVscyB9O1xyXG4gICAgICB9LFxyXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcclxuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCBkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpLCBkYXRlMS5nZXREYXRlKCkgKSAtIG5ldyBEYXRlKCBkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpLCBkYXRlMi5nZXREYXRlKCkgKSApO1xyXG4gICAgICB9LFxyXG4gICAgICBzcGxpdDogNyxcclxuICAgICAgc3RlcDogeyBtb250aHM6IDEgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ21vbnRoJyxcclxuICAgICAgZ2V0VmlzaWJsZURhdGVzOiBmdW5jdGlvbihkYXRlLCBzZWxlY3RlZCkge1xyXG4gICAgICAgIHZhciBtb250aHMgPSBuZXcgQXJyYXkoMTIpLCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDEyOyBpKysgKSB7XHJcbiAgICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZSh5ZWFyLCBpLCAxKTtcclxuICAgICAgICAgIG1vbnRoc1tpXSA9IG1ha2VEYXRlKGR0LCBmb3JtYXQubW9udGgsIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXRNb250aCgpID09PSBpICYmIHNlbGVjdGVkLmdldEZ1bGxZZWFyKCkgPT09IHllYXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgb2JqZWN0czogbW9udGhzLCB0aXRsZTogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQubW9udGhUaXRsZSkgfTtcclxuICAgICAgfSxcclxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCBkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpICkgLSBuZXcgRGF0ZSggZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSApO1xyXG4gICAgICB9LFxyXG4gICAgICBzcGxpdDogMyxcclxuICAgICAgc3RlcDogeyB5ZWFyczogMSB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAneWVhcicsXHJcbiAgICAgIGdldFZpc2libGVEYXRlczogZnVuY3Rpb24oZGF0ZSwgc2VsZWN0ZWQpIHtcclxuICAgICAgICB2YXIgeWVhcnMgPSBuZXcgQXJyYXkoeWVhclJhbmdlKSwgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSwgc3RhcnRZZWFyID0gcGFyc2VJbnQoKHllYXIgLSAxKSAvIHllYXJSYW5nZSwgMTApICogeWVhclJhbmdlICsgMTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB5ZWFyUmFuZ2U7IGkrKyApIHtcclxuICAgICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKHN0YXJ0WWVhciArIGksIDAsIDEpO1xyXG4gICAgICAgICAgeWVhcnNbaV0gPSBtYWtlRGF0ZShkdCwgZm9ybWF0LnllYXIsIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXRGdWxsWWVhcigpID09PSBkdC5nZXRGdWxsWWVhcigpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG9iamVjdHM6IHllYXJzLCB0aXRsZTogW3llYXJzWzBdLmxhYmVsLCB5ZWFyc1t5ZWFyUmFuZ2UgLSAxXS5sYWJlbF0uam9pbignIC0gJykgfTtcclxuICAgICAgfSxcclxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUxLmdldEZ1bGxZZWFyKCkgLSBkYXRlMi5nZXRGdWxsWWVhcigpO1xyXG4gICAgICB9LFxyXG4gICAgICBzcGxpdDogNSxcclxuICAgICAgc3RlcDogeyB5ZWFyczogeWVhclJhbmdlIH1cclxuICAgIH1cclxuICBdO1xyXG5cclxuICB0aGlzLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihkYXRlLCBtb2RlKSB7XHJcbiAgICB2YXIgY3VycmVudE1vZGUgPSB0aGlzLm1vZGVzW21vZGUgfHwgMF07XHJcbiAgICByZXR1cm4gKCh0aGlzLm1pbkRhdGUgJiYgY3VycmVudE1vZGUuY29tcGFyZShkYXRlLCB0aGlzLm1pbkRhdGUpIDwgMCkgfHwgKHRoaXMubWF4RGF0ZSAmJiBjdXJyZW50TW9kZS5jb21wYXJlKGRhdGUsIHRoaXMubWF4RGF0ZSkgPiAwKSB8fCAoJHNjb3BlLmRhdGVEaXNhYmxlZCAmJiAkc2NvcGUuZGF0ZURpc2FibGVkKHtkYXRlOiBkYXRlLCBtb2RlOiBjdXJyZW50TW9kZS5uYW1lfSkpKTtcclxuICB9O1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoICdkYXRlcGlja2VyJywgWydkYXRlRmlsdGVyJywgJyRwYXJzZScsICdkYXRlcGlja2VyQ29uZmlnJywgJyRsb2cnLCBmdW5jdGlvbiAoZGF0ZUZpbHRlciwgJHBhcnNlLCBkYXRlcGlja2VyQ29uZmlnLCAkbG9nKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWwnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgZGF0ZURpc2FibGVkOiAnJidcclxuICAgIH0sXHJcbiAgICByZXF1aXJlOiBbJ2RhdGVwaWNrZXInLCAnP15uZ01vZGVsJ10sXHJcbiAgICBjb250cm9sbGVyOiAnRGF0ZXBpY2tlckNvbnRyb2xsZXInLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xyXG4gICAgICB2YXIgZGF0ZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbCA9IGN0cmxzWzFdO1xyXG5cclxuICAgICAgaWYgKCFuZ01vZGVsKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICB2YXIgbW9kZSA9IDAsIHNlbGVjdGVkID0gbmV3IERhdGUoKSwgc2hvd1dlZWtzID0gZGF0ZXBpY2tlckNvbmZpZy5zaG93V2Vla3M7XHJcblxyXG4gICAgICBpZiAoYXR0cnMuc2hvd1dlZWtzKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLnNob3dXZWVrcyksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBzaG93V2Vla3MgPSAhISB2YWx1ZTtcclxuICAgICAgICAgIHVwZGF0ZVNob3dXZWVrTnVtYmVycygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZVNob3dXZWVrTnVtYmVycygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYXR0cnMubWluKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1pbiksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBkYXRlcGlja2VyQ3RybC5taW5EYXRlID0gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBudWxsO1xyXG4gICAgICAgICAgcmVmaWxsKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGF0dHJzLm1heCkge1xyXG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5tYXgpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgZGF0ZXBpY2tlckN0cmwubWF4RGF0ZSA9IHZhbHVlID8gbmV3IERhdGUodmFsdWUpIDogbnVsbDtcclxuICAgICAgICAgIHJlZmlsbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiB1cGRhdGVTaG93V2Vla051bWJlcnMoKSB7XHJcbiAgICAgICAgc2NvcGUuc2hvd1dlZWtOdW1iZXJzID0gbW9kZSA9PT0gMCAmJiBzaG93V2Vla3M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNwbGl0IGFycmF5IGludG8gc21hbGxlciBhcnJheXNcclxuICAgICAgZnVuY3Rpb24gc3BsaXQoYXJyLCBzaXplKSB7XHJcbiAgICAgICAgdmFyIGFycmF5cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChhcnIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgYXJyYXlzLnB1c2goYXJyLnNwbGljZSgwLCBzaXplKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlZmlsbCggdXBkYXRlU2VsZWN0ZWQgKSB7XHJcbiAgICAgICAgdmFyIGRhdGUgPSBudWxsLCB2YWxpZCA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmICggbmdNb2RlbC4kbW9kZWxWYWx1ZSApIHtcclxuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSggbmdNb2RlbC4kbW9kZWxWYWx1ZSApO1xyXG5cclxuICAgICAgICAgIGlmICggaXNOYU4oZGF0ZSkgKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICggdXBkYXRlU2VsZWN0ZWQgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gZGF0ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ2RhdGUnLCB2YWxpZCk7XHJcblxyXG4gICAgICAgIHZhciBjdXJyZW50TW9kZSA9IGRhdGVwaWNrZXJDdHJsLm1vZGVzW21vZGVdLCBkYXRhID0gY3VycmVudE1vZGUuZ2V0VmlzaWJsZURhdGVzKHNlbGVjdGVkLCBkYXRlKTtcclxuICAgICAgICBhbmd1bGFyLmZvckVhY2goZGF0YS5vYmplY3RzLCBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgIG9iai5kaXNhYmxlZCA9IGRhdGVwaWNrZXJDdHJsLmlzRGlzYWJsZWQob2JqLmRhdGUsIG1vZGUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZS1kaXNhYmxlZCcsICghZGF0ZSB8fCAhZGF0ZXBpY2tlckN0cmwuaXNEaXNhYmxlZChkYXRlKSkpO1xyXG5cclxuICAgICAgICBzY29wZS5yb3dzID0gc3BsaXQoZGF0YS5vYmplY3RzLCBjdXJyZW50TW9kZS5zcGxpdCk7XHJcbiAgICAgICAgc2NvcGUubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XHJcbiAgICAgICAgc2NvcGUudGl0bGUgPSBkYXRhLnRpdGxlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzZXRNb2RlKHZhbHVlKSB7XHJcbiAgICAgICAgbW9kZSA9IHZhbHVlO1xyXG4gICAgICAgIHVwZGF0ZVNob3dXZWVrTnVtYmVycygpO1xyXG4gICAgICAgIHJlZmlsbCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuZ01vZGVsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZWZpbGwoIHRydWUgKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKCBkYXRlICkge1xyXG4gICAgICAgIGlmICggbW9kZSA9PT0gMCApIHtcclxuICAgICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKCBuZ01vZGVsLiRtb2RlbFZhbHVlICk7XHJcbiAgICAgICAgICBkdC5zZXRGdWxsWWVhciggZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpICk7XHJcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoIGR0ICk7XHJcbiAgICAgICAgICByZWZpbGwoIHRydWUgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZWN0ZWQgPSBkYXRlO1xyXG4gICAgICAgICAgc2V0TW9kZSggbW9kZSAtIDEgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHNjb3BlLm1vdmUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgc3RlcCA9IGRhdGVwaWNrZXJDdHJsLm1vZGVzW21vZGVdLnN0ZXA7XHJcbiAgICAgICAgc2VsZWN0ZWQuc2V0TW9udGgoIHNlbGVjdGVkLmdldE1vbnRoKCkgKyBkaXJlY3Rpb24gKiAoc3RlcC5tb250aHMgfHwgMCkgKTtcclxuICAgICAgICBzZWxlY3RlZC5zZXRGdWxsWWVhciggc2VsZWN0ZWQuZ2V0RnVsbFllYXIoKSArIGRpcmVjdGlvbiAqIChzdGVwLnllYXJzIHx8IDApICk7XHJcbiAgICAgICAgcmVmaWxsKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHNjb3BlLnRvZ2dsZU1vZGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzZXRNb2RlKCAobW9kZSArIDEpICUgZGF0ZXBpY2tlckN0cmwubW9kZXMubGVuZ3RoICk7XHJcbiAgICAgIH07XHJcbiAgICAgIHNjb3BlLmdldFdlZWtOdW1iZXIgPSBmdW5jdGlvbihyb3cpIHtcclxuICAgICAgICByZXR1cm4gKCBtb2RlID09PSAwICYmIHNjb3BlLnNob3dXZWVrTnVtYmVycyAmJiByb3cubGVuZ3RoID09PSA3ICkgPyBnZXRJU084NjAxV2Vla051bWJlcihyb3dbMF0uZGF0ZSkgOiBudWxsO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0SVNPODYwMVdlZWtOdW1iZXIoZGF0ZSkge1xyXG4gICAgICAgIHZhciBjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgICAgICBjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtIChjaGVja0RhdGUuZ2V0RGF5KCkgfHwgNykpOyAvLyBUaHVyc2RheVxyXG4gICAgICAgIHZhciB0aW1lID0gY2hlY2tEYXRlLmdldFRpbWUoKTtcclxuICAgICAgICBjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxyXG4gICAgICAgIGNoZWNrRGF0ZS5zZXREYXRlKDEpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucm91bmQoKHRpbWUgLSBjaGVja0RhdGUpIC8gODY0MDAwMDApIC8gNykgKyAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4uY29uc3RhbnQoJ2RhdGVwaWNrZXJQb3B1cENvbmZpZycsIHtcclxuICBkYXRlRm9ybWF0OiAneXl5eS1NTS1kZCcsXHJcbiAgY2xvc2VPbkRhdGVTZWxlY3Rpb246IHRydWVcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ2RhdGVwaWNrZXJQb3B1cCcsIFsnJGNvbXBpbGUnLCAnJHBhcnNlJywgJyRkb2N1bWVudCcsICckcG9zaXRpb24nLCAnZGF0ZUZpbHRlcicsICdkYXRlcGlja2VyUG9wdXBDb25maWcnLFxyXG5mdW5jdGlvbiAoJGNvbXBpbGUsICRwYXJzZSwgJGRvY3VtZW50LCAkcG9zaXRpb24sIGRhdGVGaWx0ZXIsIGRhdGVwaWNrZXJQb3B1cENvbmZpZykge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKG9yaWdpbmFsU2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcblxyXG4gICAgICB2YXIgY2xvc2VPbkRhdGVTZWxlY3Rpb24gPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5jbG9zZU9uRGF0ZVNlbGVjdGlvbikgPyBzY29wZS4kZXZhbChhdHRycy5jbG9zZU9uRGF0ZVNlbGVjdGlvbikgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuY2xvc2VPbkRhdGVTZWxlY3Rpb247XHJcbiAgICAgIHZhciBkYXRlRm9ybWF0ID0gYXR0cnMuZGF0ZXBpY2tlclBvcHVwIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlRm9ybWF0O1xyXG5cclxuICAgICAvLyBjcmVhdGUgYSBjaGlsZCBzY29wZSBmb3IgdGhlIGRhdGVwaWNrZXIgZGlyZWN0aXZlIHNvIHdlIGFyZSBub3QgcG9sbHV0aW5nIG9yaWdpbmFsIHNjb3BlXHJcbiAgICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xyXG4gICAgICBvcmlnaW5hbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBzY29wZS4kZGVzdHJveSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBnZXRJc09wZW4sIHNldElzT3BlbjtcclxuICAgICAgaWYgKCBhdHRycy5pc09wZW4gKSB7XHJcbiAgICAgICAgZ2V0SXNPcGVuID0gJHBhcnNlKGF0dHJzLmlzT3Blbik7XHJcbiAgICAgICAgc2V0SXNPcGVuID0gZ2V0SXNPcGVuLmFzc2lnbjtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxTY29wZS4kd2F0Y2goZ2V0SXNPcGVuLCBmdW5jdGlvbiB1cGRhdGVPcGVuKHZhbHVlKSB7XHJcbiAgICAgICAgICBzY29wZS5pc09wZW4gPSAhISB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBzY29wZS5pc09wZW4gPSBnZXRJc09wZW4gPyBnZXRJc09wZW4ob3JpZ2luYWxTY29wZSkgOiBmYWxzZTsgLy8gSW5pdGlhbCBzdGF0ZVxyXG5cclxuICAgICAgZnVuY3Rpb24gc2V0T3BlbiggdmFsdWUgKSB7XHJcbiAgICAgICAgaWYgKHNldElzT3Blbikge1xyXG4gICAgICAgICAgc2V0SXNPcGVuKG9yaWdpbmFsU2NvcGUsICEhdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzY29wZS5pc09wZW4gPSAhIXZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRvY3VtZW50Q2xpY2tCaW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAoc2NvcGUuaXNPcGVuICYmIGV2ZW50LnRhcmdldCAhPT0gZWxlbWVudFswXSkge1xyXG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBzZXRPcGVuKGZhbHNlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBlbGVtZW50Rm9jdXNCaW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2V0T3BlbiggdHJ1ZSApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gcG9wdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgY2FsZW5kYXJcclxuICAgICAgdmFyIHBvcHVwRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkYXRlcGlja2VyLXBvcHVwLXdyYXA+PGRhdGVwaWNrZXI+PC9kYXRlcGlja2VyPjwvZGF0ZXBpY2tlci1wb3B1cC13cmFwPicpO1xyXG4gICAgICBwb3B1cEVsLmF0dHIoe1xyXG4gICAgICAgICduZy1tb2RlbCc6ICdkYXRlJyxcclxuICAgICAgICAnbmctY2hhbmdlJzogJ2RhdGVTZWxlY3Rpb24oKSdcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBkYXRlcGlja2VyRWwgPSBwb3B1cEVsLmZpbmQoJ2RhdGVwaWNrZXInKTtcclxuICAgICAgaWYgKGF0dHJzLmRhdGVwaWNrZXJPcHRpb25zKSB7XHJcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoYW5ndWxhci5leHRlbmQoe30sIG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMuZGF0ZXBpY2tlck9wdGlvbnMpKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRPRE86IHJldmVyc2UgZnJvbSBkYXRlRmlsdGVyIHN0cmluZyB0byBEYXRlIG9iamVjdFxyXG4gICAgICBmdW5jdGlvbiBwYXJzZURhdGUodmlld1ZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2aWV3VmFsdWUpIHtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgdHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNEYXRlKHZpZXdWYWx1ZSkpIHtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgdHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gdmlld1ZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyh2aWV3VmFsdWUpKSB7XHJcbiAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgICBpZiAoaXNOYU4oZGF0ZSkpIHtcclxuICAgICAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ2RhdGUnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZScsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ2RhdGUnLCBmYWxzZSk7XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBuZ01vZGVsLiRwYXJzZXJzLnVuc2hpZnQocGFyc2VEYXRlKTtcclxuXHJcbiAgICAgIC8vIElubmVyIGNoYW5nZVxyXG4gICAgICBzY29wZS5kYXRlU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHNjb3BlLmRhdGUpO1xyXG4gICAgICAgIG5nTW9kZWwuJHJlbmRlcigpO1xyXG5cclxuICAgICAgICBpZiAoY2xvc2VPbkRhdGVTZWxlY3Rpb24pIHtcclxuICAgICAgICAgIHNldE9wZW4oIGZhbHNlICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgZWxlbWVudC5iaW5kKCdpbnB1dCBjaGFuZ2Uga2V5dXAnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB1cGRhdGVDYWxlbmRhcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIE91dHRlciBjaGFuZ2VcclxuICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRhdGUgPSBuZ01vZGVsLiR2aWV3VmFsdWUgPyBkYXRlRmlsdGVyKG5nTW9kZWwuJHZpZXdWYWx1ZSwgZGF0ZUZvcm1hdCkgOiAnJztcclxuICAgICAgICBlbGVtZW50LnZhbChkYXRlKTtcclxuXHJcbiAgICAgICAgdXBkYXRlQ2FsZW5kYXIoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGVuZGFyKCkge1xyXG4gICAgICAgIHNjb3BlLmRhdGUgPSBuZ01vZGVsLiRtb2RlbFZhbHVlO1xyXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGFkZFdhdGNoYWJsZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHNjb3BlUHJvcGVydHksIGRhdGVwaWNrZXJBdHRyaWJ1dGUpIHtcclxuICAgICAgICBpZiAoYXR0cmlidXRlKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbFNjb3BlLiR3YXRjaCgkcGFyc2UoYXR0cmlidXRlKSwgZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICBzY29wZVtzY29wZVByb3BlcnR5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBkYXRlcGlja2VyRWwuYXR0cihkYXRlcGlja2VyQXR0cmlidXRlIHx8IHNjb3BlUHJvcGVydHksIHNjb3BlUHJvcGVydHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhZGRXYXRjaGFibGVBdHRyaWJ1dGUoYXR0cnMubWluLCAnbWluJyk7XHJcbiAgICAgIGFkZFdhdGNoYWJsZUF0dHJpYnV0ZShhdHRycy5tYXgsICdtYXgnKTtcclxuICAgICAgaWYgKGF0dHJzLnNob3dXZWVrcykge1xyXG4gICAgICAgIGFkZFdhdGNoYWJsZUF0dHJpYnV0ZShhdHRycy5zaG93V2Vla3MsICdzaG93V2Vla3MnLCAnc2hvdy13ZWVrcycpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjb3BlLnNob3dXZWVrcyA9IHRydWU7XHJcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ3Nob3ctd2Vla3MnLCAnc2hvd1dlZWtzJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGF0dHJzLmRhdGVEaXNhYmxlZCkge1xyXG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdkYXRlLWRpc2FibGVkJywgYXR0cnMuZGF0ZURpc2FibGVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XHJcbiAgICAgICAgc2NvcGUucG9zaXRpb24gPSAkcG9zaXRpb24ucG9zaXRpb24oZWxlbWVudCk7XHJcbiAgICAgICAgc2NvcGUucG9zaXRpb24udG9wID0gc2NvcGUucG9zaXRpb24udG9wICsgZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGRvY3VtZW50QmluZGluZ0luaXRpYWxpemVkID0gZmFsc2UsIGVsZW1lbnRGb2N1c0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XHJcbiAgICAgICAgICBpZihlbGVtZW50Rm9jdXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnVuYmluZCgnZm9jdXMnLCBlbGVtZW50Rm9jdXNCaW5kKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcclxuICAgICAgICAgIGRvY3VtZW50QmluZGluZ0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYoZG9jdW1lbnRCaW5kaW5nSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbGVtZW50LmJpbmQoJ2ZvY3VzJywgZWxlbWVudEZvY3VzQmluZCk7XHJcbiAgICAgICAgICBlbGVtZW50Rm9jdXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHNldElzT3BlbiApIHtcclxuICAgICAgICAgIHNldElzT3BlbihvcmlnaW5hbFNjb3BlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciAkc2V0TW9kZWxWYWx1ZSA9ICRwYXJzZShhdHRycy5uZ01vZGVsKS5hc3NpZ247XHJcblxyXG4gICAgICBzY29wZS50b2RheSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzZXRNb2RlbFZhbHVlKG9yaWdpbmFsU2NvcGUsIG5ldyBEYXRlKCkpO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzZXRNb2RlbFZhbHVlKG9yaWdpbmFsU2NvcGUsIG51bGwpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgZWxlbWVudC5hZnRlcigkY29tcGlsZShwb3B1cEVsKShzY29wZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgnZGF0ZXBpY2tlclBvcHVwV3JhcCcsIFtmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6J0UnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbCcsXHJcbiAgICBsaW5rOmZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgZWxlbWVudC5iaW5kKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5cclxuLypcclxuICogZHJvcGRvd25Ub2dnbGUgLSBQcm92aWRlcyBkcm9wZG93biBtZW51IGZ1bmN0aW9uYWxpdHkgaW4gcGxhY2Ugb2YgYm9vdHN0cmFwIGpzXHJcbiAqIEByZXN0cmljdCBjbGFzcyBvciBhdHRyaWJ1dGVcclxuICogQGV4YW1wbGU6XHJcbiAgIDxsaSBjbGFzcz1cImRyb3Bkb3duXCI+XHJcbiAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi10b2dnbGVcIj5NeSBEcm9wZG93biBNZW51PC9hPlxyXG4gICAgIDx1bCBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj5cclxuICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJjaG9pY2UgaW4gZHJvcENob2ljZXNcIj5cclxuICAgICAgICAgPGEgbmctaHJlZj1cInt7Y2hvaWNlLmhyZWZ9fVwiPnt7Y2hvaWNlLnRleHR9fTwvYT5cclxuICAgICAgIDwvbGk+XHJcbiAgICAgPC91bD5cclxuICAgPC9saT5cclxuICovXHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRyb3Bkb3duVG9nZ2xlJywgW10pLmRpcmVjdGl2ZSgnZHJvcGRvd25Ub2dnbGUnLCBbJyRkb2N1bWVudCcsICckbG9jYXRpb24nLCBmdW5jdGlvbiAoJGRvY3VtZW50LCAkbG9jYXRpb24pIHtcclxuICB2YXIgb3BlbkVsZW1lbnQgPSBudWxsLFxyXG4gICAgICBjbG9zZU1lbnUgICA9IGFuZ3VsYXIubm9vcDtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdDQScsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgc2NvcGUuJHdhdGNoKCckbG9jYXRpb24ucGF0aCcsIGZ1bmN0aW9uKCkgeyBjbG9zZU1lbnUoKTsgfSk7XHJcbiAgICAgIGVsZW1lbnQucGFyZW50KCkuYmluZCgnY2xpY2snLCBmdW5jdGlvbigpIHsgY2xvc2VNZW51KCk7IH0pO1xyXG4gICAgICBlbGVtZW50LmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBlbGVtZW50V2FzT3BlbiA9IChlbGVtZW50ID09PSBvcGVuRWxlbWVudCk7XHJcblxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIGlmICghIW9wZW5FbGVtZW50KSB7XHJcbiAgICAgICAgICBjbG9zZU1lbnUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZWxlbWVudFdhc09wZW4pIHtcclxuICAgICAgICAgIGVsZW1lbnQucGFyZW50KCkuYWRkQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAgIG9wZW5FbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgIGNsb3NlTWVudSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgY2xvc2VNZW51KTtcclxuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnQoKS5yZW1vdmVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgICAgICBjbG9zZU1lbnUgPSBhbmd1bGFyLm5vb3A7XHJcbiAgICAgICAgICAgIG9wZW5FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBjbG9zZU1lbnUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLm1vZGFsJywgW10pXHJcblxyXG4vKipcclxuICogQSBoZWxwZXIsIGludGVybmFsIGRhdGEgc3RydWN0dXJlIHRoYXQgYWN0cyBhcyBhIG1hcCBidXQgYWxzbyBhbGxvd3MgZ2V0dGluZyAvIHJlbW92aW5nXHJcbiAqIGVsZW1lbnRzIGluIHRoZSBMSUZPIG9yZGVyXHJcbiAqL1xyXG4gIC5mYWN0b3J5KCckJHN0YWNrZWRNYXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgc3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tpXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGtleXMucHVzaChzdGFja1tpXS5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRvcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2UoaWR4LCAxKVswXTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICByZW1vdmVUb3A6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSAxLCAxKVswXTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pXHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZGlyZWN0aXZlIGZvciB0aGUgJG1vZGFsIHNlcnZpY2UuIEl0IGNyZWF0ZXMgYSBiYWNrZHJvcCBlbGVtZW50LlxyXG4gKi9cclxuICAuZGlyZWN0aXZlKCdtb2RhbEJhY2tkcm9wJywgWyckbW9kYWxTdGFjaycsICckdGltZW91dCcsIGZ1bmN0aW9uICgkbW9kYWxTdGFjaywgJHRpbWVvdXQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWwnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcblxyXG4gICAgICAgIC8vdHJpZ2dlciBDU1MgdHJhbnNpdGlvbnNcclxuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzY29wZS5hbmltYXRlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2NvcGUuY2xvc2UgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICB2YXIgbW9kYWwgPSAkbW9kYWxTdGFjay5nZXRUb3AoKTtcclxuICAgICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAhPSAnc3RhdGljJykge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2JhY2tkcm9wIGNsaWNrJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgnbW9kYWxXaW5kb3cnLCBbJyR0aW1lb3V0JywgZnVuY3Rpb24gKCR0aW1lb3V0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0VBJyxcclxuICAgICAgc2NvcGU6IHtcclxuICAgICAgICBpbmRleDogJ0AnXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWwnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgc2NvcGUud2luZG93Q2xhc3MgPSBhdHRycy53aW5kb3dDbGFzcyB8fCAnJztcclxuXHJcbiAgICAgICAgLy90cmlnZ2VyIENTUyB0cmFuc2l0aW9uc1xyXG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHNjb3BlLmFuaW1hdGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKVxyXG5cclxuICAuZmFjdG9yeSgnJG1vZGFsU3RhY2snLCBbJyRkb2N1bWVudCcsICckY29tcGlsZScsICckcm9vdFNjb3BlJywgJyQkc3RhY2tlZE1hcCcsXHJcbiAgICBmdW5jdGlvbiAoJGRvY3VtZW50LCAkY29tcGlsZSwgJHJvb3RTY29wZSwgJCRzdGFja2VkTWFwKSB7XHJcblxyXG4gICAgICB2YXIgYmFja2Ryb3BqcUxpdGVFbCwgYmFja2Ryb3BEb21FbDtcclxuICAgICAgdmFyIGJhY2tkcm9wU2NvcGUgPSAkcm9vdFNjb3BlLiRuZXcodHJ1ZSk7XHJcbiAgICAgIHZhciBib2R5ID0gJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5lcSgwKTtcclxuICAgICAgdmFyIG9wZW5lZFdpbmRvd3MgPSAkJHN0YWNrZWRNYXAuY3JlYXRlTmV3KCk7XHJcbiAgICAgIHZhciAkbW9kYWxTdGFjayA9IHt9O1xyXG5cclxuICAgICAgZnVuY3Rpb24gYmFja2Ryb3BJbmRleCgpIHtcclxuICAgICAgICB2YXIgdG9wQmFja2Ryb3BJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBvcGVuZWQgPSBvcGVuZWRXaW5kb3dzLmtleXMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZW5lZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKG9wZW5lZFdpbmRvd3MuZ2V0KG9wZW5lZFtpXSkudmFsdWUuYmFja2Ryb3ApIHtcclxuICAgICAgICAgICAgdG9wQmFja2Ryb3BJbmRleCA9IGk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3BCYWNrZHJvcEluZGV4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkcm9vdFNjb3BlLiR3YXRjaChiYWNrZHJvcEluZGV4LCBmdW5jdGlvbihuZXdCYWNrZHJvcEluZGV4KXtcclxuICAgICAgICBiYWNrZHJvcFNjb3BlLmluZGV4ID0gbmV3QmFja2Ryb3BJbmRleDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlKSB7XHJcblxyXG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpLnZhbHVlO1xyXG5cclxuICAgICAgICAvL2NsZWFuIHVwIHRoZSBzdGFja1xyXG4gICAgICAgIG9wZW5lZFdpbmRvd3MucmVtb3ZlKG1vZGFsSW5zdGFuY2UpO1xyXG5cclxuICAgICAgICAvL3JlbW92ZSB3aW5kb3cgRE9NIGVsZW1lbnRcclxuICAgICAgICBtb2RhbFdpbmRvdy5tb2RhbERvbUVsLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAvL3JlbW92ZSBiYWNrZHJvcCBpZiBubyBsb25nZXIgbmVlZGVkXHJcbiAgICAgICAgaWYgKGJhY2tkcm9wSW5kZXgoKSA9PSAtMSkge1xyXG4gICAgICAgICAgYmFja2Ryb3BEb21FbC5yZW1vdmUoKTtcclxuICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Rlc3Ryb3kgc2NvcGVcclxuICAgICAgICBtb2RhbFdpbmRvdy5tb2RhbFNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRkb2N1bWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHZhciBtb2RhbDtcclxuXHJcbiAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcclxuICAgICAgICAgIG1vZGFsID0gb3BlbmVkV2luZG93cy50b3AoKTtcclxuICAgICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5rZXlib2FyZCkge1xyXG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgJG1vZGFsU3RhY2suZGlzbWlzcyhtb2RhbC5rZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgJG1vZGFsU3RhY2sub3BlbiA9IGZ1bmN0aW9uIChtb2RhbEluc3RhbmNlLCBtb2RhbCkge1xyXG5cclxuICAgICAgICBvcGVuZWRXaW5kb3dzLmFkZChtb2RhbEluc3RhbmNlLCB7XHJcbiAgICAgICAgICBkZWZlcnJlZDogbW9kYWwuZGVmZXJyZWQsXHJcbiAgICAgICAgICBtb2RhbFNjb3BlOiBtb2RhbC5zY29wZSxcclxuICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbC5iYWNrZHJvcCxcclxuICAgICAgICAgIGtleWJvYXJkOiBtb2RhbC5rZXlib2FyZFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgYW5ndWxhckRvbUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IG1vZGFsLXdpbmRvdz48L2Rpdj4nKTtcclxuICAgICAgICBhbmd1bGFyRG9tRWwuYXR0cignd2luZG93LWNsYXNzJywgbW9kYWwud2luZG93Q2xhc3MpO1xyXG4gICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKCdpbmRleCcsIG9wZW5lZFdpbmRvd3MubGVuZ3RoKCkgLSAxKTtcclxuICAgICAgICBhbmd1bGFyRG9tRWwuaHRtbChtb2RhbC5jb250ZW50KTtcclxuXHJcbiAgICAgICAgdmFyIG1vZGFsRG9tRWwgPSAkY29tcGlsZShhbmd1bGFyRG9tRWwpKG1vZGFsLnNjb3BlKTtcclxuICAgICAgICBvcGVuZWRXaW5kb3dzLnRvcCgpLnZhbHVlLm1vZGFsRG9tRWwgPSBtb2RhbERvbUVsO1xyXG4gICAgICAgIGJvZHkuYXBwZW5kKG1vZGFsRG9tRWwpO1xyXG5cclxuICAgICAgICBpZiAoYmFja2Ryb3BJbmRleCgpID49IDAgJiYgIWJhY2tkcm9wRG9tRWwpIHtcclxuICAgICAgICAgICAgYmFja2Ryb3BqcUxpdGVFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBtb2RhbC1iYWNrZHJvcD48L2Rpdj4nKTtcclxuICAgICAgICAgICAgYmFja2Ryb3BEb21FbCA9ICRjb21waWxlKGJhY2tkcm9wanFMaXRlRWwpKGJhY2tkcm9wU2NvcGUpO1xyXG4gICAgICAgICAgICBib2R5LmFwcGVuZChiYWNrZHJvcERvbUVsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5jbG9zZSA9IGZ1bmN0aW9uIChtb2RhbEluc3RhbmNlLCByZXN1bHQpIHtcclxuICAgICAgICB2YXIgbW9kYWwgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcclxuICAgICAgICBpZiAobW9kYWwpIHtcclxuICAgICAgICAgIG1vZGFsLnZhbHVlLmRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MgPSBmdW5jdGlvbiAobW9kYWxJbnN0YW5jZSwgcmVhc29uKSB7XHJcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSkudmFsdWU7XHJcbiAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XHJcbiAgICAgICAgICBtb2RhbFdpbmRvdy5kZWZlcnJlZC5yZWplY3QocmVhc29uKTtcclxuICAgICAgICAgIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gb3BlbmVkV2luZG93cy50b3AoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiAkbW9kYWxTdGFjaztcclxuICAgIH1dKVxyXG5cclxuICAucHJvdmlkZXIoJyRtb2RhbCcsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgJG1vZGFsUHJvdmlkZXIgPSB7XHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBiYWNrZHJvcDogdHJ1ZSwgLy9jYW4gYmUgYWxzbyBmYWxzZSBvciAnc3RhdGljJ1xyXG4gICAgICAgIGtleWJvYXJkOiB0cnVlXHJcbiAgICAgIH0sXHJcbiAgICAgICRnZXQ6IFsnJGluamVjdG9yJywgJyRyb290U2NvcGUnLCAnJHEnLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGNvbnRyb2xsZXInLCAnJG1vZGFsU3RhY2snLFxyXG4gICAgICAgIGZ1bmN0aW9uICgkaW5qZWN0b3IsICRyb290U2NvcGUsICRxLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUsICRjb250cm9sbGVyLCAkbW9kYWxTdGFjaykge1xyXG5cclxuICAgICAgICAgIHZhciAkbW9kYWwgPSB7fTtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBnZXRUZW1wbGF0ZVByb21pc2Uob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy50ZW1wbGF0ZSA/ICRxLndoZW4ob3B0aW9ucy50ZW1wbGF0ZSkgOlxyXG4gICAgICAgICAgICAgICRodHRwLmdldChvcHRpb25zLnRlbXBsYXRlVXJsLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0UmVzb2x2ZVByb21pc2VzKHJlc29sdmVzKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlc0FyciA9IFtdO1xyXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzb2x2ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbih2YWx1ZSkgfHwgYW5ndWxhci5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXNBcnIucHVzaCgkcS53aGVuKCRpbmplY3Rvci5pbnZva2UodmFsdWUpKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzQXJyO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICRtb2RhbC5vcGVuID0gZnVuY3Rpb24gKG1vZGFsT3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgdmFyIG1vZGFsUmVzdWx0RGVmZXJyZWQgPSAkcS5kZWZlcigpO1xyXG4gICAgICAgICAgICB2YXIgbW9kYWxPcGVuZWREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcblxyXG4gICAgICAgICAgICAvL3ByZXBhcmUgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbCB0byBiZSBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXJzIGFuZCByZXR1cm5lZCB0byBhIGNhbGxlclxyXG4gICAgICAgICAgICB2YXIgbW9kYWxJbnN0YW5jZSA9IHtcclxuICAgICAgICAgICAgICByZXN1bHQ6IG1vZGFsUmVzdWx0RGVmZXJyZWQucHJvbWlzZSxcclxuICAgICAgICAgICAgICBvcGVuZWQ6IG1vZGFsT3BlbmVkRGVmZXJyZWQucHJvbWlzZSxcclxuICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgJG1vZGFsU3RhY2suY2xvc2UobW9kYWxJbnN0YW5jZSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGRpc21pc3M6IGZ1bmN0aW9uIChyZWFzb24pIHtcclxuICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWxJbnN0YW5jZSwgcmVhc29uKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvL21lcmdlIGFuZCBjbGVhbiB1cCBvcHRpb25zXHJcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCAkbW9kYWxQcm92aWRlci5vcHRpb25zLCBtb2RhbE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBtb2RhbE9wdGlvbnMucmVzb2x2ZSA9IG1vZGFsT3B0aW9ucy5yZXNvbHZlIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy92ZXJpZnkgb3B0aW9uc1xyXG4gICAgICAgICAgICBpZiAoIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZSAmJiAhbW9kYWxPcHRpb25zLnRlbXBsYXRlVXJsKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgdGVtcGxhdGUgb3IgdGVtcGxhdGVVcmwgb3B0aW9ucyBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2UgPVxyXG4gICAgICAgICAgICAgICRxLmFsbChbZ2V0VGVtcGxhdGVQcm9taXNlKG1vZGFsT3B0aW9ucyldLmNvbmNhdChnZXRSZXNvbHZlUHJvbWlzZXMobW9kYWxPcHRpb25zLnJlc29sdmUpKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIHJlc29sdmVTdWNjZXNzKHRwbEFuZFZhcnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIG1vZGFsU2NvcGUgPSAobW9kYWxPcHRpb25zLnNjb3BlIHx8ICRyb290U2NvcGUpLiRuZXcoKTtcclxuICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRjbG9zZSA9IG1vZGFsSW5zdGFuY2UuY2xvc2U7XHJcbiAgICAgICAgICAgICAgbW9kYWxTY29wZS4kZGlzbWlzcyA9IG1vZGFsSW5zdGFuY2UuZGlzbWlzcztcclxuXHJcbiAgICAgICAgICAgICAgdmFyIGN0cmxJbnN0YW5jZSwgY3RybExvY2FscyA9IHt9O1xyXG4gICAgICAgICAgICAgIHZhciByZXNvbHZlSXRlciA9IDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vY29udHJvbGxlcnNcclxuICAgICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgICAgIGN0cmxMb2NhbHMuJHNjb3BlID0gbW9kYWxTY29wZTtcclxuICAgICAgICAgICAgICAgIGN0cmxMb2NhbHMuJG1vZGFsSW5zdGFuY2UgPSBtb2RhbEluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKG1vZGFsT3B0aW9ucy5yZXNvbHZlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICBjdHJsTG9jYWxzW2tleV0gPSB0cGxBbmRWYXJzW3Jlc29sdmVJdGVyKytdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3RybEluc3RhbmNlID0gJGNvbnRyb2xsZXIobW9kYWxPcHRpb25zLmNvbnRyb2xsZXIsIGN0cmxMb2NhbHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgJG1vZGFsU3RhY2sub3Blbihtb2RhbEluc3RhbmNlLCB7XHJcbiAgICAgICAgICAgICAgICBzY29wZTogbW9kYWxTY29wZSxcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkOiBtb2RhbFJlc3VsdERlZmVycmVkLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogdHBsQW5kVmFyc1swXSxcclxuICAgICAgICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbE9wdGlvbnMuYmFja2Ryb3AsXHJcbiAgICAgICAgICAgICAgICBrZXlib2FyZDogbW9kYWxPcHRpb25zLmtleWJvYXJkLFxyXG4gICAgICAgICAgICAgICAgd2luZG93Q2xhc3M6IG1vZGFsT3B0aW9ucy53aW5kb3dDbGFzc1xyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gcmVzb2x2ZUVycm9yKHJlYXNvbikge1xyXG4gICAgICAgICAgICAgIG1vZGFsUmVzdWx0RGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBtb2RhbE9wZW5lZERlZmVycmVkLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICBtb2RhbE9wZW5lZERlZmVycmVkLnJlamVjdChmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1vZGFsSW5zdGFuY2U7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHJldHVybiAkbW9kYWw7XHJcbiAgICAgICAgfV1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuICRtb2RhbFByb3ZpZGVyO1xyXG4gIH0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBhZ2luYXRpb24nLCBbXSlcclxuXHJcbi5jb250cm9sbGVyKCdQYWdpbmF0aW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCAnJGludGVycG9sYXRlJywgZnVuY3Rpb24gKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSkge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZGVmYXVsdEl0ZW1zUGVyUGFnZSkge1xyXG4gICAgaWYgKCRhdHRycy5pdGVtc1BlclBhZ2UpIHtcclxuICAgICAgJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuaXRlbXNQZXJQYWdlKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBzZWxmLml0ZW1zUGVyUGFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgICAgICAgJHNjb3BlLnRvdGFsUGFnZXMgPSBzZWxmLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLml0ZW1zUGVyUGFnZSA9IGRlZmF1bHRJdGVtc1BlclBhZ2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5ub1ByZXZpb3VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYWdlID09PSAxO1xyXG4gIH07XHJcbiAgdGhpcy5ub05leHQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnBhZ2UgPT09ICRzY29wZS50b3RhbFBhZ2VzO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbihwYWdlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYWdlID09PSBwYWdlO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuY2FsY3VsYXRlVG90YWxQYWdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXRlbXNQZXJQYWdlIDwgMSA/IDEgOiBNYXRoLmNlaWwoJHNjb3BlLnRvdGFsSXRlbXMgLyB0aGlzLml0ZW1zUGVyUGFnZSk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5nZXRBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgZGVmYXVsdFZhbHVlLCBpbnRlcnBvbGF0ZSkge1xyXG4gICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJpYnV0ZSkgPyAoaW50ZXJwb2xhdGUgPyAkaW50ZXJwb2xhdGUoYXR0cmlidXRlKSgkc2NvcGUuJHBhcmVudCkgOiAkc2NvcGUuJHBhcmVudC4kZXZhbChhdHRyaWJ1dGUpKSA6IGRlZmF1bHRWYWx1ZTtcclxuICB9O1xyXG5cclxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5wYWdlID0gcGFyc2VJbnQoJHNjb3BlLnBhZ2UsIDEwKSB8fCAxO1xyXG4gICAgJHNjb3BlLnBhZ2VzID0gdGhpcy5nZXRQYWdlcyh0aGlzLnBhZ2UsICRzY29wZS50b3RhbFBhZ2VzKTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuc2VsZWN0UGFnZSA9IGZ1bmN0aW9uKHBhZ2UpIHtcclxuICAgIGlmICggISBzZWxmLmlzQWN0aXZlKHBhZ2UpICYmIHBhZ2UgPiAwICYmIHBhZ2UgPD0gJHNjb3BlLnRvdGFsUGFnZXMpIHtcclxuICAgICAgJHNjb3BlLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAkc2NvcGUub25TZWxlY3RQYWdlKHsgcGFnZTogcGFnZSB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAkc2NvcGUuJHdhdGNoKCd0b3RhbEl0ZW1zJywgZnVuY3Rpb24oKSB7XHJcbiAgICAkc2NvcGUudG90YWxQYWdlcyA9IHNlbGYuY2FsY3VsYXRlVG90YWxQYWdlcygpO1xyXG4gIH0pO1xyXG5cclxuICAkc2NvcGUuJHdhdGNoKCd0b3RhbFBhZ2VzJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmICggJGF0dHJzLm51bVBhZ2VzICkge1xyXG4gICAgICAkc2NvcGUubnVtUGFnZXMgPSB2YWx1ZTsgLy8gUmVhZG9ubHkgdmFyaWFibGVcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIHNlbGYucGFnZSA+IHZhbHVlICkge1xyXG4gICAgICAkc2NvcGUuc2VsZWN0UGFnZSh2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZWxmLnJlbmRlcigpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAkc2NvcGUuJHdhdGNoKCdwYWdlJywgZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLnJlbmRlcigpO1xyXG4gIH0pO1xyXG59XSlcclxuXHJcbi5jb25zdGFudCgncGFnaW5hdGlvbkNvbmZpZycsIHtcclxuICBpdGVtc1BlclBhZ2U6IDEwLFxyXG4gIGJvdW5kYXJ5TGlua3M6IGZhbHNlLFxyXG4gIGRpcmVjdGlvbkxpbmtzOiB0cnVlLFxyXG4gIGZpcnN0VGV4dDogJ0ZpcnN0JyxcclxuICBwcmV2aW91c1RleHQ6ICdQcmV2aW91cycsXHJcbiAgbmV4dFRleHQ6ICdOZXh0JyxcclxuICBsYXN0VGV4dDogJ0xhc3QnLFxyXG4gIHJvdGF0ZTogdHJ1ZVxyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgncGFnaW5hdGlvbicsIFsnJHBhcnNlJywgJ3BhZ2luYXRpb25Db25maWcnLCBmdW5jdGlvbigkcGFyc2UsIGNvbmZpZykge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIHBhZ2U6ICc9JyxcclxuICAgICAgdG90YWxJdGVtczogJz0nLFxyXG4gICAgICBvblNlbGVjdFBhZ2U6JyAmJyxcclxuICAgICAgbnVtUGFnZXM6ICc9J1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6ICdQYWdpbmF0aW9uQ29udHJvbGxlcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHBhZ2luYXRpb25DdHJsKSB7XHJcblxyXG4gICAgICAvLyBTZXR1cCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgdmFyIG1heFNpemUsXHJcbiAgICAgIGJvdW5kYXJ5TGlua3MgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMuYm91bmRhcnlMaW5rcywgIGNvbmZpZy5ib3VuZGFyeUxpbmtzICAgICAgKSxcclxuICAgICAgZGlyZWN0aW9uTGlua3MgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5kaXJlY3Rpb25MaW5rcywgY29uZmlnLmRpcmVjdGlvbkxpbmtzICAgICApLFxyXG4gICAgICBmaXJzdFRleHQgICAgICA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLmZpcnN0VGV4dCwgICAgICBjb25maWcuZmlyc3RUZXh0LCAgICAgdHJ1ZSksXHJcbiAgICAgIHByZXZpb3VzVGV4dCAgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMucHJldmlvdXNUZXh0LCAgIGNvbmZpZy5wcmV2aW91c1RleHQsICB0cnVlKSxcclxuICAgICAgbmV4dFRleHQgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5uZXh0VGV4dCwgICAgICAgY29uZmlnLm5leHRUZXh0LCAgICAgIHRydWUpLFxyXG4gICAgICBsYXN0VGV4dCAgICAgICA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLmxhc3RUZXh0LCAgICAgICBjb25maWcubGFzdFRleHQsICAgICAgdHJ1ZSksXHJcbiAgICAgIHJvdGF0ZSAgICAgICAgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMucm90YXRlLCAgICAgICAgIGNvbmZpZy5yb3RhdGUpO1xyXG5cclxuICAgICAgcGFnaW5hdGlvbkN0cmwuaW5pdChjb25maWcuaXRlbXNQZXJQYWdlKTtcclxuXHJcbiAgICAgIGlmIChhdHRycy5tYXhTaXplKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1heFNpemUpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgbWF4U2l6ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgICAgICAgICBwYWdpbmF0aW9uQ3RybC5yZW5kZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIHBhZ2Ugb2JqZWN0IHVzZWQgaW4gdGVtcGxhdGVcclxuICAgICAgZnVuY3Rpb24gbWFrZVBhZ2UobnVtYmVyLCB0ZXh0LCBpc0FjdGl2ZSwgaXNEaXNhYmxlZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBudW1iZXI6IG51bWJlcixcclxuICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICBhY3RpdmU6IGlzQWN0aXZlLFxyXG4gICAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWRcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWdpbmF0aW9uQ3RybC5nZXRQYWdlcyA9IGZ1bmN0aW9uKGN1cnJlbnRQYWdlLCB0b3RhbFBhZ2VzKSB7XHJcbiAgICAgICAgdmFyIHBhZ2VzID0gW107XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgcGFnZSBsaW1pdHNcclxuICAgICAgICB2YXIgc3RhcnRQYWdlID0gMSwgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XHJcbiAgICAgICAgdmFyIGlzTWF4U2l6ZWQgPSAoIGFuZ3VsYXIuaXNEZWZpbmVkKG1heFNpemUpICYmIG1heFNpemUgPCB0b3RhbFBhZ2VzICk7XHJcblxyXG4gICAgICAgIC8vIHJlY29tcHV0ZSBpZiBtYXhTaXplXHJcbiAgICAgICAgaWYgKCBpc01heFNpemVkICkge1xyXG4gICAgICAgICAgaWYgKCByb3RhdGUgKSB7XHJcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXHJcbiAgICAgICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KGN1cnJlbnRQYWdlIC0gTWF0aC5mbG9vcihtYXhTaXplLzIpLCAxKTtcclxuICAgICAgICAgICAgZW5kUGFnZSAgID0gc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgaWYgbGltaXQgaXMgZXhjZWVkZWRcclxuICAgICAgICAgICAgaWYgKGVuZFBhZ2UgPiB0b3RhbFBhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgZW5kUGFnZSAgID0gdG90YWxQYWdlcztcclxuICAgICAgICAgICAgICBzdGFydFBhZ2UgPSBlbmRQYWdlIC0gbWF4U2l6ZSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFZpc2libGUgcGFnZXMgYXJlIHBhZ2luYXRlZCB3aXRoIG1heFNpemVcclxuICAgICAgICAgICAgc3RhcnRQYWdlID0gKChNYXRoLmNlaWwoY3VycmVudFBhZ2UgLyBtYXhTaXplKSAtIDEpICogbWF4U2l6ZSkgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRqdXN0IGxhc3QgcGFnZSBpZiBsaW1pdCBpcyBleGNlZWRlZFxyXG4gICAgICAgICAgICBlbmRQYWdlID0gTWF0aC5taW4oc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDEsIHRvdGFsUGFnZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyIGxpbmtzXHJcbiAgICAgICAgZm9yICh2YXIgbnVtYmVyID0gc3RhcnRQYWdlOyBudW1iZXIgPD0gZW5kUGFnZTsgbnVtYmVyKyspIHtcclxuICAgICAgICAgIHZhciBwYWdlID0gbWFrZVBhZ2UobnVtYmVyLCBudW1iZXIsIHBhZ2luYXRpb25DdHJsLmlzQWN0aXZlKG51bWJlciksIGZhbHNlKTtcclxuICAgICAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xyXG4gICAgICAgIGlmICggaXNNYXhTaXplZCAmJiAhIHJvdGF0ZSApIHtcclxuICAgICAgICAgIGlmICggc3RhcnRQYWdlID4gMSApIHtcclxuICAgICAgICAgICAgdmFyIHByZXZpb3VzUGFnZVNldCA9IG1ha2VQYWdlKHN0YXJ0UGFnZSAtIDEsICcuLi4nLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBwYWdlcy51bnNoaWZ0KHByZXZpb3VzUGFnZVNldCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCBlbmRQYWdlIDwgdG90YWxQYWdlcyApIHtcclxuICAgICAgICAgICAgdmFyIG5leHRQYWdlU2V0ID0gbWFrZVBhZ2UoZW5kUGFnZSArIDEsICcuLi4nLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlU2V0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBwcmV2aW91cyAmIG5leHQgbGlua3NcclxuICAgICAgICBpZiAoZGlyZWN0aW9uTGlua3MpIHtcclxuICAgICAgICAgIHZhciBwcmV2aW91c1BhZ2UgPSBtYWtlUGFnZShjdXJyZW50UGFnZSAtIDEsIHByZXZpb3VzVGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vUHJldmlvdXMoKSk7XHJcbiAgICAgICAgICBwYWdlcy51bnNoaWZ0KHByZXZpb3VzUGFnZSk7XHJcblxyXG4gICAgICAgICAgdmFyIG5leHRQYWdlID0gbWFrZVBhZ2UoY3VycmVudFBhZ2UgKyAxLCBuZXh0VGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vTmV4dCgpKTtcclxuICAgICAgICAgIHBhZ2VzLnB1c2gobmV4dFBhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGZpcnN0ICYgbGFzdCBsaW5rc1xyXG4gICAgICAgIGlmIChib3VuZGFyeUxpbmtzKSB7XHJcbiAgICAgICAgICB2YXIgZmlyc3RQYWdlID0gbWFrZVBhZ2UoMSwgZmlyc3RUZXh0LCBmYWxzZSwgcGFnaW5hdGlvbkN0cmwubm9QcmV2aW91cygpKTtcclxuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoZmlyc3RQYWdlKTtcclxuXHJcbiAgICAgICAgICB2YXIgbGFzdFBhZ2UgPSBtYWtlUGFnZSh0b3RhbFBhZ2VzLCBsYXN0VGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vTmV4dCgpKTtcclxuICAgICAgICAgIHBhZ2VzLnB1c2gobGFzdFBhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhZ2VzO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmNvbnN0YW50KCdwYWdlckNvbmZpZycsIHtcclxuICBpdGVtc1BlclBhZ2U6IDEwLFxyXG4gIHByZXZpb3VzVGV4dDogJ8OCwqsgUHJldmlvdXMnLFxyXG4gIG5leHRUZXh0OiAnTmV4dCDDgsK7JyxcclxuICBhbGlnbjogdHJ1ZVxyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgncGFnZXInLCBbJ3BhZ2VyQ29uZmlnJywgZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgcGFnZTogJz0nLFxyXG4gICAgICB0b3RhbEl0ZW1zOiAnPScsXHJcbiAgICAgIG9uU2VsZWN0UGFnZTonICYnLFxyXG4gICAgICBudW1QYWdlczogJz0nXHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogJ1BhZ2luYXRpb25Db250cm9sbGVyJyxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHBhZ2luYXRpb25DdHJsKSB7XHJcblxyXG4gICAgICAvLyBTZXR1cCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgdmFyIHByZXZpb3VzVGV4dCA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLnByZXZpb3VzVGV4dCwgY29uZmlnLnByZXZpb3VzVGV4dCwgdHJ1ZSksXHJcbiAgICAgIG5leHRUZXh0ICAgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5uZXh0VGV4dCwgICAgIGNvbmZpZy5uZXh0VGV4dCwgICAgIHRydWUpLFxyXG4gICAgICBhbGlnbiAgICAgICAgICAgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMuYWxpZ24sICAgICAgICBjb25maWcuYWxpZ24pO1xyXG5cclxuICAgICAgcGFnaW5hdGlvbkN0cmwuaW5pdChjb25maWcuaXRlbXNQZXJQYWdlKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBwYWdlIG9iamVjdCB1c2VkIGluIHRlbXBsYXRlXHJcbiAgICAgIGZ1bmN0aW9uIG1ha2VQYWdlKG51bWJlciwgdGV4dCwgaXNEaXNhYmxlZCwgaXNQcmV2aW91cywgaXNOZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxyXG4gICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxyXG4gICAgICAgICAgcHJldmlvdXM6ICggYWxpZ24gJiYgaXNQcmV2aW91cyApLFxyXG4gICAgICAgICAgbmV4dDogKCBhbGlnbiAmJiBpc05leHQgKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhZ2luYXRpb25DdHJsLmdldFBhZ2VzID0gZnVuY3Rpb24oY3VycmVudFBhZ2UpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgbWFrZVBhZ2UoY3VycmVudFBhZ2UgLSAxLCBwcmV2aW91c1RleHQsIHBhZ2luYXRpb25DdHJsLm5vUHJldmlvdXMoKSwgdHJ1ZSwgZmFsc2UpLFxyXG4gICAgICAgICAgbWFrZVBhZ2UoY3VycmVudFBhZ2UgKyAxLCBuZXh0VGV4dCwgcGFnaW5hdGlvbkN0cmwubm9OZXh0KCksIGZhbHNlLCB0cnVlKVxyXG4gICAgICAgIF07XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBhbmltYXRpb24gYXMgYVxyXG4gKiBmdW5jdGlvbiwgcGxhY2VtZW50IGFzIGEgZnVuY3Rpb24sIGluc2lkZSwgc3VwcG9ydCBmb3IgbW9yZSB0cmlnZ2VycyB0aGFuXHJcbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGh0bWwgdG9vbHRpcHMsIGFuZCBzZWxlY3RvciBkZWxlZ2F0aW9uLlxyXG4gKi9cclxuYW5ndWxhci5tb2R1bGUoICd1aS5ib290c3RyYXAudG9vbHRpcCcsIFsgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsICd1aS5ib290c3RyYXAuYmluZEh0bWwnIF0gKVxyXG5cclxuLyoqXHJcbiAqIFRoZSAkdG9vbHRpcCBzZXJ2aWNlIGNyZWF0ZXMgdG9vbHRpcC0gYW5kIHBvcG92ZXItbGlrZSBkaXJlY3RpdmVzIGFzIHdlbGwgYXNcclxuICogaG91c2VzIGdsb2JhbCBvcHRpb25zIGZvciB0aGVtLlxyXG4gKi9cclxuLnByb3ZpZGVyKCAnJHRvb2x0aXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB0b29sdGlwIGFuZCBwb3BvdmVyLlxyXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICAgIHBsYWNlbWVudDogJ3RvcCcsXHJcbiAgICBhbmltYXRpb246IHRydWUsXHJcbiAgICBwb3B1cERlbGF5OiAwXHJcbiAgfTtcclxuXHJcbiAgLy8gRGVmYXVsdCBoaWRlIHRyaWdnZXJzIGZvciBlYWNoIHNob3cgdHJpZ2dlclxyXG4gIHZhciB0cmlnZ2VyTWFwID0ge1xyXG4gICAgJ21vdXNlZW50ZXInOiAnbW91c2VsZWF2ZScsXHJcbiAgICAnY2xpY2snOiAnY2xpY2snLFxyXG4gICAgJ2ZvY3VzJzogJ2JsdXInXHJcbiAgfTtcclxuXHJcbiAgLy8gVGhlIG9wdGlvbnMgc3BlY2lmaWVkIHRvIHRoZSBwcm92aWRlciBnbG9iYWxseS5cclxuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IHt9O1xyXG4gIFxyXG4gIC8qKlxyXG4gICAqIGBvcHRpb25zKHt9KWAgYWxsb3dzIGdsb2JhbCBjb25maWd1cmF0aW9uIG9mIGFsbCB0b29sdGlwcyBpbiB0aGVcclxuICAgKiBhcHBsaWNhdGlvbi5cclxuICAgKlxyXG4gICAqICAgdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCAnQXBwJywgWyd1aS5ib290c3RyYXAudG9vbHRpcCddLCBmdW5jdGlvbiggJHRvb2x0aXBQcm92aWRlciApIHtcclxuICAgKiAgICAgLy8gcGxhY2UgdG9vbHRpcHMgbGVmdCBpbnN0ZWFkIG9mIHRvcCBieSBkZWZhdWx0XHJcbiAgICogICAgICR0b29sdGlwUHJvdmlkZXIub3B0aW9ucyggeyBwbGFjZW1lbnQ6ICdsZWZ0JyB9ICk7XHJcbiAgICogICB9KTtcclxuICAgKi9cclxuXHR0aGlzLm9wdGlvbnMgPSBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblx0XHRhbmd1bGFyLmV4dGVuZCggZ2xvYmFsT3B0aW9ucywgdmFsdWUgKTtcclxuXHR9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gZXh0ZW5kIHRoZSBzZXQgb2YgdHJpZ2dlciBtYXBwaW5ncyBhdmFpbGFibGUuIEUuZy46XHJcbiAgICpcclxuICAgKiAgICR0b29sdGlwUHJvdmlkZXIuc2V0VHJpZ2dlcnMoICdvcGVuVHJpZ2dlcic6ICdjbG9zZVRyaWdnZXInICk7XHJcbiAgICovXHJcbiAgdGhpcy5zZXRUcmlnZ2VycyA9IGZ1bmN0aW9uIHNldFRyaWdnZXJzICggdHJpZ2dlcnMgKSB7XHJcbiAgICBhbmd1bGFyLmV4dGVuZCggdHJpZ2dlck1hcCwgdHJpZ2dlcnMgKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciB0cmFuc2xhdGluZyBjYW1lbC1jYXNlIHRvIHNuYWtlLWNhc2UuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lKXtcclxuICAgIHZhciByZWdleHAgPSAvW0EtWl0vZztcclxuICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XHJcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24obGV0dGVyLCBwb3MpIHtcclxuICAgICAgcmV0dXJuIChwb3MgPyBzZXBhcmF0b3IgOiAnJykgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYWN0dWFsIGluc3RhbmNlIG9mIHRoZSAkdG9vbHRpcCBzZXJ2aWNlLlxyXG4gICAqIFRPRE8gc3VwcG9ydCBtdWx0aXBsZSB0cmlnZ2Vyc1xyXG4gICAqL1xyXG4gIHRoaXMuJGdldCA9IFsgJyR3aW5kb3cnLCAnJGNvbXBpbGUnLCAnJHRpbWVvdXQnLCAnJHBhcnNlJywgJyRkb2N1bWVudCcsICckcG9zaXRpb24nLCAnJGludGVycG9sYXRlJywgZnVuY3Rpb24gKCAkd2luZG93LCAkY29tcGlsZSwgJHRpbWVvdXQsICRwYXJzZSwgJGRvY3VtZW50LCAkcG9zaXRpb24sICRpbnRlcnBvbGF0ZSApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAkdG9vbHRpcCAoIHR5cGUsIHByZWZpeCwgZGVmYXVsdFRyaWdnZXJTaG93ICkge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKCB7fSwgZGVmYXVsdE9wdGlvbnMsIGdsb2JhbE9wdGlvbnMgKTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBzaG93IGFuZCBoaWRlIHRyaWdnZXJzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBJZiBhIHRyaWdnZXIgaXMgc3VwcGxpZWQsXHJcbiAgICAgICAqIGl0IGlzIHVzZWQgdG8gc2hvdyB0aGUgdG9vbHRpcDsgb3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRyaWdnZXJgXHJcbiAgICAgICAqIG9wdGlvbiBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZDsgZWxzZSBpdCB3aWxsXHJcbiAgICAgICAqIGRlZmF1bHQgdG8gdGhlIHRyaWdnZXIgc3VwcGxpZWQgdG8gdGhpcyBkaXJlY3RpdmUgZmFjdG9yeS5cclxuICAgICAgICpcclxuICAgICAgICogVGhlIGhpZGUgdHJpZ2dlciBpcyBiYXNlZCBvbiB0aGUgc2hvdyB0cmlnZ2VyLiBJZiB0aGUgYHRyaWdnZXJgIG9wdGlvblxyXG4gICAgICAgKiB3YXMgcGFzc2VkIHRvIHRoZSBgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zYCBtZXRob2QsIGl0IHdpbGwgdXNlIHRoZVxyXG4gICAgICAgKiBtYXBwZWQgdHJpZ2dlciBmcm9tIGB0cmlnZ2VyTWFwYCBvciB0aGUgcGFzc2VkIHRyaWdnZXIgaWYgdGhlIG1hcCBpc1xyXG4gICAgICAgKiB1bmRlZmluZWQ7IG90aGVyd2lzZSwgaXQgdXNlcyB0aGUgYHRyaWdnZXJNYXBgIHZhbHVlIG9mIHRoZSBzaG93XHJcbiAgICAgICAqIHRyaWdnZXI7IGVsc2UgaXQgd2lsbCBqdXN0IHVzZSB0aGUgc2hvdyB0cmlnZ2VyLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gZ2V0VHJpZ2dlcnMgKCB0cmlnZ2VyICkge1xyXG4gICAgICAgIHZhciBzaG93ID0gdHJpZ2dlciB8fCBvcHRpb25zLnRyaWdnZXIgfHwgZGVmYXVsdFRyaWdnZXJTaG93O1xyXG4gICAgICAgIHZhciBoaWRlID0gdHJpZ2dlck1hcFtzaG93XSB8fCBzaG93O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzaG93OiBzaG93LFxyXG4gICAgICAgICAgaGlkZTogaGlkZVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkaXJlY3RpdmVOYW1lID0gc25ha2VfY2FzZSggdHlwZSApO1xyXG5cclxuICAgICAgdmFyIHN0YXJ0U3ltID0gJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCk7XHJcbiAgICAgIHZhciBlbmRTeW0gPSAkaW50ZXJwb2xhdGUuZW5kU3ltYm9sKCk7XHJcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IFxyXG4gICAgICAgICc8JysgZGlyZWN0aXZlTmFtZSArJy1wb3B1cCAnK1xyXG4gICAgICAgICAgJ3RpdGxlPVwiJytzdGFydFN5bSsndHRfdGl0bGUnK2VuZFN5bSsnXCIgJytcclxuICAgICAgICAgICdjb250ZW50PVwiJytzdGFydFN5bSsndHRfY29udGVudCcrZW5kU3ltKydcIiAnK1xyXG4gICAgICAgICAgJ3BsYWNlbWVudD1cIicrc3RhcnRTeW0rJ3R0X3BsYWNlbWVudCcrZW5kU3ltKydcIiAnK1xyXG4gICAgICAgICAgJ2FuaW1hdGlvbj1cInR0X2FuaW1hdGlvbigpXCIgJytcclxuICAgICAgICAgICdpcy1vcGVuPVwidHRfaXNPcGVuXCInK1xyXG4gICAgICAgICAgJz4nK1xyXG4gICAgICAgICc8LycrIGRpcmVjdGl2ZU5hbWUgKyctcG9wdXA+JztcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICAgICAgc2NvcGU6IHRydWUsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayAoIHNjb3BlLCBlbGVtZW50LCBhdHRycyApIHtcclxuICAgICAgICAgIHZhciB0b29sdGlwID0gJGNvbXBpbGUoIHRlbXBsYXRlICkoIHNjb3BlICk7XHJcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICB2YXIgcG9wdXBUaW1lb3V0O1xyXG4gICAgICAgICAgdmFyICRib2R5O1xyXG4gICAgICAgICAgdmFyIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCBvcHRpb25zLmFwcGVuZFRvQm9keSApID8gb3B0aW9ucy5hcHBlbmRUb0JvZHkgOiBmYWxzZTtcclxuICAgICAgICAgIHZhciB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKCB1bmRlZmluZWQgKTtcclxuICAgICAgICAgIHZhciBoYXNSZWdpc3RlcmVkVHJpZ2dlcnMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBpcyBub3Qgb3Blbi5cclxuICAgICAgICAgIC8vIFRPRE8gYWRkIGFiaWxpdHkgdG8gc3RhcnQgdG9vbHRpcCBvcGVuZWRcclxuICAgICAgICAgIHNjb3BlLnR0X2lzT3BlbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIHRvZ2dsZVRvb2x0aXBCaW5kICgpIHtcclxuICAgICAgICAgICAgaWYgKCAhIHNjb3BlLnR0X2lzT3BlbiApIHtcclxuICAgICAgICAgICAgICBzaG93VG9vbHRpcEJpbmQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwIHdpdGggZGVsYXkgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2hvdyBpdCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXBCaW5kKCkge1xyXG4gICAgICAgICAgICBpZiAoIHNjb3BlLnR0X3BvcHVwRGVsYXkgKSB7XHJcbiAgICAgICAgICAgICAgcG9wdXBUaW1lb3V0ID0gJHRpbWVvdXQoIHNob3csIHNjb3BlLnR0X3BvcHVwRGVsYXkgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzY29wZS4kYXBwbHkoIHNob3cgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwQmluZCAoKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxyXG4gICAgICAgICAgZnVuY3Rpb24gc2hvdygpIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgdHRXaWR0aCxcclxuICAgICAgICAgICAgICAgIHR0SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgdHRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgZW1wdHkgdG9vbHRpcHMuXHJcbiAgICAgICAgICAgIGlmICggISBzY29wZS50dF9jb250ZW50ICkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHJlbW92ZSB0cmFuc2l0aW9uLCB3ZSBtdXN0IGNhbmNlbCBpdCwgbGVzdCB0aGVcclxuICAgICAgICAgICAgLy8gdG9vbHRpcCBiZSBteXN0ZXJpb3VzbHkgcmVtb3ZlZC5cclxuICAgICAgICAgICAgaWYgKCB0cmFuc2l0aW9uVGltZW91dCApIHtcclxuICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoIHRyYW5zaXRpb25UaW1lb3V0ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCBwb3NpdGlvbmluZy5cclxuICAgICAgICAgICAgdG9vbHRpcC5jc3MoeyB0b3A6IDAsIGxlZnQ6IDAsIGRpc3BsYXk6ICdibG9jaycgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBOb3cgd2UgYWRkIGl0IHRvIHRoZSBET00gYmVjYXVzZSBuZWVkIHNvbWUgaW5mbyBhYm91dCBpdC4gQnV0IGl0J3Mgbm90IFxyXG4gICAgICAgICAgICAvLyB2aXNpYmxlIHlldCBhbnl3YXkuXHJcbiAgICAgICAgICAgIGlmICggYXBwZW5kVG9Cb2R5ICkge1xyXG4gICAgICAgICAgICAgICAgJGJvZHkgPSAkYm9keSB8fCAkZG9jdW1lbnQuZmluZCggJ2JvZHknICk7XHJcbiAgICAgICAgICAgICAgICAkYm9keS5hcHBlbmQoIHRvb2x0aXAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBlbGVtZW50LmFmdGVyKCB0b29sdGlwICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGRpcmVjdGl2ZSBlbGVtZW50LlxyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGFwcGVuZFRvQm9keSA/ICRwb3NpdGlvbi5vZmZzZXQoIGVsZW1lbnQgKSA6ICRwb3NpdGlvbi5wb3NpdGlvbiggZWxlbWVudCApO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSB0b29sdGlwIHNvIHdlIGNhbiBjZW50ZXIgaXQuXHJcbiAgICAgICAgICAgIHR0V2lkdGggPSB0b29sdGlwLnByb3AoICdvZmZzZXRXaWR0aCcgKTtcclxuICAgICAgICAgICAgdHRIZWlnaHQgPSB0b29sdGlwLnByb3AoICdvZmZzZXRIZWlnaHQnICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRvb2x0aXAncyB0b3AgYW5kIGxlZnQgY29vcmRpbmF0ZXMgdG8gY2VudGVyIGl0IHdpdGhcclxuICAgICAgICAgICAgLy8gdGhpcyBkaXJlY3RpdmUuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoIHNjb3BlLnR0X3BsYWNlbWVudCApIHtcclxuICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICB0dFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCAvIDIgLSB0dEhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyBwb3NpdGlvbi53aWR0aFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICB0dFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCArIHBvc2l0aW9uLndpZHRoIC8gMiAtIHR0V2lkdGggLyAyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB0dFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCAvIDIgLSB0dEhlaWdodCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSB0dFdpZHRoXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHR0UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gdHRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyBwb3NpdGlvbi53aWR0aCAvIDIgLSB0dFdpZHRoIC8gMlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0dFBvc2l0aW9uLnRvcCArPSAncHgnO1xyXG4gICAgICAgICAgICB0dFBvc2l0aW9uLmxlZnQgKz0gJ3B4JztcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdyBzZXQgdGhlIGNhbGN1bGF0ZWQgcG9zaXRpb25pbmcuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuY3NzKCB0dFBvc2l0aW9uICk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFuZCBzaG93IHRoZSB0b29sdGlwLlxyXG4gICAgICAgICAgICBzY29wZS50dF9pc09wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sdGlwIHBvcHVwIGVsZW1lbnQuXHJcbiAgICAgICAgICBmdW5jdGlvbiBoaWRlKCkge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3Q6IHdlIGRvbid0IHNob3cgaXQgYW55bW9yZS5cclxuICAgICAgICAgICAgc2NvcGUudHRfaXNPcGVuID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvL2lmIHRvb2x0aXAgaXMgZ29pbmcgdG8gYmUgc2hvd24gYWZ0ZXIgZGVsYXksIHdlIG11c3QgY2FuY2VsIHRoaXNcclxuICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKCBwb3B1cFRpbWVvdXQgKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFuZCBub3cgd2UgcmVtb3ZlIGl0IGZyb20gdGhlIERPTS4gSG93ZXZlciwgaWYgd2UgaGF2ZSBhbmltYXRpb24sIHdlIFxyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHdhaXQgZm9yIGl0IHRvIGV4cGlyZSBiZWZvcmVoYW5kLlxyXG4gICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIHBvcnQgb2YgdGhlIHRyYW5zaXRpb25zIGxpYnJhcnkuXHJcbiAgICAgICAgICAgIGlmICggYW5ndWxhci5pc0RlZmluZWQoIHNjb3BlLnR0X2FuaW1hdGlvbiApICYmIHNjb3BlLnR0X2FuaW1hdGlvbigpICkge1xyXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lb3V0ID0gJHRpbWVvdXQoIGZ1bmN0aW9uICgpIHsgdG9vbHRpcC5yZW1vdmUoKTsgfSwgNTAwICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogT2JzZXJ2ZSB0aGUgcmVsZXZhbnQgYXR0cmlidXRlcy5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHR5cGUsIGZ1bmN0aW9uICggdmFsICkge1xyXG4gICAgICAgICAgICBzY29wZS50dF9jb250ZW50ID0gdmFsO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHByZWZpeCsnVGl0bGUnLCBmdW5jdGlvbiAoIHZhbCApIHtcclxuICAgICAgICAgICAgc2NvcGUudHRfdGl0bGUgPSB2YWw7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSggcHJlZml4KydQbGFjZW1lbnQnLCBmdW5jdGlvbiAoIHZhbCApIHtcclxuICAgICAgICAgICAgc2NvcGUudHRfcGxhY2VtZW50ID0gYW5ndWxhci5pc0RlZmluZWQoIHZhbCApID8gdmFsIDogb3B0aW9ucy5wbGFjZW1lbnQ7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSggcHJlZml4KydBbmltYXRpb24nLCBmdW5jdGlvbiAoIHZhbCApIHtcclxuICAgICAgICAgICAgc2NvcGUudHRfYW5pbWF0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoIHZhbCApID8gJHBhcnNlKCB2YWwgKSA6IGZ1bmN0aW9uKCl7IHJldHVybiBvcHRpb25zLmFuaW1hdGlvbjsgfTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCBwcmVmaXgrJ1BvcHVwRGVsYXknLCBmdW5jdGlvbiAoIHZhbCApIHtcclxuICAgICAgICAgICAgdmFyIGRlbGF5ID0gcGFyc2VJbnQoIHZhbCwgMTAgKTtcclxuICAgICAgICAgICAgc2NvcGUudHRfcG9wdXBEZWxheSA9ICEgaXNOYU4oZGVsYXkpID8gZGVsYXkgOiBvcHRpb25zLnBvcHVwRGVsYXk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSggcHJlZml4KydUcmlnZ2VyJywgZnVuY3Rpb24gKCB2YWwgKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzUmVnaXN0ZXJlZFRyaWdnZXJzKSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC51bmJpbmQoIHRyaWdnZXJzLnNob3csIHNob3dUb29sdGlwQmluZCApO1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQudW5iaW5kKCB0cmlnZ2Vycy5oaWRlLCBoaWRlVG9vbHRpcEJpbmQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHJpZ2dlcnMgPSBnZXRUcmlnZ2VycyggdmFsICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIHRyaWdnZXJzLnNob3cgPT09IHRyaWdnZXJzLmhpZGUgKSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKCB0cmlnZ2Vycy5zaG93LCB0b2dnbGVUb29sdGlwQmluZCApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQuYmluZCggdHJpZ2dlcnMuc2hvdywgc2hvd1Rvb2x0aXBCaW5kICk7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKCB0cmlnZ2Vycy5oaWRlLCBoaWRlVG9vbHRpcEJpbmQgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaGFzUmVnaXN0ZXJlZFRyaWdnZXJzID0gdHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCBwcmVmaXgrJ0FwcGVuZFRvQm9keScsIGZ1bmN0aW9uICggdmFsICkge1xyXG4gICAgICAgICAgICBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZCggdmFsICkgPyAkcGFyc2UoIHZhbCApKCBzY29wZSApIDogYXBwZW5kVG9Cb2R5O1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gaWYgYSB0b29sdGlwIGlzIGF0dGFjaGVkIHRvIDxib2R5PiB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBvblxyXG4gICAgICAgICAgLy8gbG9jYXRpb24gY2hhbmdlIGFzIGl0cyBwYXJlbnQgc2NvcGUgd2lsbCBwcm9iYWJseSBub3QgYmUgZGVzdHJveWVkXHJcbiAgICAgICAgICAvLyBieSB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAgaWYgKCBhcHBlbmRUb0JvZHkgKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uIGNsb3NlVG9vbHRpcE9uTG9jYXRpb25DaGFuZ2VTdWNjZXNzICgpIHtcclxuICAgICAgICAgICAgaWYgKCBzY29wZS50dF9pc09wZW4gKSB7XHJcbiAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyBkZXN0cm95ZWQgYW5kIHJlbW92ZWQuXHJcbiAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gb25EZXN0cm95VG9vbHRpcCgpIHtcclxuICAgICAgICAgICAgaWYgKCBzY29wZS50dF9pc09wZW4gKSB7XHJcbiAgICAgICAgICAgICAgaGlkZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgfV07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCAndG9vbHRpcFBvcHVwJywgZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbCdcclxuICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSggJ3Rvb2x0aXAnLCBbICckdG9vbHRpcCcsIGZ1bmN0aW9uICggJHRvb2x0aXAgKSB7XHJcbiAgcmV0dXJuICR0b29sdGlwKCAndG9vbHRpcCcsICd0b29sdGlwJywgJ21vdXNlZW50ZXInICk7XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSggJ3Rvb2x0aXBIdG1sVW5zYWZlUG9wdXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgc2NvcGU6IHsgY29udGVudDogJ0AnLCBwbGFjZW1lbnQ6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXVuc2FmZS1wb3B1cC5odG1sJ1xyXG4gIH07XHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCAndG9vbHRpcEh0bWxVbnNhZmUnLCBbICckdG9vbHRpcCcsIGZ1bmN0aW9uICggJHRvb2x0aXAgKSB7XHJcbiAgcmV0dXJuICR0b29sdGlwKCAndG9vbHRpcEh0bWxVbnNhZmUnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJyApO1xyXG59XSk7XHJcblxyXG4vKipcclxuICogVGhlIGZvbGxvd2luZyBmZWF0dXJlcyBhcmUgc3RpbGwgb3V0c3RhbmRpbmc6IHBvcHVwIGRlbGF5LCBhbmltYXRpb24gYXMgYVxyXG4gKiBmdW5jdGlvbiwgcGxhY2VtZW50IGFzIGEgZnVuY3Rpb24sIGluc2lkZSwgc3VwcG9ydCBmb3IgbW9yZSB0cmlnZ2VycyB0aGFuXHJcbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGh0bWwgcG9wb3ZlcnMsIGFuZCBzZWxlY3RvciBkZWxlZ2F0YXRpb24uXHJcbiAqL1xyXG5hbmd1bGFyLm1vZHVsZSggJ3VpLmJvb3RzdHJhcC5wb3BvdmVyJywgWyAndWkuYm9vdHN0cmFwLnRvb2x0aXAnIF0gKVxyXG4uZGlyZWN0aXZlKCAncG9wb3ZlclBvcHVwJywgZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBzY29wZTogeyB0aXRsZTogJ0AnLCBjb250ZW50OiAnQCcsIHBsYWNlbWVudDogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicgfSxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWwnXHJcbiAgfTtcclxufSlcclxuLmRpcmVjdGl2ZSggJ3BvcG92ZXInLCBbICckY29tcGlsZScsICckdGltZW91dCcsICckcGFyc2UnLCAnJHdpbmRvdycsICckdG9vbHRpcCcsIGZ1bmN0aW9uICggJGNvbXBpbGUsICR0aW1lb3V0LCAkcGFyc2UsICR3aW5kb3csICR0b29sdGlwICkge1xyXG4gIHJldHVybiAkdG9vbHRpcCggJ3BvcG92ZXInLCAncG9wb3ZlcicsICdjbGljaycgKTtcclxufV0pO1xyXG5cclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXInLCBbJ3VpLmJvb3RzdHJhcC50cmFuc2l0aW9uJ10pXHJcblxyXG4uY29uc3RhbnQoJ3Byb2dyZXNzQ29uZmlnJywge1xyXG4gIGFuaW1hdGU6IHRydWUsXHJcbiAgYXV0b1R5cGU6IGZhbHNlLFxyXG4gIHN0YWNrZWRUeXBlczogWydzdWNjZXNzJywgJ2luZm8nLCAnd2FybmluZycsICdkYW5nZXInXVxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ1Byb2dyZXNzQmFyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICdwcm9ncmVzc0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCBwcm9ncmVzc0NvbmZpZykge1xyXG5cclxuICAgIC8vIFdoZXRoZXIgYmFyIHRyYW5zaXRpb25zIHNob3VsZCBiZSBhbmltYXRlZFxyXG4gICAgdmFyIGFuaW1hdGUgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYW5pbWF0ZSkgPyAkc2NvcGUuJGV2YWwoJGF0dHJzLmFuaW1hdGUpIDogcHJvZ3Jlc3NDb25maWcuYW5pbWF0ZTtcclxuICAgIHZhciBhdXRvVHlwZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hdXRvVHlwZSkgPyAkc2NvcGUuJGV2YWwoJGF0dHJzLmF1dG9UeXBlKSA6IHByb2dyZXNzQ29uZmlnLmF1dG9UeXBlO1xyXG4gICAgdmFyIHN0YWNrZWRUeXBlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGFja2VkVHlwZXMpID8gJHNjb3BlLiRldmFsKCdbJyArICRhdHRycy5zdGFja2VkVHlwZXMgKyAnXScpIDogcHJvZ3Jlc3NDb25maWcuc3RhY2tlZFR5cGVzO1xyXG5cclxuICAgIC8vIENyZWF0ZSBiYXIgb2JqZWN0XHJcbiAgICB0aGlzLm1ha2VCYXIgPSBmdW5jdGlvbihuZXdCYXIsIG9sZEJhciwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSAoYW5ndWxhci5pc09iamVjdChuZXdCYXIpKSA/IG5ld0Jhci52YWx1ZSA6IChuZXdCYXIgfHwgMCk7XHJcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gIChhbmd1bGFyLmlzT2JqZWN0KG9sZEJhcikpID8gb2xkQmFyLnZhbHVlIDogKG9sZEJhciB8fCAwKTtcclxuICAgICAgICB2YXIgdHlwZSA9IChhbmd1bGFyLmlzT2JqZWN0KG5ld0JhcikgJiYgYW5ndWxhci5pc0RlZmluZWQobmV3QmFyLnR5cGUpKSA/IG5ld0Jhci50eXBlIDogKGF1dG9UeXBlKSA/IGdldFN0YWNrZWRUeXBlKGluZGV4IHx8IDApIDogbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZnJvbTogb2xkVmFsdWUsXHJcbiAgICAgICAgICAgIHRvOiBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFN0YWNrZWRUeXBlKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YWNrZWRUeXBlc1tpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hZGRCYXIgPSBmdW5jdGlvbihiYXIpIHtcclxuICAgICAgICAkc2NvcGUuYmFycy5wdXNoKGJhcik7XHJcbiAgICAgICAgJHNjb3BlLnRvdGFsUGVyY2VudCArPSBiYXIudG87XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xlYXJCYXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJHNjb3BlLmJhcnMgPSBbXTtcclxuICAgICAgICAkc2NvcGUudG90YWxQZXJjZW50ID0gMDtcclxuICAgIH07XHJcbiAgICB0aGlzLmNsZWFyQmFycygpO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3Byb2dyZXNzJywgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgICAgY29udHJvbGxlcjogJ1Byb2dyZXNzQmFyQ29udHJvbGxlcicsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgdmFsdWU6ICc9cGVyY2VudCcsXHJcbiAgICAgICAgICAgIG9uRnVsbDogJyYnLFxyXG4gICAgICAgICAgICBvbkVtcHR5OiAnJidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbCcsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xlYXJCYXJzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNBcnJheShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGFja2VkIHByb2dyZXNzIGJhclxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbj1uZXdWYWx1ZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hZGRCYXIoY29udHJvbGxlci5tYWtlQmFyKG5ld1ZhbHVlW2ldLCBvbGRWYWx1ZVtpXSwgaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGxlIGJhclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWRkQmFyKGNvbnRyb2xsZXIubWFrZUJhcihuZXdWYWx1ZSwgb2xkVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUb3RhbCBwZXJjZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ3RvdGFsUGVyY2VudCcsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGUub25GdWxsKCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5vbkVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgncHJvZ3Jlc3NiYXInLCBbJyR0cmFuc2l0aW9uJywgZnVuY3Rpb24oJHRyYW5zaXRpb24pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICB3aWR0aDogJz0nLFxyXG4gICAgICAgICAgICBvbGQ6ICc9JyxcclxuICAgICAgICAgICAgdHlwZTogJz0nLFxyXG4gICAgICAgICAgICBhbmltYXRlOiAnPSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWwnLFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgnd2lkdGgnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLmFuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNzcygnd2lkdGgnLCBzY29wZS5vbGQgKyAnJScpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0cmFuc2l0aW9uKGVsZW1lbnQsIHt3aWR0aDogdmFsdWUgKyAnJSd9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoJ3dpZHRoJywgdmFsdWUgKyAnJScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucmF0aW5nJywgW10pXHJcblxyXG4uY29uc3RhbnQoJ3JhdGluZ0NvbmZpZycsIHtcclxuICBtYXg6IDUsXHJcbiAgc3RhdGVPbjogbnVsbCxcclxuICBzdGF0ZU9mZjogbnVsbFxyXG59KVxyXG5cclxuLmNvbnRyb2xsZXIoJ1JhdGluZ0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJ3JhdGluZ0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsIHJhdGluZ0NvbmZpZykge1xyXG5cclxuICB0aGlzLm1heFJhbmdlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1heCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubWF4KSA6IHJhdGluZ0NvbmZpZy5tYXg7XHJcbiAgdGhpcy5zdGF0ZU9uID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnN0YXRlT24pID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnN0YXRlT24pIDogcmF0aW5nQ29uZmlnLnN0YXRlT247XHJcbiAgdGhpcy5zdGF0ZU9mZiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9mZikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPZmYpIDogcmF0aW5nQ29uZmlnLnN0YXRlT2ZmO1xyXG5cclxuICB0aGlzLmNyZWF0ZURlZmF1bHRSYW5nZSA9IGZ1bmN0aW9uKGxlbikge1xyXG4gICAgdmFyIGRlZmF1bHRTdGF0ZU9iamVjdCA9IHtcclxuICAgICAgc3RhdGVPbjogdGhpcy5zdGF0ZU9uLFxyXG4gICAgICBzdGF0ZU9mZjogdGhpcy5zdGF0ZU9mZlxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgc3RhdGVzID0gbmV3IEFycmF5KGxlbik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHN0YXRlc1tpXSA9IGRlZmF1bHRTdGF0ZU9iamVjdDtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZXM7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5ub3JtYWxpemVSYW5nZSA9IGZ1bmN0aW9uKHN0YXRlcykge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIHN0YXRlc1tpXS5zdGF0ZU9uID0gc3RhdGVzW2ldLnN0YXRlT24gfHwgdGhpcy5zdGF0ZU9uO1xyXG4gICAgICBzdGF0ZXNbaV0uc3RhdGVPZmYgPSBzdGF0ZXNbaV0uc3RhdGVPZmYgfHwgdGhpcy5zdGF0ZU9mZjtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2V0IG9iamVjdHMgdXNlZCBpbiB0ZW1wbGF0ZVxyXG4gICRzY29wZS5yYW5nZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yYXRpbmdTdGF0ZXMpID8gIHRoaXMubm9ybWFsaXplUmFuZ2UoYW5ndWxhci5jb3B5KCRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yYXRpbmdTdGF0ZXMpKSk6IHRoaXMuY3JlYXRlRGVmYXVsdFJhbmdlKHRoaXMubWF4UmFuZ2UpO1xyXG5cclxuICAkc2NvcGUucmF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoICRzY29wZS5yZWFkb25seSB8fCAkc2NvcGUudmFsdWUgPT09IHZhbHVlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAkc2NvcGUudmFsdWUgPSB2YWx1ZTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuZW50ZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYgKCAhICRzY29wZS5yZWFkb25seSApIHtcclxuICAgICAgJHNjb3BlLnZhbCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgJHNjb3BlLm9uSG92ZXIoe3ZhbHVlOiB2YWx1ZX0pO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJHNjb3BlLnZhbCA9IGFuZ3VsYXIuY29weSgkc2NvcGUudmFsdWUpO1xyXG4gICAgJHNjb3BlLm9uTGVhdmUoKTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuJHdhdGNoKCd2YWx1ZScsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAkc2NvcGUudmFsID0gdmFsdWU7XHJcbiAgfSk7XHJcblxyXG4gICRzY29wZS5yZWFkb25seSA9IGZhbHNlO1xyXG4gIGlmICgkYXR0cnMucmVhZG9ubHkpIHtcclxuICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLnJlYWRvbmx5KSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgJHNjb3BlLnJlYWRvbmx5ID0gISF2YWx1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCdyYXRpbmcnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICBzY29wZToge1xyXG4gICAgICB2YWx1ZTogJz0nLFxyXG4gICAgICBvbkhvdmVyOiAnJicsXHJcbiAgICAgIG9uTGVhdmU6ICcmJ1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6ICdSYXRpbmdDb250cm9sbGVyJyxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sJyxcclxuICAgIHJlcGxhY2U6IHRydWVcclxuICB9O1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcclxuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnNcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFuZ3VsYXJKUyB2ZXJzaW9uIG9mIHRoZSB0YWJzIGRpcmVjdGl2ZS5cclxuICovXHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRhYnMnLCBbXSlcclxuXHJcbi5kaXJlY3RpdmUoJ3RhYnMnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHRhYnNgIGRpcmVjdGl2ZSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgbWlncmF0ZSB0byBgdGFic2V0YC4gSW5zdHJ1Y3Rpb25zIGNhbiBiZSBmb3VuZCBhdCBodHRwOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL2Jvb3RzdHJhcC90cmVlL21hc3Rlci9DSEFOR0VMT0cubWRcIik7XHJcbiAgfTtcclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdUYWJzZXRDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLFxyXG5mdW5jdGlvbiBUYWJzZXRDdHJsKCRzY29wZSwgJGVsZW1lbnQpIHtcclxuXHJcbiAgdmFyIGN0cmwgPSB0aGlzLFxyXG4gICAgdGFicyA9IGN0cmwudGFicyA9ICRzY29wZS50YWJzID0gW107XHJcblxyXG4gIGN0cmwuc2VsZWN0ID0gZnVuY3Rpb24odGFiKSB7XHJcbiAgICBhbmd1bGFyLmZvckVhY2godGFicywgZnVuY3Rpb24odGFiKSB7XHJcbiAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgdGFiLmFjdGl2ZSA9IHRydWU7XHJcbiAgfTtcclxuXHJcbiAgY3RybC5hZGRUYWIgPSBmdW5jdGlvbiBhZGRUYWIodGFiKSB7XHJcbiAgICB0YWJzLnB1c2godGFiKTtcclxuICAgIGlmICh0YWJzLmxlbmd0aCA9PT0gMSB8fCB0YWIuYWN0aXZlKSB7XHJcbiAgICAgIGN0cmwuc2VsZWN0KHRhYik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY3RybC5yZW1vdmVUYWIgPSBmdW5jdGlvbiByZW1vdmVUYWIodGFiKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0YWJzLmluZGV4T2YodGFiKTtcclxuICAgIC8vU2VsZWN0IGEgbmV3IHRhYiBpZiB0aGUgdGFiIHRvIGJlIHJlbW92ZWQgaXMgc2VsZWN0ZWRcclxuICAgIGlmICh0YWIuYWN0aXZlICYmIHRhYnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAvL0lmIHRoaXMgaXMgdGhlIGxhc3QgdGFiLCBzZWxlY3QgdGhlIHByZXZpb3VzIHRhYi4gZWxzZSwgdGhlIG5leHQgdGFiLlxyXG4gICAgICB2YXIgbmV3QWN0aXZlSW5kZXggPSBpbmRleCA9PSB0YWJzLmxlbmd0aCAtIDEgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XHJcbiAgICAgIGN0cmwuc2VsZWN0KHRhYnNbbmV3QWN0aXZlSW5kZXhdKTtcclxuICAgIH1cclxuICAgIHRhYnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICB9O1xyXG59XSlcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJzZXRcclxuICogQHJlc3RyaWN0IEVBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUYWJzZXQgaXMgdGhlIG91dGVyIGNvbnRhaW5lciBmb3IgdGhlIHRhYnMgZGlyZWN0aXZlXHJcbiAqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHZlcnRpY2FsIFdoZXRoZXIgb3Igbm90IHRvIHVzZSB2ZXJ0aWNhbCBzdHlsaW5nIGZvciB0aGUgdGFicy5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBkaXJlY3Rpb24gIFdoYXQgZGlyZWN0aW9uIHRoZSB0YWJzIHNob3VsZCBiZSByZW5kZXJlZC4gQXZhaWxhYmxlOlxyXG4gKiAncmlnaHQnLCAnbGVmdCcsICdiZWxvdycuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxyXG4gIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICA8dGFic2V0PlxyXG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMVwiPjxiPkZpcnN0PC9iPiBDb250ZW50ITwvdGFiPlxyXG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMlwiPjxpPlNlY29uZDwvaT4gQ29udGVudCE8L3RhYj5cclxuICAgIDwvdGFic2V0PlxyXG4gICAgPGhyIC8+XHJcbiAgICA8dGFic2V0IHZlcnRpY2FsPVwidHJ1ZVwiPlxyXG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMVwiPjxiPkZpcnN0PC9iPiBWZXJ0aWNhbCBDb250ZW50ITwvdGFiPlxyXG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMlwiPjxpPlNlY29uZDwvaT4gVmVydGljYWwgQ29udGVudCE8L3RhYj5cclxuICAgIDwvdGFic2V0PlxyXG4gIDwvZmlsZT5cclxuPC9leGFtcGxlPlxyXG4gKi9cclxuLmRpcmVjdGl2ZSgndGFic2V0JywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICByZXF1aXJlOiAnXnRhYnNldCcsXHJcbiAgICBzY29wZToge30sXHJcbiAgICBjb250cm9sbGVyOiAnVGFic2V0Q29udHJvbGxlcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWwnLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24oZWxtLCBhdHRycywgdHJhbnNjbHVkZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB0YWJzZXRDdHJsKSB7XHJcbiAgICAgICAgc2NvcGUudmVydGljYWwgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy52ZXJ0aWNhbCkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLnZlcnRpY2FsKSA6IGZhbHNlO1xyXG4gICAgICAgIHNjb3BlLnR5cGUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMudHlwZSkgOiAndGFicyc7XHJcbiAgICAgICAgc2NvcGUuZGlyZWN0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZGlyZWN0aW9uKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMuZGlyZWN0aW9uKSA6ICd0b3AnO1xyXG4gICAgICAgIHNjb3BlLnRhYnNBYm92ZSA9IChzY29wZS5kaXJlY3Rpb24gIT0gJ2JlbG93Jyk7XHJcbiAgICAgICAgdGFic2V0Q3RybC4kc2NvcGUgPSBzY29wZTtcclxuICAgICAgICB0YWJzZXRDdHJsLiR0cmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiXHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IGhlYWRpbmcgVGhlIHZpc2libGUgaGVhZGluZywgb3IgdGl0bGUsIG9mIHRoZSB0YWIuIFNldCBIVE1MIGhlYWRpbmdzIHdpdGgge0BsaW5rIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJIZWFkaW5nIHRhYkhlYWRpbmd9LlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdCBBbiBleHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW4gdGhlIHRhYiBpcyBzZWxlY3RlZC5cclxuICogQHBhcmFtIHtib29sZWFuPX0gYWN0aXZlIEEgYmluZGluZywgdGVsbGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRhYiBpcyBzZWxlY3RlZC5cclxuICogQHBhcmFtIHtib29sZWFuPX0gZGlzYWJsZWQgQSBiaW5kaW5nLCB0ZWxsaW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGFiIGlzIGRpc2FibGVkLlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIHRhYiB3aXRoIGEgaGVhZGluZyBhbmQgY29udGVudC4gTXVzdCBiZSBwbGFjZWQgd2l0aGluIGEge0BsaW5rIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJzZXQgdGFic2V0fS5cclxuICpcclxuICogQGV4YW1wbGVcclxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XHJcbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgIDxkaXYgbmctY29udHJvbGxlcj1cIlRhYnNEZW1vQ3RybFwiPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbFwiIG5nLWNsaWNrPVwiaXRlbXNbMF0uYWN0aXZlID0gdHJ1ZVwiPlxyXG4gICAgICAgIFNlbGVjdCBpdGVtIDEsIHVzaW5nIGFjdGl2ZSBiaW5kaW5nXHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbFwiIG5nLWNsaWNrPVwiaXRlbXNbMV0uZGlzYWJsZWQgPSAhaXRlbXNbMV0uZGlzYWJsZWRcIj5cclxuICAgICAgICBFbmFibGUvZGlzYWJsZSBpdGVtIDIsIHVzaW5nIGRpc2FibGVkIGJpbmRpbmdcclxuICAgICAgPC9idXR0b24+XHJcbiAgICAgIDxiciAvPlxyXG4gICAgICA8dGFic2V0PlxyXG4gICAgICAgIDx0YWIgaGVhZGluZz1cIlRhYiAxXCI+Rmlyc3QgVGFiPC90YWI+XHJcbiAgICAgICAgPHRhYiBzZWxlY3Q9XCJhbGVydE1lKClcIj5cclxuICAgICAgICAgIDx0YWItaGVhZGluZz48aSBjbGFzcz1cImljb24tYmVsbFwiPjwvaT4gQWxlcnQgbWUhPC90YWItaGVhZGluZz5cclxuICAgICAgICAgIFNlY29uZCBUYWIsIHdpdGggYWxlcnQgY2FsbGJhY2sgYW5kIGh0bWwgaGVhZGluZyFcclxuICAgICAgICA8L3RhYj5cclxuICAgICAgICA8dGFiIG5nLXJlcGVhdD1cIml0ZW0gaW4gaXRlbXNcIlxyXG4gICAgICAgICAgaGVhZGluZz1cInt7aXRlbS50aXRsZX19XCJcclxuICAgICAgICAgIGRpc2FibGVkPVwiaXRlbS5kaXNhYmxlZFwiXHJcbiAgICAgICAgICBhY3RpdmU9XCJpdGVtLmFjdGl2ZVwiPlxyXG4gICAgICAgICAge3tpdGVtLmNvbnRlbnR9fVxyXG4gICAgICAgIDwvdGFiPlxyXG4gICAgICA8L3RhYnNldD5cclxuICAgIDwvZGl2PlxyXG4gIDwvZmlsZT5cclxuICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XHJcbiAgICBmdW5jdGlvbiBUYWJzRGVtb0N0cmwoJHNjb3BlKSB7XHJcbiAgICAgICRzY29wZS5pdGVtcyA9IFtcclxuICAgICAgICB7IHRpdGxlOlwiRHluYW1pYyBUaXRsZSAxXCIsIGNvbnRlbnQ6XCJEeW5hbWljIEl0ZW0gMFwiIH0sXHJcbiAgICAgICAgeyB0aXRsZTpcIkR5bmFtaWMgVGl0bGUgMlwiLCBjb250ZW50OlwiRHluYW1pYyBJdGVtIDFcIiwgZGlzYWJsZWQ6IHRydWUgfVxyXG4gICAgICBdO1xyXG5cclxuICAgICAgJHNjb3BlLmFsZXJ0TWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgYWxlcnQoXCJZb3UndmUgc2VsZWN0ZWQgdGhlIGFsZXJ0IHRhYiFcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIDwvZmlsZT5cclxuPC9leGFtcGxlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJIZWFkaW5nXHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhbiBIVE1MIGhlYWRpbmcgZm9yIGEge0BsaW5rIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWIgdGFifS4gTXVzdCBiZSBwbGFjZWQgYXMgYSBjaGlsZCBvZiBhIHRhYiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cclxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgPHRhYnNldD5cclxuICAgICAgPHRhYj5cclxuICAgICAgICA8dGFiLWhlYWRpbmc+PGI+SFRNTDwvYj4gaW4gbXkgdGl0bGVzPyE8L3RhYi1oZWFkaW5nPlxyXG4gICAgICAgIEFuZCBzb21lIGNvbnRlbnQsIHRvbyFcclxuICAgICAgPC90YWI+XHJcbiAgICAgIDx0YWI+XHJcbiAgICAgICAgPHRhYi1oZWFkaW5nPjxpIGNsYXNzPVwiaWNvbi1oZWFydFwiPjwvaT4gSWNvbiBoZWFkaW5nPyE/PC90YWItaGVhZGluZz5cclxuICAgICAgICBUaGF0J3MgcmlnaHQuXHJcbiAgICAgIDwvdGFiPlxyXG4gICAgPC90YWJzZXQ+XHJcbiAgPC9maWxlPlxyXG48L2V4YW1wbGU+XHJcbiAqL1xyXG4uZGlyZWN0aXZlKCd0YWInLCBbJyRwYXJzZScsICckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckY29tcGlsZScsXHJcbmZ1bmN0aW9uKCRwYXJzZSwgJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkY29tcGlsZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnXnRhYnNldCcsXHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RhYnMvdGFiLmh0bWwnLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIGhlYWRpbmc6ICdAJyxcclxuICAgICAgb25TZWxlY3Q6ICcmc2VsZWN0JywgLy9UaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBpbiBjb250ZW50SGVhZGluZ1RyYW5zY2x1ZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAvL29uY2UgaXQgaW5zZXJ0cyB0aGUgdGFiJ3MgY29udGVudCBpbnRvIHRoZSBkb21cclxuICAgICAgb25EZXNlbGVjdDogJyZkZXNlbGVjdCdcclxuICAgIH0sXHJcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy9FbXB0eSBjb250cm9sbGVyIHNvIG90aGVyIGRpcmVjdGl2ZXMgY2FuIHJlcXVpcmUgYmVpbmcgJ3VuZGVyJyBhIHRhYlxyXG4gICAgfSxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsbSwgYXR0cnMsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RMaW5rKHNjb3BlLCBlbG0sIGF0dHJzLCB0YWJzZXRDdHJsKSB7XHJcbiAgICAgICAgdmFyIGdldEFjdGl2ZSwgc2V0QWN0aXZlO1xyXG4gICAgICAgIGlmIChhdHRycy5hY3RpdmUpIHtcclxuICAgICAgICAgIGdldEFjdGl2ZSA9ICRwYXJzZShhdHRycy5hY3RpdmUpO1xyXG4gICAgICAgICAgc2V0QWN0aXZlID0gZ2V0QWN0aXZlLmFzc2lnbjtcclxuICAgICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKGdldEFjdGl2ZSwgZnVuY3Rpb24gdXBkYXRlQWN0aXZlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9ICEhdmFsdWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IGdldEFjdGl2ZShzY29wZS4kcGFyZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2V0QWN0aXZlID0gZ2V0QWN0aXZlID0gYW5ndWxhci5ub29wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcclxuICAgICAgICAgIHNldEFjdGl2ZShzY29wZS4kcGFyZW50LCBhY3RpdmUpO1xyXG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0YWJzZXRDdHJsLnNlbGVjdChzY29wZSk7XHJcbiAgICAgICAgICAgIHNjb3BlLm9uU2VsZWN0KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzY29wZS5vbkRlc2VsZWN0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNjb3BlLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCBhdHRycy5kaXNhYmxlZCApIHtcclxuICAgICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5kaXNhYmxlZCksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLmRpc2FibGVkID0gISEgdmFsdWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKCAhIHNjb3BlLmRpc2FibGVkICkge1xyXG4gICAgICAgICAgICBzY29wZS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRhYnNldEN0cmwuYWRkVGFiKHNjb3BlKTtcclxuICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB0YWJzZXRDdHJsLnJlbW92ZVRhYihzY29wZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHNjb3BlLmFjdGl2ZSkge1xyXG4gICAgICAgICAgc2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vV2UgbmVlZCB0byB0cmFuc2NsdWRlIGxhdGVyLCBvbmNlIHRoZSBjb250ZW50IGNvbnRhaW5lciBpcyByZWFkeS5cclxuICAgICAgICAvL3doZW4gdGhpcyBsaW5rIGhhcHBlbnMsIHdlJ3JlIGluc2lkZSBhIHRhYiBoZWFkaW5nLlxyXG4gICAgICAgIHNjb3BlLiR0cmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgndGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBbZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICByZXF1aXJlOiAnXnRhYicsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRycywgdGFiQ3RybCkge1xyXG4gICAgICBzY29wZS4kd2F0Y2goJ2hlYWRpbmdFbGVtZW50JywgZnVuY3Rpb24gdXBkYXRlSGVhZGluZ0VsZW1lbnQoaGVhZGluZykge1xyXG4gICAgICAgIGlmIChoZWFkaW5nKSB7XHJcbiAgICAgICAgICBlbG0uaHRtbCgnJyk7XHJcbiAgICAgICAgICBlbG0uYXBwZW5kKGhlYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd0YWJDb250ZW50VHJhbnNjbHVkZScsIFsnJGNvbXBpbGUnLCAnJHBhcnNlJywgZnVuY3Rpb24oJGNvbXBpbGUsICRwYXJzZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgcmVxdWlyZTogJ150YWJzZXQnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMpIHtcclxuICAgICAgdmFyIHRhYiA9IHNjb3BlLiRldmFsKGF0dHJzLnRhYkNvbnRlbnRUcmFuc2NsdWRlKTtcclxuXHJcbiAgICAgIC8vTm93IG91ciB0YWIgaXMgcmVhZHkgdG8gYmUgdHJhbnNjbHVkZWQ6IGJvdGggdGhlIHRhYiBoZWFkaW5nIGFyZWFcclxuICAgICAgLy9hbmQgdGhlIHRhYiBjb250ZW50IGFyZWEgYXJlIGxvYWRlZC4gIFRyYW5zY2x1ZGUgJ2VtIGJvdGguXHJcbiAgICAgIHRhYi4kdHJhbnNjbHVkZUZuKHRhYi4kcGFyZW50LCBmdW5jdGlvbihjb250ZW50cykge1xyXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb250ZW50cywgZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgaWYgKGlzVGFiSGVhZGluZyhub2RlKSkge1xyXG4gICAgICAgICAgICAvL0xldCB0YWJIZWFkaW5nVHJhbnNjbHVkZSBrbm93LlxyXG4gICAgICAgICAgICB0YWIuaGVhZGluZ0VsZW1lbnQgPSBub2RlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWxtLmFwcGVuZChub2RlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jdGlvbiBpc1RhYkhlYWRpbmcobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZSAmJiAgKFxyXG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgndGFiLWhlYWRpbmcnKSB8fFxyXG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS10YWItaGVhZGluZycpIHx8XHJcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFiLWhlYWRpbmcnIHx8XHJcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGF0YS10YWItaGVhZGluZydcclxuICAgICk7XHJcbiAgfVxyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3RhYnNldFRpdGxlcycsIFsnJGh0dHAnLCBmdW5jdGlvbigkaHR0cCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgcmVxdWlyZTogJ150YWJzZXQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90YWJzL3RhYnNldC10aXRsZXMuaHRtbCcsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYnNldEN0cmwpIHtcclxuICAgICAgaWYgKCFzY29wZS4kZXZhbChhdHRycy50YWJzZXRUaXRsZXMpKSB7XHJcbiAgICAgICAgZWxtLnJlbW92ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vbm93IHRoYXQgdGFicyBsb2NhdGlvbiBoYXMgYmVlbiBkZWNpZGVkLCB0cmFuc2NsdWRlIHRoZSB0YWIgdGl0bGVzIGluXHJcbiAgICAgICAgdGFic2V0Q3RybC4kdHJhbnNjbHVkZUZuKHRhYnNldEN0cmwuJHNjb3BlLiRwYXJlbnQsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgIGVsbS5hcHBlbmQobm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbjtcclxuXHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInLCBbXSlcclxuXHJcbi5jb25zdGFudCgndGltZXBpY2tlckNvbmZpZycsIHtcclxuICBob3VyU3RlcDogMSxcclxuICBtaW51dGVTdGVwOiAxLFxyXG4gIHNob3dNZXJpZGlhbjogdHJ1ZSxcclxuICBtZXJpZGlhbnM6IFsnQU0nLCAnUE0nXSxcclxuICByZWFkb25seUlucHV0OiBmYWxzZSxcclxuICBtb3VzZXdoZWVsOiB0cnVlXHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCd0aW1lcGlja2VyJywgWyckcGFyc2UnLCAnJGxvZycsICd0aW1lcGlja2VyQ29uZmlnJywgZnVuY3Rpb24gKCRwYXJzZSwgJGxvZywgdGltZXBpY2tlckNvbmZpZykge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHJlcXVpcmU6Jz9ebmdNb2RlbCcsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgc2NvcGU6IHt9LFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbCcsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgaWYgKCAhbmdNb2RlbCApIHtcclxuICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNlbGVjdGVkID0gbmV3IERhdGUoKSwgbWVyaWRpYW5zID0gdGltZXBpY2tlckNvbmZpZy5tZXJpZGlhbnM7XHJcblxyXG4gICAgICB2YXIgaG91clN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLmhvdXJTdGVwO1xyXG4gICAgICBpZiAoYXR0cnMuaG91clN0ZXApIHtcclxuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuaG91clN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgaG91clN0ZXAgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbWludXRlU3RlcCA9IHRpbWVwaWNrZXJDb25maWcubWludXRlU3RlcDtcclxuICAgICAgaWYgKGF0dHJzLm1pbnV0ZVN0ZXApIHtcclxuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMubWludXRlU3RlcCksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBtaW51dGVTdGVwID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gMTJIIC8gMjRIIG1vZGVcclxuICAgICAgc2NvcGUuc2hvd01lcmlkaWFuID0gdGltZXBpY2tlckNvbmZpZy5zaG93TWVyaWRpYW47XHJcbiAgICAgIGlmIChhdHRycy5zaG93TWVyaWRpYW4pIHtcclxuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuc2hvd01lcmlkaWFuKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIHNjb3BlLnNob3dNZXJpZGlhbiA9ICEhdmFsdWU7XHJcblxyXG4gICAgICAgICAgaWYgKCBuZ01vZGVsLiRlcnJvci50aW1lICkge1xyXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSBmcm9tIHRlbXBsYXRlXHJcbiAgICAgICAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCksIG1pbnV0ZXMgPSBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCggaG91cnMgKSAmJiBhbmd1bGFyLmlzRGVmaW5lZCggbWludXRlcyApKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQuc2V0SG91cnMoIGhvdXJzICk7XHJcbiAgICAgICAgICAgICAgcmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1cGRhdGVUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBHZXQgc2NvcGUuaG91cnMgaW4gMjRIIG1vZGUgaWYgdmFsaWRcclxuICAgICAgZnVuY3Rpb24gZ2V0SG91cnNGcm9tVGVtcGxhdGUgKCApIHtcclxuICAgICAgICB2YXIgaG91cnMgPSBwYXJzZUludCggc2NvcGUuaG91cnMsIDEwICk7XHJcbiAgICAgICAgdmFyIHZhbGlkID0gKCBzY29wZS5zaG93TWVyaWRpYW4gKSA/IChob3VycyA+IDAgJiYgaG91cnMgPCAxMykgOiAoaG91cnMgPj0gMCAmJiBob3VycyA8IDI0KTtcclxuICAgICAgICBpZiAoICF2YWxpZCApIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIHNjb3BlLnNob3dNZXJpZGlhbiApIHtcclxuICAgICAgICAgIGlmICggaG91cnMgPT09IDEyICkge1xyXG4gICAgICAgICAgICBob3VycyA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIHNjb3BlLm1lcmlkaWFuID09PSBtZXJpZGlhbnNbMV0gKSB7XHJcbiAgICAgICAgICAgIGhvdXJzID0gaG91cnMgKyAxMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhvdXJzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBnZXRNaW51dGVzRnJvbVRlbXBsYXRlKCkge1xyXG4gICAgICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQoc2NvcGUubWludXRlcywgMTApO1xyXG4gICAgICAgIHJldHVybiAoIG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDwgNjAgKSA/IG1pbnV0ZXMgOiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHBhZCggdmFsdWUgKSB7XHJcbiAgICAgICAgcmV0dXJuICggYW5ndWxhci5pc0RlZmluZWQodmFsdWUpICYmIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIDwgMiApID8gJzAnICsgdmFsdWUgOiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5wdXQgZWxlbWVudHNcclxuICAgICAgdmFyIGlucHV0cyA9IGVsZW1lbnQuZmluZCgnaW5wdXQnKSwgaG91cnNJbnB1dEVsID0gaW5wdXRzLmVxKDApLCBtaW51dGVzSW5wdXRFbCA9IGlucHV0cy5lcSgxKTtcclxuXHJcbiAgICAgIC8vIFJlc3BvbmQgb24gbW91c2V3aGVlbCBzcGluXHJcbiAgICAgIHZhciBtb3VzZXdoZWVsID0gKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLm1vdXNld2hlZWwpKSA/IHNjb3BlLiRldmFsKGF0dHJzLm1vdXNld2hlZWwpIDogdGltZXBpY2tlckNvbmZpZy5tb3VzZXdoZWVsO1xyXG4gICAgICBpZiAoIG1vdXNld2hlZWwgKSB7XHJcblxyXG4gICAgICAgIHZhciBpc1Njcm9sbGluZ1VwID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudCkge1xyXG4gICAgICAgICAgICBlID0gZS5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy9waWNrIGNvcnJlY3QgZGVsdGEgdmFyaWFibGUgZGVwZW5kaW5nIG9uIGV2ZW50XHJcbiAgICAgICAgICB2YXIgZGVsdGEgPSAoZS53aGVlbERlbHRhKSA/IGUud2hlZWxEZWx0YSA6IC1lLmRlbHRhWTtcclxuICAgICAgICAgIHJldHVybiAoZS5kZXRhaWwgfHwgZGVsdGEgPiAwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBob3Vyc0lucHV0RWwuYmluZCgnbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseSggKGlzU2Nyb2xsaW5nVXAoZSkpID8gc2NvcGUuaW5jcmVtZW50SG91cnMoKSA6IHNjb3BlLmRlY3JlbWVudEhvdXJzKCkgKTtcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWludXRlc0lucHV0RWwuYmluZCgnbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseSggKGlzU2Nyb2xsaW5nVXAoZSkpID8gc2NvcGUuaW5jcmVtZW50TWludXRlcygpIDogc2NvcGUuZGVjcmVtZW50TWludXRlcygpICk7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjb3BlLnJlYWRvbmx5SW5wdXQgPSAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMucmVhZG9ubHlJbnB1dCkpID8gc2NvcGUuJGV2YWwoYXR0cnMucmVhZG9ubHlJbnB1dCkgOiB0aW1lcGlja2VyQ29uZmlnLnJlYWRvbmx5SW5wdXQ7XHJcbiAgICAgIGlmICggISBzY29wZS5yZWFkb25seUlucHV0ICkge1xyXG5cclxuICAgICAgICB2YXIgaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGludmFsaWRIb3VycywgaW52YWxpZE1pbnV0ZXMpIHtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSggbnVsbCApO1xyXG4gICAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XHJcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZEhvdXJzKSkge1xyXG4gICAgICAgICAgICBzY29wZS5pbnZhbGlkSG91cnMgPSBpbnZhbGlkSG91cnM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZE1pbnV0ZXMpKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLmludmFsaWRNaW51dGVzID0gaW52YWxpZE1pbnV0ZXM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2NvcGUudXBkYXRlSG91cnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCk7XHJcblxyXG4gICAgICAgICAgaWYgKCBhbmd1bGFyLmlzRGVmaW5lZChob3VycykgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKCBob3VycyApO1xyXG4gICAgICAgICAgICByZWZyZXNoKCAnaCcgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGludmFsaWRhdGUodHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaG91cnNJbnB1dEVsLmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBpZiAoICFzY29wZS52YWxpZEhvdXJzICYmIHNjb3BlLmhvdXJzIDwgMTApIHtcclxuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBzY29wZS5ob3VycyA9IHBhZCggc2NvcGUuaG91cnMgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xyXG5cclxuICAgICAgICAgIGlmICggYW5ndWxhci5pc0RlZmluZWQobWludXRlcykgKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldE1pbnV0ZXMoIG1pbnV0ZXMgKTtcclxuICAgICAgICAgICAgcmVmcmVzaCggJ20nICk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbWludXRlc0lucHV0RWwuYmluZCgnYmx1cicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIGlmICggIXNjb3BlLmludmFsaWRNaW51dGVzICYmIHNjb3BlLm1pbnV0ZXMgPCAxMCApIHtcclxuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBzY29wZS5taW51dGVzID0gcGFkKCBzY29wZS5taW51dGVzICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNjb3BlLnVwZGF0ZUhvdXJzID0gYW5ndWxhci5ub29wO1xyXG4gICAgICAgIHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBhbmd1bGFyLm5vb3A7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5nTW9kZWwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkYXRlID0gbmdNb2RlbC4kbW9kZWxWYWx1ZSA/IG5ldyBEYXRlKCBuZ01vZGVsLiRtb2RlbFZhbHVlICkgOiBudWxsO1xyXG5cclxuICAgICAgICBpZiAoIGlzTmFOKGRhdGUpICkge1xyXG4gICAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XHJcbiAgICAgICAgICAkbG9nLmVycm9yKCdUaW1lcGlja2VyIGRpcmVjdGl2ZTogXCJuZy1tb2RlbFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDAxLjAxLjE5NzAgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIFJGQzI4MjIgb3IgSVNPIDg2MDEgZGF0ZS4nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCBkYXRlICkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGRhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtYWtlVmFsaWQoKTtcclxuICAgICAgICAgIHVwZGF0ZVRlbXBsYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gQ2FsbCBpbnRlcm5hbGx5IHdoZW4gd2Uga25vdyB0aGF0IG1vZGVsIGlzIHZhbGlkLlxyXG4gICAgICBmdW5jdGlvbiByZWZyZXNoKCBrZXlib2FyZENoYW5nZSApIHtcclxuICAgICAgICBtYWtlVmFsaWQoKTtcclxuICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoIG5ldyBEYXRlKHNlbGVjdGVkKSApO1xyXG4gICAgICAgIHVwZGF0ZVRlbXBsYXRlKCBrZXlib2FyZENoYW5nZSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBtYWtlVmFsaWQoKSB7XHJcbiAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCB0cnVlKTtcclxuICAgICAgICBzY29wZS5pbnZhbGlkSG91cnMgPSBmYWxzZTtcclxuICAgICAgICBzY29wZS5pbnZhbGlkTWludXRlcyA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiB1cGRhdGVUZW1wbGF0ZSgga2V5Ym9hcmRDaGFuZ2UgKSB7XHJcbiAgICAgICAgdmFyIGhvdXJzID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSwgbWludXRlcyA9IHNlbGVjdGVkLmdldE1pbnV0ZXMoKTtcclxuXHJcbiAgICAgICAgaWYgKCBzY29wZS5zaG93TWVyaWRpYW4gKSB7XHJcbiAgICAgICAgICBob3VycyA9ICggaG91cnMgPT09IDAgfHwgaG91cnMgPT09IDEyICkgPyAxMiA6IGhvdXJzICUgMTI7IC8vIENvbnZlcnQgMjQgdG8gMTIgaG91ciBzeXN0ZW1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2NvcGUuaG91cnMgPSAga2V5Ym9hcmRDaGFuZ2UgPT09ICdoJyA/IGhvdXJzIDogcGFkKGhvdXJzKTtcclxuICAgICAgICBzY29wZS5taW51dGVzID0ga2V5Ym9hcmRDaGFuZ2UgPT09ICdtJyA/IG1pbnV0ZXMgOiBwYWQobWludXRlcyk7XHJcbiAgICAgICAgc2NvcGUubWVyaWRpYW4gPSBzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyBtZXJpZGlhbnNbMF0gOiBtZXJpZGlhbnNbMV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGFkZE1pbnV0ZXMoIG1pbnV0ZXMgKSB7XHJcbiAgICAgICAgdmFyIGR0ID0gbmV3IERhdGUoIHNlbGVjdGVkLmdldFRpbWUoKSArIG1pbnV0ZXMgKiA2MDAwMCApO1xyXG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKCBkdC5nZXRIb3VycygpLCBkdC5nZXRNaW51dGVzKCkgKTtcclxuICAgICAgICByZWZyZXNoKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjb3BlLmluY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYWRkTWludXRlcyggaG91clN0ZXAgKiA2MCApO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS5kZWNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFkZE1pbnV0ZXMoIC0gaG91clN0ZXAgKiA2MCApO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS5pbmNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYWRkTWludXRlcyggbWludXRlU3RlcCApO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS5kZWNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYWRkTWludXRlcyggLSBtaW51dGVTdGVwICk7XHJcbiAgICAgIH07XHJcbiAgICAgIHNjb3BlLnRvZ2dsZU1lcmlkaWFuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgYWRkTWludXRlcyggMTIgKiA2MCAqICgoIHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMiApID8gMSA6IC0xKSApO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudHlwZWFoZWFkJywgWyd1aS5ib290c3RyYXAucG9zaXRpb24nLCAndWkuYm9vdHN0cmFwLmJpbmRIdG1sJ10pXHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgc2VydmljZSB0aGF0IGNhbiBwYXJzZSB0eXBlYWhlYWQncyBzeW50YXggKHN0cmluZyBwcm92aWRlZCBieSB1c2VycylcclxuICogRXh0cmFjdGVkIHRvIGEgc2VwYXJhdGUgc2VydmljZSBmb3IgZWFzZSBvZiB1bml0IHRlc3RpbmdcclxuICovXHJcbiAgLmZhY3RvcnkoJ3R5cGVhaGVhZFBhcnNlcicsIFsnJHBhcnNlJywgZnVuY3Rpb24gKCRwYXJzZSkge1xyXG5cclxuICAvLyAgICAgICAgICAgICAgICAgICAgICAwMDAwMDExMTAwMDAwMDAwMDAwMDAyMjIwMDAwMDAwMDAwMDAwMDAwMzMzMzMzMzMzMzMzMzMzMDAwMDAwMDAwMDA0NDAwMFxyXG4gIHZhciBUWVBFQUhFQURfUkVHRVhQID0gL15cXHMqKC4qPykoPzpcXHMrYXNcXHMrKC4qPykpP1xccytmb3JcXHMrKD86KFtcXCRcXHddW1xcJFxcd1xcZF0qKSlcXHMraW5cXHMrKC4qKSQvO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGFyc2U6ZnVuY3Rpb24gKGlucHV0KSB7XHJcblxyXG4gICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChUWVBFQUhFQURfUkVHRVhQKSwgbW9kZWxNYXBwZXIsIHZpZXdNYXBwZXIsIHNvdXJjZTtcclxuICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIFwiRXhwZWN0ZWQgdHlwZWFoZWFkIHNwZWNpZmljYXRpb24gaW4gZm9ybSBvZiAnX21vZGVsVmFsdWVfIChhcyBfbGFiZWxfKT8gZm9yIF9pdGVtXyBpbiBfY29sbGVjdGlvbl8nXCIgK1xyXG4gICAgICAgICAgICBcIiBidXQgZ290ICdcIiArIGlucHV0ICsgXCInLlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpdGVtTmFtZTptYXRjaFszXSxcclxuICAgICAgICBzb3VyY2U6JHBhcnNlKG1hdGNoWzRdKSxcclxuICAgICAgICB2aWV3TWFwcGVyOiRwYXJzZShtYXRjaFsyXSB8fCBtYXRjaFsxXSksXHJcbiAgICAgICAgbW9kZWxNYXBwZXI6JHBhcnNlKG1hdGNoWzFdKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWQnLCBbJyRjb21waWxlJywgJyRwYXJzZScsICckcScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJHBvc2l0aW9uJywgJ3R5cGVhaGVhZFBhcnNlcicsXHJcbiAgICBmdW5jdGlvbiAoJGNvbXBpbGUsICRwYXJzZSwgJHEsICR0aW1lb3V0LCAkZG9jdW1lbnQsICRwb3NpdGlvbiwgdHlwZWFoZWFkUGFyc2VyKSB7XHJcblxyXG4gIHZhciBIT1RfS0VZUyA9IFs5LCAxMywgMjcsIDM4LCA0MF07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiduZ01vZGVsJyxcclxuICAgIGxpbms6ZnVuY3Rpb24gKG9yaWdpbmFsU2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBtb2RlbEN0cmwpIHtcclxuXHJcbiAgICAgIC8vU1VQUE9SVEVEIEFUVFJJQlVURVMgKE9QVElPTlMpXHJcblxyXG4gICAgICAvL21pbmltYWwgbm8gb2YgY2hhcmFjdGVycyB0aGF0IG5lZWRzIHRvIGJlIGVudGVyZWQgYmVmb3JlIHR5cGVhaGVhZCBraWNrcy1pblxyXG4gICAgICB2YXIgbWluU2VhcmNoID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRNaW5MZW5ndGgpIHx8IDE7XHJcblxyXG4gICAgICAvL21pbmltYWwgd2FpdCB0aW1lIGFmdGVyIGxhc3QgY2hhcmFjdGVyIHR5cGVkIGJlZm9yZSB0eXBlaGVhZCBraWNrcy1pblxyXG4gICAgICB2YXIgd2FpdFRpbWUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFdhaXRNcykgfHwgMDtcclxuXHJcbiAgICAgIC8vc2hvdWxkIGl0IHJlc3RyaWN0IG1vZGVsIHZhbHVlcyB0byB0aGUgb25lcyBzZWxlY3RlZCBmcm9tIHRoZSBwb3B1cCBvbmx5P1xyXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRWRpdGFibGUpICE9PSBmYWxzZTtcclxuXHJcbiAgICAgIC8vYmluZGluZyB0byBhIHZhcmlhYmxlIHRoYXQgaW5kaWNhdGVzIGlmIG1hdGNoZXMgYXJlIGJlaW5nIHJldHJpZXZlZCBhc3luY2hyb25vdXNseVxyXG4gICAgICB2YXIgaXNMb2FkaW5nU2V0dGVyID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZExvYWRpbmcpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XHJcblxyXG4gICAgICAvL2EgY2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBhIG1hdGNoIGlzIHNlbGVjdGVkXHJcbiAgICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcclxuXHJcbiAgICAgIHZhciBpbnB1dEZvcm1hdHRlciA9IGF0dHJzLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyID8gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIC8vSU5URVJOQUwgVkFSSUFCTEVTXHJcblxyXG4gICAgICAvL21vZGVsIHNldHRlciBleGVjdXRlZCB1cG9uIG1hdGNoIHNlbGVjdGlvblxyXG4gICAgICB2YXIgJHNldE1vZGVsVmFsdWUgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCkuYXNzaWduO1xyXG5cclxuICAgICAgLy9leHByZXNzaW9ucyB1c2VkIGJ5IHR5cGVhaGVhZFxyXG4gICAgICB2YXIgcGFyc2VyUmVzdWx0ID0gdHlwZWFoZWFkUGFyc2VyLnBhcnNlKGF0dHJzLnR5cGVhaGVhZCk7XHJcblxyXG5cclxuICAgICAgLy9wb3AtdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgbWF0Y2hlc1xyXG4gICAgICB2YXIgcG9wVXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPHR5cGVhaGVhZC1wb3B1cD48L3R5cGVhaGVhZC1wb3B1cD4nKTtcclxuICAgICAgcG9wVXBFbC5hdHRyKHtcclxuICAgICAgICBtYXRjaGVzOiAnbWF0Y2hlcycsXHJcbiAgICAgICAgYWN0aXZlOiAnYWN0aXZlSWR4JyxcclxuICAgICAgICBzZWxlY3Q6ICdzZWxlY3QoYWN0aXZlSWR4KScsXHJcbiAgICAgICAgcXVlcnk6ICdxdWVyeScsXHJcbiAgICAgICAgcG9zaXRpb246ICdwb3NpdGlvbidcclxuICAgICAgfSk7XHJcbiAgICAgIC8vY3VzdG9tIGl0ZW0gdGVtcGxhdGVcclxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKSkge1xyXG4gICAgICAgIHBvcFVwRWwuYXR0cigndGVtcGxhdGUtdXJsJywgYXR0cnMudHlwZWFoZWFkVGVtcGxhdGVVcmwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvL2NyZWF0ZSBhIGNoaWxkIHNjb3BlIGZvciB0aGUgdHlwZWFoZWFkIGRpcmVjdGl2ZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBzY29wZVxyXG4gICAgICAvL3dpdGggdHlwZWFoZWFkLXNwZWNpZmljIGRhdGEgKG1hdGNoZXMsIHF1ZXJ5IGV0Yy4pXHJcbiAgICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xyXG4gICAgICBvcmlnaW5hbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpe1xyXG4gICAgICAgIHNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIHJlc2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNjb3BlLm1hdGNoZXMgPSBbXTtcclxuICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAtMTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBnZXRNYXRjaGVzQXN5bmMgPSBmdW5jdGlvbihpbnB1dFZhbHVlKSB7XHJcblxyXG4gICAgICAgIHZhciBsb2NhbHMgPSB7JHZpZXdWYWx1ZTogaW5wdXRWYWx1ZX07XHJcbiAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xyXG4gICAgICAgICRxLndoZW4ocGFyc2VyUmVzdWx0LnNvdXJjZShzY29wZSwgbG9jYWxzKSkudGhlbihmdW5jdGlvbihtYXRjaGVzKSB7XHJcblxyXG4gICAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCBzZXZlcmFsIGFzeW5jIHF1ZXJpZXMgd2VyZSBpbiBwcm9ncmVzcyBpZiBhIHVzZXIgd2VyZSB0eXBpbmcgZmFzdFxyXG4gICAgICAgICAgLy9idXQgd2UgYXJlIGludGVyZXN0ZWQgb25seSBpbiByZXNwb25zZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjdXJyZW50IHZpZXcgdmFsdWVcclxuICAgICAgICAgIGlmIChpbnB1dFZhbHVlID09PSBtb2RlbEN0cmwuJHZpZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IDA7XHJcbiAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAvL3RyYW5zZm9ybSBsYWJlbHNcclxuICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IG1hdGNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICBzY29wZS5tYXRjaGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICBsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIoc2NvcGUsIGxvY2FscyksXHJcbiAgICAgICAgICAgICAgICAgIG1vZGVsOiBtYXRjaGVzW2ldXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHNjb3BlLnF1ZXJ5ID0gaW5wdXRWYWx1ZTtcclxuICAgICAgICAgICAgICAvL3Bvc2l0aW9uIHBvcC11cCB3aXRoIG1hdGNoZXMgLSB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBpdHMgcG9zaXRpb24gZWFjaCB0aW1lIHdlIGFyZSBvcGVuaW5nIGEgd2luZG93XHJcbiAgICAgICAgICAgICAgLy93aXRoIG1hdGNoZXMgYXMgYSBwb3AtdXAgbWlnaHQgYmUgYWJzb2x1dGUtcG9zaXRpb25lZCBhbmQgcG9zaXRpb24gb2YgYW4gaW5wdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIG9uIGEgcGFnZVxyXG4gICAgICAgICAgICAgIC8vZHVlIHRvIG90aGVyIGVsZW1lbnRzIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgICAgICAgc2NvcGUucG9zaXRpb24gPSAkcG9zaXRpb24ucG9zaXRpb24oZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgc2NvcGUucG9zaXRpb24udG9wID0gc2NvcGUucG9zaXRpb24udG9wICsgZWxlbWVudC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcbiAgICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcblxyXG4gICAgICAvL3dlIG5lZWQgdG8gcHJvcGFnYXRlIHVzZXIncyBxdWVyeSBzbyB3ZSBjYW4gaGlnbGlnaHQgbWF0Y2hlc1xyXG4gICAgICBzY29wZS5xdWVyeSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgIC8vRGVjbGFyZSB0aGUgdGltZW91dCBwcm9taXNlIHZhciBvdXRzaWRlIHRoZSBmdW5jdGlvbiBzY29wZSBzbyB0aGF0IHN0YWNrZWQgY2FsbHMgY2FuIGJlIGNhbmNlbGxlZCBsYXRlciBcclxuICAgICAgdmFyIHRpbWVvdXRQcm9taXNlO1xyXG5cclxuICAgICAgLy9wbHVnIGludG8gJHBhcnNlcnMgcGlwZWxpbmUgdG8gb3BlbiBhIHR5cGVhaGVhZCBvbiB2aWV3IGNoYW5nZXMgaW5pdGlhdGVkIGZyb20gRE9NXHJcbiAgICAgIC8vJHBhcnNlcnMga2ljay1pbiBvbiBhbGwgdGhlIGNoYW5nZXMgY29taW5nIGZyb20gdGhlIHZpZXcgYXMgd2VsbCBhcyBtYW51YWxseSB0cmlnZ2VyZWQgYnkgJHNldFZpZXdWYWx1ZVxyXG4gICAgICBtb2RlbEN0cmwuJHBhcnNlcnMudW5zaGlmdChmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xyXG5cclxuICAgICAgICByZXNldE1hdGNoZXMoKTtcclxuICAgICAgICBpZiAoaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+PSBtaW5TZWFyY2gpIHtcclxuICAgICAgICAgIGlmICh3YWl0VGltZSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXRQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTsvL2NhbmNlbCBwcmV2aW91cyB0aW1lb3V0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGltZW91dFByb21pc2UgPSAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICB9LCB3YWl0VGltZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNFZGl0YWJsZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24gKG1vZGVsVmFsdWUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZVZpZXdWYWx1ZSwgZW1wdHlWaWV3VmFsdWU7XHJcbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xyXG5cclxuICAgICAgICBpZiAoaW5wdXRGb3JtYXR0ZXIpIHtcclxuXHJcbiAgICAgICAgICBsb2NhbHNbJyRtb2RlbCddID0gbW9kZWxWYWx1ZTtcclxuICAgICAgICAgIHJldHVybiBpbnB1dEZvcm1hdHRlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW5mbyB0byBwcm9wZXJseSByZW5kZXIgaW5wdXQgdmFsdWVcclxuICAgICAgICAgIC8vd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcyBzaXR1YXRpb24gYW5kIHNpbXBseSByZXR1cm4gbW9kZWwgdmFsdWUgaWYgd2UgY2FuJ3QgYXBwbHkgY3VzdG9tIGZvcm1hdHRpbmdcclxuICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbW9kZWxWYWx1ZTtcclxuICAgICAgICAgIGNhbmRpZGF0ZVZpZXdWYWx1ZSA9IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIGVtcHR5Vmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlVmlld1ZhbHVlIT09IGVtcHR5Vmlld1ZhbHVlID8gY2FuZGlkYXRlVmlld1ZhbHVlIDogbW9kZWxWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24gKGFjdGl2ZUlkeCkge1xyXG4gICAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIHRoZSAkZGlnZXN0KCkgY3ljbGVcclxuICAgICAgICB2YXIgbG9jYWxzID0ge307XHJcbiAgICAgICAgdmFyIG1vZGVsLCBpdGVtO1xyXG5cclxuICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGl0ZW0gPSBzY29wZS5tYXRjaGVzW2FjdGl2ZUlkeF0ubW9kZWw7XHJcbiAgICAgICAgbW9kZWwgPSBwYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcclxuICAgICAgICAkc2V0TW9kZWxWYWx1ZShvcmlnaW5hbFNjb3BlLCBtb2RlbCk7XHJcbiAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcclxuXHJcbiAgICAgICAgb25TZWxlY3RDYWxsYmFjayhvcmlnaW5hbFNjb3BlLCB7XHJcbiAgICAgICAgICAkaXRlbTogaXRlbSxcclxuICAgICAgICAgICRtb2RlbDogbW9kZWwsXHJcbiAgICAgICAgICAkbGFiZWw6IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2FscylcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcblxyXG4gICAgICAgIC8vcmV0dXJuIGZvY3VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIGEgbWFjaCB3YXMgc2VsZWN0ZWQgdmlhIGEgbW91c2UgY2xpY2sgZXZlbnRcclxuICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvL2JpbmQga2V5Ym9hcmQgZXZlbnRzOiBhcnJvd3MgdXAoMzgpIC8gZG93big0MCksIGVudGVyKDEzKSBhbmQgdGFiKDkpLCBlc2MoMjcpXHJcbiAgICAgIGVsZW1lbnQuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcclxuXHJcbiAgICAgICAgLy90eXBlYWhlYWQgaXMgb3BlbiBhbmQgYW4gXCJpbnRlcmVzdGluZ1wiIGtleSB3YXMgcHJlc3NlZFxyXG4gICAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA9PT0gMCB8fCBIT1RfS0VZUy5pbmRleE9mKGV2dC53aGljaCkgPT09IC0xKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gNDApIHtcclxuICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggKyAxKSAlIHNjb3BlLm1hdGNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gMzgpIHtcclxuICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggPyBzY29wZS5hY3RpdmVJZHggOiBzY29wZS5tYXRjaGVzLmxlbmd0aCkgLSAxO1xyXG4gICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gMTMgfHwgZXZ0LndoaWNoID09PSA5KSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4KTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcclxuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICByZXNldE1hdGNoZXMoKTtcclxuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gS2VlcCByZWZlcmVuY2UgdG8gY2xpY2sgaGFuZGxlciB0byB1bmJpbmQgaXQuXHJcbiAgICAgIHZhciBkaXNtaXNzQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50WzBdICE9PSBldnQudGFyZ2V0KSB7XHJcbiAgICAgICAgICByZXNldE1hdGNoZXMoKTtcclxuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcclxuXHJcbiAgICAgIG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgJGRvY3VtZW50LnVuYmluZCgnY2xpY2snLCBkaXNtaXNzQ2xpY2tIYW5kbGVyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBlbGVtZW50LmFmdGVyKCRjb21waWxlKHBvcFVwRWwpKHNjb3BlKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbn1dKVxyXG5cclxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWRQb3B1cCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OidFJyxcclxuICAgICAgc2NvcGU6e1xyXG4gICAgICAgIG1hdGNoZXM6Jz0nLFxyXG4gICAgICAgIHF1ZXJ5Oic9JyxcclxuICAgICAgICBhY3RpdmU6Jz0nLFxyXG4gICAgICAgIHBvc2l0aW9uOic9JyxcclxuICAgICAgICBzZWxlY3Q6JyYnXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlcGxhY2U6dHJ1ZSxcclxuICAgICAgdGVtcGxhdGVVcmw6J3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbCcsXHJcbiAgICAgIGxpbms6ZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG5cclxuICAgICAgICBzY29wZS50ZW1wbGF0ZVVybCA9IGF0dHJzLnRlbXBsYXRlVXJsO1xyXG5cclxuICAgICAgICBzY29wZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2NvcGUubWF0Y2hlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24gKG1hdGNoSWR4KSB7XHJcbiAgICAgICAgICByZXR1cm4gc2NvcGUuYWN0aXZlID09IG1hdGNoSWR4O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLnNlbGVjdEFjdGl2ZSA9IGZ1bmN0aW9uIChtYXRjaElkeCkge1xyXG4gICAgICAgICAgc2NvcGUuYWN0aXZlID0gbWF0Y2hJZHg7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2NvcGUuc2VsZWN0TWF0Y2ggPSBmdW5jdGlvbiAoYWN0aXZlSWR4KSB7XHJcbiAgICAgICAgICBzY29wZS5zZWxlY3Qoe2FjdGl2ZUlkeDphY3RpdmVJZHh9KTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pXHJcblxyXG4gIC5kaXJlY3RpdmUoJ3R5cGVhaGVhZE1hdGNoJywgWyckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckY29tcGlsZScsICckcGFyc2UnLCBmdW5jdGlvbiAoJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkY29tcGlsZSwgJHBhcnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDonRScsXHJcbiAgICAgIHNjb3BlOntcclxuICAgICAgICBpbmRleDonPScsXHJcbiAgICAgICAgbWF0Y2g6Jz0nLFxyXG4gICAgICAgIHF1ZXJ5Oic9J1xyXG4gICAgICB9LFxyXG4gICAgICBsaW5rOmZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgICB2YXIgdHBsVXJsID0gJHBhcnNlKGF0dHJzLnRlbXBsYXRlVXJsKShzY29wZS4kcGFyZW50KSB8fCAndGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sJztcclxuICAgICAgICAkaHR0cC5nZXQodHBsVXJsLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkuc3VjY2VzcyhmdW5jdGlvbih0cGxDb250ZW50KXtcclxuICAgICAgICAgICBlbGVtZW50LnJlcGxhY2VXaXRoKCRjb21waWxlKHRwbENvbnRlbnQudHJpbSgpKShzY29wZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKVxyXG5cclxuICAuZmlsdGVyKCd0eXBlYWhlYWRIaWdobGlnaHQnLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xyXG4gICAgICByZXR1cm4gcXVlcnlUb0VzY2FwZS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgXCJcXFxcJDFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1hdGNoSXRlbSwgcXVlcnkpIHtcclxuICAgICAgcmV0dXJuIHF1ZXJ5ID8gbWF0Y2hJdGVtLnJlcGxhY2UobmV3IFJlZ0V4cChlc2NhcGVSZWdleHAocXVlcnkpLCAnZ2knKSwgJzxzdHJvbmc+JCY8L3N0cm9uZz4nKSA6IG1hdGNoSXRlbTtcclxuICAgIH07XHJcbiAgfSk7XHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uLWdyb3VwXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uLWhlYWRpbmdcXFwiID48YSBjbGFzcz1cXFwiYWNjb3JkaW9uLXRvZ2dsZVxcXCIgbmctY2xpY2s9XFxcImlzT3BlbiA9ICFpc09wZW5cXFwiIGFjY29yZGlvbi10cmFuc2NsdWRlPVxcXCJoZWFkaW5nXFxcIj57e2hlYWRpbmd9fTwvYT48L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uLWJvZHlcXFwiIGNvbGxhcHNlPVxcXCIhaXNPcGVuXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJhY2NvcmRpb24taW5uZXJcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+ICA8L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJhY2NvcmRpb25cXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz0nYWxlcnQnIG5nLWNsYXNzPSd0eXBlICYmIFxcXCJhbGVydC1cXFwiICsgdHlwZSc+XFxuXCIgK1xyXG4gICAgXCIgICAgPGJ1dHRvbiBuZy1zaG93PSdjbG9zZWFibGUnIHR5cGU9J2J1dHRvbicgY2xhc3M9J2Nsb3NlJyBuZy1jbGljaz0nY2xvc2UoKSc+JnRpbWVzOzwvYnV0dG9uPlxcblwiICtcclxuICAgIFwiICAgIDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIixcclxuICAgIFwiPGRpdiBuZy1tb3VzZWVudGVyPVxcXCJwYXVzZSgpXFxcIiBuZy1tb3VzZWxlYXZlPVxcXCJwbGF5KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbFxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPG9sIGNsYXNzPVxcXCJjYXJvdXNlbC1pbmRpY2F0b3JzXFxcIiBuZy1zaG93PVxcXCJzbGlkZXMoKS5sZW5ndGggPiAxXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgICAgPGxpIG5nLXJlcGVhdD1cXFwic2xpZGUgaW4gc2xpZGVzKClcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBpc0FjdGl2ZShzbGlkZSl9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KHNsaWRlKVxcXCI+PC9saT5cXG5cIiArXHJcbiAgICBcIiAgICA8L29sPlxcblwiICtcclxuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcImNhcm91c2VsLWlubmVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcclxuICAgIFwiICAgIDxhIG5nLWNsaWNrPVxcXCJwcmV2KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbC1jb250cm9sIGxlZnRcXFwiIG5nLXNob3c9XFxcInNsaWRlcygpLmxlbmd0aCA+IDFcXFwiPiZsc2FxdW87PC9hPlxcblwiICtcclxuICAgIFwiICAgIDxhIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbC1jb250cm9sIHJpZ2h0XFxcIiBuZy1zaG93PVxcXCJzbGlkZXMoKS5sZW5ndGggPiAxXFxcIj4mcnNhcXVvOzwvYT5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIixcclxuICAgIFwiPGRpdiBuZy1jbGFzcz1cXFwie1xcblwiICtcclxuICAgIFwiICAgICdhY3RpdmUnOiBsZWF2aW5nIHx8IChhY3RpdmUgJiYgIWVudGVyaW5nKSxcXG5cIiArXHJcbiAgICBcIiAgICAncHJldic6IChuZXh0IHx8IGFjdGl2ZSkgJiYgZGlyZWN0aW9uPT0ncHJldicsXFxuXCIgK1xyXG4gICAgXCIgICAgJ25leHQnOiAobmV4dCB8fCBhY3RpdmUpICYmIGRpcmVjdGlvbj09J25leHQnLFxcblwiICtcclxuICAgIFwiICAgICdyaWdodCc6IGRpcmVjdGlvbj09J3ByZXYnLFxcblwiICtcclxuICAgIFwiICAgICdsZWZ0JzogZGlyZWN0aW9uPT0nbmV4dCdcXG5cIiArXHJcbiAgICBcIiAgfVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsXHJcbiAgICBcIjx0YWJsZT5cXG5cIiArXHJcbiAgICBcIiAgPHRoZWFkPlxcblwiICtcclxuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIHB1bGwtbGVmdFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoLTEpXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoIGNvbHNwYW49XFxcInt7cm93c1swXS5sZW5ndGggLSAyICsgc2hvd1dlZWtOdW1iZXJzfX1cXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1ibG9ja1xcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXHJcbiAgICBcIiAgICA8L3RyPlxcblwiICtcclxuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIG5nLXNob3c9XFxcImxhYmVscy5sZW5ndGggPiAwXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aCBuZy1zaG93PVxcXCJzaG93V2Vla051bWJlcnNcXFwiPiM8L3RoPlxcblwiICtcclxuICAgIFwiICAgICAgPHRoIG5nLXJlcGVhdD1cXFwibGFiZWwgaW4gbGFiZWxzXFxcIj57e2xhYmVsfX08L3RoPlxcblwiICtcclxuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xyXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xyXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXHJcbiAgICBcIiAgICA8dHIgbmctcmVwZWF0PVxcXCJyb3cgaW4gcm93c1xcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1dlZWtOdW1iZXJzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxlbT57eyBnZXRXZWVrTnVtYmVyKHJvdykgfX08L2VtPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3dcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBzdHlsZT1cXFwid2lkdGg6MTAwJTtcXFwiIGNsYXNzPVxcXCJidG5cXFwiIG5nLWNsYXNzPVxcXCJ7J2J0bi1pbmZvJzogZHQuc2VsZWN0ZWR9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZHQuZGlzYWJsZWRcXFwiPjxzcGFuIG5nLWNsYXNzPVxcXCJ7bXV0ZWQ6IGR0LnNlY29uZGFyeX1cXFwiPnt7ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgPC90Ym9keT5cXG5cIiArXHJcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcclxuICAgIFwiPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiBuZy1zdHlsZT1cXFwie2Rpc3BsYXk6IChpc09wZW4gJiYgJ2Jsb2NrJykgfHwgJ25vbmUnLCB0b3A6IHBvc2l0aW9uLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0KydweCd9XFxcIiBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCI+XFxuXCIgK1xyXG4gICAgXCJcdDxsaSBuZy10cmFuc2NsdWRlPjwvbGk+XFxuXCIgK1xyXG4gICAgXCJcdDxsaSBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9saT5cXG5cIiArXHJcbiAgICBcIlx0PGxpIHN0eWxlPVxcXCJwYWRkaW5nOiA5cHg7XFxcIj5cXG5cIiArXHJcbiAgICBcIlx0XHQ8c3BhbiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG5cIiArXHJcbiAgICBcIlx0XHRcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLWludmVyc2VcXFwiIG5nLWNsaWNrPVxcXCJ0b2RheSgpXFxcIj5Ub2RheTwvYnV0dG9uPlxcblwiICtcclxuICAgIFwiXHRcdFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1zbWFsbCBidG4taW5mb1xcXCIgbmctY2xpY2s9XFxcInNob3dXZWVrcyA9ICEgc2hvd1dlZWtzXFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogc2hvd1dlZWtzfVxcXCI+V2Vla3M8L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIlx0XHRcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLWRhbmdlclxcXCIgbmctY2xpY2s9XFxcImNsZWFyKClcXFwiPkNsZWFyPC9idXR0b24+XFxuXCIgK1xyXG4gICAgXCJcdFx0PC9zcGFuPlxcblwiICtcclxuICAgIFwiXHRcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLXN1Y2Nlc3MgcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcImlzT3BlbiA9IGZhbHNlXFxcIj5DbG9zZTwvYnV0dG9uPlxcblwiICtcclxuICAgIFwiXHQ8L2xpPlxcblwiICtcclxuICAgIFwiPC91bD5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbC1iYWNrZHJvcCBmYWRlXFxcIiBuZy1jbGFzcz1cXFwie2luOiBhbmltYXRlfVxcXCIgbmctc3R5bGU9XFxcInsnei1pbmRleCc6IDEwNDAgKyBpbmRleCoxMH1cXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSgkZXZlbnQpXFxcIj48L2Rpdj5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcIm1vZGFsIGZhZGUge3sgd2luZG93Q2xhc3MgfX1cXFwiIG5nLWNsYXNzPVxcXCJ7aW46IGFuaW1hdGV9XFxcIiBuZy1zdHlsZT1cXFwieyd6LWluZGV4JzogMTA1MCArIGluZGV4KjEwfVxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwicGFnZXJcXFwiPlxcblwiICtcclxuICAgIFwiICA8dWw+XFxuXCIgK1xyXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogcGFnZS5kaXNhYmxlZCwgcHJldmlvdXM6IHBhZ2UucHJldmlvdXMsIG5leHQ6IHBhZ2UubmV4dH1cXFwiPjxhIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UubnVtYmVyKVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcclxuICAgIFwiICA8L3VsPlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBhZ2luYXRpb25cXFwiPjx1bD5cXG5cIiArXHJcbiAgICBcIiAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlc1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IHBhZ2UuYWN0aXZlLCBkaXNhYmxlZDogcGFnZS5kaXNhYmxlZH1cXFwiPjxhIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UubnVtYmVyKVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcclxuICAgIFwiICA8L3VsPlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXVuc2FmZS1wb3B1cC5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAge3twbGFjZW1lbnR9fVxcXCIgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpLCBmYWRlOiBhbmltYXRpb24oKSB9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQtaHRtbC11bnNhZmU9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAge3twbGFjZW1lbnR9fVxcXCIgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpLCBmYWRlOiBhbmltYXRpb24oKSB9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXIge3twbGFjZW1lbnR9fVxcXCIgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpLCBmYWRlOiBhbmltYXRpb24oKSB9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiXFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctc2hvdz1cXFwidGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiICA8L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJiYXJcXFwiIG5nLWNsYXNzPSd0eXBlICYmIFxcXCJiYXItXFxcIiArIHR5cGUnPjwvZGl2PlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIj48cHJvZ3Jlc3NiYXIgbmctcmVwZWF0PVxcXCJiYXIgaW4gYmFyc1xcXCIgd2lkdGg9XFxcImJhci50b1xcXCIgb2xkPVxcXCJiYXIuZnJvbVxcXCIgYW5pbWF0ZT1cXFwiYmFyLmFuaW1hdGVcXFwiIHR5cGU9XFxcImJhci50eXBlXFxcIj48L3Byb2dyZXNzYmFyPjwvZGl2PlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFxyXG4gICAgXCI8c3BhbiBuZy1tb3VzZWxlYXZlPVxcXCJyZXNldCgpXFxcIj5cXG5cIiArXHJcbiAgICBcIlx0PGkgbmctcmVwZWF0PVxcXCJyIGluIHJhbmdlXFxcIiBuZy1tb3VzZWVudGVyPVxcXCJlbnRlcigkaW5kZXggKyAxKVxcXCIgbmctY2xpY2s9XFxcInJhdGUoJGluZGV4ICsgMSlcXFwiIG5nLWNsYXNzPVxcXCIkaW5kZXggPCB2YWwgJiYgKHIuc3RhdGVPbiB8fCAnaWNvbi1zdGFyJykgfHwgKHIuc3RhdGVPZmYgfHwgJ2ljb24tc3Rhci1lbXB0eScpXFxcIj48L2k+XFxuXCIgK1xyXG4gICAgXCI8L3NwYW4+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvcGFuZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3BhbmUuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IHNlbGVjdGVkfVxcXCIgbmctc2hvdz1cXFwic2VsZWN0ZWRcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFxyXG4gICAgXCI8bGkgbmctY2xhc3M9XFxcInthY3RpdmU6IGFjdGl2ZSwgZGlzYWJsZWQ6IGRpc2FibGVkfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxhIG5nLWNsaWNrPVxcXCJzZWxlY3QoKVxcXCIgdGFiLWhlYWRpbmctdHJhbnNjbHVkZT57e2hlYWRpbmd9fTwvYT5cXG5cIiArXHJcbiAgICBcIjwvbGk+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWJzLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RhYnMvdGFicy5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRhYmJhYmxlXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXRhYnNcXFwiPlxcblwiICtcclxuICAgIFwiICAgIDxsaSBuZy1yZXBlYXQ9XFxcInBhbmUgaW4gcGFuZXNcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOnBhbmUuc2VsZWN0ZWR9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDxhIG5nLWNsaWNrPVxcXCJzZWxlY3QocGFuZSlcXFwiPnt7cGFuZS5oZWFkaW5nfX08L2E+XFxuXCIgK1xyXG4gICAgXCIgICAgPC9saT5cXG5cIiArXHJcbiAgICBcIiAgPC91bD5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnRcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC10aXRsZXMuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdGFicy90YWJzZXQtdGl0bGVzLmh0bWxcIixcclxuICAgIFwiPHVsIGNsYXNzPVxcXCJuYXYge3t0eXBlICYmICduYXYtJyArIHR5cGV9fVxcXCIgbmctY2xhc3M9XFxcInsnbmF2LXN0YWNrZWQnOiB2ZXJ0aWNhbH1cXFwiPlxcblwiICtcclxuICAgIFwiPC91bD5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXCIsXHJcbiAgICBcIlxcblwiICtcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwidGFiYmFibGVcXFwiIG5nLWNsYXNzPVxcXCJ7J3RhYnMtcmlnaHQnOiBkaXJlY3Rpb24gPT0gJ3JpZ2h0JywgJ3RhYnMtbGVmdCc6IGRpcmVjdGlvbiA9PSAnbGVmdCcsICd0YWJzLWJlbG93JzogZGlyZWN0aW9uID09ICdiZWxvdyd9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiB0YWJzZXQtdGl0bGVzPVxcXCJ0YWJzQWJvdmVcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIFxcblwiICtcclxuICAgIFwiICAgICAgICAgbmctcmVwZWF0PVxcXCJ0YWIgaW4gdGFic1xcXCIgXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICBuZy1jbGFzcz1cXFwie2FjdGl2ZTogdGFiLmFjdGl2ZX1cXFwiXFxuXCIgK1xyXG4gICAgXCIgICAgICAgICB0YWItY29udGVudC10cmFuc2NsdWRlPVxcXCJ0YWJcXFwiPlxcblwiICtcclxuICAgIFwiICAgIDwvZGl2PlxcblwiICtcclxuICAgIFwiICA8L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiB0YWJzZXQtdGl0bGVzPVxcXCIhdGFic0Fib3ZlXFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLFxyXG4gICAgXCI8dGFibGUgY2xhc3M9XFxcImZvcm0taW5saW5lXFxcIj5cXG5cIiArXHJcbiAgICBcIlx0PHRyIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRIb3VycygpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLXVwXFxcIj48L2k+PC9hPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkPiZuYnNwOzwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRNaW51dGVzKClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxpIGNsYXNzPVxcXCJpY29uLWNoZXZyb24tdXBcXFwiPjwvaT48L2E+PC90ZD5cXG5cIiArXHJcbiAgICBcIlx0XHQ8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48L3RkPlxcblwiICtcclxuICAgIFwiXHQ8L3RyPlxcblwiICtcclxuICAgIFwiXHQ8dHI+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkIGNsYXNzPVxcXCJjb250cm9sLWdyb3VwXFxcIiBuZy1jbGFzcz1cXFwieydlcnJvcic6IGludmFsaWRIb3Vyc31cXFwiPjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwiaG91cnNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlSG91cnMoKVxcXCIgY2xhc3M9XFxcInNwYW4xIHRleHQtY2VudGVyXFxcIiBuZy1tb3VzZXdoZWVsPVxcXCJpbmNyZW1lbnRIb3VycygpXFxcIiBuZy1yZWFkb25seT1cXFwicmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiAvPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkPjo8L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZCBjbGFzcz1cXFwiY29udHJvbC1ncm91cFxcXCIgbmctY2xhc3M9XFxcInsnZXJyb3InOiBpbnZhbGlkTWludXRlc31cXFwiPjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwibWludXRlc1xcXCIgbmctY2hhbmdlPVxcXCJ1cGRhdGVNaW51dGVzKClcXFwiIGNsYXNzPVxcXCJzcGFuMSB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcInJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCI+PC90ZD5cXG5cIiArXHJcbiAgICBcIlx0XHQ8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1lcmlkaWFuKClcXFwiIGNsYXNzPVxcXCJidG4gdGV4dC1jZW50ZXJcXFwiPnt7bWVyaWRpYW59fTwvYnV0dG9uPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdDwvdHI+XFxuXCIgK1xyXG4gICAgXCJcdDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50SG91cnMoKVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi1kb3duXFxcIj48L2k+PC9hPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkPiZuYnNwOzwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkPjxhIG5nLWNsaWNrPVxcXCJkZWNyZW1lbnRNaW51dGVzKClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxpIGNsYXNzPVxcXCJpY29uLWNoZXZyb24tZG93blxcXCI+PC9pPjwvYT48L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdDwvdHI+XFxuXCIgK1xyXG4gICAgXCI8L3RhYmxlPlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFxyXG4gICAgXCI8YSB0YWJpbmRleD1cXFwiLTFcXFwiIGJpbmQtaHRtbC11bnNhZmU9XFxcIm1hdGNoLmxhYmVsIHwgdHlwZWFoZWFkSGlnaGxpZ2h0OnF1ZXJ5XFxcIj48L2E+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCIsXHJcbiAgICBcIjx1bCBjbGFzcz1cXFwidHlwZWFoZWFkIGRyb3Bkb3duLW1lbnVcXFwiIG5nLXN0eWxlPVxcXCJ7ZGlzcGxheTogaXNPcGVuKCkmJidibG9jaycgfHwgJ25vbmUnLCB0b3A6IHBvc2l0aW9uLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0KydweCd9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8bGkgbmctcmVwZWF0PVxcXCJtYXRjaCBpbiBtYXRjaGVzXFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogaXNBY3RpdmUoJGluZGV4KSB9XFxcIiBuZy1tb3VzZWVudGVyPVxcXCJzZWxlY3RBY3RpdmUoJGluZGV4KVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdE1hdGNoKCRpbmRleClcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgICA8dHlwZWFoZWFkLW1hdGNoIGluZGV4PVxcXCIkaW5kZXhcXFwiIG1hdGNoPVxcXCJtYXRjaFxcXCIgcXVlcnk9XFxcInF1ZXJ5XFxcIiB0ZW1wbGF0ZS11cmw9XFxcInRlbXBsYXRlVXJsXFxcIj48L3R5cGVhaGVhZC1tYXRjaD5cXG5cIiArXHJcbiAgICBcIiAgICA8L2xpPlxcblwiICtcclxuICAgIFwiPC91bD5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLmh0bWxcIixcclxuICAgIFwiPHVsIGNsYXNzPVxcXCJ0eXBlYWhlYWQgZHJvcGRvd24tbWVudVxcXCIgbmctc3R5bGU9XFxcIntkaXNwbGF5OiBpc09wZW4oKSYmJ2Jsb2NrJyB8fCAnbm9uZScsIHRvcDogcG9zaXRpb24udG9wKydweCcsIGxlZnQ6IHBvc2l0aW9uLmxlZnQrJ3B4J31cXFwiPlxcblwiICtcclxuICAgIFwiICAgIDxsaSBuZy1yZXBlYXQ9XFxcIm1hdGNoIGluIG1hdGNoZXNcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBpc0FjdGl2ZSgkaW5kZXgpIH1cXFwiIG5nLW1vdXNlZW50ZXI9XFxcInNlbGVjdEFjdGl2ZSgkaW5kZXgpXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgICAgPGEgdGFiaW5kZXg9XFxcIi0xXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0TWF0Y2goJGluZGV4KVxcXCIgbmctYmluZC1odG1sLXVuc2FmZT1cXFwibWF0Y2gubGFiZWwgfCB0eXBlYWhlYWRIaWdobGlnaHQ6cXVlcnlcXFwiPjwvYT5cXG5cIiArXHJcbiAgICBcIiAgICA8L2xpPlxcblwiICtcclxuICAgIFwiPC91bD5cIik7XHJcbn1dKTsiLCIvKipcclxuICogU3RhdGUtYmFzZWQgcm91dGluZyBmb3IgQW5ndWxhckpTXHJcbiAqIEB2ZXJzaW9uIHYwLjIuMFxyXG4gKiBAbGluayBodHRwOi8vYW5ndWxhci11aS5naXRodWIuY29tL1xyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSwgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuICovXHJcbihmdW5jdGlvbiAod2luZG93LCBhbmd1bGFyLCB1bmRlZmluZWQpIHtcclxuLypqc2hpbnQgZ2xvYmFsc3RyaWN0OnRydWUqL1xyXG4vKmdsb2JhbCBhbmd1bGFyOmZhbHNlKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGlzRGVmaW5lZCA9IGFuZ3VsYXIuaXNEZWZpbmVkLFxyXG4gICAgaXNGdW5jdGlvbiA9IGFuZ3VsYXIuaXNGdW5jdGlvbixcclxuICAgIGlzU3RyaW5nID0gYW5ndWxhci5pc1N0cmluZyxcclxuICAgIGlzT2JqZWN0ID0gYW5ndWxhci5pc09iamVjdCxcclxuICAgIGlzQXJyYXkgPSBhbmd1bGFyLmlzQXJyYXksXHJcbiAgICBmb3JFYWNoID0gYW5ndWxhci5mb3JFYWNoLFxyXG4gICAgZXh0ZW5kID0gYW5ndWxhci5leHRlbmQsXHJcbiAgICBjb3B5ID0gYW5ndWxhci5jb3B5O1xyXG5cclxuZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQsIGV4dHJhKSB7XHJcbiAgcmV0dXJuIGV4dGVuZChuZXcgKGV4dGVuZChmdW5jdGlvbigpIHt9LCB7IHByb3RvdHlwZTogcGFyZW50IH0pKSgpLCBleHRyYSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlKGRzdCkge1xyXG4gIGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmIChvYmogIT09IGRzdCkge1xyXG4gICAgICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgIGlmICghZHN0Lmhhc093blByb3BlcnR5KGtleSkpIGRzdFtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBkc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgY29tbW9uIGFuY2VzdG9yIHBhdGggYmV0d2VlbiB0d28gc3RhdGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgVGhlIGZpcnN0IHN0YXRlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vjb25kIFRoZSBzZWNvbmQgc3RhdGUuXHJcbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIG5hbWVzIGluIGRlc2NlbmRpbmcgb3JkZXIsIG5vdCBpbmNsdWRpbmcgdGhlIHJvb3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbmNlc3RvcnMoZmlyc3QsIHNlY29uZCkge1xyXG4gIHZhciBwYXRoID0gW107XHJcblxyXG4gIGZvciAodmFyIG4gaW4gZmlyc3QucGF0aCkge1xyXG4gICAgaWYgKGZpcnN0LnBhdGhbbl0gPT09IFwiXCIpIGNvbnRpbnVlO1xyXG4gICAgaWYgKCFzZWNvbmQucGF0aFtuXSkgYnJlYWs7XHJcbiAgICBwYXRoLnB1c2goZmlyc3QucGF0aFtuXSk7XHJcbiAgfVxyXG4gIHJldHVybiBwYXRoO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIGEgc2V0IG9mIHBhcmFtZXRlcnMgd2l0aCBhbGwgcGFyYW1ldGVycyBpbmhlcml0ZWQgYmV0d2VlbiB0aGUgY29tbW9uIHBhcmVudHMgb2YgdGhlXHJcbiAqIGN1cnJlbnQgc3RhdGUgYW5kIGEgZ2l2ZW4gZGVzdGluYXRpb24gc3RhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyZW50UGFyYW1zIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBzdGF0ZSBwYXJhbWV0ZXJzICgkc3RhdGVQYXJhbXMpLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3UGFyYW1zIFRoZSBzZXQgb2YgcGFyYW1ldGVycyB3aGljaCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCBpbmhlcml0ZWQgcGFyYW1zLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gJHRvIEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5oZXJpdFBhcmFtcyhjdXJyZW50UGFyYW1zLCBuZXdQYXJhbXMsICRjdXJyZW50LCAkdG8pIHtcclxuICB2YXIgcGFyZW50cyA9IGFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgcGFyZW50UGFyYW1zLCBpbmhlcml0ZWQgPSB7fSwgaW5oZXJpdExpc3QgPSBbXTtcclxuXHJcbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRzKSB7XHJcbiAgICBpZiAoIXBhcmVudHNbaV0ucGFyYW1zIHx8ICFwYXJlbnRzW2ldLnBhcmFtcy5sZW5ndGgpIGNvbnRpbnVlO1xyXG4gICAgcGFyZW50UGFyYW1zID0gcGFyZW50c1tpXS5wYXJhbXM7XHJcblxyXG4gICAgZm9yICh2YXIgaiBpbiBwYXJlbnRQYXJhbXMpIHtcclxuICAgICAgaWYgKGluaGVyaXRMaXN0LmluZGV4T2YocGFyZW50UGFyYW1zW2pdKSA+PSAwKSBjb250aW51ZTtcclxuICAgICAgaW5oZXJpdExpc3QucHVzaChwYXJlbnRQYXJhbXNbal0pO1xyXG4gICAgICBpbmhlcml0ZWRbcGFyZW50UGFyYW1zW2pdXSA9IGN1cnJlbnRQYXJhbXNbcGFyZW50UGFyYW1zW2pdXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGV4dGVuZCh7fSwgaW5oZXJpdGVkLCBuZXdQYXJhbXMpO1xyXG59XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnV0aWwnLCBbJ25nJ10pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicsIFsndWkucm91dGVyLnV0aWwnXSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnLCBbJ3VpLnJvdXRlci5yb3V0ZXInLCAndWkucm91dGVyLnV0aWwnXSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXInLCBbJ3VpLnJvdXRlci5zdGF0ZSddKTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5jb21wYXQnLCBbJ3VpLnJvdXRlciddKTtcclxuXHJcblxyXG4vKipcclxuICogU2VydmljZSAoYHVpLXV0aWxgKS4gTWFuYWdlcyByZXNvbHV0aW9uIG9mIChhY3ljbGljKSBncmFwaHMgb2YgcHJvbWlzZXMuXHJcbiAqIEBtb2R1bGUgJHJlc29sdmVcclxuICogQHJlcXVpcmVzICRxXHJcbiAqIEByZXF1aXJlcyAkaW5qZWN0b3JcclxuICovXHJcbiRSZXNvbHZlLiRpbmplY3QgPSBbJyRxJywgJyRpbmplY3RvciddO1xyXG5mdW5jdGlvbiAkUmVzb2x2ZSggICRxLCAgICAkaW5qZWN0b3IpIHtcclxuICBcclxuICB2YXIgVklTSVRfSU5fUFJPR1JFU1MgPSAxLFxyXG4gICAgICBWSVNJVF9ET05FID0gMixcclxuICAgICAgTk9USElORyA9IHt9LFxyXG4gICAgICBOT19ERVBFTkRFTkNJRVMgPSBbXSxcclxuICAgICAgTk9fTE9DQUxTID0gTk9USElORyxcclxuICAgICAgTk9fUEFSRU5UID0gZXh0ZW5kKCRxLndoZW4oTk9USElORyksIHsgJCRwcm9taXNlczogTk9USElORywgJCR2YWx1ZXM6IE5PVEhJTkcgfSk7XHJcbiAgXHJcblxyXG4gIC8qKlxyXG4gICAqIFN0dWRpZXMgYSBzZXQgb2YgaW52b2NhYmxlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcy5cclxuICAgKiAgICAgICRyZXNvbHZlLnN0dWR5KGludm9jYWJsZXMpKGxvY2FscywgcGFyZW50LCBzZWxmKVxyXG4gICAqIGlzIGVxdWl2YWxlbnQgdG9cclxuICAgKiAgICAgICRyZXNvbHZlLnJlc29sdmUoaW52b2NhYmxlcywgbG9jYWxzLCBwYXJlbnQsIHNlbGYpXHJcbiAgICogYnV0IHRoZSBmb3JtZXIgaXMgbW9yZSBlZmZpY2llbnQgKGluIGZhY3QgYHJlc29sdmVgIGp1c3QgY2FsbHMgYHN0dWR5YCBpbnRlcm5hbGx5KS5cclxuICAgKiBTZWUge0BsaW5rIG1vZHVsZTokcmVzb2x2ZS9yZXNvbHZlfSBmb3IgZGV0YWlscy5cclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW52b2NhYmxlc1xyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIHRoaXMuc3R1ZHkgPSBmdW5jdGlvbiAoaW52b2NhYmxlcykge1xyXG4gICAgaWYgKCFpc09iamVjdChpbnZvY2FibGVzKSkgdGhyb3cgbmV3IEVycm9yKFwiJ2ludm9jYWJsZXMnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xyXG4gICAgXHJcbiAgICAvLyBQZXJmb3JtIGEgdG9wb2xvZ2ljYWwgc29ydCBvZiBpbnZvY2FibGVzIHRvIGJ1aWxkIGFuIG9yZGVyZWQgcGxhblxyXG4gICAgdmFyIHBsYW4gPSBbXSwgY3ljbGUgPSBbXSwgdmlzaXRlZCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gdmlzaXQodmFsdWUsIGtleSkge1xyXG4gICAgICBpZiAodmlzaXRlZFtrZXldID09PSBWSVNJVF9ET05FKSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBjeWNsZS5wdXNoKGtleSk7XHJcbiAgICAgIGlmICh2aXNpdGVkW2tleV0gPT09IFZJU0lUX0lOX1BST0dSRVNTKSB7XHJcbiAgICAgICAgY3ljbGUuc3BsaWNlKDAsIGN5Y2xlLmluZGV4T2Yoa2V5KSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3k6IFwiICsgY3ljbGUuam9pbihcIiAtPiBcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIHZpc2l0ZWRba2V5XSA9IFZJU0lUX0lOX1BST0dSRVNTO1xyXG4gICAgICBcclxuICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHBsYW4ucHVzaChrZXksIFsgZnVuY3Rpb24oKSB7IHJldHVybiAkaW5qZWN0b3IuZ2V0KGtleSk7IH1dLCBOT19ERVBFTkRFTkNJRVMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSAkaW5qZWN0b3IuYW5ub3RhdGUodmFsdWUpO1xyXG4gICAgICAgIGZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICAgIGlmIChwYXJhbSAhPT0ga2V5ICYmIGludm9jYWJsZXMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB2aXNpdChpbnZvY2FibGVzW3BhcmFtXSwgcGFyYW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBsYW4ucHVzaChrZXksIHZhbHVlLCBwYXJhbXMpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjeWNsZS5wb3AoKTtcclxuICAgICAgdmlzaXRlZFtrZXldID0gVklTSVRfRE9ORTtcclxuICAgIH1cclxuICAgIGZvckVhY2goaW52b2NhYmxlcywgdmlzaXQpO1xyXG4gICAgaW52b2NhYmxlcyA9IGN5Y2xlID0gdmlzaXRlZCA9IG51bGw7IC8vIHBsYW4gaXMgYWxsIHRoYXQncyByZXF1aXJlZFxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpc1Jlc29sdmUodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS50aGVuICYmIHZhbHVlLiQkcHJvbWlzZXM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBmdW5jdGlvbiAobG9jYWxzLCBwYXJlbnQsIHNlbGYpIHtcclxuICAgICAgaWYgKGlzUmVzb2x2ZShsb2NhbHMpICYmIHNlbGYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNlbGYgPSBwYXJlbnQ7IHBhcmVudCA9IGxvY2FsczsgbG9jYWxzID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWxvY2FscykgbG9jYWxzID0gTk9fTE9DQUxTO1xyXG4gICAgICBlbHNlIGlmICghaXNPYmplY3QobG9jYWxzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIidsb2NhbHMnIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xyXG4gICAgICB9ICAgICAgIFxyXG4gICAgICBpZiAoIXBhcmVudCkgcGFyZW50ID0gTk9fUEFSRU5UO1xyXG4gICAgICBlbHNlIGlmICghaXNSZXNvbHZlKHBhcmVudCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncGFyZW50JyBtdXN0IGJlIGEgcHJvbWlzZSByZXR1cm5lZCBieSAkcmVzb2x2ZS5yZXNvbHZlKClcIik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFRvIGNvbXBsZXRlIHRoZSBvdmVyYWxsIHJlc29sdXRpb24sIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhlIHBhcmVudFxyXG4gICAgICAvLyBwcm9taXNlIGFuZCBmb3IgdGhlIHByb21pc2UgZm9yIGVhY2ggaW52b2thYmxlIGluIG91ciBwbGFuLlxyXG4gICAgICB2YXIgcmVzb2x1dGlvbiA9ICRxLmRlZmVyKCksXHJcbiAgICAgICAgICByZXN1bHQgPSByZXNvbHV0aW9uLnByb21pc2UsXHJcbiAgICAgICAgICBwcm9taXNlcyA9IHJlc3VsdC4kJHByb21pc2VzID0ge30sXHJcbiAgICAgICAgICB2YWx1ZXMgPSBleHRlbmQoe30sIGxvY2FscyksXHJcbiAgICAgICAgICB3YWl0ID0gMSArIHBsYW4ubGVuZ3RoLzMsXHJcbiAgICAgICAgICBtZXJnZWQgPSBmYWxzZTtcclxuICAgICAgICAgIFxyXG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xyXG4gICAgICAgIC8vIE1lcmdlIHBhcmVudCB2YWx1ZXMgd2UgaGF2ZW4ndCBnb3QgeWV0IGFuZCBwdWJsaXNoIG91ciBvd24gJCR2YWx1ZXNcclxuICAgICAgICBpZiAoIS0td2FpdCkge1xyXG4gICAgICAgICAgaWYgKCFtZXJnZWQpIG1lcmdlKHZhbHVlcywgcGFyZW50LiQkdmFsdWVzKTsgXHJcbiAgICAgICAgICByZXN1bHQuJCR2YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgICByZXN1bHQuJCRwcm9taXNlcyA9IHRydWU7IC8vIGtlZXAgZm9yIGlzUmVzb2x2ZSgpXHJcbiAgICAgICAgICByZXNvbHV0aW9uLnJlc29sdmUodmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XHJcbiAgICAgICAgcmVzdWx0LiQkZmFpbHVyZSA9IHJlYXNvbjtcclxuICAgICAgICByZXNvbHV0aW9uLnJlamVjdChyZWFzb24pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHBhcmVudCBoYXMgYWxyZWFkeSBmYWlsZWRcclxuICAgICAgaWYgKGlzRGVmaW5lZChwYXJlbnQuJCRmYWlsdXJlKSkge1xyXG4gICAgICAgIGZhaWwocGFyZW50LiQkZmFpbHVyZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gTWVyZ2UgcGFyZW50IHZhbHVlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IHJlc29sdmVkLCBvciBtZXJnZVxyXG4gICAgICAvLyBwYXJlbnQgcHJvbWlzZXMgYW5kIHdhaXQgaWYgdGhlIHBhcmVudCByZXNvbHZlIGlzIHN0aWxsIGluIHByb2dyZXNzLlxyXG4gICAgICBpZiAocGFyZW50LiQkdmFsdWVzKSB7XHJcbiAgICAgICAgbWVyZ2VkID0gbWVyZ2UodmFsdWVzLCBwYXJlbnQuJCR2YWx1ZXMpO1xyXG4gICAgICAgIGRvbmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBleHRlbmQocHJvbWlzZXMsIHBhcmVudC4kJHByb21pc2VzKTtcclxuICAgICAgICBwYXJlbnQudGhlbihkb25lLCBmYWlsKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGludm9jYWJsZSBpbiB0aGUgcGxhbiwgYnV0IGlnbm9yZSBhbnkgd2hlcmUgYSBsb2NhbCBvZiB0aGUgc2FtZSBuYW1lIGV4aXN0cy5cclxuICAgICAgZm9yICh2YXIgaT0wLCBpaT1wbGFuLmxlbmd0aDsgaTxpaTsgaSs9Mykge1xyXG4gICAgICAgIGlmIChsb2NhbHMuaGFzT3duUHJvcGVydHkocGxhbltpXSkpIGRvbmUoKTtcclxuICAgICAgICBlbHNlIGludm9rZShwbGFuW2ldLCBwbGFuW2krMV0sIHBsYW5baSsyXSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGZ1bmN0aW9uIGludm9rZShrZXksIGludm9jYWJsZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgZm9yIHRoaXMgaW52b2NhdGlvbi4gRmFpbHVyZXMgd2lsbCBwcm9wYWdhdGUgdG8gdGhlIHJlc29sdXRpb24gYXMgd2VsbC5cclxuICAgICAgICB2YXIgaW52b2NhdGlvbiA9ICRxLmRlZmVyKCksIHdhaXRQYXJhbXMgPSAwO1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uZmFpbHVyZShyZWFzb24pIHtcclxuICAgICAgICAgIGludm9jYXRpb24ucmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgICBmYWlsKHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBwYXJhbWV0ZXIgdGhhdCB3ZSBoYXZlIGEgcHJvbWlzZSBmb3IgKGVpdGhlciBmcm9tIHBhcmVudCBvciBmcm9tIHRoaXNcclxuICAgICAgICAvLyByZXNvbHZlOyBpbiB0aGF0IGNhc2Ugc3R1ZHkoKSB3aWxsIGhhdmUgbWFkZSBzdXJlIGl0J3Mgb3JkZXJlZCBiZWZvcmUgdXMgaW4gdGhlIHBsYW4pLlxyXG4gICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcclxuICAgICAgICAgIGlmIChwcm9taXNlcy5oYXNPd25Qcm9wZXJ0eShkZXApICYmICFsb2NhbHMuaGFzT3duUHJvcGVydHkoZGVwKSkge1xyXG4gICAgICAgICAgICB3YWl0UGFyYW1zKys7XHJcbiAgICAgICAgICAgIHByb21pc2VzW2RlcF0udGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgdmFsdWVzW2RlcF0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgaWYgKCEoLS13YWl0UGFyYW1zKSkgcHJvY2VlZCgpO1xyXG4gICAgICAgICAgICB9LCBvbmZhaWx1cmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghd2FpdFBhcmFtcykgcHJvY2VlZCgpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHByb2NlZWQoKSB7XHJcbiAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJlc3VsdC4kJGZhaWx1cmUpKSByZXR1cm47XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpbnZvY2F0aW9uLnJlc29sdmUoJGluamVjdG9yLmludm9rZShpbnZvY2FibGUsIHNlbGYsIHZhbHVlcykpO1xyXG4gICAgICAgICAgICBpbnZvY2F0aW9uLnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9LCBvbmZhaWx1cmUpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBvbmZhaWx1cmUoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1Ymxpc2ggcHJvbWlzZSBzeW5jaHJvbm91c2x5OyBpbnZvY2F0aW9ucyBmdXJ0aGVyIGRvd24gaW4gdGhlIHBsYW4gbWF5IGRlcGVuZCBvbiBpdC5cclxuICAgICAgICBwcm9taXNlc1trZXldID0gaW52b2NhdGlvbi5wcm9taXNlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9O1xyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIGEgc2V0IG9mIGludm9jYWJsZXMuIEFuIGludm9jYWJsZSBpcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgdmlhIGAkaW5qZWN0b3IuaW52b2tlKClgLFxyXG4gICAqIGFuZCBjYW4gaGF2ZSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGRlcGVuZGVuY2llcy4gQW4gaW52b2NhYmxlIGNhbiBlaXRoZXIgcmV0dXJuIGEgdmFsdWUgZGlyZWN0bHksXHJcbiAgICogb3IgYSBgJHFgIHByb21pc2UuIElmIGEgcHJvbWlzZSBpcyByZXR1cm5lZCBpdCB3aWxsIGJlIHJlc29sdmVkIGFuZCB0aGUgcmVzdWx0aW5nIHZhbHVlIHdpbGwgYmVcclxuICAgKiB1c2VkIGluc3RlYWQuIERlcGVuZGVuY2llcyBvZiBpbnZvY2FibGVzIGFyZSByZXNvbHZlZCAoaW4gdGhpcyBvcmRlciBvZiBwcmVjZWRlbmNlKVxyXG4gICAqXHJcbiAgICogLSBmcm9tIHRoZSBzcGVjaWZpZWQgYGxvY2Fsc2BcclxuICAgKiAtIGZyb20gYW5vdGhlciBpbnZvY2FibGUgdGhhdCBpcyBwYXJ0IG9mIHRoaXMgYCRyZXNvbHZlYCBjYWxsXHJcbiAgICogLSBmcm9tIGFuIGludm9jYWJsZSB0aGF0IGlzIGluaGVyaXRlZCBmcm9tIGEgYHBhcmVudGAgY2FsbCB0byBgJHJlc29sdmVgIChvciByZWN1cnNpdmVseVxyXG4gICAqICAgZnJvbSBhbnkgYW5jZXN0b3IgYCRyZXNvbHZlYCBvZiB0aGF0IHBhcmVudCkuXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkcmVzb2x2ZWAgaXMgYSBwcm9taXNlIGZvciBhbiBvYmplY3QgdGhhdCBjb250YWlucyAoaW4gdGhpcyBvcmRlciBvZiBwcmVjZWRlbmNlKVxyXG4gICAqXHJcbiAgICogLSBhbnkgYGxvY2Fsc2AgKGlmIHNwZWNpZmllZClcclxuICAgKiAtIHRoZSByZXNvbHZlZCByZXR1cm4gdmFsdWVzIG9mIGFsbCBpbmplY3RhYmxlc1xyXG4gICAqIC0gYW55IHZhbHVlcyBpbmhlcml0ZWQgZnJvbSBhIGBwYXJlbnRgIGNhbGwgdG8gYCRyZXNvbHZlYCAoaWYgc3BlY2lmaWVkKVxyXG4gICAqXHJcbiAgICogVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBgcGFyZW50YCBwcm9taXNlIChpZiBhbnkpIGFuZCBhbGwgcHJvbWlzZXMgcmV0dXJuZWQgYnkgaW5qZWN0YWJsZXNcclxuICAgKiBoYXZlIGJlZW4gcmVzb2x2ZWQuIElmIGFueSBpbnZvY2FibGUgKG9yIGAkaW5qZWN0b3IuaW52b2tlYCkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgb3IgaWYgYSBwcm9taXNlXHJcbiAgICogcmV0dXJuZWQgYnkgYW4gaW52b2NhYmxlIGlzIHJlamVjdGVkLCB0aGUgYCRyZXNvbHZlYCBwcm9taXNlIGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlIHNhbWUgZXJyb3IuXHJcbiAgICogQSByZWplY3Rpb24gb2YgYSBgcGFyZW50YCBwcm9taXNlIChpZiBzcGVjaWZpZWQpIHdpbGwgbGlrZXdpc2UgYmUgcHJvcGFnYXRlZCBpbW1lZGlhdGVseS4gT25jZSB0aGVcclxuICAgKiBgJHJlc29sdmVgIHByb21pc2UgaGFzIGJlZW4gcmVqZWN0ZWQsIG5vIGZ1cnRoZXIgaW52b2NhYmxlcyB3aWxsIGJlIGNhbGxlZC5cclxuICAgKiBcclxuICAgKiBDeWNsaWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gaW52b2NhYmxlcyBhcmUgbm90IHBlcm1pdHRlZCBhbmQgd2lsbCBjYXVlcyBgJHJlc29sdmVgIHRvIHRocm93IGFuXHJcbiAgICogZXJyb3IuIEFzIGEgc3BlY2lhbCBjYXNlLCBhbiBpbmplY3RhYmxlIGNhbiBkZXBlbmQgb24gYSBwYXJhbWV0ZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbmplY3RhYmxlLFxyXG4gICAqIHdoaWNoIHdpbGwgYmUgZnVsZmlsbGVkIGZyb20gdGhlIGBwYXJlbnRgIGluamVjdGFibGUgb2YgdGhlIHNhbWUgbmFtZS4gVGhpcyBhbGxvd3MgaW5oZXJpdGVkIHZhbHVlc1xyXG4gICAqIHRvIGJlIGRlY29yYXRlZC4gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBhbnkgb3RoZXIgaW5qZWN0YWJsZSBpbiB0aGUgc2FtZSBgJHJlc29sdmVgIHdpdGggdGhlIHNhbWVcclxuICAgKiBkZXBlbmRlbmN5IHdvdWxkIHNlZSB0aGUgZGVjb3JhdGVkIHZhbHVlLCBub3QgdGhlIGluaGVyaXRlZCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCBtaXNzaW5nIGRlcGVuZGVuY2llcyAtLSB1bmxpa2UgY3ljbGljIGRlcGVuZGVuY2llcyAtLSB3aWxsIGNhdXNlIGFuIChhc3luY2hyb25vdXMpIHJlamVjdGlvblxyXG4gICAqIG9mIHRoZSBgJHJlc29sdmVgIHByb21pc2UgcmF0aGVyIHRoYW4gYSAoc3luY2hyb25vdXMpIGV4Y2VwdGlvbi5cclxuICAgKlxyXG4gICAqIEludm9jYWJsZXMgYXJlIGludm9rZWQgZWFnZXJseSBhcyBzb29uIGFzIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGF2YWlsYWJsZS4gVGhpcyBpcyB0cnVlIGV2ZW4gZm9yXHJcbiAgICogZGVwZW5kZW5jaWVzIGluaGVyaXRlZCBmcm9tIGEgYHBhcmVudGAgY2FsbCB0byBgJHJlc29sdmVgLlxyXG4gICAqXHJcbiAgICogQXMgYSBzcGVjaWFsIGNhc2UsIGFuIGludm9jYWJsZSBjYW4gYmUgYSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgaXQgaXMgdGFrZW4gdG8gYmUgYSBzZXJ2aWNlIG5hbWVcclxuICAgKiB0byBiZSBwYXNzZWQgdG8gYCRpbmplY3Rvci5nZXQoKWAuIFRoaXMgaXMgc3VwcG9ydGVkIHByaW1hcmlseSBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCB0aGVcclxuICAgKiBgcmVzb2x2ZWAgcHJvcGVydHkgb2YgYCRyb3V0ZVByb3ZpZGVyYCByb3V0ZXMuXHJcbiAgICpcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBGdW5jdGlvbnxzdHJpbmc+fSBpbnZvY2FibGVzICBmdW5jdGlvbnMgdG8gaW52b2tlIG9yIGAkaW5qZWN0b3JgIHNlcnZpY2VzIHRvIGZldGNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fSBbbG9jYWxzXSAgdmFsdWVzIHRvIG1ha2UgYXZhaWxhYmxlIHRvIHRoZSBpbmplY3RhYmxlc1xyXG4gICAqIEBwYXJhbSB7UHJvbWlzZS48T2JqZWN0Pn0gW3BhcmVudF0gIGEgcHJvbWlzZSByZXR1cm5lZCBieSBhbm90aGVyIGNhbGwgdG8gYCRyZXNvbHZlYC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW3NlbGZdICB0aGUgYHRoaXNgIGZvciB0aGUgaW52b2tlZCBtZXRob2RzXHJcbiAgICogQHJldHVybiB7UHJvbWlzZS48T2JqZWN0Pn0gIFByb21pc2UgZm9yIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSByZXNvbHZlZCByZXR1cm4gdmFsdWVcclxuICAgKiAgICBvZiBhbGwgaW52b2NhYmxlcywgYXMgd2VsbCBhcyBhbnkgaW5oZXJpdGVkIGFuZCBsb2NhbCB2YWx1ZXMuXHJcbiAgICovXHJcbiAgdGhpcy5yZXNvbHZlID0gZnVuY3Rpb24gKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50LCBzZWxmKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHVkeShpbnZvY2FibGVzKShsb2NhbHMsIHBhcmVudCwgc2VsZik7XHJcbiAgfTtcclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykuc2VydmljZSgnJHJlc29sdmUnLCAkUmVzb2x2ZSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFNlcnZpY2UuIE1hbmFnZXMgbG9hZGluZyBvZiB0ZW1wbGF0ZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAbmFtZSAkdGVtcGxhdGVGYWN0b3J5XHJcbiAqIEByZXF1aXJlcyAkaHR0cFxyXG4gKiBAcmVxdWlyZXMgJHRlbXBsYXRlQ2FjaGVcclxuICogQHJlcXVpcmVzICRpbmplY3RvclxyXG4gKi9cclxuJFRlbXBsYXRlRmFjdG9yeS4kaW5qZWN0ID0gWyckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckaW5qZWN0b3InXTtcclxuZnVuY3Rpb24gJFRlbXBsYXRlRmFjdG9yeSggICRodHRwLCAgICR0ZW1wbGF0ZUNhY2hlLCAgICRpbmplY3Rvcikge1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZnJvbSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbmFtZSAkdGVtcGxhdGVGYWN0b3J5I2Zyb21Db25maWdcclxuICAgKiBAbWV0aG9kT2YgJHRlbXBsYXRlRmFjdG9yeVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB3aGljaCB0byBsb2FkIGEgdGVtcGxhdGUuIFRoZSBmb2xsb3dpbmdcclxuICAgKiAgICBwcm9wZXJ0aWVzIGFyZSBzZWFyY2ggaW4gdGhlIHNwZWNpZmllZCBvcmRlciwgYW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBkZWZpbmVkIGlzXHJcbiAgICogICAgdXNlZCB0byBjcmVhdGUgdGhlIHRlbXBsYXRlOlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSBjb25maWcudGVtcGxhdGUgIGh0bWwgc3RyaW5nIHRlbXBsYXRlIG9yIGZ1bmN0aW9uIHRvIGxvYWQgdmlhXHJcbiAgICogICAge0BsaW5rICR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVN0cmluZyBmcm9tU3RyaW5nfS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gY29uZmlnLnRlbXBsYXRlVXJsICB1cmwgdG8gbG9hZCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdXJsXHJcbiAgICogICAgdG8gbG9hZCB2aWEge0BsaW5rICR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVVybCBmcm9tVXJsfS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcudGVtcGxhdGVQcm92aWRlciAgZnVuY3Rpb24gdG8gaW52b2tlIHZpYVxyXG4gICAqICAgIHtAbGluayAkdGVtcGxhdGVGYWN0b3J5I2Zyb21Qcm92aWRlciBmcm9tUHJvdmlkZXJ9LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtsb2NhbHNdIExvY2FscyB0byBwYXNzIHRvIGBpbnZva2VgIGlmIHRoZSB0ZW1wbGF0ZSBpcyBsb2FkZWQgdmlhIGFcclxuICAgKiAgICAgIGB0ZW1wbGF0ZVByb3ZpZGVyYC4gRGVmYXVsdHMgdG8gYHsgcGFyYW1zOiBwYXJhbXMgfWAuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvciB0aGF0IHN0cmluZyxcclxuICAgKiAgICAgIG9yIGBudWxsYCBpZiBubyB0ZW1wbGF0ZSBpcyBjb25maWd1cmVkLlxyXG4gICAqL1xyXG4gIHRoaXMuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIHBhcmFtcywgbG9jYWxzKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlKSA/IHRoaXMuZnJvbVN0cmluZyhjb25maWcudGVtcGxhdGUsIHBhcmFtcykgOlxyXG4gICAgICBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlVXJsKSA/IHRoaXMuZnJvbVVybChjb25maWcudGVtcGxhdGVVcmwsIHBhcmFtcykgOlxyXG4gICAgICBpc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIpID8gdGhpcy5mcm9tUHJvdmlkZXIoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIsIHBhcmFtcywgbG9jYWxzKSA6XHJcbiAgICAgIG51bGxcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgJHRlbXBsYXRlRmFjdG9yeSNmcm9tU3RyaW5nXHJcbiAgICogQG1ldGhvZE9mICR0ZW1wbGF0ZUZhY3RvcnlcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gdGVtcGxhdGUgIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGh0bWxcclxuICAgKiAgICAgIHRlbXBsYXRlIGFzIGEgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvciB0aGF0IHN0cmluZy5cclxuICAgKi9cclxuICB0aGlzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odGVtcGxhdGUpID8gdGVtcGxhdGUocGFyYW1zKSA6IHRlbXBsYXRlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIGEgdGVtcGxhdGUgZnJvbSB0aGUgYSBVUkwgdmlhIGAkaHR0cGAgYW5kIGAkdGVtcGxhdGVDYWNoZWAuXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgJHRlbXBsYXRlRmFjdG9yeSNmcm9tVXJsXHJcbiAgICogQG1ldGhvZE9mICR0ZW1wbGF0ZUZhY3RvcnlcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gdXJsICB1cmwgb2YgdGhlIHRlbXBsYXRlIHRvIGxvYWQsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdXJsLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdXJsIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSAgVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdCBzdHJpbmcuXHJcbiAgICovXHJcbiAgdGhpcy5mcm9tVXJsID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih1cmwpKSB1cmwgPSB1cmwocGFyYW1zKTtcclxuICAgIGlmICh1cmwgPT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcbiAgICBlbHNlIHJldHVybiAkaHR0cFxyXG4gICAgICAgIC5nZXQodXJsLCB7IGNhY2hlOiAkdGVtcGxhdGVDYWNoZSB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS5kYXRhOyB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgYnkgaW52b2tpbmcgYW4gaW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbi5cclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbmFtZSAkdGVtcGxhdGVGYWN0b3J5I2Zyb21VcmxcclxuICAgKiBAbWV0aG9kT2YgJHRlbXBsYXRlRmFjdG9yeVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYCRpbmplY3Rvci5pbnZva2VgXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGVtcGxhdGUuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtsb2NhbHNdIExvY2FscyB0byBwYXNzIHRvIGBpbnZva2VgLiBEZWZhdWx0cyB0byBgeyBwYXJhbXM6IHBhcmFtcyB9YC5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZS48c3RyaW5nPn0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdCBzdHJpbmcuXHJcbiAgICovXHJcbiAgdGhpcy5mcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgbG9jYWxzKSB7XHJcbiAgICByZXR1cm4gJGluamVjdG9yLmludm9rZShwcm92aWRlciwgbnVsbCwgbG9jYWxzIHx8IHsgcGFyYW1zOiBwYXJhbXMgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykuc2VydmljZSgnJHRlbXBsYXRlRmFjdG9yeScsICRUZW1wbGF0ZUZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIE1hdGNoZXMgVVJMcyBhZ2FpbnN0IHBhdHRlcm5zIGFuZCBleHRyYWN0cyBuYW1lZCBwYXJhbWV0ZXJzIGZyb20gdGhlIHBhdGggb3IgdGhlIHNlYXJjaFxyXG4gKiBwYXJ0IG9mIHRoZSBVUkwuIEEgVVJMIHBhdHRlcm4gY29uc2lzdHMgb2YgYSBwYXRoIHBhdHRlcm4sIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgJz8nIGFuZCBhIGxpc3RcclxuICogb2Ygc2VhcmNoIHBhcmFtZXRlcnMuIE11bHRpcGxlIHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYXJlIHNlcGFyYXRlZCBieSAnJicuIFNlYXJjaCBwYXJhbWV0ZXJzXHJcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xyXG4gKiB0aGUgbWF0Y2hlZCBwYXJhbWV0ZXJzIHJldHVybmVkIGJ5IHtAbGluayBVcmxNYXRjaGVyI2V4ZWMgZXhlY30uXHJcbiAqIFxyXG4gKiBQYXRoIHBhcmFtZXRlciBwbGFjZWhvbGRlcnMgY2FuIGJlIHNwZWNpZmllZCB1c2luZyBzaW1wbGUgY29sb24vY2F0Y2gtYWxsIHN5bnRheCBvciBjdXJseSBicmFjZVxyXG4gKiBzeW50YXgsIHdoaWNoIG9wdGlvbmFsbHkgYWxsb3dzIGEgcmVndWxhciBleHByZXNzaW9uIGZvciB0aGUgcGFyYW1ldGVyIHRvIGJlIHNwZWNpZmllZDpcclxuICpcclxuICogKiAnOicgbmFtZSAtIGNvbG9uIHBsYWNlaG9sZGVyXHJcbiAqICogJyonIG5hbWUgLSBjYXRjaC1hbGwgcGxhY2Vob2xkZXJcclxuICogKiAneycgbmFtZSAnfScgLSBjdXJseSBwbGFjZWhvbGRlclxyXG4gKiAqICd7JyBuYW1lICc6JyByZWdleHAgJ30nIC0gY3VybHkgcGxhY2Vob2xkZXIgd2l0aCByZWdleHAuIFNob3VsZCB0aGUgcmVnZXhwIGl0c2VsZiBjb250YWluXHJcbiAqICAgY3VybHkgYnJhY2VzLCB0aGV5IG11c3QgYmUgaW4gbWF0Y2hlZCBwYWlycyBvciBlc2NhcGVkIHdpdGggYSBiYWNrc2xhc2guXHJcbiAqXHJcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXHJcbiAqIG11c3QgYmUgdW5pcXVlIHdpdGhpbiB0aGUgcGF0dGVybiAoYWNyb3NzIGJvdGggcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMpLiBGb3IgY29sb24gXHJcbiAqIHBsYWNlaG9sZGVycyBvciBjdXJseSBwbGFjZWhvbGRlcnMgd2l0aG91dCBhbiBleHBsaWNpdCByZWdleHAsIGEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnlcclxuICogbnVtYmVyIG9mIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiAnLycuIEZvciBjYXRjaC1hbGwgcGxhY2Vob2xkZXJzIHRoZSBwYXRoIHBhcmFtZXRlciBtYXRjaGVzXHJcbiAqIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycy5cclxuICogXHJcbiAqICMjIyBFeGFtcGxlc1xyXG4gKiBcclxuICogKiAnL2hlbGxvLycgLSBNYXRjaGVzIG9ubHkgaWYgdGhlIHBhdGggaXMgZXhhY3RseSAnL2hlbGxvLycuIFRoZXJlIGlzIG5vIHNwZWNpYWwgdHJlYXRtZW50IGZvclxyXG4gKiAgIHRyYWlsaW5nIHNsYXNoZXMsIGFuZCBwYXR0ZXJucyBoYXZlIHRvIG1hdGNoIHRoZSBlbnRpcmUgcGF0aCwgbm90IGp1c3QgYSBwcmVmaXguXHJcbiAqICogJy91c2VyLzppZCcgLSBNYXRjaGVzICcvdXNlci9ib2InIG9yICcvdXNlci8xMjM0ISEhJyBvciBldmVuICcvdXNlci8nIGJ1dCBub3QgJy91c2VyJyBvclxyXG4gKiAgICcvdXNlci9ib2IvZGV0YWlscycuIFRoZSBzZWNvbmQgcGF0aCBzZWdtZW50IHdpbGwgYmUgY2FwdHVyZWQgYXMgdGhlIHBhcmFtZXRlciAnaWQnLlxyXG4gKiAqICcvdXNlci97aWR9JyAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCB1c2luZyBjdXJseSBicmFjZSBzeW50YXguXHJcbiAqICogJy91c2VyL3tpZDpbXi9dKn0nIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZS5cclxuICogKiAnL3VzZXIve2lkOlswLTlhLWZBLUZdezEsOH19JyAtIFNpbWlsYXIgdG8gdGhlIHByZXZpb3VzIGV4YW1wbGUsIGJ1dCBvbmx5IG1hdGNoZXMgaWYgdGhlIGlkXHJcbiAqICAgcGFyYW1ldGVyIGNvbnNpc3RzIG9mIDEgdG8gOCBoZXggZGlnaXRzLlxyXG4gKiAqICcvZmlsZXMve3BhdGg6Lip9JyAtIE1hdGNoZXMgYW55IFVSTCBzdGFydGluZyB3aXRoICcvZmlsZXMvJyBhbmQgY2FwdHVyZXMgdGhlIHJlc3Qgb2YgdGhlXHJcbiAqICAgcGF0aCBpbnRvIHRoZSBwYXJhbWV0ZXIgJ3BhdGgnLlxyXG4gKiAqICcvZmlsZXMvKnBhdGgnIC0gZGl0dG8uXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAgdGhlIHBhdHRlcm4gdG8gY29tcGlsZSBpbnRvIGEgbWF0Y2hlci5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByZWZpeCAgQSBzdGF0aWMgcHJlZml4IG9mIHRoaXMgcGF0dGVybi4gVGhlIG1hdGNoZXIgZ3VhcmFudGVlcyB0aGF0IGFueVxyXG4gKiAgIFVSTCBtYXRjaGluZyB0aGlzIG1hdGNoZXIgKGkuZS4gYW55IHN0cmluZyBmb3Igd2hpY2gge0BsaW5rIFVybE1hdGNoZXIjZXhlYyBleGVjKCl9IHJldHVybnNcclxuICogICBub24tbnVsbCkgd2lsbCBzdGFydCB3aXRoIHRoaXMgcHJlZml4LlxyXG4gKi9cclxuZnVuY3Rpb24gVXJsTWF0Y2hlcihwYXR0ZXJuKSB7XHJcblxyXG4gIC8vIEZpbmQgYWxsIHBsYWNlaG9sZGVycyBhbmQgY3JlYXRlIGEgY29tcGlsZWQgcGF0dGVybiwgdXNpbmcgZWl0aGVyIGNsYXNzaWMgb3IgY3VybHkgc3ludGF4OlxyXG4gIC8vICAgJyonIG5hbWVcclxuICAvLyAgICc6JyBuYW1lXHJcbiAgLy8gICAneycgbmFtZSAnfSdcclxuICAvLyAgICd7JyBuYW1lICc6JyByZWdleHAgJ30nXHJcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBzb21ld2hhdCBjb21wbGljYXRlZCBkdWUgdG8gdGhlIG5lZWQgdG8gYWxsb3cgY3VybHkgYnJhY2VzXHJcbiAgLy8gaW5zaWRlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uIFRoZSBwbGFjZWhvbGRlciByZWdleHAgYnJlYWtzIGRvd24gYXMgZm9sbG93czpcclxuICAvLyAgICAoWzoqXSkoXFx3KykgICAgICAgICAgICAgICBjbGFzc2ljIHBsYWNlaG9sZGVyICgkMSAvICQyKVxyXG4gIC8vICAgIFxceyhcXHcrKSg/OlxcOiggLi4uICkpP1xcfSAgIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyICgkMykgd2l0aCBvcHRpb25hbCByZWdleHAgLi4uICgkNClcclxuICAvLyAgICAoPzogLi4uIHwgLi4uIHwgLi4uICkrICAgIHRoZSByZWdleHAgY29uc2lzdHMgb2YgYW55IG51bWJlciBvZiBhdG9tcywgYW4gYXRvbSBiZWluZyBlaXRoZXJcclxuICAvLyAgICBbXnt9XFxcXF0rICAgICAgICAgICAgICAgICAgLSBhbnl0aGluZyBvdGhlciB0aGFuIGN1cmx5IGJyYWNlcyBvciBiYWNrc2xhc2hcclxuICAvLyAgICBcXFxcLiAgICAgICAgICAgICAgICAgICAgICAgLSBhIGJhY2tzbGFzaCBlc2NhcGVcclxuICAvLyAgICBcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0gICAgIC0gYSBtYXRjaGVkIHNldCBvZiBjdXJseSBicmFjZXMgY29udGFpbmluZyBvdGhlciBhdG9tc1xyXG4gIHZhciBwbGFjZWhvbGRlciA9IC8oWzoqXSkoXFx3Kyl8XFx7KFxcdyspKD86XFw6KCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZyxcclxuICAgICAgbmFtZXMgPSB7fSwgY29tcGlsZWQgPSAnXicsIGxhc3QgPSAwLCBtLFxyXG4gICAgICBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMgPSBbXSxcclxuICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXMgPSBbXTtcclxuXHJcbiAgZnVuY3Rpb24gYWRkUGFyYW1ldGVyKGlkKSB7XHJcbiAgICBpZiAoIS9eXFx3KygtK1xcdyspKiQvLnRlc3QoaWQpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBuYW1lICdcIiArIGlkICsgXCInIGluIHBhdHRlcm4gJ1wiICsgcGF0dGVybiArIFwiJ1wiKTtcclxuICAgIGlmIChuYW1lc1tpZF0pIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XHJcbiAgICBuYW1lc1tpZF0gPSB0cnVlO1xyXG4gICAgcGFyYW1zLnB1c2goaWQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcXVvdGVSZWdFeHAoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXFxcXFxbXFxdXFxeJCorPy4oKXx7fV0vZywgXCJcXFxcJCZcIik7XHJcbiAgfVxyXG5cclxuICB0aGlzLnNvdXJjZSA9IHBhdHRlcm47XHJcblxyXG4gIC8vIFNwbGl0IGludG8gc3RhdGljIHNlZ21lbnRzIHNlcGFyYXRlZCBieSBwYXRoIHBhcmFtZXRlciBwbGFjZWhvbGRlcnMuXHJcbiAgLy8gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpcyBhbHdheXMgMSBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzLlxyXG4gIHZhciBpZCwgcmVnZXhwLCBzZWdtZW50O1xyXG4gIHdoaWxlICgobSA9IHBsYWNlaG9sZGVyLmV4ZWMocGF0dGVybikpKSB7XHJcbiAgICBpZCA9IG1bMl0gfHwgbVszXTsgLy8gSUVbNzhdIHJldHVybnMgJycgZm9yIHVubWF0Y2hlZCBncm91cHMgaW5zdGVhZCBvZiBudWxsXHJcbiAgICByZWdleHAgPSBtWzRdIHx8IChtWzFdID09ICcqJyA/ICcuKicgOiAnW14vXSonKTtcclxuICAgIHNlZ21lbnQgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0LCBtLmluZGV4KTtcclxuICAgIGlmIChzZWdtZW50LmluZGV4T2YoJz8nKSA+PSAwKSBicmVhazsgLy8gd2UncmUgaW50byB0aGUgc2VhcmNoIHBhcnRcclxuICAgIGNvbXBpbGVkICs9IHF1b3RlUmVnRXhwKHNlZ21lbnQpICsgJygnICsgcmVnZXhwICsgJyknO1xyXG4gICAgYWRkUGFyYW1ldGVyKGlkKTtcclxuICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xyXG4gIH1cclxuICBzZWdtZW50ID0gcGF0dGVybi5zdWJzdHJpbmcobGFzdCk7XHJcblxyXG4gIC8vIEZpbmQgYW55IHNlYXJjaCBwYXJhbWV0ZXIgbmFtZXMgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxhc3Qgc2VnbWVudFxyXG4gIHZhciBpID0gc2VnbWVudC5pbmRleE9mKCc/Jyk7XHJcbiAgaWYgKGkgPj0gMCkge1xyXG4gICAgdmFyIHNlYXJjaCA9IHRoaXMuc291cmNlU2VhcmNoID0gc2VnbWVudC5zdWJzdHJpbmcoaSk7XHJcbiAgICBzZWdtZW50ID0gc2VnbWVudC5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICB0aGlzLnNvdXJjZVBhdGggPSBwYXR0ZXJuLnN1YnN0cmluZygwLCBsYXN0K2kpO1xyXG5cclxuICAgIC8vIEFsbG93IHBhcmFtZXRlcnMgdG8gYmUgc2VwYXJhdGVkIGJ5ICc/JyBhcyB3ZWxsIGFzICcmJyB0byBtYWtlIGNvbmNhdCgpIGVhc2llclxyXG4gICAgZm9yRWFjaChzZWFyY2guc3Vic3RyaW5nKDEpLnNwbGl0KC9bJj9dLyksIGFkZFBhcmFtZXRlcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMuc291cmNlUGF0aCA9IHBhdHRlcm47XHJcbiAgICB0aGlzLnNvdXJjZVNlYXJjaCA9ICcnO1xyXG4gIH1cclxuXHJcbiAgY29tcGlsZWQgKz0gcXVvdGVSZWdFeHAoc2VnbWVudCkgKyAnJCc7XHJcbiAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcclxuICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAoY29tcGlsZWQpO1xyXG4gIHRoaXMucHJlZml4ID0gc2VnbWVudHNbMF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IG1hdGNoZXIgZm9yIGEgcGF0dGVybiBjb25zdHJ1Y3RlZCBieSBhcHBlbmRpbmcgdGhlIHBhdGggcGFydCBhbmQgYWRkaW5nIHRoZVxyXG4gKiBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGUgc3BlY2lmaWVkIHBhdHRlcm4gdG8gdGhpcyBwYXR0ZXJuLiBUaGUgY3VycmVudCBwYXR0ZXJuIGlzIG5vdFxyXG4gKiBtb2RpZmllZC4gVGhpcyBjYW4gYmUgdW5kZXJzdG9vZCBhcyBjcmVhdGluZyBhIHBhdHRlcm4gZm9yIFVSTHMgdGhhdCBhcmUgcmVsYXRpdmUgdG8gKG9yXHJcbiAqIHN1ZmZpeGVzIG9mKSB0aGUgY3VycmVudCBwYXR0ZXJuLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBUaGUgZm9sbG93aW5nIHR3byBtYXRjaGVycyBhcmUgZXF1aXZhbGVudDpcclxuICogYGBgXHJcbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EnKS5jb25jYXQoJy9kZXRhaWxzP2RhdGUnKTtcclxuICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0vZGV0YWlscz9xJmRhdGUnKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgcGF0dGVybiB0byBhcHBlbmQuXHJcbiAqIEByZXR1cm4ge1VybE1hdGNoZXJ9ICBBIG1hdGNoZXIgZm9yIHRoZSBjb25jYXRlbmF0ZWQgcGF0dGVybi5cclxuICovXHJcblVybE1hdGNoZXIucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XHJcbiAgLy8gQmVjYXVzZSBvcmRlciBvZiBzZWFyY2ggcGFyYW1ldGVycyBpcyBpcnJlbGV2YW50LCB3ZSBjYW4gYWRkIG91ciBvd24gc2VhcmNoXHJcbiAgLy8gcGFyYW1ldGVycyB0byB0aGUgZW5kIG9mIHRoZSBuZXcgcGF0dGVybi4gUGFyc2UgdGhlIG5ldyBwYXR0ZXJuIGJ5IGl0c2VsZlxyXG4gIC8vIGFuZCB0aGVuIGpvaW4gdGhlIGJpdHMgdG9nZXRoZXIsIGJ1dCBpdCdzIG11Y2ggZWFzaWVyIHRvIGRvIHRoaXMgb24gYSBzdHJpbmcgbGV2ZWwuXHJcbiAgcmV0dXJuIG5ldyBVcmxNYXRjaGVyKHRoaXMuc291cmNlUGF0aCArIHBhdHRlcm4gKyB0aGlzLnNvdXJjZVNlYXJjaCk7XHJcbn07XHJcblxyXG5VcmxNYXRjaGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5zb3VyY2U7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgdGhlIHNwZWNpZmllZCBwYXRoIGFnYWluc3QgdGhpcyBtYXRjaGVyLCBhbmQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FwdHVyZWRcclxuICogcGFyYW1ldGVyIHZhbHVlcywgb3IgbnVsbCBpZiB0aGUgcGF0aCBkb2VzIG5vdCBtYXRjaC4gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgdmFsdWVzXHJcbiAqIG9mIGFueSBzZWFyY2ggcGFyYW1ldGVycyB0aGF0IGFyZSBtZW50aW9uZWQgaW4gdGhlIHBhdHRlcm4sIGJ1dCB0aGVpciB2YWx1ZSBtYXkgYmUgbnVsbCBpZlxyXG4gKiB0aGV5IGFyZSBub3QgcHJlc2VudCBpbiBgc2VhcmNoUGFyYW1zYC4gVGhpcyBtZWFucyB0aGF0IHNlYXJjaCBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgdHJlYXRlZFxyXG4gKiBhcyBvcHRpb25hbC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgXHJcbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EmcicpLmV4ZWMoJy91c2VyL2JvYicsIHsgeDonMScsIHE6J2hlbGxvJyB9KTtcclxuICogLy8gcmV0dXJucyB7IGlkOidib2InLCBxOidoZWxsbycsIHI6bnVsbCB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAgVGhlIFVSTCBwYXRoIHRvIG1hdGNoLCBlLmcuIGAkbG9jYXRpb24ucGF0aCgpYC5cclxuICogQHBhcmFtIHtPYmplY3R9IHNlYXJjaFBhcmFtcyAgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzLCBlLmcuIGAkbG9jYXRpb24uc2VhcmNoKClgLlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICBUaGUgY2FwdHVyZWQgcGFyYW1ldGVyIHZhbHVlcy5cclxuICovXHJcblVybE1hdGNoZXIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAocGF0aCwgc2VhcmNoUGFyYW1zKSB7XHJcbiAgdmFyIG0gPSB0aGlzLnJlZ2V4cC5leGVjKHBhdGgpO1xyXG4gIGlmICghbSkgcmV0dXJuIG51bGw7XHJcblxyXG4gIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcywgblRvdGFsID0gcGFyYW1zLmxlbmd0aCxcclxuICAgIG5QYXRoID0gdGhpcy5zZWdtZW50cy5sZW5ndGgtMSxcclxuICAgIHZhbHVlcyA9IHt9LCBpO1xyXG5cclxuICBpZiAoblBhdGggIT09IG0ubGVuZ3RoIC0gMSkgdGhyb3cgbmV3IEVycm9yKFwiVW5iYWxhbmNlZCBjYXB0dXJlIGdyb3VwIGluIHJvdXRlICdcIiArIHRoaXMuc291cmNlICsgXCInXCIpO1xyXG5cclxuICBmb3IgKGk9MDsgaTxuUGF0aDsgaSsrKSB2YWx1ZXNbcGFyYW1zW2ldXSA9IG1baSsxXTtcclxuICBmb3IgKC8qKi87IGk8blRvdGFsOyBpKyspIHZhbHVlc1twYXJhbXNbaV1dID0gc2VhcmNoUGFyYW1zW3BhcmFtc1tpXV07XHJcblxyXG4gIHJldHVybiB2YWx1ZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmFtZXMgb2YgYWxsIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoaXMgcGF0dGVybiBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci5cclxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59ICBBbiBhcnJheSBvZiBwYXJhbWV0ZXIgbmFtZXMuIE11c3QgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkuIElmIHRoZVxyXG4gKiAgICBwYXR0ZXJuIGhhcyBubyBwYXJhbWV0ZXJzLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cclxuICovXHJcblVybE1hdGNoZXIucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucGFyYW1zO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBVUkwgdGhhdCBtYXRjaGVzIHRoaXMgcGF0dGVybiBieSBzdWJzdGl0dXRpbmcgdGhlIHNwZWNpZmllZCB2YWx1ZXNcclxuICogZm9yIHRoZSBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycy4gTnVsbCB2YWx1ZXMgZm9yIHBhdGggcGFyYW1ldGVycyBhcmVcclxuICogdHJlYXRlZCBhcyBlbXB0eSBzdHJpbmdzLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGBcclxuICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmZvcm1hdCh7IGlkOidib2InLCBxOid5ZXMnIH0pO1xyXG4gKiAvLyByZXR1cm5zICcvdXNlci9ib2I/cT15ZXMnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzICB0aGUgdmFsdWVzIHRvIHN1YnN0aXR1dGUgZm9yIHRoZSBwYXJhbWV0ZXJzIGluIHRoaXMgcGF0dGVybi5cclxuICogQHJldHVybiB7c3RyaW5nfSAgdGhlIGZvcm1hdHRlZCBVUkwgKHBhdGggYW5kIG9wdGlvbmFsbHkgc2VhcmNoIHBhcnQpLlxyXG4gKi9cclxuVXJsTWF0Y2hlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMsIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xyXG4gIGlmICghdmFsdWVzKSByZXR1cm4gc2VnbWVudHMuam9pbignJyk7XHJcblxyXG4gIHZhciBuUGF0aCA9IHNlZ21lbnRzLmxlbmd0aC0xLCBuVG90YWwgPSBwYXJhbXMubGVuZ3RoLFxyXG4gICAgcmVzdWx0ID0gc2VnbWVudHNbMF0sIGksIHNlYXJjaCwgdmFsdWU7XHJcblxyXG4gIGZvciAoaT0wOyBpPG5QYXRoOyBpKyspIHtcclxuICAgIHZhbHVlID0gdmFsdWVzW3BhcmFtc1tpXV07XHJcbiAgICAvLyBUT0RPOiBNYXliZSB3ZSBzaG91bGQgdGhyb3cgb24gbnVsbCBoZXJlPyBJdCdzIG5vdCByZWFsbHkgZ29vZCBzdHlsZSB0byB1c2UgJycgYW5kIG51bGwgaW50ZXJjaGFuZ2VhYmxleVxyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgcmVzdWx0ICs9IHNlZ21lbnRzW2krMV07XHJcbiAgfVxyXG4gIGZvciAoLyoqLzsgaTxuVG90YWw7IGkrKykge1xyXG4gICAgdmFsdWUgPSB2YWx1ZXNbcGFyYW1zW2ldXTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIHJlc3VsdCArPSAoc2VhcmNoID8gJyYnIDogJz8nKSArIHBhcmFtc1tpXSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgICAgIHNlYXJjaCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNlcnZpY2UuIEZhY3RvcnkgZm9yIHtAbGluayBVcmxNYXRjaGVyfSBpbnN0YW5jZXMuIFRoZSBmYWN0b3J5IGlzIGFsc28gYXZhaWxhYmxlIHRvIHByb3ZpZGVyc1xyXG4gKiB1bmRlciB0aGUgbmFtZSBgJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJgLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQG5hbWUgJHVybE1hdGNoZXJGYWN0b3J5XHJcbiAqL1xyXG5mdW5jdGlvbiAkVXJsTWF0Y2hlckZhY3RvcnkoKSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHtAbGluayBVcmxNYXRjaGVyfSBmb3IgdGhlIHNwZWNpZmllZCBwYXR0ZXJuLlxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBuYW1lICR1cmxNYXRjaGVyRmFjdG9yeSNjb21waWxlXHJcbiAgICogQG1ldGhvZE9mICR1cmxNYXRjaGVyRmFjdG9yeVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgVVJMIHBhdHRlcm4uXHJcbiAgICogQHJldHVybiB7VXJsTWF0Y2hlcn0gIFRoZSBVcmxNYXRjaGVyLlxyXG4gICAqL1xyXG4gIHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XHJcbiAgICByZXR1cm4gbmV3IFVybE1hdGNoZXIocGF0dGVybik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgVXJsTWF0Y2hlciwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBuYW1lICR1cmxNYXRjaGVyRmFjdG9yeSNpc01hdGNoZXJcclxuICAgKiBAbWV0aG9kT2YgJHVybE1hdGNoZXJGYWN0b3J5XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9cclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHRoaXMuaXNNYXRjaGVyID0gZnVuY3Rpb24gKG8pIHtcclxuICAgIHJldHVybiBpc09iamVjdChvKSAmJiBpc0Z1bmN0aW9uKG8uZXhlYykgJiYgaXNGdW5jdGlvbihvLmZvcm1hdCkgJiYgaXNGdW5jdGlvbihvLmNvbmNhdCk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gUmVnaXN0ZXIgYXMgYSBwcm92aWRlciBzbyBpdCdzIGF2YWlsYWJsZSB0byBvdGhlciBwcm92aWRlcnNcclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykucHJvdmlkZXIoJyR1cmxNYXRjaGVyRmFjdG9yeScsICRVcmxNYXRjaGVyRmFjdG9yeSk7XHJcblxyXG5cclxuJFVybFJvdXRlclByb3ZpZGVyLiRpbmplY3QgPSBbJyR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyJ107XHJcbmZ1bmN0aW9uICRVcmxSb3V0ZXJQcm92aWRlciggICR1cmxNYXRjaGVyRmFjdG9yeSkge1xyXG4gIHZhciBydWxlcyA9IFtdLCBcclxuICAgICAgb3RoZXJ3aXNlID0gbnVsbDtcclxuXHJcbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIGEgcHJlZml4IG9mIGFsbCBzdHJpbmdzIG1hdGNoaW5nIHRoZSBSZWdFeHBcclxuICBmdW5jdGlvbiByZWdFeHBQcmVmaXgocmUpIHtcclxuICAgIHZhciBwcmVmaXggPSAvXlxcXigoPzpcXFxcW15hLXpBLVowLTldfFteXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dKykqKS8uZXhlYyhyZS5zb3VyY2UpO1xyXG4gICAgcmV0dXJuIChwcmVmaXggIT0gbnVsbCkgPyBwcmVmaXhbMV0ucmVwbGFjZSgvXFxcXCguKS9nLCBcIiQxXCIpIDogJyc7XHJcbiAgfVxyXG5cclxuICAvLyBJbnRlcnBvbGF0ZXMgbWF0Y2hlZCB2YWx1ZXMgaW50byBhIFN0cmluZy5yZXBsYWNlKCktc3R5bGUgcGF0dGVyblxyXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKHBhdHRlcm4sIG1hdGNoKSB7XHJcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9cXCQoXFwkfFxcZHsxLDJ9KS8sIGZ1bmN0aW9uIChtLCB3aGF0KSB7XHJcbiAgICAgIHJldHVybiBtYXRjaFt3aGF0ID09PSAnJCcgPyAwIDogTnVtYmVyKHdoYXQpXTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5ydWxlID1cclxuICAgIGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICAgIGlmICghaXNGdW5jdGlvbihydWxlKSkgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICAgICAgcnVsZXMucHVzaChydWxlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICB0aGlzLm90aGVyd2lzZSA9XHJcbiAgICBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICBpZiAoaXNTdHJpbmcocnVsZSkpIHtcclxuICAgICAgICB2YXIgcmVkaXJlY3QgPSBydWxlO1xyXG4gICAgICAgIHJ1bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZWRpcmVjdDsgfTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICghaXNGdW5jdGlvbihydWxlKSkgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICAgICAgb3RoZXJ3aXNlID0gcnVsZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gaGFuZGxlSWZNYXRjaCgkaW5qZWN0b3IsIGhhbmRsZXIsIG1hdGNoKSB7XHJcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgcmVzdWx0ID0gJGluamVjdG9yLmludm9rZShoYW5kbGVyLCBoYW5kbGVyLCB7ICRtYXRjaDogbWF0Y2ggfSk7XHJcbiAgICByZXR1cm4gaXNEZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgdGhpcy53aGVuID1cclxuICAgIGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XHJcbiAgICAgIHZhciByZWRpcmVjdCwgaGFuZGxlcklzU3RyaW5nID0gaXNTdHJpbmcoaGFuZGxlcik7XHJcbiAgICAgIGlmIChpc1N0cmluZyh3aGF0KSkgd2hhdCA9ICR1cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHdoYXQpO1xyXG5cclxuICAgICAgaWYgKCFoYW5kbGVySXNTdHJpbmcgJiYgIWlzRnVuY3Rpb24oaGFuZGxlcikgJiYgIWlzQXJyYXkoaGFuZGxlcikpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCAnaGFuZGxlcicgaW4gd2hlbigpXCIpO1xyXG5cclxuICAgICAgdmFyIHN0cmF0ZWdpZXMgPSB7XHJcbiAgICAgICAgbWF0Y2hlcjogZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcclxuICAgICAgICAgIGlmIChoYW5kbGVySXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgcmVkaXJlY3QgPSAkdXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgaGFuZGxlciA9IFsnJG1hdGNoJywgZnVuY3Rpb24gKCRtYXRjaCkgeyByZXR1cm4gcmVkaXJlY3QuZm9ybWF0KCRtYXRjaCk7IH1dO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUlmTWF0Y2goJGluamVjdG9yLCBoYW5kbGVyLCB3aGF0LmV4ZWMoJGxvY2F0aW9uLnBhdGgoKSwgJGxvY2F0aW9uLnNlYXJjaCgpKSk7XHJcbiAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHByZWZpeDogaXNTdHJpbmcod2hhdC5wcmVmaXgpID8gd2hhdC5wcmVmaXggOiAnJ1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWdleDogZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcclxuICAgICAgICAgIGlmICh3aGF0Lmdsb2JhbCB8fCB3aGF0LnN0aWNreSkgdGhyb3cgbmV3IEVycm9yKFwid2hlbigpIFJlZ0V4cCBtdXN0IG5vdCBiZSBnbG9iYWwgb3Igc3RpY2t5XCIpO1xyXG5cclxuICAgICAgICAgIGlmIChoYW5kbGVySXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgcmVkaXJlY3QgPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICBoYW5kbGVyID0gWyckbWF0Y2gnLCBmdW5jdGlvbiAoJG1hdGNoKSB7IHJldHVybiBpbnRlcnBvbGF0ZShyZWRpcmVjdCwgJG1hdGNoKTsgfV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlSWZNYXRjaCgkaW5qZWN0b3IsIGhhbmRsZXIsIHdoYXQuZXhlYygkbG9jYXRpb24ucGF0aCgpKSk7XHJcbiAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHByZWZpeDogcmVnRXhwUHJlZml4KHdoYXQpXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2hlY2sgPSB7IG1hdGNoZXI6ICR1cmxNYXRjaGVyRmFjdG9yeS5pc01hdGNoZXIod2hhdCksIHJlZ2V4OiB3aGF0IGluc3RhbmNlb2YgUmVnRXhwIH07XHJcblxyXG4gICAgICBmb3IgKHZhciBuIGluIGNoZWNrKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrW25dKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlKHN0cmF0ZWdpZXNbbl0od2hhdCwgaGFuZGxlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCAnd2hhdCcgaW4gd2hlbigpXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgdGhpcy4kZ2V0ID1cclxuICAgIFsgICAgICAgICckbG9jYXRpb24nLCAnJHJvb3RTY29wZScsICckaW5qZWN0b3InLFxyXG4gICAgZnVuY3Rpb24gKCRsb2NhdGlvbiwgICAkcm9vdFNjb3BlLCAgICRpbmplY3Rvcikge1xyXG4gICAgICAvLyBUT0RPOiBPcHRpbWl6ZSBncm91cHMgb2YgcnVsZXMgd2l0aCBub24tZW1wdHkgcHJlZml4IGludG8gc29tZSBzb3J0IG9mIGRlY2lzaW9uIHRyZWVcclxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHJ1bGUpIHtcclxuICAgICAgICAgIHZhciBoYW5kbGVkID0gcnVsZSgkaW5qZWN0b3IsICRsb2NhdGlvbik7XHJcbiAgICAgICAgICBpZiAoaGFuZGxlZCkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoaGFuZGxlZCkpICRsb2NhdGlvbi5yZXBsYWNlKCkudXJsKGhhbmRsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG49cnVsZXMubGVuZ3RoLCBpO1xyXG4gICAgICAgIGZvciAoaT0wOyBpPG47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGNoZWNrKHJ1bGVzW2ldKSkgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbHdheXMgY2hlY2sgb3RoZXJ3aXNlIGxhc3QgdG8gYWxsb3cgZHluYW1pYyB1cGRhdGVzIHRvIHRoZSBzZXQgb2YgcnVsZXNcclxuICAgICAgICBpZiAob3RoZXJ3aXNlKSBjaGVjayhvdGhlcndpc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkcm9vdFNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIHVwZGF0ZSk7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1dO1xyXG59XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicpLnByb3ZpZGVyKCckdXJsUm91dGVyJywgJFVybFJvdXRlclByb3ZpZGVyKTtcclxuXHJcbiRTdGF0ZVByb3ZpZGVyLiRpbmplY3QgPSBbJyR1cmxSb3V0ZXJQcm92aWRlcicsICckdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcicsICckbG9jYXRpb25Qcm92aWRlciddO1xyXG5mdW5jdGlvbiAkU3RhdGVQcm92aWRlciggICAkdXJsUm91dGVyUHJvdmlkZXIsICAgJHVybE1hdGNoZXJGYWN0b3J5LCAgICAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIpIHtcclxuXHJcbiAgdmFyIHJvb3QsIHN0YXRlcyA9IHt9LCAkc3RhdGU7XHJcblxyXG4gIC8vIEJ1aWxkcyBzdGF0ZSBwcm9wZXJ0aWVzIGZyb20gZGVmaW5pdGlvbiBwYXNzZWQgdG8gcmVnaXN0ZXJTdGF0ZSgpXHJcbiAgdmFyIHN0YXRlQnVpbGRlciA9IHtcclxuXHJcbiAgICAvLyBEZXJpdmUgcGFyZW50IHN0YXRlIGZyb20gYSBoaWVyYXJjaGljYWwgbmFtZSBvbmx5IGlmICdwYXJlbnQnIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQuXHJcbiAgICAvLyBzdGF0ZS5jaGlsZHJlbiA9IFtdO1xyXG4gICAgLy8gaWYgKHBhcmVudCkgcGFyZW50LmNoaWxkcmVuLnB1c2goc3RhdGUpO1xyXG4gICAgcGFyZW50OiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICBpZiAoaXNEZWZpbmVkKHN0YXRlLnBhcmVudCkgJiYgc3RhdGUucGFyZW50KSByZXR1cm4gZmluZFN0YXRlKHN0YXRlLnBhcmVudCk7XHJcbiAgICAgIC8vIHJlZ2V4IG1hdGNoZXMgYW55IHZhbGlkIGNvbXBvc2l0ZSBzdGF0ZSBuYW1lXHJcbiAgICAgIC8vIHdvdWxkIG1hdGNoIFwiY29udGFjdC5saXN0XCIgYnV0IG5vdCBcImNvbnRhY3RzXCJcclxuICAgICAgdmFyIGNvbXBvc2l0ZU5hbWUgPSAvXiguKylcXC5bXi5dKyQvLmV4ZWMoc3RhdGUubmFtZSk7XHJcbiAgICAgIHJldHVybiBjb21wb3NpdGVOYW1lID8gZmluZFN0YXRlKGNvbXBvc2l0ZU5hbWVbMV0pIDogcm9vdDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gaW5oZXJpdCAnZGF0YScgZnJvbSBwYXJlbnQgYW5kIG92ZXJyaWRlIGJ5IG93biB2YWx1ZXMgKGlmIGFueSlcclxuICAgIGRhdGE6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcclxuICAgICAgICBzdGF0ZS5kYXRhID0gc3RhdGUuc2VsZi5kYXRhID0gYW5ndWxhci5leHRlbmQoe30sIHN0YXRlLnBhcmVudC5kYXRhLCBzdGF0ZS5kYXRhKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3RhdGUuZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQnVpbGQgYSBVUkxNYXRjaGVyIGlmIG5lY2Vzc2FyeSwgZWl0aGVyIHZpYSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTFxyXG4gICAgdXJsOiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICB2YXIgdXJsID0gc3RhdGUudXJsO1xyXG5cclxuICAgICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgICBpZiAodXJsLmNoYXJBdCgwKSA9PSAnXicpIHtcclxuICAgICAgICAgIHJldHVybiAkdXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZSh1cmwuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIHx8IHJvb3QpLnVybC5jb25jYXQodXJsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCR1cmxNYXRjaGVyRmFjdG9yeS5pc01hdGNoZXIodXJsKSB8fCB1cmwgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1cmwgJ1wiICsgdXJsICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChpLmUuIGlzIG5hdmlnYWJsZSlcclxuICAgIG5hdmlnYWJsZTogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlLnVybCA/IHN0YXRlIDogKHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5uYXZpZ2FibGUgOiBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGVyaXZlIHBhcmFtZXRlcnMgZm9yIHRoaXMgc3RhdGUgYW5kIGVuc3VyZSB0aGV5J3JlIGEgc3VwZXItc2V0IG9mIHBhcmVudCdzIHBhcmFtZXRlcnNcclxuICAgIHBhcmFtczogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgaWYgKCFzdGF0ZS5wYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gc3RhdGUudXJsID8gc3RhdGUudXJsLnBhcmFtZXRlcnMoKSA6IHN0YXRlLnBhcmVudC5wYXJhbXM7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc0FycmF5KHN0YXRlLnBhcmFtcykpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1zIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xyXG4gICAgICBpZiAoc3RhdGUudXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIHBhcmFtcyBhbmQgdXJsIHNwZWNpY2lmaWVkIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xyXG4gICAgICByZXR1cm4gc3RhdGUucGFyYW1zO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBleHBsaWNpdCBtdWx0aS12aWV3IGNvbmZpZ3VyYXRpb24sIG1ha2Ugb25lIHVwIHNvIHdlIGRvbid0IGhhdmVcclxuICAgIC8vIHRvIGhhbmRsZSBib3RoIGNhc2VzIGluIHRoZSB2aWV3IGRpcmVjdGl2ZSBsYXRlci4gTm90ZSB0aGF0IGhhdmluZyBhbiBleHBsaWNpdFxyXG4gICAgLy8gJ3ZpZXdzJyBwcm9wZXJ0eSB3aWxsIG1lYW4gdGhlIGRlZmF1bHQgdW5uYW1lZCB2aWV3IHByb3BlcnRpZXMgYXJlIGlnbm9yZWQuIFRoaXNcclxuICAgIC8vIGlzIGFsc28gYSBnb29kIHRpbWUgdG8gcmVzb2x2ZSB2aWV3IG5hbWVzIHRvIGFic29sdXRlIG5hbWVzLCBzbyBldmVyeXRoaW5nIGlzIGFcclxuICAgIC8vIHN0cmFpZ2h0IGxvb2t1cCBhdCBsaW5rIHRpbWUuXHJcbiAgICB2aWV3czogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgdmFyIHZpZXdzID0ge307XHJcblxyXG4gICAgICBmb3JFYWNoKGlzRGVmaW5lZChzdGF0ZS52aWV3cykgPyBzdGF0ZS52aWV3cyA6IHsgJyc6IHN0YXRlIH0sIGZ1bmN0aW9uICh2aWV3LCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignQCcpIDwgMCkgbmFtZSArPSAnQCcgKyBzdGF0ZS5wYXJlbnQubmFtZTtcclxuICAgICAgICB2aWV3c1tuYW1lXSA9IHZpZXc7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdmlld3M7XHJcbiAgICB9LFxyXG5cclxuICAgIG93blBhcmFtczogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgaWYgKCFzdGF0ZS5wYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gc3RhdGUucGFyYW1zO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBwYXJhbU5hbWVzID0ge307IGZvckVhY2goc3RhdGUucGFyYW1zLCBmdW5jdGlvbiAocCkgeyBwYXJhbU5hbWVzW3BdID0gdHJ1ZTsgfSk7XHJcblxyXG4gICAgICBmb3JFYWNoKHN0YXRlLnBhcmVudC5wYXJhbXMsIGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgaWYgKCFwYXJhbU5hbWVzW3BdKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAnXCIgKyBwICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlLm5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtTmFtZXNbcF0gPSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBvd25QYXJhbXMgPSBbXTtcclxuXHJcbiAgICAgIGZvckVhY2gocGFyYW1OYW1lcywgZnVuY3Rpb24gKG93biwgcCkge1xyXG4gICAgICAgIGlmIChvd24pIG93blBhcmFtcy5wdXNoKHApO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIG93blBhcmFtcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gS2VlcCBhIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZSBhcyB0aGlzIGlzIG5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cclxuICAgIHBhdGg6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQucGF0aC5jb25jYXQoc3RhdGUpIDogW107IC8vIGV4Y2x1ZGUgcm9vdCBmcm9tIHBhdGhcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU3BlZWQgdXAgJHN0YXRlLmNvbnRhaW5zKCkgYXMgaXQncyB1c2VkIGEgbG90XHJcbiAgICBpbmNsdWRlczogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgdmFyIGluY2x1ZGVzID0gc3RhdGUucGFyZW50ID8gZXh0ZW5kKHt9LCBzdGF0ZS5wYXJlbnQuaW5jbHVkZXMpIDoge307XHJcbiAgICAgIGluY2x1ZGVzW3N0YXRlLm5hbWVdID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGluY2x1ZGVzO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICBmdW5jdGlvbiBmaW5kU3RhdGUoc3RhdGVPck5hbWUsIGJhc2UpIHtcclxuICAgIHZhciBpc1N0ciA9IGlzU3RyaW5nKHN0YXRlT3JOYW1lKSxcclxuICAgICAgICBuYW1lICA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiBzdGF0ZU9yTmFtZS5uYW1lLFxyXG4gICAgICAgIHBhdGggID0gbmFtZS5pbmRleE9mKFwiLlwiKSA9PT0gMCB8fCBuYW1lLmluZGV4T2YoXCJeXCIpID09PSAwO1xyXG5cclxuICAgIGlmIChwYXRoKSB7XHJcbiAgICAgIGlmICghYmFzZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiAgKyBuYW1lICsgXCInXCIpO1xyXG4gICAgICB2YXIgcmVsID0gbmFtZS5zcGxpdChcIi5cIiksIGkgPSAwLCBwYXRoTGVuZ3RoID0gcmVsLmxlbmd0aCwgY3VycmVudCA9IGJhc2U7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZWxbaV0gPT09IFwiXCIgJiYgaSA9PT0gMCkge1xyXG4gICAgICAgICAgY3VycmVudCA9IGJhc2U7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbFtpXSA9PT0gXCJeXCIpIHtcclxuICAgICAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIlBhdGggJ1wiICsgbmFtZSArIFwiJyBub3QgdmFsaWQgZm9yIHN0YXRlICdcIiArIGJhc2UubmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICByZWwgPSByZWwuc2xpY2UoaSkuam9pbihcIi5cIik7XHJcbiAgICAgIG5hbWUgPSBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbCA/IFwiLlwiIDogXCJcIikgKyByZWw7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbbmFtZV07XHJcblxyXG4gICAgaWYgKHN0YXRlICYmIChpc1N0ciB8fCAoIWlzU3RyICYmIChzdGF0ZSA9PT0gc3RhdGVPck5hbWUgfHwgc3RhdGUuc2VsZiA9PT0gc3RhdGVPck5hbWUpKSkpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiByZWdpc3RlclN0YXRlKHN0YXRlKSB7XHJcbiAgICAvLyBXcmFwIGEgbmV3IG9iamVjdCBhcm91bmQgdGhlIHN0YXRlIHNvIHdlIGNhbiBzdG9yZSBvdXIgcHJpdmF0ZSBkZXRhaWxzIGVhc2lseS5cclxuICAgIHN0YXRlID0gaW5oZXJpdChzdGF0ZSwge1xyXG4gICAgICBzZWxmOiBzdGF0ZSxcclxuICAgICAgcmVzb2x2ZTogc3RhdGUucmVzb2x2ZSB8fCB7fSxcclxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWU7XHJcbiAgICBpZiAoIWlzU3RyaW5nKG5hbWUpIHx8IG5hbWUuaW5kZXhPZignQCcpID49IDApIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG11c3QgaGF2ZSBhIHZhbGlkIG5hbWVcIik7XHJcbiAgICBpZiAoc3RhdGVzW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSAnXCIgKyBuYW1lICsgXCInJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XHJcblxyXG4gICAgZm9yICh2YXIga2V5IGluIHN0YXRlQnVpbGRlcikge1xyXG4gICAgICBzdGF0ZVtrZXldID0gc3RhdGVCdWlsZGVyW2tleV0oc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGVzW25hbWVdID0gc3RhdGU7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHN0YXRlIGluIHRoZSBnbG9iYWwgc3RhdGUgbGlzdCBhbmQgd2l0aCAkdXJsUm91dGVyIGlmIG5lY2Vzc2FyeS5cclxuICAgIGlmICghc3RhdGVbJ2Fic3RyYWN0J10gJiYgc3RhdGUudXJsKSB7XHJcbiAgICAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKHN0YXRlLnVybCwgWyckbWF0Y2gnLCAnJHN0YXRlUGFyYW1zJywgZnVuY3Rpb24gKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUgIT0gc3RhdGUgfHwgIWVxdWFsRm9yS2V5cygkbWF0Y2gsICRzdGF0ZVBhcmFtcykpIHtcclxuICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEltcGxpY2l0IHJvb3Qgc3RhdGUgdGhhdCBpcyBhbHdheXMgYWN0aXZlXHJcbiAgcm9vdCA9IHJlZ2lzdGVyU3RhdGUoe1xyXG4gICAgbmFtZTogJycsXHJcbiAgICB1cmw6ICdeJyxcclxuICAgIHZpZXdzOiBudWxsLFxyXG4gICAgJ2Fic3RyYWN0JzogdHJ1ZVxyXG4gIH0pO1xyXG4gIHJvb3QubmF2aWdhYmxlID0gbnVsbDtcclxuXHJcblxyXG4gIC8vIC5zdGF0ZShzdGF0ZSlcclxuICAvLyAuc3RhdGUobmFtZSwgc3RhdGUpXHJcbiAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gIGZ1bmN0aW9uIHN0YXRlKG5hbWUsIGRlZmluaXRpb24pIHtcclxuICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgaWYgKGlzT2JqZWN0KG5hbWUpKSBkZWZpbml0aW9uID0gbmFtZTtcclxuICAgIGVsc2UgZGVmaW5pdGlvbi5uYW1lID0gbmFtZTtcclxuICAgIHJlZ2lzdGVyU3RhdGUoZGVmaW5pdGlvbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vICR1cmxSb3V0ZXIgaXMgaW5qZWN0ZWQganVzdCB0byBlbnN1cmUgaXQgZ2V0cyBpbnN0YW50aWF0ZWRcclxuICB0aGlzLiRnZXQgPSAkZ2V0O1xyXG4gICRnZXQuJGluamVjdCA9IFsnJHJvb3RTY29wZScsICckcScsICckdmlldycsICckaW5qZWN0b3InLCAnJHJlc29sdmUnLCAnJHN0YXRlUGFyYW1zJywgJyRsb2NhdGlvbicsICckdXJsUm91dGVyJ107XHJcbiAgZnVuY3Rpb24gJGdldCggICAkcm9vdFNjb3BlLCAgICRxLCAgICR2aWV3LCAgICRpbmplY3RvciwgICAkcmVzb2x2ZSwgICAkc3RhdGVQYXJhbXMsICAgJGxvY2F0aW9uLCAgICR1cmxSb3V0ZXIpIHtcclxuXHJcbiAgICB2YXIgVHJhbnNpdGlvblN1cGVyc2VkZWQgPSAkcS5yZWplY3QobmV3IEVycm9yKCd0cmFuc2l0aW9uIHN1cGVyc2VkZWQnKSk7XHJcbiAgICB2YXIgVHJhbnNpdGlvblByZXZlbnRlZCA9ICRxLnJlamVjdChuZXcgRXJyb3IoJ3RyYW5zaXRpb24gcHJldmVudGVkJykpO1xyXG5cclxuICAgIHJvb3QubG9jYWxzID0geyByZXNvbHZlOiBudWxsLCBnbG9iYWxzOiB7ICRzdGF0ZVBhcmFtczoge30gfSB9O1xyXG4gICAgJHN0YXRlID0ge1xyXG4gICAgICBwYXJhbXM6IHt9LFxyXG4gICAgICBjdXJyZW50OiByb290LnNlbGYsXHJcbiAgICAgICRjdXJyZW50OiByb290LFxyXG4gICAgICB0cmFuc2l0aW9uOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgICRzdGF0ZS5nbyA9IGZ1bmN0aW9uIGdvKHRvLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRvLCBwYXJhbXMsIGV4dGVuZCh7IGluaGVyaXQ6IHRydWUsIHJlbGF0aXZlOiAkc3RhdGUuJGN1cnJlbnQgfSwgb3B0aW9ucykpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc3RhdGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvKHRvLCB0b1BhcmFtcywgb3B0aW9ucykge1xyXG4gICAgICBpZiAoIWlzRGVmaW5lZChvcHRpb25zKSkgb3B0aW9ucyA9IChvcHRpb25zID09PSB0cnVlIHx8IG9wdGlvbnMgPT09IGZhbHNlKSA/IHsgbG9jYXRpb246IG9wdGlvbnMgfSA6IHt9O1xyXG4gICAgICB0b1BhcmFtcyA9IHRvUGFyYW1zIHx8IHt9O1xyXG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHsgbG9jYXRpb246IHRydWUsIGluaGVyaXQ6IGZhbHNlLCByZWxhdGl2ZTogbnVsbCB9LCBvcHRpb25zKTtcclxuXHJcbiAgICAgIHZhciB0b1N0YXRlID0gZmluZFN0YXRlKHRvLCBvcHRpb25zLnJlbGF0aXZlKTtcclxuICAgICAgaWYgKCFpc0RlZmluZWQodG9TdGF0ZSkpIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggc3RhdGUgXCIgKyB0b1N0YXRlKTtcclxuICAgICAgaWYgKHRvU3RhdGVbJ2Fic3RyYWN0J10pIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFuc2l0aW9uIHRvIGFic3RyYWN0IHN0YXRlICdcIiArIHRvICsgXCInXCIpO1xyXG4gICAgICBpZiAob3B0aW9ucy5pbmhlcml0KSB0b1BhcmFtcyA9IGluaGVyaXRQYXJhbXMoJHN0YXRlUGFyYW1zLCB0b1BhcmFtcyB8fCB7fSwgJHN0YXRlLiRjdXJyZW50LCB0b1N0YXRlKTtcclxuICAgICAgdG8gPSB0b1N0YXRlO1xyXG5cclxuICAgICAgdmFyIHRvUGF0aCA9IHRvLnBhdGgsXHJcbiAgICAgICAgICBmcm9tID0gJHN0YXRlLiRjdXJyZW50LCBmcm9tUGFyYW1zID0gJHN0YXRlLnBhcmFtcywgZnJvbVBhdGggPSBmcm9tLnBhdGg7XHJcblxyXG4gICAgICAvLyBTdGFydGluZyBmcm9tIHRoZSByb290IG9mIHRoZSBwYXRoLCBrZWVwIGFsbCBsZXZlbHMgdGhhdCBoYXZlbid0IGNoYW5nZWRcclxuICAgICAgdmFyIGtlZXAsIHN0YXRlLCBsb2NhbHMgPSByb290LmxvY2FscywgdG9Mb2NhbHMgPSBbXTtcclxuICAgICAgZm9yIChrZWVwID0gMCwgc3RhdGUgPSB0b1BhdGhba2VlcF07XHJcbiAgICAgICAgICAgc3RhdGUgJiYgc3RhdGUgPT09IGZyb21QYXRoW2tlZXBdICYmIGVxdWFsRm9yS2V5cyh0b1BhcmFtcywgZnJvbVBhcmFtcywgc3RhdGUub3duUGFyYW1zKTtcclxuICAgICAgICAgICBrZWVwKyssIHN0YXRlID0gdG9QYXRoW2tlZXBdKSB7XHJcbiAgICAgICAgbG9jYWxzID0gdG9Mb2NhbHNba2VlcF0gPSBzdGF0ZS5sb2NhbHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIHRvIHRoZSBzYW1lIHN0YXRlIGFuZCBhbGwgbG9jYWxzIGFyZSBrZXB0LCB3ZSd2ZSBnb3Qgbm90aGluZyB0byBkby5cclxuICAgICAgLy8gQnV0IGNsZWFyICd0cmFuc2l0aW9uJywgYXMgd2Ugc3RpbGwgd2FudCB0byBjYW5jZWwgYW55IG90aGVyIHBlbmRpbmcgdHJhbnNpdGlvbnMuXHJcbiAgICAgIC8vIFRPRE86IFdlIG1heSBub3Qgd2FudCB0byBidW1wICd0cmFuc2l0aW9uJyBpZiB3ZSdyZSBjYWxsZWQgZnJvbSBhIGxvY2F0aW9uIGNoYW5nZSB0aGF0IHdlJ3ZlIGluaXRpYXRlZCBvdXJzZWx2ZXMsXHJcbiAgICAgIC8vIGJlY2F1c2Ugd2UgbWlnaHQgYWNjaWRlbnRhbGx5IGFib3J0IGEgbGVnaXRpbWF0ZSB0cmFuc2l0aW9uIGluaXRpYXRlZCBmcm9tIGNvZGU/XHJcbiAgICAgIGlmICh0byA9PT0gZnJvbSAmJiBsb2NhbHMgPT09IGZyb20ubG9jYWxzKSB7XHJcbiAgICAgICAgJHN0YXRlLnRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiAkcS53aGVuKCRzdGF0ZS5jdXJyZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm9ybWFsaXplL2ZpbHRlciBwYXJhbWV0ZXJzIGJlZm9yZSB3ZSBwYXNzIHRoZW0gdG8gZXZlbnQgaGFuZGxlcnMgZXRjLlxyXG4gICAgICB0b1BhcmFtcyA9IG5vcm1hbGl6ZSh0by5wYXJhbXMsIHRvUGFyYW1zIHx8IHt9KTtcclxuXHJcbiAgICAgIC8vIEJyb2FkY2FzdCBzdGFydCBldmVudCBhbmQgY2FuY2VsIHRoZSB0cmFuc2l0aW9uIGlmIHJlcXVlc3RlZFxyXG4gICAgICB2YXIgZXZ0ID0gJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VTdGFydCcsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMpO1xyXG4gICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybiBUcmFuc2l0aW9uUHJldmVudGVkO1xyXG5cclxuICAgICAgLy8gUmVzb2x2ZSBsb2NhbHMgZm9yIHRoZSByZW1haW5pbmcgc3RhdGVzLCBidXQgZG9uJ3QgdXBkYXRlIGFueSBnbG9iYWwgc3RhdGUganVzdFxyXG4gICAgICAvLyB5ZXQgLS0gaWYgYW55dGhpbmcgZmFpbHMgdG8gcmVzb2x2ZSB0aGUgY3VycmVudCBzdGF0ZSBuZWVkcyB0byByZW1haW4gdW50b3VjaGVkLlxyXG4gICAgICAvLyBXZSBhbHNvIHNldCB1cCBhbiBpbmhlcml0YW5jZSBjaGFpbiBmb3IgdGhlIGxvY2FscyBoZXJlLiBUaGlzIGFsbG93cyB0aGUgdmlldyBkaXJlY3RpdmVcclxuICAgICAgLy8gdG8gcXVpY2tseSBsb29rIHVwIHRoZSBjb3JyZWN0IGRlZmluaXRpb24gZm9yIGVhY2ggdmlldyBpbiB0aGUgY3VycmVudCBzdGF0ZS4gRXZlblxyXG4gICAgICAvLyB0aG91Z2ggd2UgY3JlYXRlIHRoZSBsb2NhbHMgb2JqZWN0IGl0c2VsZiBvdXRzaWRlIHJlc29sdmVTdGF0ZSgpLCBpdCBpcyBpbml0aWFsbHlcclxuICAgICAgLy8gZW1wdHkgYW5kIGdldHMgZmlsbGVkIGFzeW5jaHJvbm91c2x5LiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHByb21pc2UgZm9yIHRoZVxyXG4gICAgICAvLyAoZnVsbHkgcmVzb2x2ZWQpIGN1cnJlbnQgbG9jYWxzLCBhbmQgcGFzcyB0aGlzIGRvd24gdGhlIGNoYWluLlxyXG4gICAgICB2YXIgcmVzb2x2ZWQgPSAkcS53aGVuKGxvY2Fscyk7XHJcbiAgICAgIGZvciAodmFyIGw9a2VlcDsgbDx0b1BhdGgubGVuZ3RoOyBsKyssIHN0YXRlPXRvUGF0aFtsXSkge1xyXG4gICAgICAgIGxvY2FscyA9IHRvTG9jYWxzW2xdID0gaW5oZXJpdChsb2NhbHMpO1xyXG4gICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZVN0YXRlKHN0YXRlLCB0b1BhcmFtcywgc3RhdGU9PT10bywgcmVzb2x2ZWQsIGxvY2Fscyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9uY2UgZXZlcnl0aGluZyBpcyByZXNvbHZlZCwgd2VyIGFyZSByZWFkeSB0byBwZXJmb3JtIHRoZSBhY3R1YWwgdHJhbnNpdGlvblxyXG4gICAgICAvLyBhbmQgcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIG5ldyBzdGF0ZS4gV2UgYWxzbyBrZWVwIHRyYWNrIG9mIHdoYXQgdGhlXHJcbiAgICAgIC8vIGN1cnJlbnQgcHJvbWlzZSBpcywgc28gdGhhdCB3ZSBjYW4gZGV0ZWN0IG92ZXJsYXBwaW5nIHRyYW5zaXRpb25zIGFuZFxyXG4gICAgICAvLyBrZWVwIG9ubHkgdGhlIG91dGNvbWUgb2YgdGhlIGxhc3QgdHJhbnNpdGlvbi5cclxuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkc3RhdGUudHJhbnNpdGlvbiA9IHJlc29sdmVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsLCBlbnRlcmluZywgZXhpdGluZztcclxuXHJcbiAgICAgICAgaWYgKCRzdGF0ZS50cmFuc2l0aW9uICE9PSB0cmFuc2l0aW9uKSByZXR1cm4gVHJhbnNpdGlvblN1cGVyc2VkZWQ7XHJcblxyXG4gICAgICAgIC8vIEV4aXQgJ2Zyb20nIHN0YXRlcyBub3Qga2VwdFxyXG4gICAgICAgIGZvciAobD1mcm9tUGF0aC5sZW5ndGgtMTsgbD49a2VlcDsgbC0tKSB7XHJcbiAgICAgICAgICBleGl0aW5nID0gZnJvbVBhdGhbbF07XHJcbiAgICAgICAgICBpZiAoZXhpdGluZy5zZWxmLm9uRXhpdCkge1xyXG4gICAgICAgICAgICAkaW5qZWN0b3IuaW52b2tlKGV4aXRpbmcuc2VsZi5vbkV4aXQsIGV4aXRpbmcuc2VsZiwgZXhpdGluZy5sb2NhbHMuZ2xvYmFscyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBleGl0aW5nLmxvY2FscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbnRlciAndG8nIHN0YXRlcyBub3Qga2VwdFxyXG4gICAgICAgIGZvciAobD1rZWVwOyBsPHRvUGF0aC5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgZW50ZXJpbmcgPSB0b1BhdGhbbF07XHJcbiAgICAgICAgICBlbnRlcmluZy5sb2NhbHMgPSB0b0xvY2Fsc1tsXTtcclxuICAgICAgICAgIGlmIChlbnRlcmluZy5zZWxmLm9uRW50ZXIpIHtcclxuICAgICAgICAgICAgJGluamVjdG9yLmludm9rZShlbnRlcmluZy5zZWxmLm9uRW50ZXIsIGVudGVyaW5nLnNlbGYsIGVudGVyaW5nLmxvY2Fscy5nbG9iYWxzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWxzIGluICRzdGF0ZVxyXG4gICAgICAgICRzdGF0ZS4kY3VycmVudCA9IHRvO1xyXG4gICAgICAgICRzdGF0ZS5jdXJyZW50ID0gdG8uc2VsZjtcclxuICAgICAgICAkc3RhdGUucGFyYW1zID0gdG9QYXJhbXM7XHJcbiAgICAgICAgY29weSgkc3RhdGUucGFyYW1zLCAkc3RhdGVQYXJhbXMpO1xyXG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlICRsb2NhdGlvblxyXG4gICAgICAgIHZhciB0b05hdiA9IHRvLm5hdmlnYWJsZTtcclxuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbiAmJiB0b05hdikge1xyXG4gICAgICAgICAgJGxvY2F0aW9uLnVybCh0b05hdi51cmwuZm9ybWF0KHRvTmF2LmxvY2Fscy5nbG9iYWxzLiRzdGF0ZVBhcmFtcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcyk7XHJcblxyXG4gICAgICAgIHJldHVybiAkc3RhdGUuY3VycmVudDtcclxuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKCRzdGF0ZS50cmFuc2l0aW9uICE9PSB0cmFuc2l0aW9uKSByZXR1cm4gVHJhbnNpdGlvblN1cGVyc2VkZWQ7XHJcblxyXG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcclxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRzdGF0ZUNoYW5nZUVycm9yJywgdG8uc2VsZiwgdG9QYXJhbXMsIGZyb20uc2VsZiwgZnJvbVBhcmFtcywgZXJyb3IpO1xyXG5cclxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdHJhbnNpdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgJHN0YXRlLmlzID0gZnVuY3Rpb24gaXMoc3RhdGVPck5hbWUpIHtcclxuICAgICAgdmFyIHN0YXRlID0gZmluZFN0YXRlKHN0YXRlT3JOYW1lKTtcclxuICAgICAgcmV0dXJuIChpc0RlZmluZWQoc3RhdGUpKSA/ICRzdGF0ZS4kY3VycmVudCA9PT0gc3RhdGUgOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgICRzdGF0ZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHN0YXRlT3JOYW1lKSB7XHJcbiAgICAgIHZhciBzdGF0ZSA9IGZpbmRTdGF0ZShzdGF0ZU9yTmFtZSk7XHJcbiAgICAgIHJldHVybiAoaXNEZWZpbmVkKHN0YXRlKSkgPyBpc0RlZmluZWQoJHN0YXRlLiRjdXJyZW50LmluY2x1ZGVzW3N0YXRlLm5hbWVdKSA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgJHN0YXRlLmhyZWYgPSBmdW5jdGlvbiBocmVmKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7IGxvc3N5OiB0cnVlLCBpbmhlcml0OiBmYWxzZSwgcmVsYXRpdmU6ICRzdGF0ZS4kY3VycmVudCB9LCBvcHRpb25zIHx8IHt9KTtcclxuICAgICAgdmFyIHN0YXRlID0gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBvcHRpb25zLnJlbGF0aXZlKTtcclxuICAgICAgaWYgKCFpc0RlZmluZWQoc3RhdGUpKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgIHBhcmFtcyA9IGluaGVyaXRQYXJhbXMoJHN0YXRlUGFyYW1zLCBwYXJhbXMgfHwge30sICRzdGF0ZS4kY3VycmVudCwgc3RhdGUpO1xyXG4gICAgICB2YXIgbmF2ID0gKHN0YXRlICYmIG9wdGlvbnMubG9zc3kpID8gc3RhdGUubmF2aWdhYmxlIDogc3RhdGU7XHJcbiAgICAgIHZhciB1cmwgPSAobmF2ICYmIG5hdi51cmwpID8gbmF2LnVybC5mb3JtYXQobm9ybWFsaXplKHN0YXRlLnBhcmFtcywgcGFyYW1zIHx8IHt9KSkgOiBudWxsO1xyXG4gICAgICByZXR1cm4gISRsb2NhdGlvblByb3ZpZGVyLmh0bWw1TW9kZSgpICYmIHVybCA/IFwiI1wiICsgdXJsIDogdXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lKSB7XHJcbiAgICAgIHZhciBzdGF0ZSA9IGZpbmRTdGF0ZShzdGF0ZU9yTmFtZSk7XHJcbiAgICAgIHJldHVybiAoc3RhdGUgJiYgc3RhdGUuc2VsZikgPyBzdGF0ZS5zZWxmIDogbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVN0YXRlKHN0YXRlLCBwYXJhbXMsIHBhcmFtc0FyZUZpbHRlcmVkLCBpbmhlcml0ZWQsIGRzdCkge1xyXG4gICAgICAvLyBNYWtlIGEgcmVzdHJpY3RlZCAkc3RhdGVQYXJhbXMgd2l0aCBvbmx5IHRoZSBwYXJhbWV0ZXJzIHRoYXQgYXBwbHkgdG8gdGhpcyBzdGF0ZSBpZlxyXG4gICAgICAvLyBuZWNlc3NhcnkuIEluIGFkZGl0aW9uIHRvIGJlaW5nIGF2YWlsYWJsZSB0byB0aGUgY29udHJvbGxlciBhbmQgb25FbnRlci9vbkV4aXQgY2FsbGJhY2tzLFxyXG4gICAgICAvLyB3ZSBhbHNvIG5lZWQgJHN0YXRlUGFyYW1zIHRvIGJlIGF2YWlsYWJsZSBmb3IgYW55ICRpbmplY3RvciBjYWxscyB3ZSBtYWtlIGR1cmluZyB0aGVcclxuICAgICAgLy8gZGVwZW5kZW5jeSByZXNvbHV0aW9uIHByb2Nlc3MuXHJcbiAgICAgIHZhciAkc3RhdGVQYXJhbXMgPSAocGFyYW1zQXJlRmlsdGVyZWQpID8gcGFyYW1zIDogZmlsdGVyQnlLZXlzKHN0YXRlLnBhcmFtcywgcGFyYW1zKTtcclxuICAgICAgdmFyIGxvY2FscyA9IHsgJHN0YXRlUGFyYW1zOiAkc3RhdGVQYXJhbXMgfTtcclxuXHJcbiAgICAgIC8vIFJlc29sdmUgJ2dsb2JhbCcgZGVwZW5kZW5jaWVzIGZvciB0aGUgc3RhdGUsIGkuZS4gdGhvc2Ugbm90IHNwZWNpZmljIHRvIGEgdmlldy5cclxuICAgICAgLy8gV2UncmUgYWxzbyBpbmNsdWRpbmcgJHN0YXRlUGFyYW1zIGluIHRoaXM7IHRoYXQgd2F5IHRoZSBwYXJhbWV0ZXJzIGFyZSByZXN0cmljdGVkXHJcbiAgICAgIC8vIHRvIHRoZSBzZXQgdGhhdCBzaG91bGQgYmUgdmlzaWJsZSB0byB0aGUgc3RhdGUsIGFuZCBhcmUgaW5kZXBlbmRlbnQgb2Ygd2hlbiB3ZSB1cGRhdGVcclxuICAgICAgLy8gdGhlIGdsb2JhbCAkc3RhdGUgYW5kICRzdGF0ZVBhcmFtcyB2YWx1ZXMuXHJcbiAgICAgIGRzdC5yZXNvbHZlID0gJHJlc29sdmUucmVzb2x2ZShzdGF0ZS5yZXNvbHZlLCBsb2NhbHMsIGRzdC5yZXNvbHZlLCBzdGF0ZSk7XHJcbiAgICAgIHZhciBwcm9taXNlcyA9IFsgZHN0LnJlc29sdmUudGhlbihmdW5jdGlvbiAoZ2xvYmFscykge1xyXG4gICAgICAgIGRzdC5nbG9iYWxzID0gZ2xvYmFscztcclxuICAgICAgfSkgXTtcclxuICAgICAgaWYgKGluaGVyaXRlZCkgcHJvbWlzZXMucHVzaChpbmhlcml0ZWQpO1xyXG5cclxuICAgICAgLy8gUmVzb2x2ZSB0ZW1wbGF0ZSBhbmQgZGVwZW5kZW5jaWVzIGZvciBhbGwgdmlld3MuXHJcbiAgICAgIGZvckVhY2goc3RhdGUudmlld3MsIGZ1bmN0aW9uICh2aWV3LCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIGluamVjdGFibGVzID0gKHZpZXcucmVzb2x2ZSAmJiB2aWV3LnJlc29sdmUgIT09IHN0YXRlLnJlc29sdmUgPyB2aWV3LnJlc29sdmUgOiB7fSk7XHJcbiAgICAgICAgaW5qZWN0YWJsZXMuJHRlbXBsYXRlID0gWyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gJHZpZXcubG9hZChuYW1lLCB7IHZpZXc6IHZpZXcsIGxvY2FsczogbG9jYWxzLCBwYXJhbXM6ICRzdGF0ZVBhcmFtcywgbm90aWZ5OiBmYWxzZSB9KSB8fCAnJztcclxuICAgICAgICB9XTtcclxuXHJcbiAgICAgICAgcHJvbWlzZXMucHVzaCgkcmVzb2x2ZS5yZXNvbHZlKGluamVjdGFibGVzLCBsb2NhbHMsIGRzdC5yZXNvbHZlLCBzdGF0ZSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAvLyBSZWZlcmVuY2VzIHRvIHRoZSBjb250cm9sbGVyIChvbmx5IGluc3RhbnRpYXRlZCBhdCBsaW5rIHRpbWUpXHJcbiAgICAgICAgICByZXN1bHQuJCRjb250cm9sbGVyID0gdmlldy5jb250cm9sbGVyO1xyXG4gICAgICAgICAgLy8gUHJvdmlkZSBhY2Nlc3MgdG8gdGhlIHN0YXRlIGl0c2VsZiBmb3IgaW50ZXJuYWwgdXNlXHJcbiAgICAgICAgICByZXN1bHQuJCRzdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgZHN0W25hbWVdID0gcmVzdWx0O1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciBhbGwgdGhlIHByb21pc2VzIGFuZCB0aGVuIHJldHVybiB0aGUgYWN0aXZhdGlvbiBvYmplY3RcclxuICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICRzdGF0ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShrZXlzLCB2YWx1ZXMpIHtcclxuICAgIHZhciBub3JtYWxpemVkID0ge307XHJcblxyXG4gICAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbbmFtZV07XHJcbiAgICAgIG5vcm1hbGl6ZWRbbmFtZV0gPSAodmFsdWUgIT0gbnVsbCkgPyBTdHJpbmcodmFsdWUpIDogbnVsbDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlcXVhbEZvcktleXMoYSwgYiwga2V5cykge1xyXG4gICAgLy8gSWYga2V5cyBub3QgcHJvdmlkZWQsIGFzc3VtZSBrZXlzIGZyb20gb2JqZWN0ICdhJ1xyXG4gICAgaWYgKCFrZXlzKSB7XHJcbiAgICAgIGtleXMgPSBbXTtcclxuICAgICAgZm9yICh2YXIgbiBpbiBhKSBrZXlzLnB1c2gobik7IC8vIFVzZWQgaW5zdGVhZCBvZiBPYmplY3Qua2V5cygpIGZvciBJRTggY29tcGF0aWJpbGl0eVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBrID0ga2V5c1tpXTtcclxuICAgICAgaWYgKGFba10gIT0gYltrXSkgcmV0dXJuIGZhbHNlOyAvLyBOb3QgJz09PScsIHZhbHVlcyBhcmVuJ3QgbmVjZXNzYXJpbHkgbm9ybWFsaXplZFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaWx0ZXJCeUtleXMoa2V5cywgdmFsdWVzKSB7XHJcbiAgICB2YXIgZmlsdGVyZWQgPSB7fTtcclxuXHJcbiAgICBmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIGZpbHRlcmVkW25hbWVdID0gdmFsdWVzW25hbWVdO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgfVxyXG59XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcclxuICAudmFsdWUoJyRzdGF0ZVBhcmFtcycsIHt9KVxyXG4gIC5wcm92aWRlcignJHN0YXRlJywgJFN0YXRlUHJvdmlkZXIpO1xyXG5cclxuXHJcbiRWaWV3UHJvdmlkZXIuJGluamVjdCA9IFtdO1xyXG5mdW5jdGlvbiAkVmlld1Byb3ZpZGVyKCkge1xyXG5cclxuICB0aGlzLiRnZXQgPSAkZ2V0O1xyXG4gICRnZXQuJGluamVjdCA9IFsnJHJvb3RTY29wZScsICckdGVtcGxhdGVGYWN0b3J5J107XHJcbiAgZnVuY3Rpb24gJGdldCggICAkcm9vdFNjb3BlLCAgICR0ZW1wbGF0ZUZhY3RvcnkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vICR2aWV3LmxvYWQoJ2Z1bGwudmlld05hbWUnLCB7IHRlbXBsYXRlOiAuLi4sIGNvbnRyb2xsZXI6IC4uLiwgcmVzb2x2ZTogLi4uLCBhc3luYzogZmFsc2UsIHBhcmFtczogLi4uIH0pXHJcbiAgICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQobmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciByZXN1bHQsIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgdGVtcGxhdGU6IG51bGwsIGNvbnRyb2xsZXI6IG51bGwsIHZpZXc6IG51bGwsIGxvY2FsczogbnVsbCwgbm90aWZ5OiB0cnVlLCBhc3luYzogdHJ1ZSwgcGFyYW1zOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXcpIHtcclxuICAgICAgICAgIHJlc3VsdCA9ICR0ZW1wbGF0ZUZhY3RvcnkuZnJvbUNvbmZpZyhvcHRpb25zLnZpZXcsIG9wdGlvbnMucGFyYW1zLCBvcHRpb25zLmxvY2Fscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQgJiYgb3B0aW9ucy5ub3RpZnkpIHtcclxuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHZpZXdDb250ZW50TG9hZGluZycsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckdmlldycsICRWaWV3UHJvdmlkZXIpO1xyXG5cclxuXHJcbiRWaWV3RGlyZWN0aXZlLiRpbmplY3QgPSBbJyRzdGF0ZScsICckY29tcGlsZScsICckY29udHJvbGxlcicsICckaW5qZWN0b3InLCAnJGFuY2hvclNjcm9sbCddO1xyXG5mdW5jdGlvbiAkVmlld0RpcmVjdGl2ZSggICAkc3RhdGUsICAgJGNvbXBpbGUsICAgJGNvbnRyb2xsZXIsICAgJGluamVjdG9yLCAgICRhbmNob3JTY3JvbGwpIHtcclxuICAvLyBUT0RPOiBDaGFuZ2UgdG8gJGluamVjdG9yLmhhcygpIHdoZW4gd2UgdmVyc2lvbiBidW1wIHRvIEFuZ3VsYXIgMS4xLjUuXHJcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvbWFzdGVyL0NIQU5HRUxPRy5tZCMxMTUtdHJpYW5nbGUtc3F1YXJpZmljYXRpb24tMjAxMy0wNS0yMlxyXG4gIHZhciAkYW5pbWF0b3I7IHRyeSB7ICRhbmltYXRvciA9ICRpbmplY3Rvci5nZXQoJyRhbmltYXRvcicpOyB9IGNhdGNoIChlKSB7IC8qIGRvIG5vdGhpbmcgKi8gfVxyXG4gIHZhciB2aWV3SXNVcGRhdGluZyA9IGZhbHNlO1xyXG5cclxuICB2YXIgZGlyZWN0aXZlID0ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQ0EnLFxyXG4gICAgdGVybWluYWw6IHRydWUsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHIsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgdmFyIHZpZXdTY29wZSwgdmlld0xvY2FscyxcclxuICAgICAgICAgICAgbmFtZSA9IGF0dHJbZGlyZWN0aXZlLm5hbWVdIHx8IGF0dHIubmFtZSB8fCAnJyxcclxuICAgICAgICAgICAgb25sb2FkRXhwID0gYXR0ci5vbmxvYWQgfHwgJycsXHJcbiAgICAgICAgICAgIGFuaW1hdGUgPSBpc0RlZmluZWQoJGFuaW1hdG9yKSAmJiAkYW5pbWF0b3Ioc2NvcGUsIGF0dHIpO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIGEgc2V0IG9mIERPTSBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIGJhc2VkIG9uIHdoZXRoZXIgYW5pbWF0aW9uXHJcbiAgICAgICAgLy8gc2hvdWxkIGJlIHBlcmZvcm1lZFxyXG4gICAgICAgIHZhciByZW5kZXJlciA9IGZ1bmN0aW9uKGRvQW5pbWF0ZSkge1xyXG4gICAgICAgICAgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIFwidHJ1ZVwiOiB7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihlbGVtZW50KSB7IGFuaW1hdGUubGVhdmUoZWxlbWVudC5jb250ZW50cygpLCBlbGVtZW50KTsgfSxcclxuICAgICAgICAgICAgICByZXN0b3JlOiBmdW5jdGlvbihjb21waWxlZCwgZWxlbWVudCkgeyBhbmltYXRlLmVudGVyKGNvbXBpbGVkLCBlbGVtZW50KTsgfSxcclxuICAgICAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24odGVtcGxhdGUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdj48L2Rpdj4nKS5odG1sKHRlbXBsYXRlKS5jb250ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZS5lbnRlcihjb250ZW50cywgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHM7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImZhbHNlXCI6IHtcclxuICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHsgZWxlbWVudC5odG1sKCcnKTsgfSxcclxuICAgICAgICAgICAgICByZXN0b3JlOiBmdW5jdGlvbihjb21waWxlZCwgZWxlbWVudCkgeyBlbGVtZW50LmFwcGVuZChjb21waWxlZCk7IH0sXHJcbiAgICAgICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKHRlbXBsYXRlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lmh0bWwodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY29udGVudHMoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pW2RvQW5pbWF0ZS50b1N0cmluZygpXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBQdXQgYmFjayB0aGUgY29tcGlsZWQgaW5pdGlhbCB2aWV3XHJcbiAgICAgICAgZWxlbWVudC5hcHBlbmQodHJhbnNjbHVkZShzY29wZSkpO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRoZSBkZXRhaWxzIG9mIHRoZSBwYXJlbnQgdmlldyBkaXJlY3RpdmUgKGlmIGFueSkgYW5kIHVzZSBpdFxyXG4gICAgICAgIC8vIHRvIGRlcml2ZSBvdXIgb3duIHF1YWxpZmllZCB2aWV3IG5hbWUsIHRoZW4gaGFuZyBvdXIgb3duIGRldGFpbHNcclxuICAgICAgICAvLyBvZmYgdGhlIERPTSBzbyBjaGlsZCBkaXJlY3RpdmVzIGNhbiBmaW5kIGl0LlxyXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCgpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcclxuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdAJykgPCAwKSBuYW1lICA9IG5hbWUgKyAnQCcgKyAocGFyZW50ID8gcGFyZW50LnN0YXRlLm5hbWUgOiAnJyk7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB7IG5hbWU6IG5hbWUsIHN0YXRlOiBudWxsIH07XHJcbiAgICAgICAgZWxlbWVudC5kYXRhKCckdWlWaWV3Jywgdmlldyk7XHJcblxyXG4gICAgICAgIHZhciBldmVudEhvb2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICh2aWV3SXNVcGRhdGluZykgcmV0dXJuO1xyXG4gICAgICAgICAgdmlld0lzVXBkYXRpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIHRyeSB7IHVwZGF0ZVZpZXcodHJ1ZSk7IH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmlld0lzVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZpZXdJc1VwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgZXZlbnRIb29rKTtcclxuICAgICAgICBzY29wZS4kb24oJyR2aWV3Q29udGVudExvYWRpbmcnLCBldmVudEhvb2spO1xyXG4gICAgICAgIHVwZGF0ZVZpZXcoZmFsc2UpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaWV3KGRvQW5pbWF0ZSkge1xyXG4gICAgICAgICAgdmFyIGxvY2FscyA9ICRzdGF0ZS4kY3VycmVudCAmJiAkc3RhdGUuJGN1cnJlbnQubG9jYWxzW25hbWVdO1xyXG4gICAgICAgICAgaWYgKGxvY2FscyA9PT0gdmlld0xvY2FscykgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICB2YXIgcmVuZGVyID0gcmVuZGVyZXIoYW5pbWF0ZSAmJiBkb0FuaW1hdGUpO1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBjb250ZW50XHJcbiAgICAgICAgICByZW5kZXIucmVtb3ZlKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIC8vIERlc3Ryb3kgcHJldmlvdXMgdmlldyBzY29wZVxyXG4gICAgICAgICAgaWYgKHZpZXdTY29wZSkge1xyXG4gICAgICAgICAgICB2aWV3U2NvcGUuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdmlld1Njb3BlID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWxvY2Fscykge1xyXG4gICAgICAgICAgICB2aWV3TG9jYWxzID0gbnVsbDtcclxuICAgICAgICAgICAgdmlldy5zdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBpbml0aWFsIHZpZXdcclxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlci5yZXN0b3JlKHRyYW5zY2x1ZGUoc2NvcGUpLCBlbGVtZW50KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2aWV3TG9jYWxzID0gbG9jYWxzO1xyXG4gICAgICAgICAgdmlldy5zdGF0ZSA9IGxvY2Fscy4kJHN0YXRlO1xyXG5cclxuICAgICAgICAgIHZhciBsaW5rID0gJGNvbXBpbGUocmVuZGVyLnBvcHVsYXRlKGxvY2Fscy4kdGVtcGxhdGUsIGVsZW1lbnQpKTtcclxuICAgICAgICAgIHZpZXdTY29wZSA9IHNjb3BlLiRuZXcoKTtcclxuXHJcbiAgICAgICAgICBpZiAobG9jYWxzLiQkY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICBsb2NhbHMuJHNjb3BlID0gdmlld1Njb3BlO1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9ICRjb250cm9sbGVyKGxvY2Fscy4kJGNvbnRyb2xsZXIsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4oKS5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGluayh2aWV3U2NvcGUpO1xyXG4gICAgICAgICAgdmlld1Njb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkZWQnKTtcclxuICAgICAgICAgIGlmIChvbmxvYWRFeHApIHZpZXdTY29wZS4kZXZhbChvbmxvYWRFeHApO1xyXG5cclxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgc2VlbXMgc3RyYW5nZSwgc2hvdWxkbid0ICRhbmNob3JTY3JvbGwgbGlzdGVuIGZvciAkdmlld0NvbnRlbnRMb2FkZWQgaWYgbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgLy8gJGFuY2hvclNjcm9sbCBtaWdodCBsaXN0ZW4gb24gZXZlbnQuLi5cclxuICAgICAgICAgICRhbmNob3JTY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gZGlyZWN0aXZlO1xyXG59XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZSk7XHJcblxyXG5mdW5jdGlvbiBwYXJzZVN0YXRlUmVmKHJlZikge1xyXG4gIHZhciBwYXJzZWQgPSByZWYubWF0Y2goL14oW14oXSs/KVxccyooXFwoKC4qKVxcKSk/JC8pO1xyXG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZC5sZW5ndGggIT09IDQpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgcmVmICdcIiArIHJlZiArIFwiJ1wiKTtcclxuICByZXR1cm4geyBzdGF0ZTogcGFyc2VkWzFdLCBwYXJhbUV4cHI6IHBhcnNlZFszXSB8fCBudWxsIH07XHJcbn1cclxuXHJcbiRTdGF0ZVJlZkRpcmVjdGl2ZS4kaW5qZWN0ID0gWyckc3RhdGUnXTtcclxuZnVuY3Rpb24gJFN0YXRlUmVmRGlyZWN0aXZlKCRzdGF0ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHZhciByZWYgPSBwYXJzZVN0YXRlUmVmKGF0dHJzLnVpU3JlZik7XHJcbiAgICAgIHZhciBwYXJhbXMgPSBudWxsLCB1cmwgPSBudWxsLCBiYXNlID0gJHN0YXRlLiRjdXJyZW50O1xyXG4gICAgICB2YXIgaXNGb3JtID0gZWxlbWVudFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XHJcbiAgICAgIHZhciBhdHRyID0gaXNGb3JtID8gXCJhY3Rpb25cIiA6IFwiaHJlZlwiLCBuYXYgPSB0cnVlO1xyXG5cclxuICAgICAgdmFyIHN0YXRlRGF0YSA9IGVsZW1lbnQucGFyZW50KCkuaW5oZXJpdGVkRGF0YSgnJHVpVmlldycpO1xyXG5cclxuICAgICAgaWYgKHN0YXRlRGF0YSAmJiBzdGF0ZURhdGEuc3RhdGUgJiYgc3RhdGVEYXRhLnN0YXRlLm5hbWUpIHtcclxuICAgICAgICBiYXNlID0gc3RhdGVEYXRhLnN0YXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24obmV3VmFsKSB7XHJcbiAgICAgICAgaWYgKG5ld1ZhbCkgcGFyYW1zID0gbmV3VmFsO1xyXG4gICAgICAgIGlmICghbmF2KSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBuZXdIcmVmID0gJHN0YXRlLmhyZWYocmVmLnN0YXRlLCBwYXJhbXMsIHsgcmVsYXRpdmU6IGJhc2UgfSk7XHJcblxyXG4gICAgICAgIGlmICghbmV3SHJlZikge1xyXG4gICAgICAgICAgbmF2ID0gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnRbMF1bYXR0cl0gPSBuZXdIcmVmO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKHJlZi5wYXJhbUV4cHIpIHtcclxuICAgICAgICBzY29wZS4kd2F0Y2gocmVmLnBhcmFtRXhwciwgZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcclxuICAgICAgICAgIGlmIChuZXdWYWwgIT09IG9sZFZhbCkgdXBkYXRlKG5ld1ZhbCk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgcGFyYW1zID0gc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcik7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlKCk7XHJcblxyXG4gICAgICBpZiAoaXNGb3JtKSByZXR1cm47XHJcblxyXG4gICAgICBlbGVtZW50LmJpbmQoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKChlLndoaWNoID09IDEpICYmICFlLmN0cmxLZXkgJiYgIWUubWV0YUtleSAmJiAhZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgJHN0YXRlLmdvKHJlZi5zdGF0ZSwgcGFyYW1zLCB7IHJlbGF0aXZlOiBiYXNlIH0pO1xyXG4gICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVNyZWYnLCAkU3RhdGVSZWZEaXJlY3RpdmUpO1xyXG5cclxuJFJvdXRlUHJvdmlkZXIuJGluamVjdCA9IFsnJHN0YXRlUHJvdmlkZXInLCAnJHVybFJvdXRlclByb3ZpZGVyJ107XHJcbmZ1bmN0aW9uICRSb3V0ZVByb3ZpZGVyKCAgJHN0YXRlUHJvdmlkZXIsICAgICR1cmxSb3V0ZXJQcm92aWRlcikge1xyXG5cclxuICB2YXIgcm91dGVzID0gW107XHJcblxyXG4gIG9uRW50ZXJSb3V0ZS4kaW5qZWN0ID0gWyckJHN0YXRlJ107XHJcbiAgZnVuY3Rpb24gb25FbnRlclJvdXRlKCAgICQkc3RhdGUpIHtcclxuICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgdGhpcy5sb2NhbHMgPSAkJHN0YXRlLmxvY2Fscy5nbG9iYWxzO1xyXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLmxvY2Fscy4kc3RhdGVQYXJhbXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvbkV4aXRSb3V0ZSgpIHtcclxuICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgdGhpcy5sb2NhbHMgPSBudWxsO1xyXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgdGhpcy53aGVuID0gd2hlbjtcclxuICBmdW5jdGlvbiB3aGVuKHVybCwgcm91dGUpIHtcclxuICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgaWYgKHJvdXRlLnJlZGlyZWN0VG8gIT0gbnVsbCkge1xyXG4gICAgICAvLyBSZWRpcmVjdCwgY29uZmlndXJlIGRpcmVjdGx5IG9uICR1cmxSb3V0ZXJQcm92aWRlclxyXG4gICAgICB2YXIgcmVkaXJlY3QgPSByb3V0ZS5yZWRpcmVjdFRvLCBoYW5kbGVyO1xyXG4gICAgICBpZiAoaXNTdHJpbmcocmVkaXJlY3QpKSB7XHJcbiAgICAgICAgaGFuZGxlciA9IHJlZGlyZWN0OyAvLyBsZWF2ZSAkdXJsUm91dGVyUHJvdmlkZXIgdG8gaGFuZGxlXHJcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyZWRpcmVjdCkpIHtcclxuICAgICAgICAvLyBBZGFwdCB0byAkdXJsUm91dGVyUHJvdmlkZXIgQVBJXHJcbiAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChwYXJhbXMsICRsb2NhdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIHJlZGlyZWN0KHBhcmFtcywgJGxvY2F0aW9uLnBhdGgoKSwgJGxvY2F0aW9uLnNlYXJjaCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgJ3JlZGlyZWN0VG8nIGluIHdoZW4oKVwiKTtcclxuICAgICAgfVxyXG4gICAgICAkdXJsUm91dGVyUHJvdmlkZXIud2hlbih1cmwsIGhhbmRsZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUmVndWxhciByb3V0ZSwgY29uZmlndXJlIGFzIHN0YXRlXHJcbiAgICAgICRzdGF0ZVByb3ZpZGVyLnN0YXRlKGluaGVyaXQocm91dGUsIHtcclxuICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgbmFtZTogJ3JvdXRlOicgKyBlbmNvZGVVUklDb21wb25lbnQodXJsKSxcclxuICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICBvbkVudGVyOiBvbkVudGVyUm91dGUsXHJcbiAgICAgICAgb25FeGl0OiBvbkV4aXRSb3V0ZVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHRoaXMuJGdldCA9ICRnZXQ7XHJcbiAgJGdldC4kaW5qZWN0ID0gWyckc3RhdGUnLCAnJHJvb3RTY29wZScsICckcm91dGVQYXJhbXMnXTtcclxuICBmdW5jdGlvbiAkZ2V0KCAgICRzdGF0ZSwgICAkcm9vdFNjb3BlLCAgICRyb3V0ZVBhcmFtcykge1xyXG5cclxuICAgIHZhciAkcm91dGUgPSB7XHJcbiAgICAgIHJvdXRlczogcm91dGVzLFxyXG4gICAgICBwYXJhbXM6ICRyb3V0ZVBhcmFtcyxcclxuICAgICAgY3VycmVudDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXRlQXNSb3V0ZShzdGF0ZSkge1xyXG4gICAgICByZXR1cm4gKHN0YXRlLm5hbWUgIT09ICcnKSA/IHN0YXRlIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdGFydCcsIGZ1bmN0aW9uIChldiwgdG8sIHRvUGFyYW1zLCBmcm9tLCBmcm9tUGFyYW1zKSB7XHJcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHJvdXRlQ2hhbmdlU3RhcnQnLCBzdGF0ZUFzUm91dGUodG8pLCBzdGF0ZUFzUm91dGUoZnJvbSkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbiAoZXYsIHRvLCB0b1BhcmFtcywgZnJvbSwgZnJvbVBhcmFtcykge1xyXG4gICAgICAkcm91dGUuY3VycmVudCA9IHN0YXRlQXNSb3V0ZSh0byk7XHJcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHJvdXRlQ2hhbmdlU3VjY2VzcycsIHN0YXRlQXNSb3V0ZSh0byksIHN0YXRlQXNSb3V0ZShmcm9tKSk7XHJcbiAgICAgIGNvcHkodG9QYXJhbXMsICRyb3V0ZS5wYXJhbXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJHJvb3RTY29wZS4kb24oJyRzdGF0ZUNoYW5nZUVycm9yJywgZnVuY3Rpb24gKGV2LCB0bywgdG9QYXJhbXMsIGZyb20sIGZyb21QYXJhbXMsIGVycm9yKSB7XHJcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHJvdXRlQ2hhbmdlRXJyb3InLCBzdGF0ZUFzUm91dGUodG8pLCBzdGF0ZUFzUm91dGUoZnJvbSksIGVycm9yKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAkcm91dGU7XHJcbiAgfVxyXG59XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLmNvbXBhdCcpXHJcbiAgLnByb3ZpZGVyKCckcm91dGUnLCAkUm91dGVQcm92aWRlcilcclxuICAuZGlyZWN0aXZlKCduZ1ZpZXcnLCAkVmlld0RpcmVjdGl2ZSk7XHJcbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpOyIsIi8qKlxyXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuMi4wLXJjLjJcclxuICogKGMpIDIwMTAtMjAxMiBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24od2luZG93LCBhbmd1bGFyLCB1bmRlZmluZWQpIHsndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQG5nZG9jIG92ZXJ2aWV3XHJcbiAqIEBuYW1lIG5nQ29va2llc1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogIyBuZ0Nvb2tpZXNcclxuICpcclxuICogUHJvdmlkZXMgdGhlIHtAbGluayBuZ0Nvb2tpZXMuJGNvb2tpZXMgYCRjb29raWVzYH0gYW5kXHJcbiAqIHtAbGluayBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlIGAkY29va2llU3RvcmVgfSBzZXJ2aWNlcy5cclxuICpcclxuICoge0BpbnN0YWxsTW9kdWxlIGNvb2tpZXN9XHJcbiAqXHJcbiAqIFNlZSB7QGxpbmsgbmdDb29raWVzLiRjb29raWVzIGAkY29va2llc2B9IGFuZFxyXG4gKiB7QGxpbmsgbmdDb29raWVzLiRjb29raWVTdG9yZSBgJGNvb2tpZVN0b3JlYH0gZm9yIHVzYWdlLlxyXG4gKi9cclxuXHJcblxyXG5hbmd1bGFyLm1vZHVsZSgnbmdDb29raWVzJywgWyduZyddKS5cclxuICAvKipcclxuICAgKiBAbmdkb2Mgb2JqZWN0XHJcbiAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVzXHJcbiAgICogQHJlcXVpcmVzICRicm93c2VyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBQcm92aWRlcyByZWFkL3dyaXRlIGFjY2VzcyB0byBicm93c2VyJ3MgY29va2llcy5cclxuICAgKlxyXG4gICAqIE9ubHkgYSBzaW1wbGUgT2JqZWN0IGlzIGV4cG9zZWQgYW5kIGJ5IGFkZGluZyBvciByZW1vdmluZyBwcm9wZXJ0aWVzIHRvL2Zyb21cclxuICAgKiB0aGlzIG9iamVjdCwgbmV3IGNvb2tpZXMgYXJlIGNyZWF0ZWQvZGVsZXRlZCBhdCB0aGUgZW5kIG9mIGN1cnJlbnQgJGV2YWwuXHJcbiAgICpcclxuICAgKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nQ29va2llcyBgbmdDb29raWVzYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEV4YW1wbGVDb250cm9sbGVyKCRjb29raWVzKSB7XHJcbiAgICAgICAgICAgLy8gUmV0cmlldmluZyBhIGNvb2tpZVxyXG4gICAgICAgICAgIHZhciBmYXZvcml0ZUNvb2tpZSA9ICRjb29raWVzLm15RmF2b3JpdGU7XHJcbiAgICAgICAgICAgLy8gU2V0dGluZyBhIGNvb2tpZVxyXG4gICAgICAgICAgICRjb29raWVzLm15RmF2b3JpdGUgPSAnb2F0bWVhbCc7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICAgKi9cclxuICAgZmFjdG9yeSgnJGNvb2tpZXMnLCBbJyRyb290U2NvcGUnLCAnJGJyb3dzZXInLCBmdW5jdGlvbiAoJHJvb3RTY29wZSwgJGJyb3dzZXIpIHtcclxuICAgICAgdmFyIGNvb2tpZXMgPSB7fSxcclxuICAgICAgICAgIGxhc3RDb29raWVzID0ge30sXHJcbiAgICAgICAgICBsYXN0QnJvd3NlckNvb2tpZXMsXHJcbiAgICAgICAgICBydW5FdmFsID0gZmFsc2UsXHJcbiAgICAgICAgICBjb3B5ID0gYW5ndWxhci5jb3B5LFxyXG4gICAgICAgICAgaXNVbmRlZmluZWQgPSBhbmd1bGFyLmlzVW5kZWZpbmVkO1xyXG5cclxuICAgICAgLy9jcmVhdGVzIGEgcG9sbGVyIGZuIHRoYXQgY29waWVzIGFsbCBjb29raWVzIGZyb20gdGhlICRicm93c2VyIHRvIHNlcnZpY2UgJiBpbml0cyB0aGUgc2VydmljZVxyXG4gICAgICAkYnJvd3Nlci5hZGRQb2xsRm4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRDb29raWVzID0gJGJyb3dzZXIuY29va2llcygpO1xyXG4gICAgICAgIGlmIChsYXN0QnJvd3NlckNvb2tpZXMgIT0gY3VycmVudENvb2tpZXMpIHsgLy9yZWxpZXMgb24gYnJvd3Nlci5jb29raWVzKCkgaW1wbFxyXG4gICAgICAgICAgbGFzdEJyb3dzZXJDb29raWVzID0gY3VycmVudENvb2tpZXM7XHJcbiAgICAgICAgICBjb3B5KGN1cnJlbnRDb29raWVzLCBsYXN0Q29va2llcyk7XHJcbiAgICAgICAgICBjb3B5KGN1cnJlbnRDb29raWVzLCBjb29raWVzKTtcclxuICAgICAgICAgIGlmIChydW5FdmFsKSAkcm9vdFNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkoKTtcclxuXHJcbiAgICAgIHJ1bkV2YWwgPSB0cnVlO1xyXG5cclxuICAgICAgLy9hdCB0aGUgZW5kIG9mIGVhY2ggZXZhbCwgcHVzaCBjb29raWVzXHJcbiAgICAgIC8vVE9ETzogdGhpcyBzaG91bGQgaGFwcGVuIGJlZm9yZSB0aGUgXCJkZWxheWVkXCIgd2F0Y2hlcyBmaXJlLCBiZWNhdXNlIGlmIHNvbWUgY29va2llcyBhcmUgbm90XHJcbiAgICAgIC8vICAgICAgc3RyaW5ncyBvciBicm93c2VyIHJlZnVzZXMgdG8gc3RvcmUgc29tZSBjb29raWVzLCB3ZSB1cGRhdGUgdGhlIG1vZGVsIGluIHRoZSBwdXNoIGZuLlxyXG4gICAgICAkcm9vdFNjb3BlLiR3YXRjaChwdXNoKTtcclxuXHJcbiAgICAgIHJldHVybiBjb29raWVzO1xyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQdXNoZXMgYWxsIHRoZSBjb29raWVzIGZyb20gdGhlIHNlcnZpY2UgdG8gdGhlIGJyb3dzZXIgYW5kIHZlcmlmaWVzIGlmIGFsbCBjb29raWVzIHdlcmUgc3RvcmVkLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gcHVzaCgpIHtcclxuICAgICAgICB2YXIgbmFtZSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIGJyb3dzZXJDb29raWVzLFxyXG4gICAgICAgICAgICB1cGRhdGVkO1xyXG5cclxuICAgICAgICAvL2RlbGV0ZSBhbnkgY29va2llcyBkZWxldGVkIGluICRjb29raWVzXHJcbiAgICAgICAgZm9yIChuYW1lIGluIGxhc3RDb29raWVzKSB7XHJcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY29va2llc1tuYW1lXSkpIHtcclxuICAgICAgICAgICAgJGJyb3dzZXIuY29va2llcyhuYW1lLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91cGRhdGUgYWxsIGNvb2tpZXMgdXBkYXRlZCBpbiAkY29va2llc1xyXG4gICAgICAgIGZvcihuYW1lIGluIGNvb2tpZXMpIHtcclxuICAgICAgICAgIHZhbHVlID0gY29va2llc1tuYW1lXTtcclxuICAgICAgICAgIGlmICghYW5ndWxhci5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGxhc3RDb29raWVzW25hbWVdKSkge1xyXG4gICAgICAgICAgICAgIGNvb2tpZXNbbmFtZV0gPSBsYXN0Q29va2llc1tuYW1lXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBkZWxldGUgY29va2llc1tuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbGFzdENvb2tpZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgJGJyb3dzZXIuY29va2llcyhuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy92ZXJpZnkgd2hhdCB3YXMgYWN0dWFsbHkgc3RvcmVkXHJcbiAgICAgICAgaWYgKHVwZGF0ZWQpe1xyXG4gICAgICAgICAgdXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgYnJvd3NlckNvb2tpZXMgPSAkYnJvd3Nlci5jb29raWVzKCk7XHJcblxyXG4gICAgICAgICAgZm9yIChuYW1lIGluIGNvb2tpZXMpIHtcclxuICAgICAgICAgICAgaWYgKGNvb2tpZXNbbmFtZV0gIT09IGJyb3dzZXJDb29raWVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgLy9kZWxldGUgb3IgcmVzZXQgYWxsIGNvb2tpZXMgdGhhdCB0aGUgYnJvd3NlciBkcm9wcGVkIGZyb20gJGNvb2tpZXNcclxuICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoYnJvd3NlckNvb2tpZXNbbmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgY29va2llc1tuYW1lXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29va2llc1tuYW1lXSA9IGJyb3dzZXJDb29raWVzW25hbWVdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfV0pLlxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG9iamVjdFxyXG4gICAqIEBuYW1lIG5nQ29va2llcy4kY29va2llU3RvcmVcclxuICAgKiBAcmVxdWlyZXMgJGNvb2tpZXNcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFByb3ZpZGVzIGEga2V5LXZhbHVlIChzdHJpbmctb2JqZWN0KSBzdG9yYWdlLCB0aGF0IGlzIGJhY2tlZCBieSBzZXNzaW9uIGNvb2tpZXMuXHJcbiAgICogT2JqZWN0cyBwdXQgb3IgcmV0cmlldmVkIGZyb20gdGhpcyBzdG9yYWdlIGFyZSBhdXRvbWF0aWNhbGx5IHNlcmlhbGl6ZWQgb3JcclxuICAgKiBkZXNlcmlhbGl6ZWQgYnkgYW5ndWxhcidzIHRvSnNvbi9mcm9tSnNvbi5cclxuICAgKlxyXG4gICAqIFJlcXVpcmVzIHRoZSB7QGxpbmsgbmdDb29raWVzIGBuZ0Nvb2tpZXNgfSBtb2R1bGUgdG8gYmUgaW5zdGFsbGVkLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKi9cclxuICAgZmFjdG9yeSgnJGNvb2tpZVN0b3JlJywgWyckY29va2llcycsIGZ1bmN0aW9uKCRjb29raWVzKSB7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgKiBAbmFtZSBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlI2dldFxyXG4gICAgICAgICAqIEBtZXRob2RPZiBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBnaXZlbiBjb29raWUga2V5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIHRvIHVzZSBmb3IgbG9va3VwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IERlc2VyaWFsaXplZCBjb29raWUgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9ICRjb29raWVzW2tleV07XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyBhbmd1bGFyLmZyb21Kc29uKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgKiBAbmFtZSBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlI3B1dFxyXG4gICAgICAgICAqIEBtZXRob2RPZiBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBTZXRzIGEgdmFsdWUgZm9yIGdpdmVuIGNvb2tpZSBrZXlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgSWQgZm9yIHRoZSBgdmFsdWVgLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBiZSBzdG9yZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHV0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAkY29va2llc1trZXldID0gYW5ndWxhci50b0pzb24odmFsdWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgKiBAbmFtZSBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlI3JlbW92ZVxyXG4gICAgICAgICAqIEBtZXRob2RPZiBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBSZW1vdmUgZ2l2ZW4gY29va2llXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIG9mIHRoZSBrZXktdmFsdWUgcGFpciB0byBkZWxldGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgIGRlbGV0ZSAkY29va2llc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICB9XSk7XHJcblxyXG5cclxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7IiwiLyoqXHJcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS4yLjAtcmMuMlxyXG4gKiAoYykgMjAxMC0yMDEyIEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xyXG4gKiBMaWNlbnNlOiBNSVRcclxuICovXHJcbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHsndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRoaXMgb2JqZWN0IHByb3ZpZGVzIGEgdXRpbGl0eSBmb3IgcHJvZHVjaW5nIHJpY2ggRXJyb3IgbWVzc2FnZXMgd2l0aGluXHJcbiAqIEFuZ3VsYXIuIEl0IGNhbiBiZSBjYWxsZWQgYXMgZm9sbG93czpcclxuICpcclxuICogdmFyIGV4YW1wbGVNaW5FcnIgPSBtaW5FcnIoJ2V4YW1wbGUnKTtcclxuICogdGhyb3cgZXhhbXBsZU1pbkVycignb25lJywgJ1RoaXMgezB9IGlzIHsxfScsIGZvbywgYmFyKTtcclxuICpcclxuICogVGhlIGFib3ZlIGNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgbWluRXJyIGluIHRoZSBleGFtcGxlIG5hbWVzcGFjZS4gVGhlXHJcbiAqIHJlc3VsdGluZyBlcnJvciB3aWxsIGhhdmUgYSBuYW1lc3BhY2VkIGVycm9yIGNvZGUgb2YgZXhhbXBsZS5vbmUuICBUaGVcclxuICogcmVzdWx0aW5nIGVycm9yIHdpbGwgcmVwbGFjZSB7MH0gd2l0aCB0aGUgdmFsdWUgb2YgZm9vLCBhbmQgezF9IHdpdGggdGhlXHJcbiAqIHZhbHVlIG9mIGJhci4gVGhlIG9iamVjdCBpcyBub3QgcmVzdHJpY3RlZCBpbiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpdCBjYW5cclxuICogdGFrZS5cclxuICpcclxuICogSWYgZmV3ZXIgYXJndW1lbnRzIGFyZSBzcGVjaWZpZWQgdGhhbiBuZWNlc3NhcnkgZm9yIGludGVycG9sYXRpb24sIHRoZSBleHRyYVxyXG4gKiBpbnRlcnBvbGF0aW9uIG1hcmtlcnMgd2lsbCBiZSBwcmVzZXJ2ZWQgaW4gdGhlIGZpbmFsIHN0cmluZy5cclxuICpcclxuICogU2luY2UgZGF0YSB3aWxsIGJlIHBhcnNlZCBzdGF0aWNhbGx5IGR1cmluZyBhIGJ1aWxkIHN0ZXAsIHNvbWUgcmVzdHJpY3Rpb25zXHJcbiAqIGFyZSBhcHBsaWVkIHdpdGggcmVzcGVjdCB0byBob3cgbWluRXJyIGluc3RhbmNlcyBhcmUgY3JlYXRlZCBhbmQgY2FsbGVkLlxyXG4gKiBJbnN0YW5jZXMgc2hvdWxkIGhhdmUgbmFtZXMgb2YgdGhlIGZvcm0gbmFtZXNwYWNlTWluRXJyIGZvciBhIG1pbkVyciBjcmVhdGVkXHJcbiAqIHVzaW5nIG1pbkVycignbmFtZXNwYWNlJykgLiBFcnJvciBjb2RlcywgbmFtZXNwYWNlcyBhbmQgdGVtcGxhdGUgc3RyaW5nc1xyXG4gKiBzaG91bGQgYWxsIGJlIHN0YXRpYyBzdHJpbmdzLCBub3QgdmFyaWFibGVzIG9yIGdlbmVyYWwgZXhwcmVzc2lvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGUgVGhlIG5hbWVzcGFjZSB0byB1c2UgZm9yIHRoZSBuZXcgbWluRXJyIGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcsIC4uLik6IEVycm9yfSBpbnN0YW5jZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1pbkVycihtb2R1bGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNvZGUgPSBhcmd1bWVudHNbMF0sXHJcbiAgICAgIHByZWZpeCA9ICdbJyArIChtb2R1bGUgPyBtb2R1bGUgKyAnOicgOiAnJykgKyBjb2RlICsgJ10gJyxcclxuICAgICAgdGVtcGxhdGUgPSBhcmd1bWVudHNbMV0sXHJcbiAgICAgIHRlbXBsYXRlQXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpIHtcclxuICAgICAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKS5yZXBsYWNlKC8gXFx7W1xcc1xcU10qJC8sICcnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzVW5kZWZpbmVkKG9iaikpIHtcclxuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmluZyhvYmopKSB7XHJcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSxcclxuICAgICAgbWVzc2FnZSwgaTtcclxuXHJcbiAgICBtZXNzYWdlID0gcHJlZml4ICsgdGVtcGxhdGUucmVwbGFjZSgvXFx7XFxkK1xcfS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgdmFyIGluZGV4ID0gK21hdGNoLnNsaWNlKDEsIC0xKSwgYXJnO1xyXG5cclxuICAgICAgaWYgKGluZGV4ICsgMiA8IHRlbXBsYXRlQXJncy5sZW5ndGgpIHtcclxuICAgICAgICBhcmcgPSB0ZW1wbGF0ZUFyZ3NbaW5kZXggKyAyXTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihhcmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gYXJnLnRvU3RyaW5nKCkucmVwbGFjZSgvID9cXHtbXFxzXFxTXSokLywgJycpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZmluZWQoYXJnKSkge1xyXG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKGFyZykpIHtcclxuICAgICAgICAgIHJldHVybiB0b0pzb24oYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9KTtcclxuXHJcbiAgICBtZXNzYWdlID0gbWVzc2FnZSArICdcXG5odHRwOi8vZXJyb3JzLmFuZ3VsYXJqcy5vcmcvJyArIHZlcnNpb24uZnVsbCArICcvJyArXHJcbiAgICAgIChtb2R1bGUgPyBtb2R1bGUgKyAnLycgOiAnJykgKyBjb2RlO1xyXG4gICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSArIChpID09IDIgPyAnPycgOiAnJicpICsgJ3AnICsgKGktMikgKyAnPScgK1xyXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICB9O1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBoYXNPd25Qcm9wZXJ0eSBtYXkgYmUgb3ZlcndyaXR0ZW4gYnkgYSBwcm9wZXJ0eSBvZiB0aGUgc2FtZSBuYW1lLCBvciBlbnRpcmVseVxyXG4gKiBhYnNlbnQgZnJvbSBhbiBvYmplY3QgdGhhdCBkb2VzIG5vdCBpbmhlcml0IE9iamVjdC5wcm90b3R5cGU7IHRoaXMgY29weSBpc1xyXG4gKiB1c2VkIGluc3RlYWRcclxuICovXHJcbnZhciBoYXNPd25Qcm9wZXJ0eUZuID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIGhhc093blByb3BlcnR5TG9jYWwgPSBmdW5jdGlvbihvYmosIGtleSkge1xyXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eUZuLmNhbGwob2JqLCBrZXkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmxvd2VyY2FzZVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgc3RyaW5nIHRvIGxvd2VyY2FzZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cclxuICogQHJldHVybnMge3N0cmluZ30gTG93ZXJjYXNlZCBzdHJpbmcuXHJcbiAqL1xyXG52YXIgbG93ZXJjYXNlID0gZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gaXNTdHJpbmcoc3RyaW5nKSA/IHN0cmluZy50b0xvd2VyQ2FzZSgpIDogc3RyaW5nO307XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLnVwcGVyY2FzZVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgc3RyaW5nIHRvIHVwcGVyY2FzZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIHVwcGVyY2FzZS5cclxuICogQHJldHVybnMge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmcuXHJcbiAqL1xyXG52YXIgdXBwZXJjYXNlID0gZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gaXNTdHJpbmcoc3RyaW5nKSA/IHN0cmluZy50b1VwcGVyQ2FzZSgpIDogc3RyaW5nO307XHJcblxyXG5cclxudmFyIG1hbnVhbExvd2VyY2FzZSA9IGZ1bmN0aW9uKHMpIHtcclxuICByZXR1cm4gaXNTdHJpbmcocylcclxuICAgICAgPyBzLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uKGNoKSB7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2guY2hhckNvZGVBdCgwKSB8IDMyKTt9KVxyXG4gICAgICA6IHM7XHJcbn07XHJcbnZhciBtYW51YWxVcHBlcmNhc2UgPSBmdW5jdGlvbihzKSB7XHJcbiAgcmV0dXJuIGlzU3RyaW5nKHMpXHJcbiAgICAgID8gcy5yZXBsYWNlKC9bYS16XS9nLCBmdW5jdGlvbihjaCkge3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoLmNoYXJDb2RlQXQoMCkgJiB+MzIpO30pXHJcbiAgICAgIDogcztcclxufTtcclxuXHJcblxyXG4vLyBTdHJpbmcjdG9Mb3dlckNhc2UgYW5kIFN0cmluZyN0b1VwcGVyQ2FzZSBkb24ndCBwcm9kdWNlIGNvcnJlY3QgcmVzdWx0cyBpbiBicm93c2VycyB3aXRoIFR1cmtpc2hcclxuLy8gbG9jYWxlLCBmb3IgdGhpcyByZWFzb24gd2UgbmVlZCB0byBkZXRlY3QgdGhpcyBjYXNlIGFuZCByZWRlZmluZSBsb3dlcmNhc2UvdXBwZXJjYXNlIG1ldGhvZHNcclxuLy8gd2l0aCBjb3JyZWN0IGJ1dCBzbG93ZXIgYWx0ZXJuYXRpdmVzLlxyXG5pZiAoJ2knICE9PSAnSScudG9Mb3dlckNhc2UoKSkge1xyXG4gIGxvd2VyY2FzZSA9IG1hbnVhbExvd2VyY2FzZTtcclxuICB1cHBlcmNhc2UgPSBtYW51YWxVcHBlcmNhc2U7XHJcbn1cclxuXHJcblxyXG52YXIgLyoqIGhvbGRzIG1ham9yIHZlcnNpb24gbnVtYmVyIGZvciBJRSBvciBOYU4gZm9yIHJlYWwgYnJvd3NlcnMgKi9cclxuICAgIG1zaWUsXHJcbiAgICBqcUxpdGUsICAgICAgICAgICAvLyBkZWxheSBiaW5kaW5nIHNpbmNlIGpRdWVyeSBjb3VsZCBiZSBsb2FkZWQgYWZ0ZXIgdXMuXHJcbiAgICBqUXVlcnksICAgICAgICAgICAvLyBkZWxheSBiaW5kaW5nXHJcbiAgICBzbGljZSAgICAgICAgICAgICA9IFtdLnNsaWNlLFxyXG4gICAgcHVzaCAgICAgICAgICAgICAgPSBbXS5wdXNoLFxyXG4gICAgdG9TdHJpbmcgICAgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxyXG4gICAgbmdNaW5FcnIgICAgICAgICAgPSBtaW5FcnIoJ25nJyksXHJcblxyXG5cclxuICAgIF9hbmd1bGFyICAgICAgICAgID0gd2luZG93LmFuZ3VsYXIsXHJcbiAgICAvKiogQG5hbWUgYW5ndWxhciAqL1xyXG4gICAgYW5ndWxhciAgICAgICAgICAgPSB3aW5kb3cuYW5ndWxhciB8fCAod2luZG93LmFuZ3VsYXIgPSB7fSksXHJcbiAgICBhbmd1bGFyTW9kdWxlLFxyXG4gICAgbm9kZU5hbWVfLFxyXG4gICAgdWlkICAgICAgICAgICAgICAgPSBbJzAnLCAnMCcsICcwJ107XHJcblxyXG4vKipcclxuICogSUUgMTEgY2hhbmdlZCB0aGUgZm9ybWF0IG9mIHRoZSBVc2VyQWdlbnQgc3RyaW5nLlxyXG4gKiBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3NTAzLmFzcHhcclxuICovXHJcbm1zaWUgPSBpbnQoKC9tc2llIChcXGQrKS8uZXhlYyhsb3dlcmNhc2UobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHx8IFtdKVsxXSk7XHJcbmlmIChpc05hTihtc2llKSkge1xyXG4gIG1zaWUgPSBpbnQoKC90cmlkZW50XFwvLio7IHJ2OihcXGQrKS8uZXhlYyhsb3dlcmNhc2UobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHx8IFtdKVsxXSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmpcclxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGBvYmpgIGlzIGFuIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0IChOb2RlTGlzdCwgQXJndW1lbnRzLCAuLi4pXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcclxuICBpZiAob2JqID09IG51bGwgfHwgaXNXaW5kb3cob2JqKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBcclxuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcclxuXHJcbiAgaWYgKG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzQXJyYXkob2JqKSB8fCAhaXNGdW5jdGlvbihvYmopICYmIChcclxuICAgIGxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9ialxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5mb3JFYWNoXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogSW52b2tlcyB0aGUgYGl0ZXJhdG9yYCBmdW5jdGlvbiBvbmNlIGZvciBlYWNoIGl0ZW0gaW4gYG9iamAgY29sbGVjdGlvbiwgd2hpY2ggY2FuIGJlIGVpdGhlciBhblxyXG4gKiBvYmplY3Qgb3IgYW4gYXJyYXkuIFRoZSBgaXRlcmF0b3JgIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBgaXRlcmF0b3IodmFsdWUsIGtleSlgLCB3aGVyZSBgdmFsdWVgXHJcbiAqIGlzIHRoZSB2YWx1ZSBvZiBhbiBvYmplY3QgcHJvcGVydHkgb3IgYW4gYXJyYXkgZWxlbWVudCBhbmQgYGtleWAgaXMgdGhlIG9iamVjdCBwcm9wZXJ0eSBrZXkgb3JcclxuICogYXJyYXkgZWxlbWVudCBpbmRleC4gU3BlY2lmeWluZyBhIGBjb250ZXh0YCBmb3IgdGhlIGZ1bmN0aW9uIGlzIG9wdGlvbmFsLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBhbmd1bGFyLmZvcmVhY2hgLlxyXG4gKlxyXG4gICA8cHJlPlxyXG4gICAgIHZhciB2YWx1ZXMgPSB7bmFtZTogJ21pc2tvJywgZ2VuZGVyOiAnbWFsZSd9O1xyXG4gICAgIHZhciBsb2cgPSBbXTtcclxuICAgICBhbmd1bGFyLmZvckVhY2godmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcclxuICAgICAgIHRoaXMucHVzaChrZXkgKyAnOiAnICsgdmFsdWUpO1xyXG4gICAgIH0sIGxvZyk7XHJcbiAgICAgZXhwZWN0KGxvZykudG9FcXVhbChbJ25hbWU6IG1pc2tvJywgJ2dlbmRlcjptYWxlJ10pO1xyXG4gICA8L3ByZT5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBPYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvciBJdGVyYXRvciBmdW5jdGlvbi5cclxuICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0IE9iamVjdCB0byBiZWNvbWUgY29udGV4dCAoYHRoaXNgKSBmb3IgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fSBSZWZlcmVuY2UgdG8gYG9iamAuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICB2YXIga2V5O1xyXG4gIGlmIChvYmopIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikpe1xyXG4gICAgICBmb3IgKGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoa2V5ICE9ICdwcm90b3R5cGUnICYmIGtleSAhPSAnbGVuZ3RoJyAmJiBrZXkgIT0gJ25hbWUnICYmIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCAhPT0gZm9yRWFjaCkge1xyXG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcclxuICAgICAgZm9yIChrZXkgPSAwOyBrZXkgPCBvYmoubGVuZ3RoOyBrZXkrKylcclxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzb3J0ZWRLZXlzKG9iaikge1xyXG4gIHZhciBrZXlzID0gW107XHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ga2V5cy5zb3J0KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvckVhY2hTb3J0ZWQob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gIHZhciBrZXlzID0gc29ydGVkS2V5cyhvYmopO1xyXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleXNbaV1dLCBrZXlzW2ldKTtcclxuICB9XHJcbiAgcmV0dXJuIGtleXM7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogd2hlbiB1c2luZyBmb3JFYWNoIHRoZSBwYXJhbXMgYXJlIHZhbHVlLCBrZXksIGJ1dCBpdCBpcyBvZnRlbiB1c2VmdWwgdG8gaGF2ZSBrZXksIHZhbHVlLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgKil9IGl0ZXJhdG9yRm5cclxuICogQHJldHVybnMge2Z1bmN0aW9uKCosIHN0cmluZyl9XHJcbiAqL1xyXG5mdW5jdGlvbiByZXZlcnNlUGFyYW1zKGl0ZXJhdG9yRm4pIHtcclxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGtleSkgeyBpdGVyYXRvckZuKGtleSwgdmFsdWUpIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGNvbnNpc3RlbnQgd2F5IG9mIGNyZWF0aW5nIHVuaXF1ZSBJRHMgaW4gYW5ndWxhci4gVGhlIElEIGlzIGEgc2VxdWVuY2Ugb2YgYWxwaGEgbnVtZXJpY1xyXG4gKiBjaGFyYWN0ZXJzIHN1Y2ggYXMgJzAxMkFCQycuIFRoZSByZWFzb24gd2h5IHdlIGFyZSBub3QgdXNpbmcgc2ltcGx5IGEgbnVtYmVyIGNvdW50ZXIgaXMgdGhhdFxyXG4gKiB0aGUgbnVtYmVyIHN0cmluZyBnZXRzIGxvbmdlciBvdmVyIHRpbWUsIGFuZCBpdCBjYW4gYWxzbyBvdmVyZmxvdywgd2hlcmUgYXMgdGhlIG5leHRJZFxyXG4gKiB3aWxsIGdyb3cgbXVjaCBzbG93ZXIsIGl0IGlzIGEgc3RyaW5nLCBhbmQgaXQgd2lsbCBuZXZlciBvdmVyZmxvdy5cclxuICpcclxuICogQHJldHVybnMgYW4gdW5pcXVlIGFscGhhLW51bWVyaWMgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0VWlkKCkge1xyXG4gIHZhciBpbmRleCA9IHVpZC5sZW5ndGg7XHJcbiAgdmFyIGRpZ2l0O1xyXG5cclxuICB3aGlsZShpbmRleCkge1xyXG4gICAgaW5kZXgtLTtcclxuICAgIGRpZ2l0ID0gdWlkW2luZGV4XS5jaGFyQ29kZUF0KDApO1xyXG4gICAgaWYgKGRpZ2l0ID09IDU3IC8qJzknKi8pIHtcclxuICAgICAgdWlkW2luZGV4XSA9ICdBJztcclxuICAgICAgcmV0dXJuIHVpZC5qb2luKCcnKTtcclxuICAgIH1cclxuICAgIGlmIChkaWdpdCA9PSA5MCAgLyonWicqLykge1xyXG4gICAgICB1aWRbaW5kZXhdID0gJzAnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdWlkW2luZGV4XSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGlnaXQgKyAxKTtcclxuICAgICAgcmV0dXJuIHVpZC5qb2luKCcnKTtcclxuICAgIH1cclxuICB9XHJcbiAgdWlkLnVuc2hpZnQoJzAnKTtcclxuICByZXR1cm4gdWlkLmpvaW4oJycpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFNldCBvciBjbGVhciB0aGUgaGFzaGtleSBmb3IgYW4gb2JqZWN0LlxyXG4gKiBAcGFyYW0gb2JqIG9iamVjdFxyXG4gKiBAcGFyYW0gaCB0aGUgaGFzaGtleSAoIXRydXRoeSB0byBkZWxldGUgdGhlIGhhc2hrZXkpXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRIYXNoS2V5KG9iaiwgaCkge1xyXG4gIGlmIChoKSB7XHJcbiAgICBvYmouJCRoYXNoS2V5ID0gaDtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBkZWxldGUgb2JqLiQkaGFzaEtleTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5leHRlbmRcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBFeHRlbmRzIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgYGRzdGAgYnkgY29weWluZyBhbGwgb2YgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgYHNyY2Agb2JqZWN0KHMpXHJcbiAqIHRvIGBkc3RgLiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgYHNyY2Agb2JqZWN0cy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGRzdCBEZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzcmMgU291cmNlIG9iamVjdChzKS5cclxuICogQHJldHVybnMge09iamVjdH0gUmVmZXJlbmNlIHRvIGBkc3RgLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kKGRzdCkge1xyXG4gIHZhciBoID0gZHN0LiQkaGFzaEtleTtcclxuICBmb3JFYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24ob2JqKXtcclxuICAgIGlmIChvYmogIT09IGRzdCkge1xyXG4gICAgICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSl7XHJcbiAgICAgICAgZHN0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHNldEhhc2hLZXkoZHN0LGgpO1xyXG4gIHJldHVybiBkc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludChzdHIpIHtcclxuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpbmhlcml0KHBhcmVudCwgZXh0cmEpIHtcclxuICByZXR1cm4gZXh0ZW5kKG5ldyAoZXh0ZW5kKGZ1bmN0aW9uKCkge30sIHtwcm90b3R5cGU6cGFyZW50fSkpKCksIGV4dHJhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLm5vb3BcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgbm8gb3BlcmF0aW9ucy4gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZnVsIHdoZW4gd3JpdGluZyBjb2RlIGluIHRoZVxyXG4gKiBmdW5jdGlvbmFsIHN0eWxlLlxyXG4gICA8cHJlPlxyXG4gICAgIGZ1bmN0aW9uIGZvbyhjYWxsYmFjaykge1xyXG4gICAgICAgdmFyIHJlc3VsdCA9IGNhbGN1bGF0ZVJlc3VsdCgpO1xyXG4gICAgICAgKGNhbGxiYWNrIHx8IGFuZ3VsYXIubm9vcCkocmVzdWx0KTtcclxuICAgICB9XHJcbiAgIDwvcHJlPlxyXG4gKi9cclxuZnVuY3Rpb24gbm9vcCgpIHt9XHJcbm5vb3AuJGluamVjdCA9IFtdO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pZGVudGl0eVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB3cml0aW5nIGNvZGUgaW4gdGhlXHJcbiAqIGZ1bmN0aW9uYWwgc3R5bGUuXHJcbiAqXHJcbiAgIDxwcmU+XHJcbiAgICAgZnVuY3Rpb24gdHJhbnNmb3JtZXIodHJhbnNmb3JtYXRpb25GbiwgdmFsdWUpIHtcclxuICAgICAgIHJldHVybiAodHJhbnNmb3JtYXRpb25GbiB8fCBhbmd1bGFyLmlkZW50aXR5KSh2YWx1ZSk7XHJcbiAgICAgfTtcclxuICAgPC9wcmU+XHJcbiAqL1xyXG5mdW5jdGlvbiBpZGVudGl0eSgkKSB7cmV0dXJuICQ7fVxyXG5pZGVudGl0eS4kaW5qZWN0ID0gW107XHJcblxyXG5cclxuZnVuY3Rpb24gdmFsdWVGbih2YWx1ZSkge3JldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gdmFsdWU7fTt9XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNVbmRlZmluZWRcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIHVuZGVmaW5lZC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7fVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pc0RlZmluZWRcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGRlZmluZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGRlZmluZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWUgIT0gJ3VuZGVmaW5lZCc7fVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pc09iamVjdFxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYW4gYE9iamVjdGAuIFVubGlrZSBgdHlwZW9mYCBpbiBKYXZhU2NyaXB0LCBgbnVsbGBzIGFyZSBub3RcclxuICogY29uc2lkZXJlZCB0byBiZSBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhbiBgT2JqZWN0YCBidXQgbm90IGBudWxsYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKXtyZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7fVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pc1N0cmluZ1xyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYSBgU3RyaW5nYC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnO31cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNOdW1iZXJcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGEgYE51bWJlcmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYE51bWJlcmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSl7cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJzt9XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmlzRGF0ZVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgYSB2YWx1ZSBpcyBhIGRhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYERhdGVgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKXtcclxuICByZXR1cm4gdG9TdHJpbmcuYXBwbHkodmFsdWUpID09ICdbb2JqZWN0IERhdGVdJztcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pc0FycmF5XHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyBhbiBgQXJyYXlgLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhbiBgQXJyYXlgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZy5hcHBseSh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJztcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pc0Z1bmN0aW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyBhIGBGdW5jdGlvbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYEZ1bmN0aW9uYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJzt9XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYSB2YWx1ZSBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYFJlZ0V4cGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xyXG4gIHJldHVybiB0b1N0cmluZy5hcHBseSh2YWx1ZSkgPT0gJ1tvYmplY3QgUmVnRXhwXSc7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGBvYmpgIGlzIGEgd2luZG93IG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0IHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGBvYmpgIGlzIGEgd2luZG93IG9iai5cclxuICovXHJcbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xyXG4gIHJldHVybiBvYmogJiYgb2JqLmRvY3VtZW50ICYmIG9iai5sb2NhdGlvbiAmJiBvYmouYWxlcnQgJiYgb2JqLnNldEludGVydmFsO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaXNTY29wZShvYmopIHtcclxuICByZXR1cm4gb2JqICYmIG9iai4kZXZhbEFzeW5jICYmIG9iai4kd2F0Y2g7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc0ZpbGUob2JqKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nLmFwcGx5KG9iaikgPT09ICdbb2JqZWN0IEZpbGVdJztcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nO1xyXG59XHJcblxyXG5cclxudmFyIHRyaW0gPSAoZnVuY3Rpb24oKSB7XHJcbiAgLy8gbmF0aXZlIHRyaW0gaXMgd2F5IGZhc3RlcjogaHR0cDovL2pzcGVyZi5jb20vYW5ndWxhci10cmltLXRlc3RcclxuICAvLyBidXQgSUUgZG9lc24ndCBoYXZlIGl0Li4uIDotKFxyXG4gIC8vIFRPRE86IHdlIHNob3VsZCBtb3ZlIHRoaXMgaW50byBJRS9FUzUgcG9seWZpbGxcclxuICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKSA6IHZhbHVlO1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNFbGVtZW50XHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyBhIERPTSBlbGVtZW50IChvciB3cmFwcGVkIGpRdWVyeSBlbGVtZW50KS5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCAob3Igd3JhcHBlZCBqUXVlcnkgZWxlbWVudCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xyXG4gIHJldHVybiBub2RlICYmXHJcbiAgICAobm9kZS5ub2RlTmFtZSAgLy8gd2UgYXJlIGEgZGlyZWN0IGVsZW1lbnRcclxuICAgIHx8IChub2RlLm9uICYmIG5vZGUuZmluZCkpOyAgLy8gd2UgaGF2ZSBhbiBvbiBhbmQgZmluZCBtZXRob2QgcGFydCBvZiBqUXVlcnkgQVBJXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gc3RyICdrZXkxLGtleTIsLi4uJ1xyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBpbiB0aGUgZm9ybSBvZiB7a2V5MTp0cnVlLCBrZXkyOnRydWUsIC4uLn1cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyKXtcclxuICB2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KFwiLFwiKSwgaTtcclxuICBmb3IgKCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrIClcclxuICAgIG9ialsgaXRlbXNbaV0gXSA9IHRydWU7XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuXHJcbmlmIChtc2llIDwgOSkge1xyXG4gIG5vZGVOYW1lXyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5vZGVOYW1lID8gZWxlbWVudCA6IGVsZW1lbnRbMF07XHJcbiAgICByZXR1cm4gKGVsZW1lbnQuc2NvcGVOYW1lICYmIGVsZW1lbnQuc2NvcGVOYW1lICE9ICdIVE1MJylcclxuICAgICAgPyB1cHBlcmNhc2UoZWxlbWVudC5zY29wZU5hbWUgKyAnOicgKyBlbGVtZW50Lm5vZGVOYW1lKSA6IGVsZW1lbnQubm9kZU5hbWU7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICBub2RlTmFtZV8gPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZSA/IGVsZW1lbnQubm9kZU5hbWUgOiBlbGVtZW50WzBdLm5vZGVOYW1lO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBtYXAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gIHZhciByZXN1bHRzID0gW107XHJcbiAgZm9yRWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBhcnJheSwgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFuIG9iamVjdCBoYXMsIG9yXHJcbiAqIHRoZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdWdtZW50IHRoZSBPYmplY3QgdHlwZSBpbiBBbmd1bGFyIGV4cHJlc3Npb25zLiBTZWVcclxuICoge0BsaW5rIGFuZ3VsYXIuT2JqZWN0fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBBbmd1bGFyIGFycmF5cy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8c3RyaW5nfSBvYmogT2JqZWN0LCBhcnJheSwgb3Igc3RyaW5nIHRvIGluc3BlY3QuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW293blByb3BzT25seT1mYWxzZV0gQ291bnQgb25seSBcIm93blwiIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzaXplIG9mIGBvYmpgIG9yIGAwYCBpZiBgb2JqYCBpcyBuZWl0aGVyIGFuIG9iamVjdCBub3IgYW4gYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaXplKG9iaiwgb3duUHJvcHNPbmx5KSB7XHJcbiAgdmFyIHNpemUgPSAwLCBrZXk7XHJcblxyXG4gIGlmIChpc0FycmF5KG9iaikgfHwgaXNTdHJpbmcob2JqKSkge1xyXG4gICAgcmV0dXJuIG9iai5sZW5ndGg7XHJcbiAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKXtcclxuICAgIGZvciAoa2V5IGluIG9iailcclxuICAgICAgaWYgKCFvd25Qcm9wc09ubHkgfHwgb2JqLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgc2l6ZSsrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNpemU7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgb2JqKSB7XHJcbiAgcmV0dXJuIGluZGV4T2YoYXJyYXksIG9iaikgIT0gLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIG9iaikge1xyXG4gIGlmIChhcnJheS5pbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihvYmopO1xyXG5cclxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKG9iaiA9PT0gYXJyYXlbaV0pIHJldHVybiBpO1xyXG4gIH1cclxuICByZXR1cm4gLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5UmVtb3ZlKGFycmF5LCB2YWx1ZSkge1xyXG4gIHZhciBpbmRleCA9IGluZGV4T2YoYXJyYXksIHZhbHVlKTtcclxuICBpZiAoaW5kZXggPj0wKVxyXG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTGVhZk5vZGUgKG5vZGUpIHtcclxuICBpZiAobm9kZSkge1xyXG4gICAgc3dpdGNoIChub2RlLm5vZGVOYW1lKSB7XHJcbiAgICBjYXNlIFwiT1BUSU9OXCI6XHJcbiAgICBjYXNlIFwiUFJFXCI6XHJcbiAgICBjYXNlIFwiVElUTEVcIjpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmNvcHlcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgLCB3aGljaCBzaG91bGQgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxyXG4gKlxyXG4gKiAqIElmIG5vIGRlc3RpbmF0aW9uIGlzIHN1cHBsaWVkLCBhIGNvcHkgb2YgdGhlIG9iamVjdCBvciBhcnJheSBpcyBjcmVhdGVkLlxyXG4gKiAqIElmIGEgZGVzdGluYXRpb24gaXMgcHJvdmlkZWQsIGFsbCBvZiBpdHMgZWxlbWVudHMgKGZvciBhcnJheSkgb3IgcHJvcGVydGllcyAoZm9yIG9iamVjdHMpXHJcbiAqICAgYXJlIGRlbGV0ZWQgYW5kIHRoZW4gYWxsIGVsZW1lbnRzL3Byb3BlcnRpZXMgZnJvbSB0aGUgc291cmNlIGFyZSBjb3BpZWQgdG8gaXQuXHJcbiAqICogSWYgIGBzb3VyY2VgIGlzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGBzb3VyY2VgIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXVnbWVudCB0aGUgT2JqZWN0IHR5cGUgaW4gQW5ndWxhciBleHByZXNzaW9ucy4gU2VlXHJcbiAqIHtAbGluayBuZy4kZmlsdGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBBbmd1bGFyIGFycmF5cy5cclxuICpcclxuICogQHBhcmFtIHsqfSBzb3VyY2UgVGhlIHNvdXJjZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYWtlIGEgY29weS5cclxuICogICAgICAgICAgICAgICAgICAgQ2FuIGJlIGFueSB0eXBlLCBpbmNsdWRpbmcgcHJpbWl0aXZlcywgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGAuXHJcbiAqIEBwYXJhbSB7KE9iamVjdHxBcnJheSk9fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBpbnRvIHdoaWNoIHRoZSBzb3VyY2UgaXMgY29waWVkLiBJZlxyXG4gKiAgICAgcHJvdmlkZWQsIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZSBhcyBgc291cmNlYC5cclxuICogQHJldHVybnMgeyp9IFRoZSBjb3B5IG9yIHVwZGF0ZWQgYGRlc3RpbmF0aW9uYCwgaWYgYGRlc3RpbmF0aW9uYCB3YXMgc3BlY2lmaWVkLlxyXG4gKi9cclxuZnVuY3Rpb24gY29weShzb3VyY2UsIGRlc3RpbmF0aW9uKXtcclxuICBpZiAoaXNXaW5kb3coc291cmNlKSB8fCBpc1Njb3BlKHNvdXJjZSkpIHtcclxuICAgIHRocm93IG5nTWluRXJyKCdjcHdzJywgXCJDYW4ndCBjb3B5ISBNYWtpbmcgY29waWVzIG9mIFdpbmRvdyBvciBTY29wZSBpbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZC5cIik7XHJcbiAgfVxyXG5cclxuICBpZiAoIWRlc3RpbmF0aW9uKSB7XHJcbiAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcclxuICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uID0gY29weShzb3VyY2UsIFtdKTtcclxuICAgICAgfSBlbHNlIGlmIChpc0RhdGUoc291cmNlKSkge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uID0gbmV3IERhdGUoc291cmNlLmdldFRpbWUoKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAoc291cmNlKSkge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uID0gbmV3IFJlZ0V4cChzb3VyY2Uuc291cmNlKTtcclxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XHJcbiAgICAgICAgZGVzdGluYXRpb24gPSBjb3B5KHNvdXJjZSwge30pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChzb3VyY2UgPT09IGRlc3RpbmF0aW9uKSB0aHJvdyBuZ01pbkVycignY3BpJywgXCJDYW4ndCBjb3B5ISBTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSBpZGVudGljYWwuXCIpO1xyXG4gICAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICBkZXN0aW5hdGlvbi5sZW5ndGggPSAwO1xyXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGNvcHkoc291cmNlW2ldKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBoID0gZGVzdGluYXRpb24uJCRoYXNoS2V5O1xyXG4gICAgICBmb3JFYWNoKGRlc3RpbmF0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcclxuICAgICAgICBkZWxldGUgZGVzdGluYXRpb25ba2V5XTtcclxuICAgICAgfSk7XHJcbiAgICAgIGZvciAoIHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNvcHkoc291cmNlW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHNldEhhc2hLZXkoZGVzdGluYXRpb24saCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBkZXN0aW5hdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KHNyYywgZHN0KSB7XHJcbiAgZHN0ID0gZHN0IHx8IHt9O1xyXG5cclxuICBmb3IodmFyIGtleSBpbiBzcmMpIHtcclxuICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSAnJCQnKSB7XHJcbiAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZHN0O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmVxdWFsc1xyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgdHdvIG9iamVjdHMgb3IgdHdvIHZhbHVlcyBhcmUgZXF1aXZhbGVudC4gU3VwcG9ydHMgdmFsdWUgdHlwZXMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGFycmF5cyBhbmRcclxuICogb2JqZWN0cy5cclxuICpcclxuICogVHdvIG9iamVjdHMgb3IgdmFsdWVzIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcclxuICpcclxuICogKiBCb3RoIG9iamVjdHMgb3IgdmFsdWVzIHBhc3MgYD09PWAgY29tcGFyaXNvbi5cclxuICogKiBCb3RoIG9iamVjdHMgb3IgdmFsdWVzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCBhbGwgb2YgdGhlaXIgcHJvcGVydGllcyBwYXNzIGA9PT1gIGNvbXBhcmlzb24uXHJcbiAqICogQm90aCB2YWx1ZXMgYXJlIE5hTi4gKEluIEphdmFzU2NyaXB0LCBOYU4gPT0gTmFOID0+IGZhbHNlLiBCdXQgd2UgY29uc2lkZXIgdHdvIE5hTiBhcyBlcXVhbClcclxuICogKiBCb3RoIHZhbHVlcyByZXByZXNlbnQgdGhlIHNhbWUgcmVndWxhciBleHByZXNzaW9uIChJbiBKYXZhc1NjcmlwdCxcclxuICogICAvYWJjLyA9PSAvYWJjLyA9PiBmYWxzZS4gQnV0IHdlIGNvbnNpZGVyIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGFzIGVxdWFsIHdoZW4gdGhlaXIgdGV4dHVhbFxyXG4gKiAgIHJlcHJlc2VudGF0aW9uIG1hdGNoZXMpLlxyXG4gKlxyXG4gKiBEdXJpbmcgYSBwcm9wZXJ0eSBjb21wYXJpc29uLCBwcm9wZXJ0aWVzIG9mIGBmdW5jdGlvbmAgdHlwZSBhbmQgcHJvcGVydGllcyB3aXRoIG5hbWVzXHJcbiAqIHRoYXQgYmVnaW4gd2l0aCBgJGAgYXJlIGlnbm9yZWQuXHJcbiAqXHJcbiAqIFNjb3BlIGFuZCBET01XaW5kb3cgb2JqZWN0cyBhcmUgYmVpbmcgY29tcGFyZWQgb25seSBieSBpZGVudGlmeSAoYD09PWApLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG8xIE9iamVjdCBvciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0geyp9IG8yIE9iamVjdCBvciB2YWx1ZSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhcmd1bWVudHMgYXJlIGVxdWFsLlxyXG4gKi9cclxuZnVuY3Rpb24gZXF1YWxzKG8xLCBvMikge1xyXG4gIGlmIChvMSA9PT0gbzIpIHJldHVybiB0cnVlO1xyXG4gIGlmIChvMSA9PT0gbnVsbCB8fCBvMiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG4gIGlmIChvMSAhPT0gbzEgJiYgbzIgIT09IG8yKSByZXR1cm4gdHJ1ZTsgLy8gTmFOID09PSBOYU5cclxuICB2YXIgdDEgPSB0eXBlb2YgbzEsIHQyID0gdHlwZW9mIG8yLCBsZW5ndGgsIGtleSwga2V5U2V0O1xyXG4gIGlmICh0MSA9PSB0Mikge1xyXG4gICAgaWYgKHQxID09ICdvYmplY3QnKSB7XHJcbiAgICAgIGlmIChpc0FycmF5KG8xKSkge1xyXG4gICAgICAgIGlmICghaXNBcnJheShvMikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoKGxlbmd0aCA9IG8xLmxlbmd0aCkgPT0gbzIubGVuZ3RoKSB7XHJcbiAgICAgICAgICBmb3Ioa2V5PTA7IGtleTxsZW5ndGg7IGtleSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKG8xKSkge1xyXG4gICAgICAgIHJldHVybiBpc0RhdGUobzIpICYmIG8xLmdldFRpbWUoKSA9PSBvMi5nZXRUaW1lKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAobzEpICYmIGlzUmVnRXhwKG8yKSkge1xyXG4gICAgICAgIHJldHVybiBvMS50b1N0cmluZygpID09IG8yLnRvU3RyaW5nKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzU2NvcGUobzEpIHx8IGlzU2NvcGUobzIpIHx8IGlzV2luZG93KG8xKSB8fCBpc1dpbmRvdyhvMikgfHwgaXNBcnJheShvMikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBrZXlTZXQgPSB7fTtcclxuICAgICAgICBmb3Ioa2V5IGluIG8xKSB7XHJcbiAgICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJyQnIHx8IGlzRnVuY3Rpb24obzFba2V5XSkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgaWYgKCFlcXVhbHMobzFba2V5XSwgbzJba2V5XSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIGtleVNldFtrZXldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGtleSBpbiBvMikge1xyXG4gICAgICAgICAgaWYgKCFrZXlTZXQuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxyXG4gICAgICAgICAgICAgIGtleS5jaGFyQXQoMCkgIT09ICckJyAmJlxyXG4gICAgICAgICAgICAgIG8yW2tleV0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICFpc0Z1bmN0aW9uKG8yW2tleV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbmNhdChhcnJheTEsIGFycmF5MiwgaW5kZXgpIHtcclxuICByZXR1cm4gYXJyYXkxLmNvbmNhdChzbGljZS5jYWxsKGFycmF5MiwgaW5kZXgpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2xpY2VBcmdzKGFyZ3MsIHN0YXJ0SW5kZXgpIHtcclxuICByZXR1cm4gc2xpY2UuY2FsbChhcmdzLCBzdGFydEluZGV4IHx8IDApO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmJpbmRcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggY2FsbHMgZnVuY3Rpb24gYGZuYCBib3VuZCB0byBgc2VsZmAgKGBzZWxmYCBiZWNvbWVzIHRoZSBgdGhpc2AgZm9yXHJcbiAqIGBmbmApLiBZb3UgY2FuIHN1cHBseSBvcHRpb25hbCBgYXJnc2AgdGhhdCBhcmUgcHJlYm91bmQgdG8gdGhlIGZ1bmN0aW9uLiBUaGlzIGZlYXR1cmUgaXMgYWxzb1xyXG4gKiBrbm93biBhcyBbZnVuY3Rpb24gY3VycnlpbmddKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3VycnlpbmcpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBDb250ZXh0IHdoaWNoIGBmbmAgc2hvdWxkIGJlIGV2YWx1YXRlZCBpbi5cclxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmbiBGdW5jdGlvbiB0byBiZSBib3VuZC5cclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwcmVib3VuZCB0byB0aGUgYGZuYCBmdW5jdGlvbiBjYWxsLlxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKX0gRnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgYGZuYCB3aXRoIGFsbCB0aGUgc3BlY2lmaWVkIGJpbmRpbmdzLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluZChzZWxmLCBmbikge1xyXG4gIHZhciBjdXJyeUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IHNsaWNlQXJncyhhcmd1bWVudHMsIDIpIDogW107XHJcbiAgaWYgKGlzRnVuY3Rpb24oZm4pICYmICEoZm4gaW5zdGFuY2VvZiBSZWdFeHApKSB7XHJcbiAgICByZXR1cm4gY3VycnlBcmdzLmxlbmd0aFxyXG4gICAgICA/IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAgICAgPyBmbi5hcHBseShzZWxmLCBjdXJyeUFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpXHJcbiAgICAgICAgICAgIDogZm4uYXBwbHkoc2VsZiwgY3VycnlBcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICAgICA/IGZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcclxuICAgICAgICAgICAgOiBmbi5jYWxsKHNlbGYpO1xyXG4gICAgICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGluIElFLCBuYXRpdmUgbWV0aG9kcyBhcmUgbm90IGZ1bmN0aW9ucyBzbyB0aGV5IGNhbm5vdCBiZSBib3VuZCAobm90ZTogdGhleSBkb24ndCBuZWVkIHRvIGJlKVxyXG4gICAgcmV0dXJuIGZuO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcclxuICB2YXIgdmFsID0gdmFsdWU7XHJcblxyXG4gIGlmICgvXlxcJCsvLnRlc3Qoa2V5KSkge1xyXG4gICAgdmFsID0gdW5kZWZpbmVkO1xyXG4gIH0gZWxzZSBpZiAoaXNXaW5kb3codmFsdWUpKSB7XHJcbiAgICB2YWwgPSAnJFdJTkRPVyc7XHJcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiAgZG9jdW1lbnQgPT09IHZhbHVlKSB7XHJcbiAgICB2YWwgPSAnJERPQ1VNRU5UJztcclxuICB9IGVsc2UgaWYgKGlzU2NvcGUodmFsdWUpKSB7XHJcbiAgICB2YWwgPSAnJFNDT1BFJztcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWw7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIudG9Kc29uXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU2VyaWFsaXplcyBpbnB1dCBpbnRvIGEgSlNPTi1mb3JtYXR0ZWQgc3RyaW5nLiBQcm9wZXJ0aWVzIHdpdGggbGVhZGluZyAkIGNoYXJhY3RlcnMgd2lsbCBiZVxyXG4gKiBzdHJpcHBlZCBzaW5jZSBhbmd1bGFyIHVzZXMgdGhpcyBub3RhdGlvbiBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxEYXRlfHN0cmluZ3xudW1iZXJ9IG9iaiBJbnB1dCB0byBiZSBzZXJpYWxpemVkIGludG8gSlNPTi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gcHJldHR5IElmIHNldCB0byB0cnVlLCB0aGUgSlNPTiBvdXRwdXQgd2lsbCBjb250YWluIG5ld2xpbmVzIGFuZCB3aGl0ZXNwYWNlLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gSlNPTi1pZmllZCBzdHJpbmcgcmVwcmVzZW50aW5nIGBvYmpgLlxyXG4gKi9cclxuZnVuY3Rpb24gdG9Kc29uKG9iaiwgcHJldHR5KSB7XHJcbiAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHRvSnNvblJlcGxhY2VyLCBwcmV0dHkgPyAnICAnIDogbnVsbCk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuZnJvbUpzb25cclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXNlcmlhbGl6ZXMgYSBKU09OIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGpzb24gSlNPTiBzdHJpbmcgdG8gZGVzZXJpYWxpemUuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl8RGF0ZXxzdHJpbmd8bnVtYmVyfSBEZXNlcmlhbGl6ZWQgdGhpbmd5LlxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUpzb24oanNvbikge1xyXG4gIHJldHVybiBpc1N0cmluZyhqc29uKVxyXG4gICAgICA/IEpTT04ucGFyc2UoanNvbilcclxuICAgICAgOiBqc29uO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgdmFyIHYgPSBsb3dlcmNhc2UoXCJcIiArIHZhbHVlKTtcclxuICAgIHZhbHVlID0gISh2ID09ICdmJyB8fCB2ID09ICcwJyB8fCB2ID09ICdmYWxzZScgfHwgdiA9PSAnbm8nIHx8IHYgPT0gJ24nIHx8IHYgPT0gJ1tdJyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0aW5nVGFnKGVsZW1lbnQpIHtcclxuICBlbGVtZW50ID0ganFMaXRlKGVsZW1lbnQpLmNsb25lKCk7XHJcbiAgdHJ5IHtcclxuICAgIC8vIHR1cm5zIG91dCBJRSBkb2VzIG5vdCBsZXQgeW91IHNldCAuaHRtbCgpIG9uIGVsZW1lbnRzIHdoaWNoXHJcbiAgICAvLyBhcmUgbm90IGFsbG93ZWQgdG8gaGF2ZSBjaGlsZHJlbi4gU28gd2UganVzdCBpZ25vcmUgaXQuXHJcbiAgICBlbGVtZW50Lmh0bWwoJycpO1xyXG4gIH0gY2F0Y2goZSkge31cclxuICAvLyBBcyBQZXIgRE9NIFN0YW5kYXJkc1xyXG4gIHZhciBURVhUX05PREUgPSAzO1xyXG4gIHZhciBlbGVtSHRtbCA9IGpxTGl0ZSgnPGRpdj4nKS5hcHBlbmQoZWxlbWVudCkuaHRtbCgpO1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZWxlbWVudFswXS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gbG93ZXJjYXNlKGVsZW1IdG1sKSA6XHJcbiAgICAgICAgZWxlbUh0bWwuXHJcbiAgICAgICAgICBtYXRjaCgvXig8W14+XSs+KS8pWzFdLlxyXG4gICAgICAgICAgcmVwbGFjZSgvXjwoW1xcd1xcLV0rKS8sIGZ1bmN0aW9uKG1hdGNoLCBub2RlTmFtZSkgeyByZXR1cm4gJzwnICsgbG93ZXJjYXNlKG5vZGVOYW1lKTsgfSk7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICByZXR1cm4gbG93ZXJjYXNlKGVsZW1IdG1sKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIFRyaWVzIHRvIGRlY29kZSB0aGUgVVJJIGNvbXBvbmVudCB3aXRob3V0IHRocm93aW5nIGFuIGV4Y2VwdGlvbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHN0ciB2YWx1ZSBwb3RlbnRpYWwgVVJJIGNvbXBvbmVudCB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBjYW4gYmUgZGVjb2RlZFxyXG4gKiB3aXRoIHRoZSBkZWNvZGVVUklDb21wb25lbnQgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiB0cnlEZWNvZGVVUklDb21wb25lbnQodmFsdWUpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICAvLyBJZ25vcmUgYW55IGludmFsaWQgdXJpIGNvbXBvbmVudFxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgYW4gZXNjYXBlZCB1cmwgcXVlcnkgc3RyaW5nIGludG8ga2V5LXZhbHVlIHBhaXJzLlxyXG4gKiBAcmV0dXJucyBPYmplY3QuPChzdHJpbmd8Ym9vbGVhbik+XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUtleVZhbHVlKC8qKnN0cmluZyova2V5VmFsdWUpIHtcclxuICB2YXIgb2JqID0ge30sIGtleV92YWx1ZSwga2V5O1xyXG4gIGZvckVhY2goKGtleVZhbHVlIHx8IFwiXCIpLnNwbGl0KCcmJyksIGZ1bmN0aW9uKGtleVZhbHVlKXtcclxuICAgIGlmICgga2V5VmFsdWUgKSB7XHJcbiAgICAgIGtleV92YWx1ZSA9IGtleVZhbHVlLnNwbGl0KCc9Jyk7XHJcbiAgICAgIGtleSA9IHRyeURlY29kZVVSSUNvbXBvbmVudChrZXlfdmFsdWVbMF0pO1xyXG4gICAgICBpZiAoIGlzRGVmaW5lZChrZXkpICkge1xyXG4gICAgICAgIHZhciB2YWwgPSBpc0RlZmluZWQoa2V5X3ZhbHVlWzFdKSA/IHRyeURlY29kZVVSSUNvbXBvbmVudChrZXlfdmFsdWVbMV0pIDogdHJ1ZTtcclxuICAgICAgICBpZiAoIW9ialtrZXldKSB7XHJcbiAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcclxuICAgICAgICB9IGVsc2UgaWYoaXNBcnJheShvYmpba2V5XSkpIHtcclxuICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV0sdmFsXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0tleVZhbHVlKG9iaikge1xyXG4gIHZhciBwYXJ0cyA9IFtdO1xyXG4gIGZvckVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oYXJyYXlWYWx1ZSkge1xyXG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVXJpUXVlcnkoa2V5LCB0cnVlKSArIChhcnJheVZhbHVlID09PSB0cnVlID8gJycgOiAnPScgKyBlbmNvZGVVcmlRdWVyeShhcnJheVZhbHVlLCB0cnVlKSkpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICBwYXJ0cy5wdXNoKGVuY29kZVVyaVF1ZXJ5KGtleSwgdHJ1ZSkgKyAodmFsdWUgPT09IHRydWUgPyAnJyA6ICc9JyArIGVuY29kZVVyaVF1ZXJ5KHZhbHVlLCB0cnVlKSkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPyBwYXJ0cy5qb2luKCcmJykgOiAnJztcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBXZSBuZWVkIG91ciBjdXN0b20gbWV0aG9kIGJlY2F1c2UgZW5jb2RlVVJJQ29tcG9uZW50IGlzIHRvbyBhZ2dyZXNzaXZlIGFuZCBkb2Vzbid0IGZvbGxvd1xyXG4gKiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzOTg2LnR4dCB3aXRoIHJlZ2FyZHMgdG8gdGhlIGNoYXJhY3RlciBzZXQgKHBjaGFyKSBhbGxvd2VkIGluIHBhdGhcclxuICogc2VnbWVudHM6XHJcbiAqICAgIHNlZ21lbnQgICAgICAgPSAqcGNoYXJcclxuICogICAgcGNoYXIgICAgICAgICA9IHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiAvIFwiQFwiXHJcbiAqICAgIHBjdC1lbmNvZGVkICAgPSBcIiVcIiBIRVhESUcgSEVYRElHXHJcbiAqICAgIHVucmVzZXJ2ZWQgICAgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcclxuICogICAgc3ViLWRlbGltcyAgICA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIlxyXG4gKiAgICAgICAgICAgICAgICAgICAgIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlVXJpU2VnbWVudCh2YWwpIHtcclxuICByZXR1cm4gZW5jb2RlVXJpUXVlcnkodmFsLCB0cnVlKS5cclxuICAgICAgICAgICAgIHJlcGxhY2UoLyUyNi9naSwgJyYnKS5cclxuICAgICAgICAgICAgIHJlcGxhY2UoLyUzRC9naSwgJz0nKS5cclxuICAgICAgICAgICAgIHJlcGxhY2UoLyUyQi9naSwgJysnKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZW5jb2RpbmcgKmtleSogb3IgKnZhbHVlKiBwYXJ0cyBvZiBxdWVyeSBjb21wb25lbnQuIFdlIG5lZWQgYSBjdXN0b21cclxuICogbWV0aG9kIGJlY2F1c2UgZW5jb2RlVVJJQ29tcG9uZW50IGlzIHRvbyBhZ2dyZXNzaXZlIGFuZCBlbmNvZGVzIHN0dWZmIHRoYXQgZG9lc24ndCBoYXZlIHRvIGJlXHJcbiAqIGVuY29kZWQgcGVyIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODY6XHJcbiAqICAgIHF1ZXJ5ICAgICAgID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcclxuICogICAgcGNoYXIgICAgICAgICA9IHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiAvIFwiQFwiXHJcbiAqICAgIHVucmVzZXJ2ZWQgICAgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcclxuICogICAgcGN0LWVuY29kZWQgICA9IFwiJVwiIEhFWERJRyBIRVhESUdcclxuICogICAgc3ViLWRlbGltcyAgICA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIlxyXG4gKiAgICAgICAgICAgICAgICAgICAgIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlVXJpUXVlcnkodmFsLCBwY3RFbmNvZGVTcGFjZXMpIHtcclxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cclxuICAgICAgICAgICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cclxuICAgICAgICAgICAgIHJlcGxhY2UoLyUyMC9nLCAocGN0RW5jb2RlU3BhY2VzID8gJyUyMCcgOiAnKycpKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0FwcFxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHthbmd1bGFyLk1vZHVsZX0gbmdBcHAgYW4gb3B0aW9uYWwgYXBwbGljYXRpb25cclxuICogICB7QGxpbmsgYW5ndWxhci5tb2R1bGUgbW9kdWxlfSBuYW1lIHRvIGxvYWQuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBVc2UgdGhpcyBkaXJlY3RpdmUgdG8gYXV0by1ib290c3RyYXAgYW4gYXBwbGljYXRpb24uIE9ubHlcclxuICogb25lIG5nQXBwIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBwZXIgSFRNTCBkb2N1bWVudC4gVGhlIGRpcmVjdGl2ZVxyXG4gKiBkZXNpZ25hdGVzIHRoZSByb290IG9mIHRoZSBhcHBsaWNhdGlvbiBhbmQgaXMgdHlwaWNhbGx5IHBsYWNlZFxyXG4gKiBhdCB0aGUgcm9vdCBvZiB0aGUgcGFnZS5cclxuICpcclxuICogVGhlIGZpcnN0IG5nQXBwIGZvdW5kIGluIHRoZSBkb2N1bWVudCB3aWxsIGJlIGF1dG8tYm9vdHN0cmFwcGVkLiBUbyB1c2UgbXVsdGlwbGUgYXBwbGljYXRpb25zIGluIGFuXHJcbiAqIEhUTUwgZG9jdW1lbnQgeW91IG11c3QgbWFudWFsbHkgYm9vdHN0cmFwIHRoZW0gdXNpbmcge0BsaW5rIGFuZ3VsYXIuYm9vdHN0cmFwfS5cclxuICogQXBwbGljYXRpb25zIGNhbm5vdCBiZSBuZXN0ZWQuXHJcbiAqXHJcbiAqIEluIHRoZSBleGFtcGxlIGJlbG93IGlmIHRoZSBgbmdBcHBgIGRpcmVjdGl2ZSB3b3VsZCBub3QgYmUgcGxhY2VkXHJcbiAqIG9uIHRoZSBgaHRtbGAgZWxlbWVudCB0aGVuIHRoZSBkb2N1bWVudCB3b3VsZCBub3QgYmUgY29tcGlsZWRcclxuICogYW5kIHRoZSBge3sgMSsyIH19YCB3b3VsZCBub3QgYmUgcmVzb2x2ZWQgdG8gYDNgLlxyXG4gKlxyXG4gKiBgbmdBcHBgIGlzIHRoZSBlYXNpZXN0IHdheSB0byBib290c3RyYXAgYW4gYXBwbGljYXRpb24uXHJcbiAqXHJcbiA8ZG9jOmV4YW1wbGU+XHJcbiAgIDxkb2M6c291cmNlPlxyXG4gICAgSSBjYW4gYWRkOiAxICsgMiA9ICB7eyAxKzIgfX1cclxuICAgPC9kb2M6c291cmNlPlxyXG4gPC9kb2M6ZXhhbXBsZT5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFuZ3VsYXJJbml0KGVsZW1lbnQsIGJvb3RzdHJhcCkge1xyXG4gIHZhciBlbGVtZW50cyA9IFtlbGVtZW50XSxcclxuICAgICAgYXBwRWxlbWVudCxcclxuICAgICAgbW9kdWxlLFxyXG4gICAgICBuYW1lcyA9IFsnbmc6YXBwJywgJ25nLWFwcCcsICd4LW5nLWFwcCcsICdkYXRhLW5nLWFwcCddLFxyXG4gICAgICBOR19BUFBfQ0xBU1NfUkVHRVhQID0gL1xcc25nWzpcXC1dYXBwKDpcXHMqKFtcXHdcXGRfXSspOz8pP1xccy87XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGVuZChlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50ICYmIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBuYW1lc1tuYW1lXSA9IHRydWU7XHJcbiAgICBhcHBlbmQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZSkpO1xyXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgnOicsICdcXFxcOicpO1xyXG4gICAgaWYgKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCkge1xyXG4gICAgICBmb3JFYWNoKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBuYW1lKSwgYXBwZW5kKTtcclxuICAgICAgZm9yRWFjaChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgbmFtZSArICdcXFxcOicpLCBhcHBlbmQpO1xyXG4gICAgICBmb3JFYWNoKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnWycgKyBuYW1lICsgJ10nKSwgYXBwZW5kKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgaWYgKCFhcHBFbGVtZW50KSB7XHJcbiAgICAgIHZhciBjbGFzc05hbWUgPSAnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJztcclxuICAgICAgdmFyIG1hdGNoID0gTkdfQVBQX0NMQVNTX1JFR0VYUC5leGVjKGNsYXNzTmFtZSk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGFwcEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIG1vZHVsZSA9IChtYXRjaFsyXSB8fCAnJykucmVwbGFjZSgvXFxzKy9nLCAnLCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvckVhY2goZWxlbWVudC5hdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XHJcbiAgICAgICAgICBpZiAoIWFwcEVsZW1lbnQgJiYgbmFtZXNbYXR0ci5uYW1lXSkge1xyXG4gICAgICAgICAgICBhcHBFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgbW9kdWxlID0gYXR0ci52YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGlmIChhcHBFbGVtZW50KSB7XHJcbiAgICBib290c3RyYXAoYXBwRWxlbWVudCwgbW9kdWxlID8gW21vZHVsZV0gOiBbXSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuYm9vdHN0cmFwXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiB0byBtYW51YWxseSBzdGFydCB1cCBhbmd1bGFyIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBTZWU6IHtAbGluayBndWlkZS9ib290c3RyYXAgQm9vdHN0cmFwfVxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbmdTY2VuYXJpby1iYXNlZCBlbmQtdG8tZW5kIHRlc3RzIGNhbm5vdCB1c2UgdGhpcyBmdW5jdGlvbiB0byBib290c3RyYXAgbWFudWFsbHkuXHJcbiAqIFRoZXkgbXVzdCB1c2Uge0BsaW5rIGFwaS9uZy5kaXJlY3RpdmU6bmdBcHAgbmdBcHB9LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRE9NIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHJvb3Qgb2YgYW5ndWxhciBhcHBsaWNhdGlvbi5cclxuICogQHBhcmFtIHtBcnJheTxTdHJpbmd8RnVuY3Rpb24+PX0gbW9kdWxlcyBhbiBhcnJheSBvZiBtb2R1bGUgZGVjbGFyYXRpb25zLiBTZWU6IHtAbGluayBhbmd1bGFyLm1vZHVsZSBtb2R1bGVzfVxyXG4gKiBAcmV0dXJucyB7QVVUTy4kaW5qZWN0b3J9IFJldHVybnMgdGhlIG5ld2x5IGNyZWF0ZWQgaW5qZWN0b3IgZm9yIHRoaXMgYXBwLlxyXG4gKi9cclxuZnVuY3Rpb24gYm9vdHN0cmFwKGVsZW1lbnQsIG1vZHVsZXMpIHtcclxuICB2YXIgZG9Cb290c3RyYXAgPSBmdW5jdGlvbigpIHtcclxuICAgIGVsZW1lbnQgPSBqcUxpdGUoZWxlbWVudCk7XHJcblxyXG4gICAgaWYgKGVsZW1lbnQuaW5qZWN0b3IoKSkge1xyXG4gICAgICB2YXIgdGFnID0gKGVsZW1lbnRbMF0gPT09IGRvY3VtZW50KSA/ICdkb2N1bWVudCcgOiBzdGFydGluZ1RhZyhlbGVtZW50KTtcclxuICAgICAgdGhyb3cgbmdNaW5FcnIoJ2J0c3RycGQnLCBcIkFwcCBBbHJlYWR5IEJvb3RzdHJhcHBlZCB3aXRoIHRoaXMgRWxlbWVudCAnezB9J1wiLCB0YWcpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZXMgPSBtb2R1bGVzIHx8IFtdO1xyXG4gICAgbW9kdWxlcy51bnNoaWZ0KFsnJHByb3ZpZGUnLCBmdW5jdGlvbigkcHJvdmlkZSkge1xyXG4gICAgICAkcHJvdmlkZS52YWx1ZSgnJHJvb3RFbGVtZW50JywgZWxlbWVudCk7XHJcbiAgICB9XSk7XHJcbiAgICBtb2R1bGVzLnVuc2hpZnQoJ25nJyk7XHJcbiAgICB2YXIgaW5qZWN0b3IgPSBjcmVhdGVJbmplY3Rvcihtb2R1bGVzKTtcclxuICAgIGluamVjdG9yLmludm9rZShbJyRyb290U2NvcGUnLCAnJHJvb3RFbGVtZW50JywgJyRjb21waWxlJywgJyRpbmplY3RvcicsICckYW5pbWF0ZScsXHJcbiAgICAgICBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgY29tcGlsZSwgaW5qZWN0b3IsIGFuaW1hdGUpIHtcclxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBlbGVtZW50LmRhdGEoJyRpbmplY3RvcicsIGluamVjdG9yKTtcclxuICAgICAgICAgIGNvbXBpbGUoZWxlbWVudCkoc2NvcGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFuaW1hdGUuZW5hYmxlZCh0cnVlKTtcclxuICAgICAgfV1cclxuICAgICk7XHJcbiAgICByZXR1cm4gaW5qZWN0b3I7XHJcbiAgfTtcclxuXHJcbiAgdmFyIE5HX0RFRkVSX0JPT1RTVFJBUCA9IC9eTkdfREVGRVJfQk9PVFNUUkFQIS87XHJcblxyXG4gIGlmICh3aW5kb3cgJiYgIU5HX0RFRkVSX0JPT1RTVFJBUC50ZXN0KHdpbmRvdy5uYW1lKSkge1xyXG4gICAgcmV0dXJuIGRvQm9vdHN0cmFwKCk7XHJcbiAgfVxyXG5cclxuICB3aW5kb3cubmFtZSA9IHdpbmRvdy5uYW1lLnJlcGxhY2UoTkdfREVGRVJfQk9PVFNUUkFQLCAnJyk7XHJcbiAgYW5ndWxhci5yZXN1bWVCb290c3RyYXAgPSBmdW5jdGlvbihleHRyYU1vZHVsZXMpIHtcclxuICAgIGZvckVhY2goZXh0cmFNb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcclxuICAgICAgbW9kdWxlcy5wdXNoKG1vZHVsZSk7XHJcbiAgICB9KTtcclxuICAgIGRvQm9vdHN0cmFwKCk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIFNOQUtFX0NBU0VfUkVHRVhQID0gL1tBLVpdL2c7XHJcbmZ1bmN0aW9uIHNuYWtlX2Nhc2UobmFtZSwgc2VwYXJhdG9yKXtcclxuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJ18nO1xyXG4gIHJldHVybiBuYW1lLnJlcGxhY2UoU05BS0VfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uKGxldHRlciwgcG9zKSB7XHJcbiAgICByZXR1cm4gKHBvcyA/IHNlcGFyYXRvciA6ICcnKSArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiaW5kSlF1ZXJ5KCkge1xyXG4gIC8vIGJpbmQgdG8galF1ZXJ5IGlmIHByZXNlbnQ7XHJcbiAgalF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcclxuICAvLyByZXNldCB0byBqUXVlcnkgb3IgZGVmYXVsdCB0byB1cy5cclxuICBpZiAoalF1ZXJ5KSB7XHJcbiAgICBqcUxpdGUgPSBqUXVlcnk7XHJcbiAgICBleHRlbmQoalF1ZXJ5LmZuLCB7XHJcbiAgICAgIHNjb3BlOiBKUUxpdGVQcm90b3R5cGUuc2NvcGUsXHJcbiAgICAgIGNvbnRyb2xsZXI6IEpRTGl0ZVByb3RvdHlwZS5jb250cm9sbGVyLFxyXG4gICAgICBpbmplY3RvcjogSlFMaXRlUHJvdG90eXBlLmluamVjdG9yLFxyXG4gICAgICBpbmhlcml0ZWREYXRhOiBKUUxpdGVQcm90b3R5cGUuaW5oZXJpdGVkRGF0YVxyXG4gICAgfSk7XHJcbiAgICAvLyBNZXRob2Qgc2lnbmF0dXJlOiBKUUxpdGVQYXRjaEpRdWVyeVJlbW92ZShuYW1lLCBkaXNwYXRjaFRoaXMsIGZpbHRlckVsZW1zLCBnZXR0ZXJJZk5vQXJndW1lbnRzKVxyXG4gICAgSlFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUoJ3JlbW92ZScsIHRydWUsIHRydWUsIGZhbHNlKTtcclxuICAgIEpRTGl0ZVBhdGNoSlF1ZXJ5UmVtb3ZlKCdlbXB0eScsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgSlFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUoJ2h0bWwnLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBqcUxpdGUgPSBKUUxpdGU7XHJcbiAgfVxyXG4gIGFuZ3VsYXIuZWxlbWVudCA9IGpxTGl0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHRocm93IGVycm9yIGlmIHRoZSBhcmd1bWVudCBpcyBmYWxzeS5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydEFyZyhhcmcsIG5hbWUsIHJlYXNvbikge1xyXG4gIGlmICghYXJnKSB7XHJcbiAgICB0aHJvdyBuZ01pbkVycignYXJlcScsIFwiQXJndW1lbnQgJ3swfScgaXMgezF9XCIsIChuYW1lIHx8ICc/JyksIChyZWFzb24gfHwgXCJyZXF1aXJlZFwiKSk7XHJcbiAgfVxyXG4gIHJldHVybiBhcmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzc2VydEFyZ0ZuKGFyZywgbmFtZSwgYWNjZXB0QXJyYXlBbm5vdGF0aW9uKSB7XHJcbiAgaWYgKGFjY2VwdEFycmF5QW5ub3RhdGlvbiAmJiBpc0FycmF5KGFyZykpIHtcclxuICAgICAgYXJnID0gYXJnW2FyZy5sZW5ndGggLSAxXTtcclxuICB9XHJcblxyXG4gIGFzc2VydEFyZyhpc0Z1bmN0aW9uKGFyZyksIG5hbWUsICdub3QgYSBmdW5jdGlvbiwgZ290ICcgK1xyXG4gICAgICAoYXJnICYmIHR5cGVvZiBhcmcgPT0gJ29iamVjdCcgPyBhcmcuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JyA6IHR5cGVvZiBhcmcpKTtcclxuICByZXR1cm4gYXJnO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSB2YWx1ZSBhY2Nlc3NpYmxlIGZyb20gdGhlIG9iamVjdCBieSBwYXRoLiBBbnkgdW5kZWZpbmVkIHRyYXZlcnNhbHMgYXJlIGlnbm9yZWRcclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBzdGFydGluZyBvYmplY3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byB0cmF2ZXJzZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49dHJ1ZX0gYmluZEZuVG9TY29wZVxyXG4gKiBAcmV0dXJucyB2YWx1ZSBhcyBhY2Nlc3NpYmxlIGJ5IHBhdGhcclxuICovXHJcbi8vVE9ETyhtaXNrbyk6IHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmVtb3ZlZFxyXG5mdW5jdGlvbiBnZXR0ZXIob2JqLCBwYXRoLCBiaW5kRm5Ub1Njb3BlKSB7XHJcbiAgaWYgKCFwYXRoKSByZXR1cm4gb2JqO1xyXG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gIHZhciBrZXk7XHJcbiAgdmFyIGxhc3RJbnN0YW5jZSA9IG9iajtcclxuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGtleSA9IGtleXNbaV07XHJcbiAgICBpZiAob2JqKSB7XHJcbiAgICAgIG9iaiA9IChsYXN0SW5zdGFuY2UgPSBvYmopW2tleV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghYmluZEZuVG9TY29wZSAmJiBpc0Z1bmN0aW9uKG9iaikpIHtcclxuICAgIHJldHVybiBiaW5kKGxhc3RJbnN0YW5jZSwgb2JqKTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBpbnRlcmZhY2VcclxuICogQG5hbWUgYW5ndWxhci5Nb2R1bGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIEludGVyZmFjZSBmb3IgY29uZmlndXJpbmcgYW5ndWxhciB7QGxpbmsgYW5ndWxhci5tb2R1bGUgbW9kdWxlc30uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2V0dXBNb2R1bGVMb2FkZXIod2luZG93KSB7XHJcblxyXG4gIGZ1bmN0aW9uIGVuc3VyZShvYmosIG5hbWUsIGZhY3RvcnkpIHtcclxuICAgIHJldHVybiBvYmpbbmFtZV0gfHwgKG9ialtuYW1lXSA9IGZhY3RvcnkoKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZW5zdXJlKGVuc3VyZSh3aW5kb3csICdhbmd1bGFyJywgT2JqZWN0KSwgJ21vZHVsZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgYW5ndWxhci5Nb2R1bGU+fSAqL1xyXG4gICAgdmFyIG1vZHVsZXMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgYW5ndWxhci5tb2R1bGVcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIFRoZSBgYW5ndWxhci5tb2R1bGVgIGlzIGEgZ2xvYmFsIHBsYWNlIGZvciBjcmVhdGluZywgcmVnaXN0ZXJpbmcgYW5kIHJldHJpZXZpbmcgQW5ndWxhciBtb2R1bGVzLlxyXG4gICAgICogQWxsIG1vZHVsZXMgKGFuZ3VsYXIgY29yZSBvciAzcmQgcGFydHkpIHRoYXQgc2hvdWxkIGJlIGF2YWlsYWJsZSB0byBhbiBhcHBsaWNhdGlvbiBtdXN0IGJlXHJcbiAgICAgKiByZWdpc3RlcmVkIHVzaW5nIHRoaXMgbWVjaGFuaXNtLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gcGFzc2VkIHR3byBvciBtb3JlIGFyZ3VtZW50cywgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQuICBJZiBwYXNzZWQgb25seSBvbmUgYXJndW1lbnQsIGFuXHJcbiAgICAgKiBleGlzdGluZyBtb2R1bGUgKHRoZSBuYW1lIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYG1vZHVsZWApIGlzIHJldHJpZXZlZC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogIyBNb2R1bGVcclxuICAgICAqXHJcbiAgICAgKiBBIG1vZHVsZSBpcyBhIGNvbGxlY3Rpb24gb2Ygc2VydmljZXMsIGRpcmVjdGl2ZXMsIGZpbHRlcnMsIGFuZCBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uLlxyXG4gICAgICogYGFuZ3VsYXIubW9kdWxlYCBpcyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0uXHJcbiAgICAgKlxyXG4gICAgICogPHByZT5cclxuICAgICAqIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGVcclxuICAgICAqIHZhciBteU1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdteU1vZHVsZScsIFtdKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyByZWdpc3RlciBhIG5ldyBzZXJ2aWNlXHJcbiAgICAgKiBteU1vZHVsZS52YWx1ZSgnYXBwTmFtZScsICdNeUNvb2xBcHAnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjb25maWd1cmUgZXhpc3Rpbmcgc2VydmljZXMgaW5zaWRlIGluaXRpYWxpemF0aW9uIGJsb2Nrcy5cclxuICAgICAqIG15TW9kdWxlLmNvbmZpZyhmdW5jdGlvbigkbG9jYXRpb25Qcm92aWRlcikge1xyXG4gICAgICogICAvLyBDb25maWd1cmUgZXhpc3RpbmcgcHJvdmlkZXJzXHJcbiAgICAgKiAgICRsb2NhdGlvblByb3ZpZGVyLmhhc2hQcmVmaXgoJyEnKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKlxyXG4gICAgICogVGhlbiB5b3UgY2FuIGNyZWF0ZSBhbiBpbmplY3RvciBhbmQgbG9hZCB5b3VyIG1vZHVsZXMgbGlrZSB0aGlzOlxyXG4gICAgICpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBhbmd1bGFyLmluamVjdG9yKFsnbmcnLCAnTXlNb2R1bGUnXSlcclxuICAgICAqIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIEhvd2V2ZXIgaXQncyBtb3JlIGxpa2VseSB0aGF0IHlvdSdsbCBqdXN0IHVzZVxyXG4gICAgICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0FwcCBuZ0FwcH0gb3JcclxuICAgICAqIHtAbGluayBhbmd1bGFyLmJvb3RzdHJhcH0gdG8gc2ltcGxpZnkgdGhpcyBwcm9jZXNzIGZvciB5b3UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBtb2R1bGUgdG8gY3JlYXRlIG9yIHJldHJpZXZlLlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPj19IHJlcXVpcmVzIElmIHNwZWNpZmllZCB0aGVuIG5ldyBtb2R1bGUgaXMgYmVpbmcgY3JlYXRlZC4gSWYgdW5zcGVjaWZpZWQgdGhlbiB0aGVcclxuICAgICAqICAgICAgICB0aGUgbW9kdWxlIGlzIGJlaW5nIHJldHJpZXZlZCBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnRm4gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmdW5jdGlvbiBmb3IgdGhlIG1vZHVsZS4gU2FtZSBhc1xyXG4gICAgICogICAgICAgIHtAbGluayBhbmd1bGFyLk1vZHVsZSNjb25maWcgTW9kdWxlI2NvbmZpZygpfS5cclxuICAgICAqIEByZXR1cm5zIHttb2R1bGV9IG5ldyBtb2R1bGUgd2l0aCB0aGUge0BsaW5rIGFuZ3VsYXIuTW9kdWxlfSBhcGkuXHJcbiAgICAgKi9cclxuICAgIHJldHVybiBmdW5jdGlvbiBtb2R1bGUobmFtZSwgcmVxdWlyZXMsIGNvbmZpZ0ZuKSB7XHJcbiAgICAgIGlmIChyZXF1aXJlcyAmJiBtb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgbW9kdWxlc1tuYW1lXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGVuc3VyZShtb2R1bGVzLCBuYW1lLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXJlcXVpcmVzKSB7XHJcbiAgICAgICAgICB0aHJvdyBtaW5FcnIoJyRpbmplY3RvcicpKCdub21vZCcsIFwiTW9kdWxlICd7MH0nIGlzIG5vdCBhdmFpbGFibGUhIFlvdSBlaXRoZXIgbWlzc3BlbGxlZCB0aGUgbW9kdWxlIG5hbWUgXCIgK1xyXG4gICAgICAgICAgICAgIFwib3IgZm9yZ290IHRvIGxvYWQgaXQuIElmIHJlZ2lzdGVyaW5nIGEgbW9kdWxlIGVuc3VyZSB0aGF0IHlvdSBzcGVjaWZ5IHRoZSBkZXBlbmRlbmNpZXMgYXMgdGhlIHNlY29uZCBcIiArXHJcbiAgICAgICAgICAgICAgXCJhcmd1bWVudC5cIiwgbmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiogQHR5cGUgeyFBcnJheS48QXJyYXkuPCo+Pn0gKi9cclxuICAgICAgICB2YXIgaW52b2tlUXVldWUgPSBbXTtcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXkuPEZ1bmN0aW9uPn0gKi9cclxuICAgICAgICB2YXIgcnVuQmxvY2tzID0gW107XHJcblxyXG4gICAgICAgIHZhciBjb25maWcgPSBpbnZva2VMYXRlcignJGluamVjdG9yJywgJ2ludm9rZScpO1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge2FuZ3VsYXIuTW9kdWxlfSAqL1xyXG4gICAgICAgIHZhciBtb2R1bGVJbnN0YW5jZSA9IHtcclxuICAgICAgICAgIC8vIFByaXZhdGUgc3RhdGVcclxuICAgICAgICAgIF9pbnZva2VRdWV1ZTogaW52b2tlUXVldWUsXHJcbiAgICAgICAgICBfcnVuQmxvY2tzOiBydW5CbG9ja3MsXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgcHJvcGVydHlcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI3JlcXVpcmVzXHJcbiAgICAgICAgICAgKiBAcHJvcGVydHlPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBMaXN0IG9mIG1vZHVsZSBuYW1lcyB3aGljaCBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgdGhpcyBtb2R1bGUuXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqIEhvbGRzIHRoZSBsaXN0IG9mIG1vZHVsZXMgd2hpY2ggdGhlIGluamVjdG9yIHdpbGwgbG9hZCBiZWZvcmUgdGhlIGN1cnJlbnQgbW9kdWxlIGlzIGxvYWRlZC5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgcmVxdWlyZXM6IHJlcXVpcmVzLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIHByb3BlcnR5XHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNuYW1lXHJcbiAgICAgICAgICAgKiBAcHJvcGVydHlPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gTmFtZSBvZiB0aGUgbW9kdWxlLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIG5hbWU6IG5hbWUsXHJcblxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjcHJvdmlkZXJcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VydmljZSBuYW1lXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm92aWRlclR5cGUgQ29uc3RydWN0aW9uIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgdGhlIHNlcnZpY2UuXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNwcm92aWRlciAkcHJvdmlkZS5wcm92aWRlcigpfS5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgcHJvdmlkZXI6IGludm9rZUxhdGVyKCckcHJvdmlkZScsICdwcm92aWRlcicpLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjZmFjdG9yeVxyXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBzZXJ2aWNlIG5hbWVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3ZpZGVyRnVuY3Rpb24gRnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZSBvZiB0aGUgc2VydmljZS5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICogU2VlIHtAbGluayBBVVRPLiRwcm92aWRlI2ZhY3RvcnkgJHByb3ZpZGUuZmFjdG9yeSgpfS5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgZmFjdG9yeTogaW52b2tlTGF0ZXIoJyRwcm92aWRlJywgJ2ZhY3RvcnknKSxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI3NlcnZpY2VcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VydmljZSBuYW1lXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBBIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnN0YW50aWF0ZWQuXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNzZXJ2aWNlICRwcm92aWRlLnNlcnZpY2UoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHNlcnZpY2U6IGludm9rZUxhdGVyKCckcHJvdmlkZScsICdzZXJ2aWNlJyksXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSN2YWx1ZVxyXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBzZXJ2aWNlIG5hbWVcclxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFNlcnZpY2UgaW5zdGFuY2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIEFVVE8uJHByb3ZpZGUjdmFsdWUgJHByb3ZpZGUudmFsdWUoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHZhbHVlOiBpbnZva2VMYXRlcignJHByb3ZpZGUnLCAndmFsdWUnKSxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2NvbnN0YW50XHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbnN0YW50IG5hbWVcclxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IENvbnN0YW50IHZhbHVlLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBCZWNhdXNlIHRoZSBjb25zdGFudCBhcmUgZml4ZWQsIHRoZXkgZ2V0IGFwcGxpZWQgYmVmb3JlIG90aGVyIHByb3ZpZGUgbWV0aG9kcy5cclxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNjb25zdGFudCAkcHJvdmlkZS5jb25zdGFudCgpfS5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgY29uc3RhbnQ6IGludm9rZUxhdGVyKCckcHJvdmlkZScsICdjb25zdGFudCcsICd1bnNoaWZ0JyksXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNhbmltYXRpb25cclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgYW5pbWF0aW9uIG5hbWVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFuaW1hdGlvbkZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIGFuIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqICoqTk9URSoqOiBhbmltYXRpb25zIGFyZSB0YWtlIGVmZmVjdCBvbmx5IGlmIHRoZSAqKm5nQW5pbWF0ZSoqIG1vZHVsZSBpcyBsb2FkZWQuXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIERlZmluZXMgYW4gYW5pbWF0aW9uIGhvb2sgdGhhdCBjYW4gYmUgbGF0ZXIgdXNlZCB3aXRoIHtAbGluayBuZ0FuaW1hdGUuJGFuaW1hdGUgJGFuaW1hdGV9IHNlcnZpY2UgYW5kXHJcbiAgICAgICAgICAgKiBkaXJlY3RpdmVzIHRoYXQgdXNlIHRoaXMgc2VydmljZS5cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiA8cHJlPlxyXG4gICAgICAgICAgICogbW9kdWxlLmFuaW1hdGlvbignLmFuaW1hdGlvbi1uYW1lJywgZnVuY3Rpb24oJGluamVjdDEsICRpbmplY3QyKSB7XHJcbiAgICAgICAgICAgKiAgIHJldHVybiB7XHJcbiAgICAgICAgICAgKiAgICAgZXZlbnROYW1lIDogZnVuY3Rpb24oZWxlbWVudCwgZG9uZSkge1xyXG4gICAgICAgICAgICogICAgICAgLy9jb2RlIHRvIHJ1biB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgKiAgICAgICAvL29uY2UgY29tcGxldGUsIHRoZW4gcnVuIGRvbmUoKVxyXG4gICAgICAgICAgICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbGxhdGlvbkZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAqICAgICAgICAgLy9jb2RlIHRvIGNhbmNlbCB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgKiAgICAgICB9XHJcbiAgICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAgICogICB9XHJcbiAgICAgICAgICAgKiB9KVxyXG4gICAgICAgICAgICogPC9wcmU+XHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogU2VlIHtAbGluayBuZ0FuaW1hdGUuJGFuaW1hdGVQcm92aWRlciNyZWdpc3RlciAkYW5pbWF0ZVByb3ZpZGVyLnJlZ2lzdGVyKCl9IGFuZFxyXG4gICAgICAgICAgICoge0BsaW5rIG5nQW5pbWF0ZSBuZ0FuaW1hdGUgbW9kdWxlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgYW5pbWF0aW9uOiBpbnZva2VMYXRlcignJGFuaW1hdGVQcm92aWRlcicsICdyZWdpc3RlcicpLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjZmlsdGVyXHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpbHRlciBuYW1lLlxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyRmFjdG9yeSBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgZmlsdGVyLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIG5nLiRmaWx0ZXJQcm92aWRlciNyZWdpc3RlciAkZmlsdGVyUHJvdmlkZXIucmVnaXN0ZXIoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGZpbHRlcjogaW52b2tlTGF0ZXIoJyRmaWx0ZXJQcm92aWRlcicsICdyZWdpc3RlcicpLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjY29udHJvbGxlclxyXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDb250cm9sbGVyIG5hbWUuXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDb250cm9sbGVyIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIG5nLiRjb250cm9sbGVyUHJvdmlkZXIjcmVnaXN0ZXIgJGNvbnRyb2xsZXJQcm92aWRlci5yZWdpc3RlcigpfS5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgY29udHJvbGxlcjogaW52b2tlTGF0ZXIoJyRjb250cm9sbGVyUHJvdmlkZXInLCAncmVnaXN0ZXInKSxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2RpcmVjdGl2ZVxyXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBkaXJlY3RpdmUgbmFtZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlyZWN0aXZlRmFjdG9yeSBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2ZcclxuICAgICAgICAgICAqIGRpcmVjdGl2ZXMuXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlciNkaXJlY3RpdmUgJGNvbXBpbGVQcm92aWRlci5kaXJlY3RpdmUoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGRpcmVjdGl2ZTogaW52b2tlTGF0ZXIoJyRjb21waWxlUHJvdmlkZXInLCAnZGlyZWN0aXZlJyksXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNjb25maWdcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnRm4gRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIG9uIG1vZHVsZSBsb2FkLiBVc2VmdWwgZm9yIHNlcnZpY2VcclxuICAgICAgICAgICAqICAgIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byByZWdpc3RlciB3b3JrIHdoaWNoIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCBvbiBtb2R1bGUgbG9hZGluZy5cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgY29uZmlnOiBjb25maWcsXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNydW5cclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5pdGlhbGl6YXRpb25GbiBFeGVjdXRlIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgaW5qZWN0b3IgY3JlYXRpb24uXHJcbiAgICAgICAgICAgKiAgICBVc2VmdWwgZm9yIGFwcGxpY2F0aW9uIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVnaXN0ZXIgd29yayB3aGljaCBzaG91bGQgYmUgcGVyZm9ybWVkIHdoZW4gdGhlIGluamVjdG9yIGlzIGRvbmVcclxuICAgICAgICAgICAqIGxvYWRpbmcgYWxsIG1vZHVsZXMuXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHJ1bjogZnVuY3Rpb24oYmxvY2spIHtcclxuICAgICAgICAgICAgcnVuQmxvY2tzLnB1c2goYmxvY2spO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnRm4pIHtcclxuICAgICAgICAgIGNvbmZpZyhjb25maWdGbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gIG1vZHVsZUluc3RhbmNlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdmlkZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmc9fSBpbnNlcnRNZXRob2RcclxuICAgICAgICAgKiBAcmV0dXJucyB7YW5ndWxhci5Nb2R1bGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlTGF0ZXIocHJvdmlkZXIsIG1ldGhvZCwgaW5zZXJ0TWV0aG9kKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGludm9rZVF1ZXVlW2luc2VydE1ldGhvZCB8fCAncHVzaCddKFtwcm92aWRlciwgbWV0aG9kLCBhcmd1bWVudHNdKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUluc3RhbmNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gKiBAbmFtZSBhbmd1bGFyLnZlcnNpb25cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IEFuZ3VsYXJKUyB2ZXJzaW9uLiBUaGlzIG9iamVjdCBoYXMgdGhlXHJcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAtIGBmdWxsYCDDouKCrOKAnCBge3N0cmluZ31gIMOi4oKs4oCcIEZ1bGwgdmVyc2lvbiBzdHJpbmcsIHN1Y2ggYXMgXCIwLjkuMThcIi5cclxuICogLSBgbWFqb3JgIMOi4oKs4oCcIGB7bnVtYmVyfWAgw6LigqzigJwgTWFqb3IgdmVyc2lvbiBudW1iZXIsIHN1Y2ggYXMgXCIwXCIuXHJcbiAqIC0gYG1pbm9yYCDDouKCrOKAnCBge251bWJlcn1gIMOi4oKs4oCcIE1pbm9yIHZlcnNpb24gbnVtYmVyLCBzdWNoIGFzIFwiOVwiLlxyXG4gKiAtIGBkb3RgIMOi4oKs4oCcIGB7bnVtYmVyfWAgw6LigqzigJwgRG90IHZlcnNpb24gbnVtYmVyLCBzdWNoIGFzIFwiMThcIi5cclxuICogLSBgY29kZU5hbWVgIMOi4oKs4oCcIGB7c3RyaW5nfWAgw6LigqzigJwgQ29kZSBuYW1lIG9mIHRoZSByZWxlYXNlLCBzdWNoIGFzIFwiamlnZ2xpbmctYXJtZmF0XCIuXHJcbiAqL1xyXG52YXIgdmVyc2lvbiA9IHtcclxuICBmdWxsOiAnMS4yLjAtcmMuMicsICAgIC8vIGFsbCBvZiB0aGVzZSBwbGFjZWhvbGRlciBzdHJpbmdzIHdpbGwgYmUgcmVwbGFjZWQgYnkgZ3J1bnQnc1xyXG4gIG1ham9yOiAxLCAgICAvLyBwYWNrYWdlIHRhc2tcclxuICBtaW5vcjogMixcclxuICBkb3Q6IDAsXHJcbiAgY29kZU5hbWU6ICdiYXJlaGFuZC1hdG9tc3BsaXR0aW5nJ1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIHB1Ymxpc2hFeHRlcm5hbEFQSShhbmd1bGFyKXtcclxuICBleHRlbmQoYW5ndWxhciwge1xyXG4gICAgJ2Jvb3RzdHJhcCc6IGJvb3RzdHJhcCxcclxuICAgICdjb3B5JzogY29weSxcclxuICAgICdleHRlbmQnOiBleHRlbmQsXHJcbiAgICAnZXF1YWxzJzogZXF1YWxzLFxyXG4gICAgJ2VsZW1lbnQnOiBqcUxpdGUsXHJcbiAgICAnZm9yRWFjaCc6IGZvckVhY2gsXHJcbiAgICAnaW5qZWN0b3InOiBjcmVhdGVJbmplY3RvcixcclxuICAgICdub29wJzpub29wLFxyXG4gICAgJ2JpbmQnOmJpbmQsXHJcbiAgICAndG9Kc29uJzogdG9Kc29uLFxyXG4gICAgJ2Zyb21Kc29uJzogZnJvbUpzb24sXHJcbiAgICAnaWRlbnRpdHknOmlkZW50aXR5LFxyXG4gICAgJ2lzVW5kZWZpbmVkJzogaXNVbmRlZmluZWQsXHJcbiAgICAnaXNEZWZpbmVkJzogaXNEZWZpbmVkLFxyXG4gICAgJ2lzU3RyaW5nJzogaXNTdHJpbmcsXHJcbiAgICAnaXNGdW5jdGlvbic6IGlzRnVuY3Rpb24sXHJcbiAgICAnaXNPYmplY3QnOiBpc09iamVjdCxcclxuICAgICdpc051bWJlcic6IGlzTnVtYmVyLFxyXG4gICAgJ2lzRWxlbWVudCc6IGlzRWxlbWVudCxcclxuICAgICdpc0FycmF5JzogaXNBcnJheSxcclxuICAgICckJG1pbkVycic6IG1pbkVycixcclxuICAgICd2ZXJzaW9uJzogdmVyc2lvbixcclxuICAgICdpc0RhdGUnOiBpc0RhdGUsXHJcbiAgICAnbG93ZXJjYXNlJzogbG93ZXJjYXNlLFxyXG4gICAgJ3VwcGVyY2FzZSc6IHVwcGVyY2FzZSxcclxuICAgICdjYWxsYmFja3MnOiB7Y291bnRlcjogMH1cclxuICB9KTtcclxuXHJcbiAgYW5ndWxhck1vZHVsZSA9IHNldHVwTW9kdWxlTG9hZGVyKHdpbmRvdyk7XHJcbiAgdHJ5IHtcclxuICAgIGFuZ3VsYXJNb2R1bGUoJ25nTG9jYWxlJyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgYW5ndWxhck1vZHVsZSgnbmdMb2NhbGUnLCBbXSkucHJvdmlkZXIoJyRsb2NhbGUnLCAkTG9jYWxlUHJvdmlkZXIpO1xyXG4gIH1cclxuXHJcbiAgYW5ndWxhck1vZHVsZSgnbmcnLCBbJ25nTG9jYWxlJ10sIFsnJHByb3ZpZGUnLFxyXG4gICAgZnVuY3Rpb24gbmdNb2R1bGUoJHByb3ZpZGUpIHtcclxuICAgICAgJHByb3ZpZGUucHJvdmlkZXIoJyRjb21waWxlJywgJENvbXBpbGVQcm92aWRlcikuXHJcbiAgICAgICAgZGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgYTogaHRtbEFuY2hvckRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0RGlyZWN0aXZlLFxyXG4gICAgICAgICAgICB0ZXh0YXJlYTogaW5wdXREaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIGZvcm06IGZvcm1EaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIHNjcmlwdDogc2NyaXB0RGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBzZWxlY3Q6IHNlbGVjdERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBvcHRpb246IG9wdGlvbkRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdCaW5kOiBuZ0JpbmREaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQmluZEh0bWw6IG5nQmluZEh0bWxEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQmluZFRlbXBsYXRlOiBuZ0JpbmRUZW1wbGF0ZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdDbGFzczogbmdDbGFzc0RpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdDbGFzc0V2ZW46IG5nQ2xhc3NFdmVuRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0NsYXNzT2RkOiBuZ0NsYXNzT2RkRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0NzcDogbmdDc3BEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQ2xvYWs6IG5nQ2xvYWtEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQ29udHJvbGxlcjogbmdDb250cm9sbGVyRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0Zvcm06IG5nRm9ybURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdIaWRlOiBuZ0hpZGVEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nSWY6IG5nSWZEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nSW5jbHVkZTogbmdJbmNsdWRlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0luaXQ6IG5nSW5pdERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdOb25CaW5kYWJsZTogbmdOb25CaW5kYWJsZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdQbHVyYWxpemU6IG5nUGx1cmFsaXplRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1JlcGVhdDogbmdSZXBlYXREaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nU2hvdzogbmdTaG93RGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1N0eWxlOiBuZ1N0eWxlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1N3aXRjaDogbmdTd2l0Y2hEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nU3dpdGNoV2hlbjogbmdTd2l0Y2hXaGVuRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1N3aXRjaERlZmF1bHQ6IG5nU3dpdGNoRGVmYXVsdERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdPcHRpb25zOiBuZ09wdGlvbnNEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nVHJhbnNjbHVkZTogbmdUcmFuc2NsdWRlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ01vZGVsOiBuZ01vZGVsRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0xpc3Q6IG5nTGlzdERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdDaGFuZ2U6IG5nQ2hhbmdlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWREaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nUmVxdWlyZWQ6IHJlcXVpcmVkRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1ZhbHVlOiBuZ1ZhbHVlRGlyZWN0aXZlXHJcbiAgICAgICAgfSkuXHJcbiAgICAgICAgZGlyZWN0aXZlKG5nQXR0cmlidXRlQWxpYXNEaXJlY3RpdmVzKS5cclxuICAgICAgICBkaXJlY3RpdmUobmdFdmVudERpcmVjdGl2ZXMpO1xyXG4gICAgICAkcHJvdmlkZS5wcm92aWRlcih7XHJcbiAgICAgICAgJGFuY2hvclNjcm9sbDogJEFuY2hvclNjcm9sbFByb3ZpZGVyLFxyXG4gICAgICAgICRhbmltYXRlOiAkQW5pbWF0ZVByb3ZpZGVyLFxyXG4gICAgICAgICRicm93c2VyOiAkQnJvd3NlclByb3ZpZGVyLFxyXG4gICAgICAgICRjYWNoZUZhY3Rvcnk6ICRDYWNoZUZhY3RvcnlQcm92aWRlcixcclxuICAgICAgICAkY29udHJvbGxlcjogJENvbnRyb2xsZXJQcm92aWRlcixcclxuICAgICAgICAkZG9jdW1lbnQ6ICREb2N1bWVudFByb3ZpZGVyLFxyXG4gICAgICAgICRleGNlcHRpb25IYW5kbGVyOiAkRXhjZXB0aW9uSGFuZGxlclByb3ZpZGVyLFxyXG4gICAgICAgICRmaWx0ZXI6ICRGaWx0ZXJQcm92aWRlcixcclxuICAgICAgICAkaW50ZXJwb2xhdGU6ICRJbnRlcnBvbGF0ZVByb3ZpZGVyLFxyXG4gICAgICAgICRodHRwOiAkSHR0cFByb3ZpZGVyLFxyXG4gICAgICAgICRodHRwQmFja2VuZDogJEh0dHBCYWNrZW5kUHJvdmlkZXIsXHJcbiAgICAgICAgJGxvY2F0aW9uOiAkTG9jYXRpb25Qcm92aWRlcixcclxuICAgICAgICAkbG9nOiAkTG9nUHJvdmlkZXIsXHJcbiAgICAgICAgJHBhcnNlOiAkUGFyc2VQcm92aWRlcixcclxuICAgICAgICAkcm9vdFNjb3BlOiAkUm9vdFNjb3BlUHJvdmlkZXIsXHJcbiAgICAgICAgJHE6ICRRUHJvdmlkZXIsXHJcbiAgICAgICAgJHNjZTogJFNjZVByb3ZpZGVyLFxyXG4gICAgICAgICRzY2VEZWxlZ2F0ZTogJFNjZURlbGVnYXRlUHJvdmlkZXIsXHJcbiAgICAgICAgJHNuaWZmZXI6ICRTbmlmZmVyUHJvdmlkZXIsXHJcbiAgICAgICAgJHRlbXBsYXRlQ2FjaGU6ICRUZW1wbGF0ZUNhY2hlUHJvdmlkZXIsXHJcbiAgICAgICAgJHRpbWVvdXQ6ICRUaW1lb3V0UHJvdmlkZXIsXHJcbiAgICAgICAgJHdpbmRvdzogJFdpbmRvd1Byb3ZpZGVyLFxyXG4gICAgICAgICQkdXJsVXRpbHM6ICQkVXJsVXRpbHNQcm92aWRlclxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vL0pRTGl0ZVxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuZWxlbWVudFxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFdyYXBzIGEgcmF3IERPTSBlbGVtZW50IG9yIEhUTUwgc3RyaW5nIGFzIGEgW2pRdWVyeV0oaHR0cDovL2pxdWVyeS5jb20pIGVsZW1lbnQuXHJcbiAqIGBhbmd1bGFyLmVsZW1lbnRgIGNhbiBiZSBlaXRoZXIgYW4gYWxpYXMgZm9yIFtqUXVlcnldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkvKSBmdW5jdGlvbiwgaWZcclxuICogalF1ZXJ5IGlzIGF2YWlsYWJsZSwgb3IgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBlbGVtZW50IG9yIHN0cmluZyBpbiBBbmd1bGFyJ3MgalF1ZXJ5IGxpdGVcclxuICogaW1wbGVtZW50YXRpb24gKGNvbW1vbmx5IHJlZmVycmVkIHRvIGFzIGpxTGl0ZSkuXHJcbiAqXHJcbiAqIFJlYWwgalF1ZXJ5IGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIganFMaXRlLCBwcm92aWRlZCBpdCB3YXMgbG9hZGVkIGJlZm9yZSBgRE9NQ29udGVudExvYWRlZGBcclxuICogZXZlbnQgZmlyZWQuXHJcbiAqXHJcbiAqIGpxTGl0ZSBpcyBhIHRpbnksIEFQSS1jb21wYXRpYmxlIHN1YnNldCBvZiBqUXVlcnkgdGhhdCBhbGxvd3NcclxuICogQW5ndWxhciB0byBtYW5pcHVsYXRlIHRoZSBET00uIGpxTGl0ZSBpbXBsZW1lbnRzIG9ubHkgdGhlIG1vc3QgY29tbW9ubHkgbmVlZGVkIGZ1bmN0aW9uYWxpdHlcclxuICogd2l0aGluIGEgdmVyeSBzbWFsbCBmb290cHJpbnQsIHNvIG9ubHkgYSBzdWJzZXQgb2YgdGhlIGpRdWVyeSBBUEkgLSBtZXRob2RzLCBhcmd1bWVudHMgYW5kXHJcbiAqIGludm9jYXRpb24gc3R5bGVzIC0gYXJlIHN1cHBvcnRlZC5cclxuICpcclxuICogTm90ZTogQWxsIGVsZW1lbnQgcmVmZXJlbmNlcyBpbiBBbmd1bGFyIGFyZSBhbHdheXMgd3JhcHBlZCB3aXRoIGpRdWVyeSBvciBqcUxpdGU7IHRoZXkgYXJlIG5ldmVyXHJcbiAqIHJhdyBET00gcmVmZXJlbmNlcy5cclxuICpcclxuICogIyMgQW5ndWxhcidzIGpxTGl0ZVxyXG4gKiBBbmd1bGFyJ3MgbGl0ZSB2ZXJzaW9uIG9mIGpRdWVyeSBwcm92aWRlcyBvbmx5IHRoZSBmb2xsb3dpbmcgalF1ZXJ5IG1ldGhvZHM6XHJcbiAqXHJcbiAqIC0gW2FkZENsYXNzKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9hZGRDbGFzcy8pXHJcbiAqIC0gW2FmdGVyKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9hZnRlci8pXHJcbiAqIC0gW2FwcGVuZCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vYXBwZW5kLylcclxuICogLSBbYXR0cigpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vYXR0ci8pXHJcbiAqIC0gW2JpbmQoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL29uLykgLSBEb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMsIHNlbGVjdG9ycyBvciBldmVudERhdGFcclxuICogLSBbY2hpbGRyZW4oKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2NoaWxkcmVuLykgLSBEb2VzIG5vdCBzdXBwb3J0IHNlbGVjdG9yc1xyXG4gKiAtIFtjbG9uZSgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vY2xvbmUvKVxyXG4gKiAtIFtjb250ZW50cygpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vY29udGVudHMvKVxyXG4gKiAtIFtjc3MoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2Nzcy8pXHJcbiAqIC0gW2RhdGEoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2RhdGEvKVxyXG4gKiAtIFtlcSgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vZXEvKVxyXG4gKiAtIFtmaW5kKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9maW5kLykgLSBMaW1pdGVkIHRvIGxvb2t1cHMgYnkgdGFnIG5hbWVcclxuICogLSBbaGFzQ2xhc3MoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2hhc0NsYXNzLylcclxuICogLSBbaHRtbCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vaHRtbC8pXHJcbiAqIC0gW25leHQoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL25leHQvKSAtIERvZXMgbm90IHN1cHBvcnQgc2VsZWN0b3JzXHJcbiAqIC0gW29uKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vbi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzLCBzZWxlY3RvcnMgb3IgZXZlbnREYXRhXHJcbiAqIC0gW29mZigpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vb2ZmLykgLSBEb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMgb3Igc2VsZWN0b3JzXHJcbiAqIC0gW3BhcmVudCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcGFyZW50LykgLSBEb2VzIG5vdCBzdXBwb3J0IHNlbGVjdG9yc1xyXG4gKiAtIFtwcmVwZW5kKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9wcmVwZW5kLylcclxuICogLSBbcHJvcCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcHJvcC8pXHJcbiAqIC0gW3JlYWR5KCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9yZWFkeS8pXHJcbiAqIC0gW3JlbW92ZSgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVtb3ZlLylcclxuICogLSBbcmVtb3ZlQXR0cigpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVtb3ZlQXR0ci8pXHJcbiAqIC0gW3JlbW92ZUNsYXNzKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9yZW1vdmVDbGFzcy8pXHJcbiAqIC0gW3JlbW92ZURhdGEoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlbW92ZURhdGEvKVxyXG4gKiAtIFtyZXBsYWNlV2l0aCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVwbGFjZVdpdGgvKVxyXG4gKiAtIFt0ZXh0KCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS90ZXh0LylcclxuICogLSBbdG9nZ2xlQ2xhc3MoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3RvZ2dsZUNsYXNzLylcclxuICogLSBbdHJpZ2dlckhhbmRsZXIoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3RyaWdnZXJIYW5kbGVyLykgLSBQYXNzZXMgYSBkdW1teSBldmVudCBvYmplY3QgdG8gaGFuZGxlcnMuXHJcbiAqIC0gW3VuYmluZCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vb2ZmLykgLSBEb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXNcclxuICogLSBbdmFsKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS92YWwvKVxyXG4gKiAtIFt3cmFwKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS93cmFwLylcclxuICpcclxuICogIyMgalF1ZXJ5L2pxTGl0ZSBFeHRyYXNcclxuICogQW5ndWxhciBhbHNvIHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBtZXRob2RzIGFuZCBldmVudHMgdG8gYm90aCBqUXVlcnkgYW5kIGpxTGl0ZTpcclxuICpcclxuICogIyMjIEV2ZW50c1xyXG4gKiAtIGAkZGVzdHJveWAgLSBBbmd1bGFySlMgaW50ZXJjZXB0cyBhbGwganFMaXRlL2pRdWVyeSdzIERPTSBkZXN0cnVjdGlvbiBhcGlzIGFuZCBmaXJlcyB0aGlzIGV2ZW50XHJcbiAqICAgIG9uIGFsbCBET00gbm9kZXMgYmVpbmcgcmVtb3ZlZC4gIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2xlYW4gdXAgYW5kIDNyZCBwYXJ0eSBiaW5kaW5ncyB0byB0aGUgRE9NXHJcbiAqICAgIGVsZW1lbnQgYmVmb3JlIGl0IGlzIHJlbW92ZWQuXHJcbiAqICMjIyBNZXRob2RzXHJcbiAqIC0gYGNvbnRyb2xsZXIobmFtZSlgIC0gcmV0cmlldmVzIHRoZSBjb250cm9sbGVyIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgb3IgaXRzIHBhcmVudC4gQnkgZGVmYXVsdFxyXG4gKiAgIHJldHJpZXZlcyBjb250cm9sbGVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgYG5nQ29udHJvbGxlcmAgZGlyZWN0aXZlLiBJZiBgbmFtZWAgaXMgcHJvdmlkZWQgYXNcclxuICogICBjYW1lbENhc2UgZGlyZWN0aXZlIG5hbWUsIHRoZW4gdGhlIGNvbnRyb2xsZXIgZm9yIHRoaXMgZGlyZWN0aXZlIHdpbGwgYmUgcmV0cmlldmVkIChlLmcuXHJcbiAqICAgYCduZ01vZGVsJ2ApLlxyXG4gKiAtIGBpbmplY3RvcigpYCAtIHJldHJpZXZlcyB0aGUgaW5qZWN0b3Igb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBvciBpdHMgcGFyZW50LlxyXG4gKiAtIGBzY29wZSgpYCAtIHJldHJpZXZlcyB0aGUge0BsaW5rIGFwaS9uZy4kcm9vdFNjb3BlLlNjb3BlIHNjb3BlfSBvZiB0aGUgY3VycmVudFxyXG4gKiAgIGVsZW1lbnQgb3IgaXRzIHBhcmVudC5cclxuICogLSBgaW5oZXJpdGVkRGF0YSgpYCAtIHNhbWUgYXMgYGRhdGEoKWAsIGJ1dCB3YWxrcyB1cCB0aGUgRE9NIHVudGlsIGEgdmFsdWUgaXMgZm91bmQgb3IgdGhlIHRvcFxyXG4gKiAgIHBhcmVudCBlbGVtZW50IGlzIHJlYWNoZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfERPTUVsZW1lbnR9IGVsZW1lbnQgSFRNTCBzdHJpbmcgb3IgRE9NRWxlbWVudCB0byBiZSB3cmFwcGVkIGludG8galF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBqUXVlcnkgb2JqZWN0LlxyXG4gKi9cclxuXHJcbnZhciBqcUNhY2hlID0gSlFMaXRlLmNhY2hlID0ge30sXHJcbiAgICBqcU5hbWUgPSBKUUxpdGUuZXhwYW5kbyA9ICduZy0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICBqcUlkID0gMSxcclxuICAgIGFkZEV2ZW50TGlzdGVuZXJGbiA9ICh3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgICA/IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7fVxyXG4gICAgICA6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7ZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO30pLFxyXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckZuID0gKHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyXHJcbiAgICAgID8gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgZm4pIHtlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTsgfVxyXG4gICAgICA6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7ZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pOyB9KTtcclxuXHJcbmZ1bmN0aW9uIGpxTmV4dElkKCkgeyByZXR1cm4gKytqcUlkOyB9XHJcblxyXG5cclxudmFyIFNQRUNJQUxfQ0hBUlNfUkVHRVhQID0gLyhbXFw6XFwtXFxfXSsoLikpL2c7XHJcbnZhciBNT1pfSEFDS19SRUdFWFAgPSAvXm1veihbQS1aXSkvO1xyXG52YXIganFMaXRlTWluRXJyID0gbWluRXJyKCdqcUxpdGUnKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIGNhbWVsQ2FzZS5cclxuICogQWxzbyB0aGVyZSBpcyBzcGVjaWFsIGNhc2UgZm9yIE1veiBwcmVmaXggc3RhcnRpbmcgd2l0aCB1cHBlciBjYXNlIGxldHRlci5cclxuICogQHBhcmFtIG5hbWUgTmFtZSB0byBub3JtYWxpemVcclxuICovXHJcbmZ1bmN0aW9uIGNhbWVsQ2FzZShuYW1lKSB7XHJcbiAgcmV0dXJuIG5hbWUuXHJcbiAgICByZXBsYWNlKFNQRUNJQUxfQ0hBUlNfUkVHRVhQLCBmdW5jdGlvbihfLCBzZXBhcmF0b3IsIGxldHRlciwgb2Zmc2V0KSB7XHJcbiAgICAgIHJldHVybiBvZmZzZXQgPyBsZXR0ZXIudG9VcHBlckNhc2UoKSA6IGxldHRlcjtcclxuICAgIH0pLlxyXG4gICAgcmVwbGFjZShNT1pfSEFDS19SRUdFWFAsICdNb3okMScpO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8galF1ZXJ5IG11dGF0aW9uIHBhdGNoXHJcbi8vXHJcbi8vIEluIGNvbmp1bmN0aW9uIHdpdGggYmluZEpRdWVyeSBpbnRlcmNlcHRzIGFsbCBqUXVlcnkncyBET00gZGVzdHJ1Y3Rpb24gYXBpcyBhbmQgZmlyZXMgYVxyXG4vLyAkZGVzdHJveSBldmVudCBvbiBhbGwgRE9NIG5vZGVzIGJlaW5nIHJlbW92ZWQuXHJcbi8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuZnVuY3Rpb24gSlFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUobmFtZSwgZGlzcGF0Y2hUaGlzLCBmaWx0ZXJFbGVtcywgZ2V0dGVySWZOb0FyZ3VtZW50cykge1xyXG4gIHZhciBvcmlnaW5hbEpxRm4gPSBqUXVlcnkuZm5bbmFtZV07XHJcbiAgb3JpZ2luYWxKcUZuID0gb3JpZ2luYWxKcUZuLiRvcmlnaW5hbCB8fCBvcmlnaW5hbEpxRm47XHJcbiAgcmVtb3ZlUGF0Y2guJG9yaWdpbmFsID0gb3JpZ2luYWxKcUZuO1xyXG4gIGpRdWVyeS5mbltuYW1lXSA9IHJlbW92ZVBhdGNoO1xyXG5cclxuICBmdW5jdGlvbiByZW1vdmVQYXRjaChwYXJhbSkge1xyXG4gICAgdmFyIGxpc3QgPSBmaWx0ZXJFbGVtcyAmJiBwYXJhbSA/IFt0aGlzLmZpbHRlcihwYXJhbSldIDogW3RoaXNdLFxyXG4gICAgICAgIGZpcmVFdmVudCA9IGRpc3BhdGNoVGhpcyxcclxuICAgICAgICBzZXQsIHNldEluZGV4LCBzZXRMZW5ndGgsXHJcbiAgICAgICAgZWxlbWVudCwgY2hpbGRJbmRleCwgY2hpbGRMZW5ndGgsIGNoaWxkcmVuO1xyXG5cclxuICAgIGlmICghZ2V0dGVySWZOb0FyZ3VtZW50cyB8fCBwYXJhbSAhPSBudWxsKSB7XHJcbiAgICAgIHdoaWxlKGxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgc2V0ID0gbGlzdC5zaGlmdCgpO1xyXG4gICAgICAgIGZvcihzZXRJbmRleCA9IDAsIHNldExlbmd0aCA9IHNldC5sZW5ndGg7IHNldEluZGV4IDwgc2V0TGVuZ3RoOyBzZXRJbmRleCsrKSB7XHJcbiAgICAgICAgICBlbGVtZW50ID0ganFMaXRlKHNldFtzZXRJbmRleF0pO1xyXG4gICAgICAgICAgaWYgKGZpcmVFdmVudCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCckZGVzdHJveScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZmlyZUV2ZW50ID0gIWZpcmVFdmVudDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZvcihjaGlsZEluZGV4ID0gMCwgY2hpbGRMZW5ndGggPSAoY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuKCkpLmxlbmd0aDtcclxuICAgICAgICAgICAgICBjaGlsZEluZGV4IDwgY2hpbGRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChqUXVlcnkoY2hpbGRyZW5bY2hpbGRJbmRleF0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnaW5hbEpxRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5mdW5jdGlvbiBKUUxpdGUoZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSlFMaXRlKSB7XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEpRTGl0ZSkpIHtcclxuICAgIGlmIChpc1N0cmluZyhlbGVtZW50KSAmJiBlbGVtZW50LmNoYXJBdCgwKSAhPSAnPCcpIHtcclxuICAgICAgdGhyb3cganFMaXRlTWluRXJyKCdub3NlbCcsICdMb29raW5nIHVwIGVsZW1lbnRzIHZpYSBzZWxlY3RvcnMgaXMgbm90IHN1cHBvcnRlZCBieSBqcUxpdGUhIFNlZTogaHR0cDovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvYW5ndWxhci5lbGVtZW50Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEpRTGl0ZShlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIGlmIChpc1N0cmluZyhlbGVtZW50KSkge1xyXG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgLy8gUmVhZCBhYm91dCB0aGUgTm9TY29wZSBlbGVtZW50cyBoZXJlOlxyXG4gICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMzODk3KFZTLjg1KS5hc3B4XHJcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxkaXY+JiMxNjA7PC9kaXY+JyArIGVsZW1lbnQ7IC8vIElFIGluc2FuaXR5IHRvIG1ha2UgTm9TY29wZSBlbGVtZW50cyB3b3JrIVxyXG4gICAgZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTsgLy8gcmVtb3ZlIHRoZSBzdXBlcmZsdW91cyBkaXZcclxuICAgIEpRTGl0ZUFkZE5vZGVzKHRoaXMsIGRpdi5jaGlsZE5vZGVzKTtcclxuICAgIHZhciBmcmFnbWVudCA9IGpxTGl0ZShkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpO1xyXG4gICAgZnJhZ21lbnQuYXBwZW5kKHRoaXMpOyAvLyBkZXRhY2ggdGhlIGVsZW1lbnRzIGZyb20gdGhlIHRlbXBvcmFyeSBET00gZGl2LlxyXG4gIH0gZWxzZSB7XHJcbiAgICBKUUxpdGVBZGROb2Rlcyh0aGlzLCBlbGVtZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZUNsb25lKGVsZW1lbnQpIHtcclxuICByZXR1cm4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZURlYWxvYyhlbGVtZW50KXtcclxuICBKUUxpdGVSZW1vdmVEYXRhKGVsZW1lbnQpO1xyXG4gIGZvciAoIHZhciBpID0gMCwgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMgfHwgW107IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgSlFMaXRlRGVhbG9jKGNoaWxkcmVuW2ldKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZU9mZihlbGVtZW50LCB0eXBlLCBmbiwgdW5zdXBwb3J0ZWQpIHtcclxuICBpZiAoaXNEZWZpbmVkKHVuc3VwcG9ydGVkKSkgdGhyb3cganFMaXRlTWluRXJyKCdvZmZhcmdzJywgJ2pxTGl0ZSNvZmYoKSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgc2VsZWN0b3JgIGFyZ3VtZW50Jyk7XHJcblxyXG4gIHZhciBldmVudHMgPSBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2V2ZW50cycpLFxyXG4gICAgICBoYW5kbGUgPSBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2hhbmRsZScpO1xyXG5cclxuICBpZiAoIWhhbmRsZSkgcmV0dXJuOyAvL25vIGxpc3RlbmVycyByZWdpc3RlcmVkXHJcblxyXG4gIGlmIChpc1VuZGVmaW5lZCh0eXBlKSkge1xyXG4gICAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2ZW50SGFuZGxlciwgdHlwZSkge1xyXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyRm4oZWxlbWVudCwgdHlwZSwgZXZlbnRIYW5kbGVyKTtcclxuICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBmb3JFYWNoKHR5cGUuc3BsaXQoJyAnKSwgZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICBpZiAoaXNVbmRlZmluZWQoZm4pKSB7XHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckZuKGVsZW1lbnQsIHR5cGUsIGV2ZW50c1t0eXBlXSk7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhcnJheVJlbW92ZShldmVudHNbdHlwZV0gfHwgW10sIGZuKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVSZW1vdmVEYXRhKGVsZW1lbnQsIG5hbWUpIHtcclxuICB2YXIgZXhwYW5kb0lkID0gZWxlbWVudFtqcU5hbWVdLFxyXG4gICAgICBleHBhbmRvU3RvcmUgPSBqcUNhY2hlW2V4cGFuZG9JZF07XHJcblxyXG4gIGlmIChleHBhbmRvU3RvcmUpIHtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIGRlbGV0ZSBqcUNhY2hlW2V4cGFuZG9JZF0uZGF0YVtuYW1lXTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHBhbmRvU3RvcmUuaGFuZGxlKSB7XHJcbiAgICAgIGV4cGFuZG9TdG9yZS5ldmVudHMuJGRlc3Ryb3kgJiYgZXhwYW5kb1N0b3JlLmhhbmRsZSh7fSwgJyRkZXN0cm95Jyk7XHJcbiAgICAgIEpRTGl0ZU9mZihlbGVtZW50KTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBqcUNhY2hlW2V4cGFuZG9JZF07XHJcbiAgICBlbGVtZW50W2pxTmFtZV0gPSB1bmRlZmluZWQ7IC8vIGllIGRvZXMgbm90IGFsbG93IGRlbGV0aW9uIG9mIGF0dHJpYnV0ZXMgb24gZWxlbWVudHMuXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xyXG4gIHZhciBleHBhbmRvSWQgPSBlbGVtZW50W2pxTmFtZV0sXHJcbiAgICAgIGV4cGFuZG9TdG9yZSA9IGpxQ2FjaGVbZXhwYW5kb0lkIHx8IC0xXTtcclxuXHJcbiAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgIGlmICghZXhwYW5kb1N0b3JlKSB7XHJcbiAgICAgIGVsZW1lbnRbanFOYW1lXSA9IGV4cGFuZG9JZCA9IGpxTmV4dElkKCk7XHJcbiAgICAgIGV4cGFuZG9TdG9yZSA9IGpxQ2FjaGVbZXhwYW5kb0lkXSA9IHt9O1xyXG4gICAgfVxyXG4gICAgZXhwYW5kb1N0b3JlW2tleV0gPSB2YWx1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGV4cGFuZG9TdG9yZSAmJiBleHBhbmRvU3RvcmVba2V5XTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZURhdGEoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xyXG4gIHZhciBkYXRhID0gSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdkYXRhJyksXHJcbiAgICAgIGlzU2V0dGVyID0gaXNEZWZpbmVkKHZhbHVlKSxcclxuICAgICAga2V5RGVmaW5lZCA9ICFpc1NldHRlciAmJiBpc0RlZmluZWQoa2V5KSxcclxuICAgICAgaXNTaW1wbGVHZXR0ZXIgPSBrZXlEZWZpbmVkICYmICFpc09iamVjdChrZXkpO1xyXG5cclxuICBpZiAoIWRhdGEgJiYgIWlzU2ltcGxlR2V0dGVyKSB7XHJcbiAgICBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2RhdGEnLCBkYXRhID0ge30pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzU2V0dGVyKSB7XHJcbiAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGtleURlZmluZWQpIHtcclxuICAgICAgaWYgKGlzU2ltcGxlR2V0dGVyKSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgY3JlYXRlIGRhdGEgaW4gdGhpcyBjYXNlLlxyXG4gICAgICAgIHJldHVybiBkYXRhICYmIGRhdGFba2V5XTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBleHRlbmQoZGF0YSwga2V5KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVIYXNDbGFzcyhlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gIHJldHVybiAoKFwiIFwiICsgZWxlbWVudC5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZSgvW1xcblxcdF0vZywgXCIgXCIpLlxyXG4gICAgICBpbmRleE9mKCBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIgKSA+IC0xKTtcclxufVxyXG5cclxuZnVuY3Rpb24gSlFMaXRlUmVtb3ZlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3Nlcykge1xyXG4gIGlmIChjc3NDbGFzc2VzKSB7XHJcbiAgICBmb3JFYWNoKGNzc0NsYXNzZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24oY3NzQ2xhc3MpIHtcclxuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB0cmltKFxyXG4gICAgICAgICAgKFwiIFwiICsgZWxlbWVudC5jbGFzc05hbWUgKyBcIiBcIilcclxuICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXFx0XS9nLCBcIiBcIilcclxuICAgICAgICAgIC5yZXBsYWNlKFwiIFwiICsgdHJpbShjc3NDbGFzcykgKyBcIiBcIiwgXCIgXCIpXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZUFkZENsYXNzKGVsZW1lbnQsIGNzc0NsYXNzZXMpIHtcclxuICBpZiAoY3NzQ2xhc3Nlcykge1xyXG4gICAgZm9yRWFjaChjc3NDbGFzc2VzLnNwbGl0KCcgJyksIGZ1bmN0aW9uKGNzc0NsYXNzKSB7XHJcbiAgICAgIGlmICghSlFMaXRlSGFzQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpKSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSB0cmltKGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgdHJpbShjc3NDbGFzcykpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZUFkZE5vZGVzKHJvb3QsIGVsZW1lbnRzKSB7XHJcbiAgaWYgKGVsZW1lbnRzKSB7XHJcbiAgICBlbGVtZW50cyA9ICghZWxlbWVudHMubm9kZU5hbWUgJiYgaXNEZWZpbmVkKGVsZW1lbnRzLmxlbmd0aCkgJiYgIWlzV2luZG93KGVsZW1lbnRzKSlcclxuICAgICAgPyBlbGVtZW50c1xyXG4gICAgICA6IFsgZWxlbWVudHMgXTtcclxuICAgIGZvcih2YXIgaT0wOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcm9vdC5wdXNoKGVsZW1lbnRzW2ldKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZUNvbnRyb2xsZXIoZWxlbWVudCwgbmFtZSkge1xyXG4gIHJldHVybiBKUUxpdGVJbmhlcml0ZWREYXRhKGVsZW1lbnQsICckJyArIChuYW1lIHx8ICduZ0NvbnRyb2xsZXInICkgKyAnQ29udHJvbGxlcicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVJbmhlcml0ZWREYXRhKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XHJcbiAgZWxlbWVudCA9IGpxTGl0ZShlbGVtZW50KTtcclxuXHJcbiAgLy8gaWYgZWxlbWVudCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IHdvcmsgd2l0aCB0aGUgaHRtbCBlbGVtZW50IGluc3RlYWRcclxuICAvLyB0aGlzIG1ha2VzICQoZG9jdW1lbnQpLnNjb3BlKCkgcG9zc2libGVcclxuICBpZihlbGVtZW50WzBdLm5vZGVUeXBlID09IDkpIHtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50LmZpbmQoJ2h0bWwnKTtcclxuICB9XHJcblxyXG4gIHdoaWxlIChlbGVtZW50Lmxlbmd0aCkge1xyXG4gICAgaWYgKCh2YWx1ZSA9IGVsZW1lbnQuZGF0YShuYW1lKSkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gRnVuY3Rpb25zIHdoaWNoIGFyZSBkZWNsYXJlZCBkaXJlY3RseS5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbnZhciBKUUxpdGVQcm90b3R5cGUgPSBKUUxpdGUucHJvdG90eXBlID0ge1xyXG4gIHJlYWR5OiBmdW5jdGlvbihmbikge1xyXG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gdHJpZ2dlcigpIHtcclxuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XHJcbiAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgZm4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBpZiBkb2N1bWVudCBhbHJlYWR5IGlzIGxvYWRlZFxyXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpe1xyXG4gICAgICBzZXRUaW1lb3V0KHRyaWdnZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5vbignRE9NQ29udGVudExvYWRlZCcsIHRyaWdnZXIpOyAvLyB3b3JrcyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBJRTlcclxuICAgICAgLy8gd2UgY2FuIG5vdCB1c2UganFMaXRlIHNpbmNlIHdlIGFyZSBub3QgZG9uZSBsb2FkaW5nIGFuZCBqUXVlcnkgY291bGQgYmUgbG9hZGVkIGxhdGVyLlxyXG4gICAgICBKUUxpdGUod2luZG93KS5vbignbG9hZCcsIHRyaWdnZXIpOyAvLyBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkIGZvciBvdGhlcnNcclxuICAgIH1cclxuICB9LFxyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZSA9IFtdO1xyXG4gICAgZm9yRWFjaCh0aGlzLCBmdW5jdGlvbihlKXsgdmFsdWUucHVzaCgnJyArIGUpO30pO1xyXG4gICAgcmV0dXJuICdbJyArIHZhbHVlLmpvaW4oJywgJykgKyAnXSc7XHJcbiAgfSxcclxuXHJcbiAgZXE6IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgIHJldHVybiAoaW5kZXggPj0gMCkgPyBqcUxpdGUodGhpc1tpbmRleF0pIDoganFMaXRlKHRoaXNbdGhpcy5sZW5ndGggKyBpbmRleF0pO1xyXG4gIH0sXHJcblxyXG4gIGxlbmd0aDogMCxcclxuICBwdXNoOiBwdXNoLFxyXG4gIHNvcnQ6IFtdLnNvcnQsXHJcbiAgc3BsaWNlOiBbXS5zcGxpY2VcclxufTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBGdW5jdGlvbnMgaXRlcmF0aW5nIGdldHRlci9zZXR0ZXJzLlxyXG4vLyB0aGVzZSBmdW5jdGlvbnMgcmV0dXJuIHNlbGYgb24gc2V0dGVyIGFuZFxyXG4vLyB2YWx1ZSBvbiBnZXQuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG52YXIgQk9PTEVBTl9BVFRSID0ge307XHJcbmZvckVhY2goJ211bHRpcGxlLHNlbGVjdGVkLGNoZWNrZWQsZGlzYWJsZWQscmVhZE9ubHkscmVxdWlyZWQsb3Blbicuc3BsaXQoJywnKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICBCT09MRUFOX0FUVFJbbG93ZXJjYXNlKHZhbHVlKV0gPSB2YWx1ZTtcclxufSk7XHJcbnZhciBCT09MRUFOX0VMRU1FTlRTID0ge307XHJcbmZvckVhY2goJ2lucHV0LHNlbGVjdCxvcHRpb24sdGV4dGFyZWEsYnV0dG9uLGZvcm0sZGV0YWlscycuc3BsaXQoJywnKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICBCT09MRUFOX0VMRU1FTlRTW3VwcGVyY2FzZSh2YWx1ZSldID0gdHJ1ZTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBnZXRCb29sZWFuQXR0ck5hbWUoZWxlbWVudCwgbmFtZSkge1xyXG4gIC8vIGNoZWNrIGRvbSBsYXN0IHNpbmNlIHdlIHdpbGwgbW9zdCBsaWtlbHkgZmFpbCBvbiBuYW1lXHJcbiAgdmFyIGJvb2xlYW5BdHRyID0gQk9PTEVBTl9BVFRSW25hbWUudG9Mb3dlckNhc2UoKV07XHJcblxyXG4gIC8vIGJvb2xlYW5BdHRyIGlzIGhlcmUgdHdpY2UgdG8gbWluaW1pemUgRE9NIGFjY2Vzc1xyXG4gIHJldHVybiBib29sZWFuQXR0ciAmJiBCT09MRUFOX0VMRU1FTlRTW2VsZW1lbnQubm9kZU5hbWVdICYmIGJvb2xlYW5BdHRyO1xyXG59XHJcblxyXG5mb3JFYWNoKHtcclxuICBkYXRhOiBKUUxpdGVEYXRhLFxyXG4gIGluaGVyaXRlZERhdGE6IEpRTGl0ZUluaGVyaXRlZERhdGEsXHJcblxyXG4gIHNjb3BlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gSlFMaXRlSW5oZXJpdGVkRGF0YShlbGVtZW50LCAnJHNjb3BlJyk7XHJcbiAgfSxcclxuXHJcbiAgY29udHJvbGxlcjogSlFMaXRlQ29udHJvbGxlciAsXHJcblxyXG4gIGluamVjdG9yOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gSlFMaXRlSW5oZXJpdGVkRGF0YShlbGVtZW50LCAnJGluamVjdG9yJyk7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlQXR0cjogZnVuY3Rpb24oZWxlbWVudCxuYW1lKSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcclxuICB9LFxyXG5cclxuICBoYXNDbGFzczogSlFMaXRlSGFzQ2xhc3MsXHJcblxyXG4gIGNzczogZnVuY3Rpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcclxuICAgIG5hbWUgPSBjYW1lbENhc2UobmFtZSk7XHJcblxyXG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHZhbDtcclxuXHJcbiAgICAgIGlmIChtc2llIDw9IDgpIHtcclxuICAgICAgICAvLyB0aGlzIGlzIHNvbWUgSUUgc3BlY2lmaWMgd2VpcmRuZXNzIHRoYXQgalF1ZXJ5IDEuNi40IGRvZXMgbm90IHN1cmUgd2h5XHJcbiAgICAgICAgdmFsID0gZWxlbWVudC5jdXJyZW50U3R5bGUgJiYgZWxlbWVudC5jdXJyZW50U3R5bGVbbmFtZV07XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gJycpIHZhbCA9ICdhdXRvJztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFsID0gdmFsIHx8IGVsZW1lbnQuc3R5bGVbbmFtZV07XHJcblxyXG4gICAgICBpZiAobXNpZSA8PSA4KSB7XHJcbiAgICAgICAgLy8ganF1ZXJ5IHdlaXJkbmVzcyA6LS9cclxuICAgICAgICB2YWwgPSAodmFsID09PSAnJykgPyB1bmRlZmluZWQgOiB2YWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAgdmFsO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGF0dHI6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKXtcclxuICAgIHZhciBsb3dlcmNhc2VkTmFtZSA9IGxvd2VyY2FzZShuYW1lKTtcclxuICAgIGlmIChCT09MRUFOX0FUVFJbbG93ZXJjYXNlZE5hbWVdKSB7XHJcbiAgICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKCEhdmFsdWUpIHtcclxuICAgICAgICAgIGVsZW1lbnRbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgbG93ZXJjYXNlZE5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGVtZW50W25hbWVdID0gZmFsc2U7XHJcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShsb3dlcmNhc2VkTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAoZWxlbWVudFtuYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgIChlbGVtZW50LmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKG5hbWUpfHwgbm9vcCkuc3BlY2lmaWVkKVxyXG4gICAgICAgICAgICAgICA/IGxvd2VyY2FzZWROYW1lXHJcbiAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xyXG4gICAgICAvLyB0aGUgZXh0cmEgYXJndW1lbnQgXCIyXCIgaXMgdG8gZ2V0IHRoZSByaWdodCB0aGluZyBmb3IgYS5ocmVmIGluIElFLCBzZWUgalF1ZXJ5IGNvZGVcclxuICAgICAgLy8gc29tZSBlbGVtZW50cyAoZS5nLiBEb2N1bWVudCkgZG9uJ3QgaGF2ZSBnZXQgYXR0cmlidXRlLCBzbyByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgIHZhciByZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lLCAyKTtcclxuICAgICAgLy8gbm9ybWFsaXplIG5vbi1leGlzdGluZyBhdHRyaWJ1dGVzIHRvIHVuZGVmaW5lZCAoYXMgalF1ZXJ5KVxyXG4gICAgICByZXR1cm4gcmV0ID09PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHByb3A6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICBlbGVtZW50W25hbWVdID0gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZWxlbWVudFtuYW1lXTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB0ZXh0OiAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFkgPSBbXTtcclxuICAgIGlmIChtc2llIDwgOSkge1xyXG4gICAgICBOT0RFX1RZUEVfVEVYVF9QUk9QRVJUWVsxXSA9ICdpbm5lclRleHQnOyAgICAvKiogRWxlbWVudCAqKi9cclxuICAgICAgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbM10gPSAnbm9kZVZhbHVlJzsgICAgLyoqIFRleHQgKiovXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBOT0RFX1RZUEVfVEVYVF9QUk9QRVJUWVsxXSA9ICAgICAgICAgICAgICAgICAvKiogRWxlbWVudCAqKi9cclxuICAgICAgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbM10gPSAndGV4dENvbnRlbnQnOyAgLyoqIFRleHQgKiovXHJcbiAgICB9XHJcbiAgICBnZXRUZXh0LiRkdiA9ICcnO1xyXG4gICAgcmV0dXJuIGdldFRleHQ7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VGV4dChlbGVtZW50LCB2YWx1ZSkge1xyXG4gICAgICB2YXIgdGV4dFByb3AgPSBOT0RFX1RZUEVfVEVYVF9QUk9QRVJUWVtlbGVtZW50Lm5vZGVUeXBlXVxyXG4gICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRleHRQcm9wID8gZWxlbWVudFt0ZXh0UHJvcF0gOiAnJztcclxuICAgICAgfVxyXG4gICAgICBlbGVtZW50W3RleHRQcm9wXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH0pKCksXHJcblxyXG4gIHZhbDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcclxuICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgaWYgKG5vZGVOYW1lXyhlbGVtZW50KSA9PT0gJ1NFTEVDVCcgJiYgZWxlbWVudC5tdWx0aXBsZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3JFYWNoKGVsZW1lbnQub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcclxuICAgIH1cclxuICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcclxuICB9LFxyXG5cclxuICBodG1sOiBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMCwgY2hpbGROb2RlcyA9IGVsZW1lbnQuY2hpbGROb2RlczsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgSlFMaXRlRGVhbG9jKGNoaWxkTm9kZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSB2YWx1ZTtcclxuICB9XHJcbn0sIGZ1bmN0aW9uKGZuLCBuYW1lKXtcclxuICAvKipcclxuICAgKiBQcm9wZXJ0aWVzOiB3cml0ZXMgcmV0dXJuIHNlbGVjdGlvbiwgcmVhZHMgcmV0dXJuIGZpcnN0IHZhbHVlXHJcbiAgICovXHJcbiAgSlFMaXRlLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcclxuICAgIHZhciBpLCBrZXk7XHJcblxyXG4gICAgLy8gSlFMaXRlSGFzQ2xhc3MgaGFzIG9ubHkgdHdvIGFyZ3VtZW50cywgYnV0IGlzIGEgZ2V0dGVyLW9ubHkgZm4sIHNvIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGl0XHJcbiAgICAvLyBpbiBhIHdheSB0aGF0IHN1cnZpdmVzIG1pbmlmaWNhdGlvbi5cclxuICAgIGlmICgoKGZuLmxlbmd0aCA9PSAyICYmIChmbiAhPT0gSlFMaXRlSGFzQ2xhc3MgJiYgZm4gIT09IEpRTGl0ZUNvbnRyb2xsZXIpKSA/IGFyZzEgOiBhcmcyKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChpc09iamVjdChhcmcxKSkge1xyXG5cclxuICAgICAgICAvLyB3ZSBhcmUgYSB3cml0ZSwgYnV0IHRoZSBvYmplY3QgcHJvcGVydGllcyBhcmUgdGhlIGtleS92YWx1ZXNcclxuICAgICAgICBmb3IoaT0wOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGZuID09PSBKUUxpdGVEYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGRhdGEoKSB0YWtlcyB0aGUgd2hvbGUgb2JqZWN0IGluIGpRdWVyeVxyXG4gICAgICAgICAgICBmbih0aGlzW2ldLCBhcmcxKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZzEpIHtcclxuICAgICAgICAgICAgICBmbih0aGlzW2ldLCBrZXksIGFyZzFba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIHNlbGYgZm9yIGNoYWluaW5nXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gd2UgYXJlIGEgcmVhZCwgc28gcmVhZCB0aGUgZmlyc3QgY2hpbGQuXHJcbiAgICAgICAgdmFyIHZhbHVlID0gZm4uJGR2O1xyXG4gICAgICAgIC8vIE9ubHkgaWYgd2UgaGF2ZSAkZHYgZG8gd2UgaXRlcmF0ZSBvdmVyIGFsbCwgb3RoZXJ3aXNlIGl0IGlzIGp1c3QgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGpqID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gTWF0aC5taW4odGhpcy5sZW5ndGgsIDEpIDogdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgICB2YXIgbm9kZVZhbHVlID0gZm4odGhpc1tqXSwgYXJnMSwgYXJnMik7XHJcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgKyBub2RlVmFsdWUgOiBub2RlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gd2UgYXJlIGEgd3JpdGUsIHNvIGFwcGx5IHRvIGFsbCBjaGlsZHJlblxyXG4gICAgICBmb3IoaT0wOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZuKHRoaXNbaV0sIGFyZzEsIGFyZzIpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJldHVybiBzZWxmIGZvciBjaGFpbmluZ1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudHMpIHtcclxuICB2YXIgZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LCB0eXBlKSB7XHJcbiAgICBpZiAoIWV2ZW50LnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTsgLy9pZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7IC8vaWVcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xyXG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1VuZGVmaW5lZChldmVudC5kZWZhdWx0UHJldmVudGVkKSkge1xyXG4gICAgICB2YXIgcHJldmVudCA9IGV2ZW50LnByZXZlbnREZWZhdWx0O1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIHByZXZlbnQuY2FsbChldmVudCk7XHJcbiAgICAgIH07XHJcbiAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgZXZlbnQucmV0dXJuVmFsdWUgPT0gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvckVhY2goZXZlbnRzW3R5cGUgfHwgZXZlbnQudHlwZV0sIGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgIGZuLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIG1vbmtleS1wYXRjaGVkIG1ldGhvZHMgKElFKSxcclxuICAgIC8vIGFzIHRoZXkgd291bGQgY2F1c2UgbWVtb3J5IGxlYWtzIGluIElFOC5cclxuICAgIGlmIChtc2llIDw9IDgpIHtcclxuICAgICAgLy8gSUU3LzggZG9lcyBub3QgYWxsb3cgdG8gZGVsZXRlIHByb3BlcnR5IG9uIG5hdGl2ZSBvYmplY3RcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBudWxsO1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBudWxsO1xyXG4gICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSXQgc2hvdWxkbid0IGFmZmVjdCBub3JtYWwgYnJvd3NlcnMgKG5hdGl2ZSBtZXRob2RzIGFyZSBkZWZpbmVkIG9uIHByb3RvdHlwZSkuXHJcbiAgICAgIGRlbGV0ZSBldmVudC5wcmV2ZW50RGVmYXVsdDtcclxuICAgICAgZGVsZXRlIGV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcclxuICAgICAgZGVsZXRlIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZDtcclxuICAgIH1cclxuICB9O1xyXG4gIGV2ZW50SGFuZGxlci5lbGVtID0gZWxlbWVudDtcclxuICByZXR1cm4gZXZlbnRIYW5kbGVyO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gRnVuY3Rpb25zIGl0ZXJhdGluZyB0cmF2ZXJzYWwuXHJcbi8vIFRoZXNlIGZ1bmN0aW9ucyBjaGFpbiByZXN1bHRzIGludG8gYSBzaW5nbGVcclxuLy8gc2VsZWN0b3IuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5mb3JFYWNoKHtcclxuICByZW1vdmVEYXRhOiBKUUxpdGVSZW1vdmVEYXRhLFxyXG5cclxuICBkZWFsb2M6IEpRTGl0ZURlYWxvYyxcclxuXHJcbiAgb246IGZ1bmN0aW9uIG9uRm4oZWxlbWVudCwgdHlwZSwgZm4sIHVuc3VwcG9ydGVkKXtcclxuICAgIGlmIChpc0RlZmluZWQodW5zdXBwb3J0ZWQpKSB0aHJvdyBqcUxpdGVNaW5FcnIoJ29uYXJncycsICdqcUxpdGUjb24oKSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgc2VsZWN0b3JgIG9yIGBldmVudERhdGFgIHBhcmFtZXRlcnMnKTtcclxuXHJcbiAgICB2YXIgZXZlbnRzID0gSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdldmVudHMnKSxcclxuICAgICAgICBoYW5kbGUgPSBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2hhbmRsZScpO1xyXG5cclxuICAgIGlmICghZXZlbnRzKSBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2V2ZW50cycsIGV2ZW50cyA9IHt9KTtcclxuICAgIGlmICghaGFuZGxlKSBKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2hhbmRsZScsIGhhbmRsZSA9IGNyZWF0ZUV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudHMpKTtcclxuXHJcbiAgICBmb3JFYWNoKHR5cGUuc3BsaXQoJyAnKSwgZnVuY3Rpb24odHlwZSl7XHJcbiAgICAgIHZhciBldmVudEZucyA9IGV2ZW50c1t0eXBlXTtcclxuXHJcbiAgICAgIGlmICghZXZlbnRGbnMpIHtcclxuICAgICAgICBpZiAodHlwZSA9PSAnbW91c2VlbnRlcicgfHwgdHlwZSA9PSAnbW91c2VsZWF2ZScpIHtcclxuICAgICAgICAgIHZhciBjb250YWlucyA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMgfHwgZG9jdW1lbnQuYm9keS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XHJcbiAgICAgICAgICBmdW5jdGlvbiggYSwgYiApIHtcclxuICAgICAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcclxuICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxyXG4gICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zID9cclxuICAgICAgICAgICAgICBhZG93bi5jb250YWlucyggYnVwICkgOlxyXG4gICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxyXG4gICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICB9IDpcclxuICAgICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCBiICkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICggYiA9PT0gYSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gW107XHJcblxyXG4gICAgICAgICAgLy8gUmVmZXIgdG8galF1ZXJ5J3MgaW1wbGVtZW50YXRpb24gb2YgbW91c2VlbnRlciAmIG1vdXNlbGVhdmVcclxuICAgICAgICAgIC8vIFJlYWQgYWJvdXQgbW91c2VlbnRlciBhbmQgbW91c2VsZWF2ZTpcclxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX21vdXNlLmh0bWwjbGluazhcclxuICAgICAgICAgIHZhciBldmVudG1hcCA9IHsgbW91c2VsZWF2ZSA6IFwibW91c2VvdXRcIiwgbW91c2VlbnRlciA6IFwibW91c2VvdmVyXCJ9O1xyXG5cclxuICAgICAgICAgIG9uRm4oZWxlbWVudCwgZXZlbnRtYXBbdHlwZV0sIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLCByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcclxuICAgICAgICAgICAgLy8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xyXG4gICAgICAgICAgICBpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWNvbnRhaW5zKHRhcmdldCwgcmVsYXRlZCkpICl7XHJcbiAgICAgICAgICAgICAgaGFuZGxlKGV2ZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyRm4oZWxlbWVudCwgdHlwZSwgaGFuZGxlKTtcclxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudEZucyA9IGV2ZW50c1t0eXBlXVxyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50Rm5zLnB1c2goZm4pO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgb2ZmOiBKUUxpdGVPZmYsXHJcblxyXG4gIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihlbGVtZW50LCByZXBsYWNlTm9kZSkge1xyXG4gICAgdmFyIGluZGV4LCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICBKUUxpdGVEZWFsb2MoZWxlbWVudCk7XHJcbiAgICBmb3JFYWNoKG5ldyBKUUxpdGUocmVwbGFjZU5vZGUpLCBmdW5jdGlvbihub2RlKXtcclxuICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBpbmRleC5uZXh0U2libGluZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCBlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICBpbmRleCA9IG5vZGU7XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBjaGlsZHJlbjogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICBmb3JFYWNoKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24oZWxlbWVudCl7XHJcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSAxKVxyXG4gICAgICAgIGNoaWxkcmVuLnB1c2goZWxlbWVudCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxuICB9LFxyXG5cclxuICBjb250ZW50czogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGROb2RlcyB8fCBbXTtcclxuICB9LFxyXG5cclxuICBhcHBlbmQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG5vZGUpIHtcclxuICAgIGZvckVhY2gobmV3IEpRTGl0ZShub2RlKSwgZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtZW50Lm5vZGVUeXBlID09PSAxMSkge1xyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBwcmVwZW5kOiBmdW5jdGlvbihlbGVtZW50LCBub2RlKSB7XHJcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICB2YXIgaW5kZXggPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICAgIGZvckVhY2gobmV3IEpRTGl0ZShub2RlKSwgZnVuY3Rpb24oY2hpbGQpe1xyXG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBpbmRleCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHdyYXA6IGZ1bmN0aW9uKGVsZW1lbnQsIHdyYXBOb2RlKSB7XHJcbiAgICB3cmFwTm9kZSA9IGpxTGl0ZSh3cmFwTm9kZSlbMF07XHJcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHdyYXBOb2RlLCBlbGVtZW50KTtcclxuICAgIH1cclxuICAgIHdyYXBOb2RlLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgSlFMaXRlRGVhbG9jKGVsZW1lbnQpO1xyXG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICB9LFxyXG5cclxuICBhZnRlcjogZnVuY3Rpb24oZWxlbWVudCwgbmV3RWxlbWVudCkge1xyXG4gICAgdmFyIGluZGV4ID0gZWxlbWVudCwgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgZm9yRWFjaChuZXcgSlFMaXRlKG5ld0VsZW1lbnQpLCBmdW5jdGlvbihub2RlKXtcclxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBpbmRleC5uZXh0U2libGluZyk7XHJcbiAgICAgIGluZGV4ID0gbm9kZTtcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGFkZENsYXNzOiBKUUxpdGVBZGRDbGFzcyxcclxuICByZW1vdmVDbGFzczogSlFMaXRlUmVtb3ZlQ2xhc3MsXHJcblxyXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3RvciwgY29uZGl0aW9uKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQoY29uZGl0aW9uKSkge1xyXG4gICAgICBjb25kaXRpb24gPSAhSlFMaXRlSGFzQ2xhc3MoZWxlbWVudCwgc2VsZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgKGNvbmRpdGlvbiA/IEpRTGl0ZUFkZENsYXNzIDogSlFMaXRlUmVtb3ZlQ2xhc3MpKGVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICB9LFxyXG5cclxuICBwYXJlbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIG5leHQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSUU4IGRvZXNuJ3QgaGF2ZSBuZXh0RWxlbWVudFNpYmxpbmdcclxuICAgIHZhciBlbG0gPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xyXG4gICAgd2hpbGUgKGVsbSAhPSBudWxsICYmIGVsbS5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICBlbG0gPSBlbG0ubmV4dFNpYmxpbmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxtO1xyXG4gIH0sXHJcblxyXG4gIGZpbmQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3Rvcik7XHJcbiAgfSxcclxuXHJcbiAgY2xvbmU6IEpRTGl0ZUNsb25lLFxyXG5cclxuICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBldmVudERhdGEpIHtcclxuICAgIHZhciBldmVudEZucyA9IChKUUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2V2ZW50cycpIHx8IHt9KVtldmVudE5hbWVdO1xyXG4gICAgZXZlbnREYXRhID0gZXZlbnREYXRhIHx8IHtcclxuICAgICAgcHJldmVudERlZmF1bHQ6IG5vb3AsXHJcbiAgICAgIHN0b3BQcm9wYWdhdGlvbjogbm9vcFxyXG4gICAgfTtcclxuXHJcbiAgICBmb3JFYWNoKGV2ZW50Rm5zLCBmdW5jdGlvbihmbikge1xyXG4gICAgICBmbi5jYWxsKGVsZW1lbnQsIGV2ZW50RGF0YSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn0sIGZ1bmN0aW9uKGZuLCBuYW1lKXtcclxuICAvKipcclxuICAgKiBjaGFpbmluZyBmdW5jdGlvbnNcclxuICAgKi9cclxuICBKUUxpdGUucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YWx1ZSA9IGZuKHRoaXNbaV0sIGFyZzEsIGFyZzIsIGFyZzMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAvLyBhbnkgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHZhbHVlIG5lZWRzIHRvIGJlIHdyYXBwZWRcclxuICAgICAgICAgIHZhbHVlID0ganFMaXRlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgSlFMaXRlQWRkTm9kZXModmFsdWUsIGZuKHRoaXNbaV0sIGFyZzEsIGFyZzIsIGFyZzMpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlID09IHVuZGVmaW5lZCA/IHRoaXMgOiB2YWx1ZTtcclxuICB9O1xyXG5cclxuICAvLyBiaW5kIGxlZ2FjeSBiaW5kL3VuYmluZCB0byBvbi9vZmZcclxuICBKUUxpdGUucHJvdG90eXBlLmJpbmQgPSBKUUxpdGUucHJvdG90eXBlLm9uO1xyXG4gIEpRTGl0ZS5wcm90b3R5cGUudW5iaW5kID0gSlFMaXRlLnByb3RvdHlwZS5vZmY7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGEgaGFzaCBvZiBhbiAnb2JqJy5cclxuICogSGFzaCBvZiBhOlxyXG4gKiAgc3RyaW5nIGlzIHN0cmluZ1xyXG4gKiAgbnVtYmVyIGlzIG51bWJlciBhcyBzdHJpbmdcclxuICogIG9iamVjdCBpcyBlaXRoZXIgcmVzdWx0IG9mIGNhbGxpbmcgJCRoYXNoS2V5IGZ1bmN0aW9uIG9uIHRoZSBvYmplY3Qgb3IgdW5pcXVlbHkgZ2VuZXJhdGVkIGlkLFxyXG4gKiAgICAgICAgIHRoYXQgaXMgYWxzbyBhc3NpZ25lZCB0byB0aGUgJCRoYXNoS2V5IHByb3BlcnR5IG9mIHRoZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmpcclxuICogQHJldHVybnMge3N0cmluZ30gaGFzaCBzdHJpbmcgc3VjaCB0aGF0IHRoZSBzYW1lIGlucHV0IHdpbGwgaGF2ZSB0aGUgc2FtZSBoYXNoIHN0cmluZy5cclxuICogICAgICAgICBUaGUgcmVzdWx0aW5nIHN0cmluZyBrZXkgaXMgaW4gJ3R5cGU6aGFzaEtleScgZm9ybWF0LlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzaEtleShvYmopIHtcclxuICB2YXIgb2JqVHlwZSA9IHR5cGVvZiBvYmosXHJcbiAgICAgIGtleTtcclxuXHJcbiAgaWYgKG9ialR5cGUgPT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XHJcbiAgICBpZiAodHlwZW9mIChrZXkgPSBvYmouJCRoYXNoS2V5KSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIC8vIG11c3QgaW52b2tlIG9uIG9iamVjdCB0byBrZWVwIHRoZSByaWdodCB0aGlzXHJcbiAgICAgIGtleSA9IG9iai4kJGhhc2hLZXkoKTtcclxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAga2V5ID0gb2JqLiQkaGFzaEtleSA9IG5leHRVaWQoKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAga2V5ID0gb2JqO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9ialR5cGUgKyAnOicgKyBrZXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYXNoTWFwIHdoaWNoIGNhbiB1c2Ugb2JqZWN0cyBhcyBrZXlzXHJcbiAqL1xyXG5mdW5jdGlvbiBIYXNoTWFwKGFycmF5KXtcclxuICBmb3JFYWNoKGFycmF5LCB0aGlzLnB1dCwgdGhpcyk7XHJcbn1cclxuSGFzaE1hcC5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICogU3RvcmUga2V5IHZhbHVlIHBhaXJcclxuICAgKiBAcGFyYW0ga2V5IGtleSB0byBzdG9yZSBjYW4gYmUgYW55IHR5cGVcclxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gc3RvcmUgY2FuIGJlIGFueSB0eXBlXHJcbiAgICovXHJcbiAgcHV0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICB0aGlzW2hhc2hLZXkoa2V5KV0gPSB2YWx1ZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ga2V5XHJcbiAgICogQHJldHVybnMgdGhlIHZhbHVlIGZvciB0aGUga2V5XHJcbiAgICovXHJcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcclxuICAgIHJldHVybiB0aGlzW2hhc2hLZXkoa2V5KV07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBrZXkvdmFsdWUgcGFpclxyXG4gICAqIEBwYXJhbSBrZXlcclxuICAgKi9cclxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgdmFyIHZhbHVlID0gdGhpc1trZXkgPSBoYXNoS2V5KGtleSldO1xyXG4gICAgZGVsZXRlIHRoaXNba2V5XTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaW5qZWN0b3JcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGFuIGluamVjdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHJldHJpZXZpbmcgc2VydmljZXMgYXMgd2VsbCBhcyBmb3JcclxuICogZGVwZW5kZW5jeSBpbmplY3Rpb24gKHNlZSB7QGxpbmsgZ3VpZGUvZGkgZGVwZW5kZW5jeSBpbmplY3Rpb259KS5cclxuICpcclxuXHJcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xGdW5jdGlvbj59IG1vZHVsZXMgQSBsaXN0IG9mIG1vZHVsZSBmdW5jdGlvbnMgb3IgdGhlaXIgYWxpYXNlcy4gU2VlXHJcbiAqICAgICAgICB7QGxpbmsgYW5ndWxhci5tb2R1bGV9LiBUaGUgYG5nYCBtb2R1bGUgbXVzdCBiZSBleHBsaWNpdGx5IGFkZGVkLlxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKX0gSW5qZWN0b3IgZnVuY3Rpb24uIFNlZSB7QGxpbmsgQVVUTy4kaW5qZWN0b3IgJGluamVjdG9yfS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogVHlwaWNhbCB1c2FnZVxyXG4gKiA8cHJlPlxyXG4gKiAgIC8vIGNyZWF0ZSBhbiBpbmplY3RvclxyXG4gKiAgIHZhciAkaW5qZWN0b3IgPSBhbmd1bGFyLmluamVjdG9yKFsnbmcnXSk7XHJcbiAqXHJcbiAqICAgLy8gdXNlIHRoZSBpbmplY3RvciB0byBraWNrIG9mZiB5b3VyIGFwcGxpY2F0aW9uXHJcbiAqICAgLy8gdXNlIHRoZSB0eXBlIGluZmVyZW5jZSB0byBhdXRvIGluamVjdCBhcmd1bWVudHMsIG9yIHVzZSBpbXBsaWNpdCBpbmplY3Rpb25cclxuICogICAkaW5qZWN0b3IuaW52b2tlKGZ1bmN0aW9uKCRyb290U2NvcGUsICRjb21waWxlLCAkZG9jdW1lbnQpe1xyXG4gKiAgICAgJGNvbXBpbGUoJGRvY3VtZW50KSgkcm9vdFNjb3BlKTtcclxuICogICAgICRyb290U2NvcGUuJGRpZ2VzdCgpO1xyXG4gKiAgIH0pO1xyXG4gKiA8L3ByZT5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvdmVydmlld1xyXG4gKiBAbmFtZSBBVVRPXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBJbXBsaWNpdCBtb2R1bGUgd2hpY2ggZ2V0cyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIGVhY2gge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0uXHJcbiAqL1xyXG5cclxudmFyIEZOX0FSR1MgPSAvXmZ1bmN0aW9uXFxzKlteXFwoXSpcXChcXHMqKFteXFwpXSopXFwpL207XHJcbnZhciBGTl9BUkdfU1BMSVQgPSAvLC87XHJcbnZhciBGTl9BUkcgPSAvXlxccyooXz8pKFxcUys/KVxcMVxccyokLztcclxudmFyIFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xyXG52YXIgJGluamVjdG9yTWluRXJyID0gbWluRXJyKCckaW5qZWN0b3InKTtcclxuZnVuY3Rpb24gYW5ub3RhdGUoZm4pIHtcclxuICB2YXIgJGluamVjdCxcclxuICAgICAgZm5UZXh0LFxyXG4gICAgICBhcmdEZWNsLFxyXG4gICAgICBsYXN0O1xyXG5cclxuICBpZiAodHlwZW9mIGZuID09ICdmdW5jdGlvbicpIHtcclxuICAgIGlmICghKCRpbmplY3QgPSBmbi4kaW5qZWN0KSkge1xyXG4gICAgICAkaW5qZWN0ID0gW107XHJcbiAgICAgIGlmIChmbi5sZW5ndGgpIHtcclxuICAgICAgICBmblRleHQgPSBmbi50b1N0cmluZygpLnJlcGxhY2UoU1RSSVBfQ09NTUVOVFMsICcnKTtcclxuICAgICAgICBhcmdEZWNsID0gZm5UZXh0Lm1hdGNoKEZOX0FSR1MpO1xyXG4gICAgICAgIGZvckVhY2goYXJnRGVjbFsxXS5zcGxpdChGTl9BUkdfU1BMSVQpLCBmdW5jdGlvbihhcmcpe1xyXG4gICAgICAgICAgYXJnLnJlcGxhY2UoRk5fQVJHLCBmdW5jdGlvbihhbGwsIHVuZGVyc2NvcmUsIG5hbWUpe1xyXG4gICAgICAgICAgICAkaW5qZWN0LnB1c2gobmFtZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBmbi4kaW5qZWN0ID0gJGluamVjdDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICBsYXN0ID0gZm4ubGVuZ3RoIC0gMTtcclxuICAgIGFzc2VydEFyZ0ZuKGZuW2xhc3RdLCAnZm4nKTtcclxuICAgICRpbmplY3QgPSBmbi5zbGljZSgwLCBsYXN0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgYXNzZXJ0QXJnRm4oZm4sICdmbicsIHRydWUpO1xyXG4gIH1cclxuICByZXR1cm4gJGluamVjdDtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBBVVRPLiRpbmplY3RvclxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIGAkaW5qZWN0b3JgIGlzIHVzZWQgdG8gcmV0cmlldmUgb2JqZWN0IGluc3RhbmNlcyBhcyBkZWZpbmVkIGJ5XHJcbiAqIHtAbGluayBBVVRPLiRwcm92aWRlIHByb3ZpZGVyfSwgaW5zdGFudGlhdGUgdHlwZXMsIGludm9rZSBtZXRob2RzLFxyXG4gKiBhbmQgbG9hZCBtb2R1bGVzLlxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGFsd2F5cyBob2xkcyB0cnVlOlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIHZhciAkaW5qZWN0b3IgPSBhbmd1bGFyLmluamVjdG9yKCk7XHJcbiAqICAgZXhwZWN0KCRpbmplY3Rvci5nZXQoJyRpbmplY3RvcicpKS50b0JlKCRpbmplY3Rvcik7XHJcbiAqICAgZXhwZWN0KCRpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oJGluamVjdG9yKXtcclxuICogICAgIHJldHVybiAkaW5qZWN0b3I7XHJcbiAqICAgfSkudG9CZSgkaW5qZWN0b3IpO1xyXG4gKiA8L3ByZT5cclxuICpcclxuICogIyBJbmplY3Rpb24gRnVuY3Rpb24gQW5ub3RhdGlvblxyXG4gKlxyXG4gKiBKYXZhU2NyaXB0IGRvZXMgbm90IGhhdmUgYW5ub3RhdGlvbnMsIGFuZCBhbm5vdGF0aW9ucyBhcmUgbmVlZGVkIGZvciBkZXBlbmRlbmN5IGluamVjdGlvbi4gVGhlXHJcbiAqIGZvbGxvd2luZyBhcmUgYWxsIHZhbGlkIHdheXMgb2YgYW5ub3RhdGluZyBmdW5jdGlvbiB3aXRoIGluamVjdGlvbiBhcmd1bWVudHMgYW5kIGFyZSBlcXVpdmFsZW50LlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIC8vIGluZmVycmVkIChvbmx5IHdvcmtzIGlmIGNvZGUgbm90IG1pbmlmaWVkL29iZnVzY2F0ZWQpXHJcbiAqICAgJGluamVjdG9yLmludm9rZShmdW5jdGlvbihzZXJ2aWNlQSl7fSk7XHJcbiAqXHJcbiAqICAgLy8gYW5ub3RhdGVkXHJcbiAqICAgZnVuY3Rpb24gZXhwbGljaXQoc2VydmljZUEpIHt9O1xyXG4gKiAgIGV4cGxpY2l0LiRpbmplY3QgPSBbJ3NlcnZpY2VBJ107XHJcbiAqICAgJGluamVjdG9yLmludm9rZShleHBsaWNpdCk7XHJcbiAqXHJcbiAqICAgLy8gaW5saW5lXHJcbiAqICAgJGluamVjdG9yLmludm9rZShbJ3NlcnZpY2VBJywgZnVuY3Rpb24oc2VydmljZUEpe31dKTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqICMjIEluZmVyZW5jZVxyXG4gKlxyXG4gKiBJbiBKYXZhU2NyaXB0IGNhbGxpbmcgYHRvU3RyaW5nKClgIG9uIGEgZnVuY3Rpb24gcmV0dXJucyB0aGUgZnVuY3Rpb24gZGVmaW5pdGlvbi4gVGhlIGRlZmluaXRpb24gY2FuIHRoZW4gYmVcclxuICogcGFyc2VkIGFuZCB0aGUgZnVuY3Rpb24gYXJndW1lbnRzIGNhbiBiZSBleHRyYWN0ZWQuICpOT1RFOiogVGhpcyBkb2VzIG5vdCB3b3JrIHdpdGggbWluaWZpY2F0aW9uLCBhbmQgb2JmdXNjYXRpb25cclxuICogdG9vbHMgc2luY2UgdGhlc2UgdG9vbHMgY2hhbmdlIHRoZSBhcmd1bWVudCBuYW1lcy5cclxuICpcclxuICogIyMgYCRpbmplY3RgIEFubm90YXRpb25cclxuICogQnkgYWRkaW5nIGEgYCRpbmplY3RgIHByb3BlcnR5IG9udG8gYSBmdW5jdGlvbiB0aGUgaW5qZWN0aW9uIHBhcmFtZXRlcnMgY2FuIGJlIHNwZWNpZmllZC5cclxuICpcclxuICogIyMgSW5saW5lXHJcbiAqIEFzIGFuIGFycmF5IG9mIGluamVjdGlvbiBuYW1lcywgd2hlcmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgYXJyYXkgaXMgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjZ2V0XHJcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUmV0dXJuIGFuIGluc3RhbmNlIG9mIHRoZSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UgdG8gcmV0cmlldmUuXHJcbiAqIEByZXR1cm4geyp9IFRoZSBpbnN0YW5jZS5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIG1ldGhvZFxyXG4gKiBAbmFtZSBBVVRPLiRpbmplY3RvciNpbnZva2VcclxuICogQG1ldGhvZE9mIEFVVE8uJGluamVjdG9yXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBJbnZva2UgdGhlIG1ldGhvZCBhbmQgc3VwcGx5IHRoZSBtZXRob2QgYXJndW1lbnRzIGZyb20gdGhlIGAkaW5qZWN0b3JgLlxyXG4gKlxyXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gVGhlIGZ1bmN0aW9uIGFyZ3VtZW50cyBjb21lIGZvcm0gdGhlIGZ1bmN0aW9uIGFubm90YXRpb24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2VsZiBUaGUgYHRoaXNgIGZvciB0aGUgaW52b2tlZCBtZXRob2QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gbG9jYWxzIE9wdGlvbmFsIG9iamVjdC4gSWYgcHJlc2V0IHRoZW4gYW55IGFyZ3VtZW50IG5hbWVzIGFyZSByZWFkIGZyb20gdGhpcyBvYmplY3QgZmlyc3QsIGJlZm9yZVxyXG4gKiAgIHRoZSBgJGluamVjdG9yYCBpcyBjb25zdWx0ZWQuXHJcbiAqIEByZXR1cm5zIHsqfSB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGludm9rZWQgYGZuYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIG1ldGhvZFxyXG4gKiBAbmFtZSBBVVRPLiRpbmplY3RvciNoYXNcclxuICogQG1ldGhvZE9mIEFVVE8uJGluamVjdG9yXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcXVlcnkgaWYgdGhlIHBhcnRpY3VsYXIgc2VydmljZSBleGlzdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IE5hbWUgb2YgdGhlIHNlcnZpY2UgdG8gcXVlcnkuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgaW5qZWN0b3IgaGFzIGdpdmVuIHNlcnZpY2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjaW5zdGFudGlhdGVcclxuICogQG1ldGhvZE9mIEFVVE8uJGluamVjdG9yXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgSlMgdHlwZS4gVGhlIG1ldGhvZCB0YWtlcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGludm9rZXMgdGhlIG5ldyBvcGVyYXRvciBhbmQgc3VwcGxpZXNcclxuICogYWxsIG9mIHRoZSBhcmd1bWVudHMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGFzIHNwZWNpZmllZCBieSB0aGUgY29uc3RydWN0b3IgYW5ub3RhdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gVHlwZSBBbm5vdGF0ZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gbG9jYWxzIE9wdGlvbmFsIG9iamVjdC4gSWYgcHJlc2V0IHRoZW4gYW55IGFyZ3VtZW50IG5hbWVzIGFyZSByZWFkIGZyb20gdGhpcyBvYmplY3QgZmlyc3QsIGJlZm9yZVxyXG4gKiAgIHRoZSBgJGluamVjdG9yYCBpcyBjb25zdWx0ZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5ldyBpbnN0YW5jZSBvZiBgVHlwZWAuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjYW5ub3RhdGVcclxuICogQG1ldGhvZE9mIEFVVE8uJGluamVjdG9yXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNlcnZpY2UgbmFtZXMgd2hpY2ggdGhlIGZ1bmN0aW9uIGlzIHJlcXVlc3RpbmcgZm9yIGluamVjdGlvbi4gVGhpcyBBUEkgaXMgdXNlZCBieSB0aGUgaW5qZWN0b3JcclxuICogdG8gZGV0ZXJtaW5lIHdoaWNoIHNlcnZpY2VzIG5lZWQgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgZnVuY3Rpb24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZC4gVGhlcmUgYXJlIHRocmVlXHJcbiAqIHdheXMgaW4gd2hpY2ggdGhlIGZ1bmN0aW9uIGNhbiBiZSBhbm5vdGF0ZWQgd2l0aCB0aGUgbmVlZGVkIGRlcGVuZGVuY2llcy5cclxuICpcclxuICogIyBBcmd1bWVudCBuYW1lc1xyXG4gKlxyXG4gKiBUaGUgc2ltcGxlc3QgZm9ybSBpcyB0byBleHRyYWN0IHRoZSBkZXBlbmRlbmNpZXMgZnJvbSB0aGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvbi4gVGhpcyBpcyBkb25lIGJ5IGNvbnZlcnRpbmdcclxuICogdGhlIGZ1bmN0aW9uIGludG8gYSBzdHJpbmcgdXNpbmcgYHRvU3RyaW5nKClgIG1ldGhvZCBhbmQgZXh0cmFjdGluZyB0aGUgYXJndW1lbnQgbmFtZXMuXHJcbiAqIDxwcmU+XHJcbiAqICAgLy8gR2l2ZW5cclxuICogICBmdW5jdGlvbiBNeUNvbnRyb2xsZXIoJHNjb3BlLCAkcm91dGUpIHtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH1cclxuICpcclxuICogICAvLyBUaGVuXHJcbiAqICAgZXhwZWN0KGluamVjdG9yLmFubm90YXRlKE15Q29udHJvbGxlcikpLnRvRXF1YWwoWyckc2NvcGUnLCAnJHJvdXRlJ10pO1xyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhpcyBtZXRob2QgZG9lcyBub3Qgd29yayB3aXRoIGNvZGUgbWluaWZpY2F0aW9uIC8gb2JmdXNjYXRpb24uIEZvciB0aGlzIHJlYXNvbiB0aGUgZm9sbG93aW5nIGFubm90YXRpb24gc3RyYXRlZ2llc1xyXG4gKiBhcmUgc3VwcG9ydGVkLlxyXG4gKlxyXG4gKiAjIFRoZSBgJGluamVjdGAgcHJvcGVydHlcclxuICpcclxuICogSWYgYSBmdW5jdGlvbiBoYXMgYW4gYCRpbmplY3RgIHByb3BlcnR5IGFuZCBpdHMgdmFsdWUgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiB0aGUgc3RyaW5ncyByZXByZXNlbnQgbmFtZXMgb2ZcclxuICogc2VydmljZXMgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgZnVuY3Rpb24uXHJcbiAqIDxwcmU+XHJcbiAqICAgLy8gR2l2ZW5cclxuICogICB2YXIgTXlDb250cm9sbGVyID0gZnVuY3Rpb24ob2JmdXNjYXRlZFNjb3BlLCBvYmZ1c2NhdGVkUm91dGUpIHtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH1cclxuICogICAvLyBEZWZpbmUgZnVuY3Rpb24gZGVwZW5kZW5jaWVzXHJcbiAqICAgTXlDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckcm91dGUnXTtcclxuICpcclxuICogICAvLyBUaGVuXHJcbiAqICAgZXhwZWN0KGluamVjdG9yLmFubm90YXRlKE15Q29udHJvbGxlcikpLnRvRXF1YWwoWyckc2NvcGUnLCAnJHJvdXRlJ10pO1xyXG4gKiA8L3ByZT5cclxuICpcclxuICogIyBUaGUgYXJyYXkgbm90YXRpb25cclxuICpcclxuICogSXQgaXMgb2Z0ZW4gZGVzaXJhYmxlIHRvIGlubGluZSBJbmplY3RlZCBmdW5jdGlvbnMgYW5kIHRoYXQncyB3aGVuIHNldHRpbmcgdGhlIGAkaW5qZWN0YCBwcm9wZXJ0eSBpcyB2ZXJ5XHJcbiAqIGluY29udmVuaWVudC4gSW4gdGhlc2Ugc2l0dWF0aW9ucyB1c2luZyB0aGUgYXJyYXkgbm90YXRpb24gdG8gc3BlY2lmeSB0aGUgZGVwZW5kZW5jaWVzIGluIGEgd2F5IHRoYXQgc3Vydml2ZXNcclxuICogbWluaWZpY2F0aW9uIGlzIGEgYmV0dGVyIGNob2ljZTpcclxuICpcclxuICogPHByZT5cclxuICogICAvLyBXZSB3aXNoIHRvIHdyaXRlIHRoaXMgKG5vdCBtaW5pZmljYXRpb24gLyBvYmZ1c2NhdGlvbiBzYWZlKVxyXG4gKiAgIGluamVjdG9yLmludm9rZShmdW5jdGlvbigkY29tcGlsZSwgJHJvb3RTY29wZSkge1xyXG4gKiAgICAgLy8gLi4uXHJcbiAqICAgfSk7XHJcbiAqXHJcbiAqICAgLy8gV2UgYXJlIGZvcmNlZCB0byB3cml0ZSBicmVhayBpbmxpbmluZ1xyXG4gKiAgIHZhciB0bXBGbiA9IGZ1bmN0aW9uKG9iZnVzY2F0ZWRDb21waWxlLCBvYmZ1c2NhdGVkUm9vdFNjb3BlKSB7XHJcbiAqICAgICAvLyAuLi5cclxuICogICB9O1xyXG4gKiAgIHRtcEZuLiRpbmplY3QgPSBbJyRjb21waWxlJywgJyRyb290U2NvcGUnXTtcclxuICogICBpbmplY3Rvci5pbnZva2UodG1wRm4pO1xyXG4gKlxyXG4gKiAgIC8vIFRvIGJldHRlciBzdXBwb3J0IGlubGluZSBmdW5jdGlvbiB0aGUgaW5saW5lIGFubm90YXRpb24gaXMgc3VwcG9ydGVkXHJcbiAqICAgaW5qZWN0b3IuaW52b2tlKFsnJGNvbXBpbGUnLCAnJHJvb3RTY29wZScsIGZ1bmN0aW9uKG9iZkNvbXBpbGUsIG9iZlJvb3RTY29wZSkge1xyXG4gKiAgICAgLy8gLi4uXHJcbiAqICAgfV0pO1xyXG4gKlxyXG4gKiAgIC8vIFRoZXJlZm9yZVxyXG4gKiAgIGV4cGVjdChpbmplY3Rvci5hbm5vdGF0ZShcclxuICogICAgICBbJyRjb21waWxlJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbihvYmZ1c18kY29tcGlsZSwgb2JmdXNfJHJvb3RTY29wZSkge31dKVxyXG4gKiAgICApLnRvRXF1YWwoWyckY29tcGlsZScsICckcm9vdFNjb3BlJ10pO1xyXG4gKiA8L3ByZT5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbnxBcnJheS48c3RyaW5nfEZ1bmN0aW9uPn0gZm4gRnVuY3Rpb24gZm9yIHdoaWNoIGRlcGVuZGVudCBzZXJ2aWNlIG5hbWVzIG5lZWQgdG8gYmUgcmV0cmlldmVkIGFzIGRlc2NyaWJlZFxyXG4gKiAgIGFib3ZlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IFRoZSBuYW1lcyBvZiB0aGUgc2VydmljZXMgd2hpY2ggdGhlIGZ1bmN0aW9uIHJlcXVpcmVzLlxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFVzZSBgJHByb3ZpZGVgIHRvIHJlZ2lzdGVyIG5ldyBwcm92aWRlcnMgd2l0aCB0aGUgYCRpbmplY3RvcmAuIFRoZSBwcm92aWRlcnMgYXJlIHRoZSBmYWN0b3JpZXMgZm9yIHRoZSBpbnN0YW5jZS5cclxuICogVGhlIHByb3ZpZGVycyBzaGFyZSB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbnN0YW5jZSB0aGV5IGNyZWF0ZSB3aXRoIGBQcm92aWRlcmAgc3VmZml4ZWQgdG8gdGhlbS5cclxuICpcclxuICogQSBwcm92aWRlciBpcyBhbiBvYmplY3Qgd2l0aCBhIGAkZ2V0KClgIG1ldGhvZC4gVGhlIGluamVjdG9yIGNhbGxzIHRoZSBgJGdldGAgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZlxyXG4gKiBhIHNlcnZpY2UuIFRoZSBQcm92aWRlciBjYW4gaGF2ZSBhZGRpdGlvbmFsIG1ldGhvZHMgd2hpY2ggd291bGQgYWxsb3cgZm9yIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHByb3ZpZGVyLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIGZ1bmN0aW9uIEdyZWV0UHJvdmlkZXIoKSB7XHJcbiAqICAgICB2YXIgc2FsdXRhdGlvbiA9ICdIZWxsbyc7XHJcbiAqXHJcbiAqICAgICB0aGlzLnNhbHV0YXRpb24gPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAqICAgICAgIHNhbHV0YXRpb24gPSB0ZXh0O1xyXG4gKiAgICAgfTtcclxuICpcclxuICogICAgIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuICogICAgICAgICByZXR1cm4gc2FsdXRhdGlvbiArICcgJyArIG5hbWUgKyAnISc7XHJcbiAqICAgICAgIH07XHJcbiAqICAgICB9O1xyXG4gKiAgIH1cclxuICpcclxuICogICBkZXNjcmliZSgnR3JlZXRlcicsIGZ1bmN0aW9uKCl7XHJcbiAqXHJcbiAqICAgICBiZWZvcmVFYWNoKG1vZHVsZShmdW5jdGlvbigkcHJvdmlkZSkge1xyXG4gKiAgICAgICAkcHJvdmlkZS5wcm92aWRlcignZ3JlZXQnLCBHcmVldFByb3ZpZGVyKTtcclxuICogICAgIH0pKTtcclxuICpcclxuICogICAgIGl0KCdzaG91bGQgZ3JlZXQnLCBpbmplY3QoZnVuY3Rpb24oZ3JlZXQpIHtcclxuICogICAgICAgZXhwZWN0KGdyZWV0KCdhbmd1bGFyJykpLnRvRXF1YWwoJ0hlbGxvIGFuZ3VsYXIhJyk7XHJcbiAqICAgICB9KSk7XHJcbiAqXHJcbiAqICAgICBpdCgnc2hvdWxkIGFsbG93IGNvbmZpZ3VyYXRpb24gb2Ygc2FsdXRhdGlvbicsIGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICBtb2R1bGUoZnVuY3Rpb24oZ3JlZXRQcm92aWRlcikge1xyXG4gKiAgICAgICAgIGdyZWV0UHJvdmlkZXIuc2FsdXRhdGlvbignQWhvaicpO1xyXG4gKiAgICAgICB9KTtcclxuICogICAgICAgaW5qZWN0KGZ1bmN0aW9uKGdyZWV0KSB7XHJcbiAqICAgICAgICAgZXhwZWN0KGdyZWV0KCdhbmd1bGFyJykpLnRvRXF1YWwoJ0Fob2ogYW5ndWxhciEnKTtcclxuICogICAgICAgfSk7XHJcbiAqICAgICB9KTtcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kcHJvdmlkZSNwcm92aWRlclxyXG4gKiBAbWV0aG9kT2YgQVVUTy4kcHJvdmlkZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogUmVnaXN0ZXIgYSBwcm92aWRlciBmb3IgYSBzZXJ2aWNlLiBUaGUgcHJvdmlkZXJzIGNhbiBiZSByZXRyaWV2ZWQgYW5kIGNhbiBoYXZlIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBtZXRob2RzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UuIE5PVEU6IHRoZSBwcm92aWRlciB3aWxsIGJlIGF2YWlsYWJsZSB1bmRlciBgbmFtZSArICdQcm92aWRlcidgIGtleS5cclxuICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKCkpfSBwcm92aWRlciBJZiB0aGUgcHJvdmlkZXIgaXM6XHJcbiAqXHJcbiAqICAgLSBgT2JqZWN0YDogdGhlbiBpdCBzaG91bGQgaGF2ZSBhIGAkZ2V0YCBtZXRob2QuIFRoZSBgJGdldGAgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCB1c2luZ1xyXG4gKiAgICAgICAgICAgICAgIHtAbGluayBBVVRPLiRpbmplY3RvciNpbnZva2UgJGluamVjdG9yLmludm9rZSgpfSB3aGVuIGFuIGluc3RhbmNlIG5lZWRzIHRvIGJlIGNyZWF0ZWQuXHJcbiAqICAgLSBgQ29uc3RydWN0b3JgOiBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgcHJvdmlkZXIgd2lsbCBiZSBjcmVhdGVkIHVzaW5nXHJcbiAqICAgICAgICAgICAgICAge0BsaW5rIEFVVE8uJGluamVjdG9yI2luc3RhbnRpYXRlICRpbmplY3Rvci5pbnN0YW50aWF0ZSgpfSwgdGhlbiB0cmVhdGVkIGFzIGBvYmplY3RgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIHByb3ZpZGVyIGluc3RhbmNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kcHJvdmlkZSNmYWN0b3J5XHJcbiAqIEBtZXRob2RPZiBBVVRPLiRwcm92aWRlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBBIHNob3J0IGhhbmQgZm9yIGNvbmZpZ3VyaW5nIHNlcnZpY2VzIGlmIG9ubHkgYCRnZXRgIG1ldGhvZCBpcyByZXF1aXJlZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9ICRnZXRGbiBUaGUgJGdldEZuIGZvciB0aGUgaW5zdGFuY2UgY3JlYXRpb24uIEludGVybmFsbHkgdGhpcyBpcyBhIHNob3J0IGhhbmQgZm9yXHJcbiAqIGAkcHJvdmlkZS5wcm92aWRlcihuYW1lLCB7JGdldDogJGdldEZufSlgLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIHByb3ZpZGVyIGluc3RhbmNlXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjc2VydmljZVxyXG4gKiBAbWV0aG9kT2YgQVVUTy4kcHJvdmlkZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogQSBzaG9ydCBoYW5kIGZvciByZWdpc3RlcmluZyBzZXJ2aWNlIG9mIGdpdmVuIGNsYXNzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIEEgY2xhc3MgKGNvbnN0cnVjdG9yIGZ1bmN0aW9uKSB0aGF0IHdpbGwgYmUgaW5zdGFudGlhdGVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIHByb3ZpZGVyIGluc3RhbmNlXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjdmFsdWVcclxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIEEgc2hvcnQgaGFuZCBmb3IgY29uZmlndXJpbmcgc2VydmljZXMgaWYgdGhlIGAkZ2V0YCBtZXRob2QgaXMgYSBjb25zdGFudC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cclxuICogQHJldHVybnMge09iamVjdH0gcmVnaXN0ZXJlZCBwcm92aWRlciBpbnN0YW5jZVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG1ldGhvZFxyXG4gKiBAbmFtZSBBVVRPLiRwcm92aWRlI2NvbnN0YW50XHJcbiAqIEBtZXRob2RPZiBBVVRPLiRwcm92aWRlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBBIGNvbnN0YW50IHZhbHVlLCBidXQgdW5saWtlIHtAbGluayBBVVRPLiRwcm92aWRlI3ZhbHVlIHZhbHVlfSBpdCBjYW4gYmUgaW5qZWN0ZWRcclxuICogaW50byBjb25maWd1cmF0aW9uIGZ1bmN0aW9uIChvdGhlciBtb2R1bGVzKSBhbmQgaXQgaXMgbm90IGludGVyY2VwdGFibGUgYnlcclxuICoge0BsaW5rIEFVVE8uJHByb3ZpZGUjZGVjb3JhdG9yIGRlY29yYXRvcn0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb25zdGFudC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgY29uc3RhbnQgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IHJlZ2lzdGVyZWQgaW5zdGFuY2VcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kcHJvdmlkZSNkZWNvcmF0b3JcclxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIERlY29yYXRpb24gb2Ygc2VydmljZSwgYWxsb3dzIHRoZSBkZWNvcmF0b3IgdG8gaW50ZXJjZXB0IHRoZSBzZXJ2aWNlIGluc3RhbmNlIGNyZWF0aW9uLiBUaGVcclxuICogcmV0dXJuZWQgaW5zdGFuY2UgbWF5IGJlIHRoZSBvcmlnaW5hbCBpbnN0YW5jZSwgb3IgYSBuZXcgaW5zdGFuY2Ugd2hpY2ggZGVsZWdhdGVzIHRvIHRoZVxyXG4gKiBvcmlnaW5hbCBpbnN0YW5jZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgdG8gZGVjb3JhdGUuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZGVjb3JhdG9yIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIHNlcnZpY2UgbmVlZHMgdG8gYmVcclxuICogICAgaW5zdGFudGlhdGVkLiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHVzaW5nIHRoZSB7QGxpbmsgQVVUTy4kaW5qZWN0b3IjaW52b2tlXHJcbiAqICAgIGluamVjdG9yLmludm9rZX0gbWV0aG9kIGFuZCBpcyB0aGVyZWZvcmUgZnVsbHkgaW5qZWN0YWJsZS4gTG9jYWwgaW5qZWN0aW9uIGFyZ3VtZW50czpcclxuICpcclxuICogICAgKiBgJGRlbGVnYXRlYCAtIFRoZSBvcmlnaW5hbCBzZXJ2aWNlIGluc3RhbmNlLCB3aGljaCBjYW4gYmUgbW9ua2V5IHBhdGNoZWQsIGNvbmZpZ3VyZWQsXHJcbiAqICAgICAgZGVjb3JhdGVkIG9yIGRlbGVnYXRlZCB0by5cclxuICovXHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3IobW9kdWxlc1RvTG9hZCkge1xyXG4gIHZhciBJTlNUQU5USUFUSU5HID0ge30sXHJcbiAgICAgIHByb3ZpZGVyU3VmZml4ID0gJ1Byb3ZpZGVyJyxcclxuICAgICAgcGF0aCA9IFtdLFxyXG4gICAgICBsb2FkZWRNb2R1bGVzID0gbmV3IEhhc2hNYXAoKSxcclxuICAgICAgcHJvdmlkZXJDYWNoZSA9IHtcclxuICAgICAgICAkcHJvdmlkZToge1xyXG4gICAgICAgICAgICBwcm92aWRlcjogc3VwcG9ydE9iamVjdChwcm92aWRlciksXHJcbiAgICAgICAgICAgIGZhY3Rvcnk6IHN1cHBvcnRPYmplY3QoZmFjdG9yeSksXHJcbiAgICAgICAgICAgIHNlcnZpY2U6IHN1cHBvcnRPYmplY3Qoc2VydmljZSksXHJcbiAgICAgICAgICAgIHZhbHVlOiBzdXBwb3J0T2JqZWN0KHZhbHVlKSxcclxuICAgICAgICAgICAgY29uc3RhbnQ6IHN1cHBvcnRPYmplY3QoY29uc3RhbnQpLFxyXG4gICAgICAgICAgICBkZWNvcmF0b3I6IGRlY29yYXRvclxyXG4gICAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBwcm92aWRlckluamVjdG9yID0gKHByb3ZpZGVyQ2FjaGUuJGluamVjdG9yID1cclxuICAgICAgICAgIGNyZWF0ZUludGVybmFsSW5qZWN0b3IocHJvdmlkZXJDYWNoZSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycigndW5wcicsIFwiVW5rbm93biBwcm92aWRlcjogezB9XCIsIHBhdGguam9pbignIDwtICcpKTtcclxuICAgICAgICAgIH0pKSxcclxuICAgICAgaW5zdGFuY2VDYWNoZSA9IHt9LFxyXG4gICAgICBpbnN0YW5jZUluamVjdG9yID0gKGluc3RhbmNlQ2FjaGUuJGluamVjdG9yID1cclxuICAgICAgICAgIGNyZWF0ZUludGVybmFsSW5qZWN0b3IoaW5zdGFuY2VDYWNoZSwgZnVuY3Rpb24oc2VydmljZW5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJJbmplY3Rvci5nZXQoc2VydmljZW5hbWUgKyBwcm92aWRlclN1ZmZpeCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZUluamVjdG9yLmludm9rZShwcm92aWRlci4kZ2V0LCBwcm92aWRlcik7XHJcbiAgICAgICAgICB9KSk7XHJcblxyXG5cclxuICBmb3JFYWNoKGxvYWRNb2R1bGVzKG1vZHVsZXNUb0xvYWQpLCBmdW5jdGlvbihmbikgeyBpbnN0YW5jZUluamVjdG9yLmludm9rZShmbiB8fCBub29wKTsgfSk7XHJcblxyXG4gIHJldHVybiBpbnN0YW5jZUluamVjdG9yO1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyAkcHJvdmlkZXJcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgZnVuY3Rpb24gc3VwcG9ydE9iamVjdChkZWxlZ2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcclxuICAgICAgICBmb3JFYWNoKGtleSwgcmV2ZXJzZVBhcmFtcyhkZWxlZ2F0ZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZShrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcHJvdmlkZXIobmFtZSwgcHJvdmlkZXJfKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihwcm92aWRlcl8pIHx8IGlzQXJyYXkocHJvdmlkZXJfKSkge1xyXG4gICAgICBwcm92aWRlcl8gPSBwcm92aWRlckluamVjdG9yLmluc3RhbnRpYXRlKHByb3ZpZGVyXyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXByb3ZpZGVyXy4kZ2V0KSB7XHJcbiAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycigncGdldCcsIFwiUHJvdmlkZXIgJ3swfScgbXVzdCBkZWZpbmUgJGdldCBmYWN0b3J5IG1ldGhvZC5cIiwgbmFtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvdmlkZXJDYWNoZVtuYW1lICsgcHJvdmlkZXJTdWZmaXhdID0gcHJvdmlkZXJfO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmFjdG9yeShuYW1lLCBmYWN0b3J5Rm4pIHsgcmV0dXJuIHByb3ZpZGVyKG5hbWUsIHsgJGdldDogZmFjdG9yeUZuIH0pOyB9XHJcblxyXG4gIGZ1bmN0aW9uIHNlcnZpY2UobmFtZSwgY29uc3RydWN0b3IpIHtcclxuICAgIHJldHVybiBmYWN0b3J5KG5hbWUsIFsnJGluamVjdG9yJywgZnVuY3Rpb24oJGluamVjdG9yKSB7XHJcbiAgICAgIHJldHVybiAkaW5qZWN0b3IuaW5zdGFudGlhdGUoY29uc3RydWN0b3IpO1xyXG4gICAgfV0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmFsdWUobmFtZSwgdmFsdWUpIHsgcmV0dXJuIGZhY3RvcnkobmFtZSwgdmFsdWVGbih2YWx1ZSkpOyB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XHJcbiAgICBwcm92aWRlckNhY2hlW25hbWVdID0gdmFsdWU7XHJcbiAgICBpbnN0YW5jZUNhY2hlW25hbWVdID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZWNvcmF0b3Ioc2VydmljZU5hbWUsIGRlY29yRm4pIHtcclxuICAgIHZhciBvcmlnUHJvdmlkZXIgPSBwcm92aWRlckluamVjdG9yLmdldChzZXJ2aWNlTmFtZSArIHByb3ZpZGVyU3VmZml4KSxcclxuICAgICAgICBvcmlnJGdldCA9IG9yaWdQcm92aWRlci4kZ2V0O1xyXG5cclxuICAgIG9yaWdQcm92aWRlci4kZ2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBvcmlnSW5zdGFuY2UgPSBpbnN0YW5jZUluamVjdG9yLmludm9rZShvcmlnJGdldCwgb3JpZ1Byb3ZpZGVyKTtcclxuICAgICAgcmV0dXJuIGluc3RhbmNlSW5qZWN0b3IuaW52b2tlKGRlY29yRm4sIG51bGwsIHskZGVsZWdhdGU6IG9yaWdJbnN0YW5jZX0pO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIE1vZHVsZSBMb2FkaW5nXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgZnVuY3Rpb24gbG9hZE1vZHVsZXMobW9kdWxlc1RvTG9hZCl7XHJcbiAgICB2YXIgcnVuQmxvY2tzID0gW107XHJcbiAgICBmb3JFYWNoKG1vZHVsZXNUb0xvYWQsIGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4gICAgICBpZiAobG9hZGVkTW9kdWxlcy5nZXQobW9kdWxlKSkgcmV0dXJuO1xyXG4gICAgICBsb2FkZWRNb2R1bGVzLnB1dChtb2R1bGUsIHRydWUpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcobW9kdWxlKSkge1xyXG4gICAgICAgICAgdmFyIG1vZHVsZUZuID0gYW5ndWxhck1vZHVsZShtb2R1bGUpO1xyXG4gICAgICAgICAgcnVuQmxvY2tzID0gcnVuQmxvY2tzLmNvbmNhdChsb2FkTW9kdWxlcyhtb2R1bGVGbi5yZXF1aXJlcykpLmNvbmNhdChtb2R1bGVGbi5fcnVuQmxvY2tzKTtcclxuXHJcbiAgICAgICAgICBmb3IodmFyIGludm9rZVF1ZXVlID0gbW9kdWxlRm4uX2ludm9rZVF1ZXVlLCBpID0gMCwgaWkgPSBpbnZva2VRdWV1ZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnZva2VBcmdzID0gaW52b2tlUXVldWVbaV0sXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVySW5qZWN0b3IuZ2V0KGludm9rZUFyZ3NbMF0pO1xyXG5cclxuICAgICAgICAgICAgcHJvdmlkZXJbaW52b2tlQXJnc1sxXV0uYXBwbHkocHJvdmlkZXIsIGludm9rZUFyZ3NbMl0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihtb2R1bGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bkJsb2Nrcy5wdXNoKHByb3ZpZGVySW5qZWN0b3IuaW52b2tlKG1vZHVsZSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShtb2R1bGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bkJsb2Nrcy5wdXNoKHByb3ZpZGVySW5qZWN0b3IuaW52b2tlKG1vZHVsZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhc3NlcnRBcmdGbihtb2R1bGUsICdtb2R1bGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShtb2R1bGUpKSB7XHJcbiAgICAgICAgICBtb2R1bGUgPSBtb2R1bGVbbW9kdWxlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZS5tZXNzYWdlICYmIGUuc3RhY2sgJiYgZS5zdGFjay5pbmRleE9mKGUubWVzc2FnZSkgPT0gLTEpIHtcclxuICAgICAgICAgIC8vIFNhZmFyaSAmIEZGJ3Mgc3RhY2sgdHJhY2VzIGRvbid0IGNvbnRhaW4gZXJyb3IubWVzc2FnZSBjb250ZW50IHVubGlrZSB0aG9zZSBvZiBDaHJvbWUgYW5kIElFXHJcbiAgICAgICAgICAvLyBTbyBpZiBzdGFjayBkb2Vzbid0IGNvbnRhaW4gbWVzc2FnZSwgd2UgY3JlYXRlIGEgbmV3IHN0cmluZyB0aGF0IGNvbnRhaW5zIGJvdGguXHJcbiAgICAgICAgICAvLyBTaW5jZSBlcnJvci5zdGFjayBpcyByZWFkLW9ubHkgaW4gU2FmYXJpLCBJJ20gb3ZlcnJpZGluZyBlIGFuZCBub3QgZS5zdGFjayBoZXJlLlxyXG4gICAgICAgICAgZSA9IGUubWVzc2FnZSArICdcXG4nICsgZS5zdGFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgJGluamVjdG9yTWluRXJyKCdtb2R1bGVycicsIFwiRmFpbGVkIHRvIGluc3RhbnRpYXRlIG1vZHVsZSB7MH0gZHVlIHRvOlxcbnsxfVwiLCBtb2R1bGUsIGUuc3RhY2sgfHwgZS5tZXNzYWdlIHx8IGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBydW5CbG9ja3M7XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBpbnRlcm5hbCBJbmplY3RvclxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbEluamVjdG9yKGNhY2hlLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2VydmljZShzZXJ2aWNlTmFtZSkge1xyXG4gICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoc2VydmljZU5hbWUpKSB7XHJcbiAgICAgICAgaWYgKGNhY2hlW3NlcnZpY2VOYW1lXSA9PT0gSU5TVEFOVElBVElORykge1xyXG4gICAgICAgICAgdGhyb3cgJGluamVjdG9yTWluRXJyKCdjZGVwJywgJ0NpcmN1bGFyIGRlcGVuZGVuY3kgZm91bmQ6IHswfScsIHBhdGguam9pbignIDwtICcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlW3NlcnZpY2VOYW1lXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcGF0aC51bnNoaWZ0KHNlcnZpY2VOYW1lKTtcclxuICAgICAgICAgIGNhY2hlW3NlcnZpY2VOYW1lXSA9IElOU1RBTlRJQVRJTkc7XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGVbc2VydmljZU5hbWVdID0gZmFjdG9yeShzZXJ2aWNlTmFtZSk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHBhdGguc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnZva2UoZm4sIHNlbGYsIGxvY2Fscyl7XHJcbiAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICAkaW5qZWN0ID0gYW5ub3RhdGUoZm4pLFxyXG4gICAgICAgICAgbGVuZ3RoLCBpLFxyXG4gICAgICAgICAga2V5O1xyXG5cclxuICAgICAgZm9yKGkgPSAwLCBsZW5ndGggPSAkaW5qZWN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAga2V5ID0gJGluamVjdFtpXTtcclxuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycignaXRrbicsICdJbmNvcnJlY3QgaW5qZWN0aW9uIHRva2VuISBFeHBlY3RlZCBzZXJ2aWNlIG5hbWUgYXMgc3RyaW5nLCBnb3QgezB9Jywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXJncy5wdXNoKFxyXG4gICAgICAgICAgbG9jYWxzICYmIGxvY2Fscy5oYXNPd25Qcm9wZXJ0eShrZXkpXHJcbiAgICAgICAgICA/IGxvY2Fsc1trZXldXHJcbiAgICAgICAgICA6IGdldFNlcnZpY2Uoa2V5KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFmbi4kaW5qZWN0KSB7XHJcbiAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHdlIG11c3QgYmUgYW4gYXJyYXkuXHJcbiAgICAgICAgZm4gPSBmbltsZW5ndGhdO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBodHRwOi8vanNwZXJmLmNvbS9hcHBseS12cy1jYWxsLXZzLWludm9rZVxyXG4gICAgICBzd2l0Y2ggKHNlbGYgPyAtMSA6IGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgY2FzZSAgMDogcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgY2FzZSAgMTogcmV0dXJuIGZuKGFyZ3NbMF0pO1xyXG4gICAgICAgIGNhc2UgIDI6IHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgICAgICBjYXNlICAzOiByZXR1cm4gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XHJcbiAgICAgICAgY2FzZSAgNDogcmV0dXJuIGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xyXG4gICAgICAgIGNhc2UgIDU6IHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcclxuICAgICAgICBjYXNlICA2OiByZXR1cm4gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XHJcbiAgICAgICAgY2FzZSAgNzogcmV0dXJuIGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xyXG4gICAgICAgIGNhc2UgIDg6IHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdLCBhcmdzWzddKTtcclxuICAgICAgICBjYXNlICA5OiByZXR1cm4gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSwgYXJnc1s3XSwgYXJnc1s4XSk7XHJcbiAgICAgICAgY2FzZSAxMDogcmV0dXJuIGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0sIGFyZ3NbN10sIGFyZ3NbOF0sIGFyZ3NbOV0pO1xyXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBmbi5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlKFR5cGUsIGxvY2Fscykge1xyXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHt9LFxyXG4gICAgICAgICAgaW5zdGFuY2UsIHJldHVybmVkVmFsdWU7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiBUeXBlIGlzIGFubm90YXRlZCBhbmQgdXNlIGp1c3QgdGhlIGdpdmVuIGZ1bmN0aW9uIGF0IG4tMSBhcyBwYXJhbWV0ZXJcclxuICAgICAgLy8gZS5nLiBzb21lTW9kdWxlLmZhY3RvcnkoJ2dyZWV0ZXInLCBbJyR3aW5kb3cnLCBmdW5jdGlvbihyZW5hbWVkJHdpbmRvdykge31dKTtcclxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gKGlzQXJyYXkoVHlwZSkgPyBUeXBlW1R5cGUubGVuZ3RoIC0gMV0gOiBUeXBlKS5wcm90b3R5cGU7XHJcbiAgICAgIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XHJcbiAgICAgIHJldHVybmVkVmFsdWUgPSBpbnZva2UoVHlwZSwgaW5zdGFuY2UsIGxvY2Fscyk7XHJcblxyXG4gICAgICByZXR1cm4gaXNPYmplY3QocmV0dXJuZWRWYWx1ZSkgPyByZXR1cm5lZFZhbHVlIDogaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaW52b2tlOiBpbnZva2UsXHJcbiAgICAgIGluc3RhbnRpYXRlOiBpbnN0YW50aWF0ZSxcclxuICAgICAgZ2V0OiBnZXRTZXJ2aWNlLFxyXG4gICAgICBhbm5vdGF0ZTogYW5ub3RhdGUsXHJcbiAgICAgIGhhczogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwcm92aWRlckNhY2hlLmhhc093blByb3BlcnR5KG5hbWUgKyBwcm92aWRlclN1ZmZpeCkgfHwgY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIG5nLiRhbmNob3JTY3JvbGxcclxuICogQHJlcXVpcmVzICR3aW5kb3dcclxuICogQHJlcXVpcmVzICRsb2NhdGlvblxyXG4gKiBAcmVxdWlyZXMgJHJvb3RTY29wZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogV2hlbiBjYWxsZWQsIGl0IGNoZWNrcyBjdXJyZW50IHZhbHVlIG9mIGAkbG9jYXRpb24uaGFzaCgpYCBhbmQgc2Nyb2xsIHRvIHJlbGF0ZWQgZWxlbWVudCxcclxuICogYWNjb3JkaW5nIHRvIHJ1bGVzIHNwZWNpZmllZCBpblxyXG4gKiB7QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI3RoZS1pbmRpY2F0ZWQtcGFydC1vZi10aGUtZG9jdW1lbnQgSHRtbDUgc3BlY30uXHJcbiAqXHJcbiAqIEl0IGFsc28gd2F0Y2hlcyB0aGUgYCRsb2NhdGlvbi5oYXNoKClgIGFuZCBzY3JvbGwgd2hlbmV2ZXIgaXQgY2hhbmdlcyB0byBtYXRjaCBhbnkgYW5jaG9yLlxyXG4gKiBUaGlzIGNhbiBiZSBkaXNhYmxlZCBieSBjYWxsaW5nIGAkYW5jaG9yU2Nyb2xsUHJvdmlkZXIuZGlzYWJsZUF1dG9TY3JvbGxpbmcoKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiAkQW5jaG9yU2Nyb2xsUHJvdmlkZXIoKSB7XHJcblxyXG4gIHZhciBhdXRvU2Nyb2xsaW5nRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIHRoaXMuZGlzYWJsZUF1dG9TY3JvbGxpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIGF1dG9TY3JvbGxpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckd2luZG93JywgJyRsb2NhdGlvbicsICckcm9vdFNjb3BlJywgZnVuY3Rpb24oJHdpbmRvdywgJGxvY2F0aW9uLCAkcm9vdFNjb3BlKSB7XHJcbiAgICB2YXIgZG9jdW1lbnQgPSAkd2luZG93LmRvY3VtZW50O1xyXG5cclxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgZmlyc3QgYW5jaG9yIGZyb20gYSBOb2RlTGlzdFxyXG4gICAgLy8gY2FuJ3QgdXNlIGZpbHRlci5maWx0ZXIsIGFzIGl0IGFjY2VwdHMgb25seSBpbnN0YW5jZXMgb2YgQXJyYXlcclxuICAgIC8vIGFuZCBJRSBjYW4ndCBjb252ZXJ0IE5vZGVMaXN0IHRvIGFuIGFycmF5IHVzaW5nIFtdLnNsaWNlXHJcbiAgICAvLyBUT0RPKHZvanRhKTogdXNlIGZpbHRlciBpZiB3ZSBjaGFuZ2UgaXQgdG8gYWNjZXB0IGxpc3RzIGFzIHdlbGxcclxuICAgIGZ1bmN0aW9uIGdldEZpcnN0QW5jaG9yKGxpc3QpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgIGZvckVhY2gobGlzdCwgZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIGxvd2VyY2FzZShlbGVtZW50Lm5vZGVOYW1lKSA9PT0gJ2EnKSByZXN1bHQgPSBlbGVtZW50O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY3JvbGwoKSB7XHJcbiAgICAgIHZhciBoYXNoID0gJGxvY2F0aW9uLmhhc2goKSwgZWxtO1xyXG5cclxuICAgICAgLy8gZW1wdHkgaGFzaCwgc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2VcclxuICAgICAgaWYgKCFoYXNoKSAkd2luZG93LnNjcm9sbFRvKDAsIDApO1xyXG5cclxuICAgICAgLy8gZWxlbWVudCB3aXRoIGdpdmVuIGlkXHJcbiAgICAgIGVsc2UgaWYgKChlbG0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKSkpIGVsbS5zY3JvbGxJbnRvVmlldygpO1xyXG5cclxuICAgICAgLy8gZmlyc3QgYW5jaG9yIHdpdGggZ2l2ZW4gbmFtZSA6LURcclxuICAgICAgZWxzZSBpZiAoKGVsbSA9IGdldEZpcnN0QW5jaG9yKGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpKSkpIGVsbS5zY3JvbGxJbnRvVmlldygpO1xyXG5cclxuICAgICAgLy8gbm8gZWxlbWVudCBhbmQgaGFzaCA9PSAndG9wJywgc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2VcclxuICAgICAgZWxzZSBpZiAoaGFzaCA9PT0gJ3RvcCcpICR3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZG9lcyBub3Qgc2Nyb2xsIHdoZW4gdXNlciBjbGlja3Mgb24gYW5jaG9yIGxpbmsgdGhhdCBpcyBjdXJyZW50bHkgb25cclxuICAgIC8vIChubyB1cmwgY2hhbmdlLCBubyAkbG9jYXRpb24uaGFzaCgpIGNoYW5nZSksIGJyb3dzZXIgbmF0aXZlIGRvZXMgc2Nyb2xsXHJcbiAgICBpZiAoYXV0b1Njcm9sbGluZ0VuYWJsZWQpIHtcclxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24gYXV0b1Njcm9sbFdhdGNoKCkge3JldHVybiAkbG9jYXRpb24uaGFzaCgpO30sXHJcbiAgICAgICAgZnVuY3Rpb24gYXV0b1Njcm9sbFdhdGNoQWN0aW9uKCkge1xyXG4gICAgICAgICAgJHJvb3RTY29wZS4kZXZhbEFzeW5jKHNjcm9sbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNjcm9sbDtcclxuICB9XTtcclxufVxyXG5cclxudmFyICRhbmltYXRlTWluRXJyID0gbWluRXJyKCckYW5pbWF0ZScpO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJGFuaW1hdGVQcm92aWRlclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiAkYW5pbWF0ZSB0aGF0IGRvZXNuJ3QgcGVyZm9ybSBhbnkgYW5pbWF0aW9ucywgaW5zdGVhZCBqdXN0IHN5bmNocm9ub3VzbHkgcGVyZm9ybXMgRE9NXHJcbiAqIHVwZGF0ZXMgYW5kIGNhbGxzIGRvbmUoKSBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEluIG9yZGVyIHRvIGVuYWJsZSBhbmltYXRpb25zIHRoZSBuZ0FuaW1hdGUgbW9kdWxlIGhhcyB0byBiZSBsb2FkZWQuXHJcbiAqXHJcbiAqIFRvIHNlZSB0aGUgZnVuY3Rpb25hbCBpbXBsZW1lbnRhdGlvbiBjaGVjayBvdXQgc3JjL25nQW5pbWF0ZS9hbmltYXRlLmpzXHJcbiAqL1xyXG52YXIgJEFuaW1hdGVQcm92aWRlciA9IFsnJHByb3ZpZGUnLCBmdW5jdGlvbigkcHJvdmlkZSkge1xyXG5cclxuICB0aGlzLiQkc2VsZWN0b3JzID0ge307XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy4kYW5pbWF0ZVByb3ZpZGVyI3JlZ2lzdGVyXHJcbiAgICogQG1ldGhvZE9mIG5nLiRhbmltYXRlUHJvdmlkZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFJlZ2lzdGVycyBhIG5ldyBpbmplY3RhYmxlIGFuaW1hdGlvbiBmYWN0b3J5IGZ1bmN0aW9uLiBUaGUgZmFjdG9yeSBmdW5jdGlvbiBwcm9kdWNlcyB0aGUgYW5pbWF0aW9uIG9iamVjdCB3aGljaFxyXG4gICAqIGNvbnRhaW5zIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudCB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuaW1hdGVkLlxyXG4gICAqXHJcbiAgICogICAqIGBldmVudEZuYDogYGZ1bmN0aW9uKEVsZW1lbnQsIGRvbmVGdW5jdGlvbilgIFRoZSBlbGVtZW50IHRvIGFuaW1hdGUsIHRoZSBgZG9uZUZ1bmN0aW9uYCBtdXN0IGJlIGNhbGxlZCBvbmNlIHRoZVxyXG4gICAqICAgZWxlbWVudCBhbmltYXRpb24gaXMgY29tcGxldGUuIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgdGhlbiB0aGUgYW5pbWF0aW9uIHNlcnZpY2Ugd2lsbCB1c2UgdGhpcyBmdW5jdGlvbiB0b1xyXG4gICAqICAgY2FuY2VsIHRoZSBhbmltYXRpb24gd2hlbmV2ZXIgYSBjYW5jZWwgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAqXHJcbiAgICpcclxuICAgKjxwcmU+XHJcbiAgICogICByZXR1cm4ge1xyXG4gICAgICogICAgIGV2ZW50Rm4gOiBmdW5jdGlvbihlbGVtZW50LCBkb25lKSB7XHJcbiAgICAgKiAgICAgICAvL2NvZGUgdG8gcnVuIHRoZSBhbmltYXRpb25cclxuICAgICAqICAgICAgIC8vb25jZSBjb21wbGV0ZSwgdGhlbiBydW4gZG9uZSgpXHJcbiAgICAgKiAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FuY2VsbGF0aW9uRnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgICAgIC8vY29kZSB0byBjYW5jZWwgdGhlIGFuaW1hdGlvblxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAqPC9wcmU+XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhY3RvcnkgVGhlIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHJldHVybiB0aGUgYW5pbWF0aW9uIG9iamVjdC5cclxuICAgKi9cclxuICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24obmFtZSwgZmFjdG9yeSkge1xyXG4gICAgdmFyIGtleSA9IG5hbWUgKyAnLWFuaW1hdGlvbic7XHJcbiAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSAhPSAnLicpIHRocm93ICRhbmltYXRlTWluRXJyKCdub3Rjc2VsJyxcclxuICAgICAgICBcIkV4cGVjdGluZyBjbGFzcyBzZWxlY3RvciBzdGFydGluZyB3aXRoICcuJyBnb3QgJ3swfScuXCIsIG5hbWUpO1xyXG4gICAgdGhpcy4kJHNlbGVjdG9yc1tuYW1lLnN1YnN0cigxKV0gPSBrZXk7XHJcbiAgICAkcHJvdmlkZS5mYWN0b3J5KGtleSwgZmFjdG9yeSk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckdGltZW91dCcsIGZ1bmN0aW9uKCR0aW1lb3V0KSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2Mgb2JqZWN0XHJcbiAgICAgKiBAbmFtZSBuZy4kYW5pbWF0ZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogVGhlICRhbmltYXRlIHNlcnZpY2UgcHJvdmlkZXMgcnVkaW1lbnRhcnkgRE9NIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgdG8gaW5zZXJ0LCByZW1vdmUsIG1vdmUgZWxlbWVudHMgd2l0aGluXHJcbiAgICAgKiB0aGUgRE9NIGFzIHdlbGwgYXMgYWRkaW5nIGFuZCByZW1vdmluZyBjbGFzc2VzLiBUaGlzIHNlcnZpY2UgaXMgdGhlIGNvcmUgc2VydmljZSB1c2VkIGJ5IHRoZSBuZ0FuaW1hdGUgJGFuaW1hdG9yXHJcbiAgICAgKiBzZXJ2aWNlIHdoaWNoIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYW5pbWF0aW9uIGhvb2tzIGZvciBDU1MgYW5kIEphdmFTY3JpcHQuIFxyXG4gICAgICpcclxuICAgICAqICRhbmltYXRlIGlzIGF2YWlsYWJsZSBpbiB0aGUgQW5ndWxhckpTIGNvcmUsIGhvd2V2ZXIsIHRoZSBuZ0FuaW1hdGUgbW9kdWxlIG11c3QgYmUgaW5jbHVkZWQgdG8gZW5hYmxlIGZ1bGwgb3V0XHJcbiAgICAgKiBhbmltYXRpb24gc3VwcG9ydC4gT3RoZXJ3aXNlLCAkYW5pbWF0ZSB3aWxsIG9ubHkgcGVyZm9ybSBzaW1wbGUgRE9NIG1hbmlwdWxhdGlvbiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIFRvIGxlYXJuIG1vcmUgYWJvdXQgZW5hYmxpbmcgYW5pbWF0aW9uIHN1cHBvcnQsIGNsaWNrIGhlcmUgdG8gdmlzaXQgdGhlIHtAbGluayBuZ0FuaW1hdGUgbmdBbmltYXRlIG1vZHVsZSBwYWdlfVxyXG4gICAgICogYXMgd2VsbCBhcyB0aGUge0BsaW5rIG5nQW5pbWF0ZS4kYW5pbWF0ZSBuZ0FuaW1hdGUgJGFuaW1hdGUgc2VydmljZSBwYWdlfS5cclxuICAgICAqL1xyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjZW50ZXJcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRhbmltYXRlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogSW5zZXJ0cyB0aGUgZWxlbWVudCBpbnRvIHRoZSBET00gZWl0aGVyIGFmdGVyIHRoZSBgYWZ0ZXJgIGVsZW1lbnQgb3Igd2l0aGluIHRoZSBgcGFyZW50YCBlbGVtZW50LiBPbmNlIGNvbXBsZXRlLFxyXG4gICAgICAgKiB0aGUgZG9uZSgpIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgKGlmIHByb3ZpZGVkKS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET01cclxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IHBhcmVudCB0aGUgcGFyZW50IGVsZW1lbnQgd2hpY2ggd2lsbCBhcHBlbmQgdGhlIGVsZW1lbnQgYXMgYSBjaGlsZCAoaWYgdGhlIGFmdGVyIGVsZW1lbnQgaXMgbm90IHByZXNlbnQpXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBhZnRlciB0aGUgc2libGluZyBlbGVtZW50IHdoaWNoIHdpbGwgYXBwZW5kIHRoZSBlbGVtZW50IGFmdGVyIGl0c2VsZlxyXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gZG9uZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIERPTVxyXG4gICAgICAgKi9cclxuICAgICAgZW50ZXIgOiBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIGFmdGVyLCBkb25lKSB7XHJcbiAgICAgICAgdmFyIGFmdGVyTm9kZSA9IGFmdGVyICYmIGFmdGVyW2FmdGVyLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50ICYmIHBhcmVudFswXSB8fCBhZnRlck5vZGUgJiYgYWZ0ZXJOb2RlLnBhcmVudE5vZGU7XHJcbiAgICAgICAgLy8gSUUgZG9lcyBub3QgbGlrZSB1bmRlZmluZWQgc28gd2UgaGF2ZSB0byBwYXNzIG51bGwuXHJcbiAgICAgICAgdmFyIGFmdGVyTmV4dFNpYmxpbmcgPSAoYWZ0ZXJOb2RlICYmIGFmdGVyTm9kZS5uZXh0U2libGluZykgfHwgbnVsbDtcclxuICAgICAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGFmdGVyTmV4dFNpYmxpbmcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGRvbmUgJiYgJHRpbWVvdXQoZG9uZSwgMCwgZmFsc2UpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kYW5pbWF0ZSNsZWF2ZVxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGFuaW1hdGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTS4gT25jZSBjb21wbGV0ZSwgdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGRvbmUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIERPTVxyXG4gICAgICAgKi9cclxuICAgICAgbGVhdmUgOiBmdW5jdGlvbihlbGVtZW50LCBkb25lKSB7XHJcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICBkb25lICYmICR0aW1lb3V0KGRvbmUsIDAsIGZhbHNlKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjbW92ZVxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGFuaW1hdGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBNb3ZlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQgd2l0aGluIHRoZSBET00gdG8gYmUgcGxhY2VkIGVpdGhlciBhZnRlciB0aGUgYGFmdGVyYCBlbGVtZW50IG9yIGluc2lkZSBvZiB0aGUgYHBhcmVudGAgZWxlbWVudC5cclxuICAgICAgICogT25jZSBjb21wbGV0ZSwgdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgbW92ZWQgYXJvdW5kIHdpdGhpbiB0aGUgRE9NXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBwYXJlbnQgdGhlIHBhcmVudCBlbGVtZW50IHdoZXJlIHRoZSBlbGVtZW50IHdpbGwgYmUgaW5zZXJ0ZWQgaW50byAoaWYgdGhlIGFmdGVyIGVsZW1lbnQgaXMgbm90IHByZXNlbnQpXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBhZnRlciB0aGUgc2libGluZyBlbGVtZW50IHdoZXJlIHRoZSBlbGVtZW50IHdpbGwgYmUgcG9zaXRpb25lZCBuZXh0IHRvXHJcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBkb25lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAoaWYgcHJvdmlkZWQpIHRoYXQgd2lsbCBiZSBmaXJlZCBhZnRlciB0aGUgZWxlbWVudCBoYXMgYmVlbiBtb3ZlZCB0byBpdCdzIG5ldyBwb3NpdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgbW92ZSA6IGZ1bmN0aW9uKGVsZW1lbnQsIHBhcmVudCwgYWZ0ZXIsIGRvbmUpIHtcclxuICAgICAgICAvLyBEbyBub3QgcmVtb3ZlIGVsZW1lbnQgYmVmb3JlIGluc2VydC4gUmVtb3Zpbmcgd2lsbCBjYXVzZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGVcclxuICAgICAgICAvLyBlbGVtZW50IHRvIGJlIGRyb3BwZWQuIEluc2VydCB3aWxsIGltcGxpY2l0bHkgZG8gdGhlIHJlbW92ZS5cclxuICAgICAgICB0aGlzLmVudGVyKGVsZW1lbnQsIHBhcmVudCwgYWZ0ZXIsIGRvbmUpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kYW5pbWF0ZSNhZGRDbGFzc1xyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGFuaW1hdGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBBZGRzIHRoZSBwcm92aWRlZCBjbGFzc05hbWUgQ1NTIGNsYXNzIHZhbHVlIHRvIHRoZSBwcm92aWRlZCBlbGVtZW50LiBPbmNlIGNvbXBsZXRlLCB0aGUgZG9uZSgpIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgKGlmIHByb3ZpZGVkKS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBoYXZlIHRoZSBjbGFzc05hbWUgdmFsdWUgYWRkZWQgdG8gaXRcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIHdoaWNoIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnRcclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGRvbmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIChpZiBwcm92aWRlZCkgdGhhdCB3aWxsIGJlIGZpcmVkIGFmdGVyIHRoZSBjbGFzc05hbWUgdmFsdWUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGVsZW1lbnRcclxuICAgICAgICovXHJcbiAgICAgIGFkZENsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XHJcbiAgICAgICAgY2xhc3NOYW1lID0gaXNTdHJpbmcoY2xhc3NOYW1lKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShjbGFzc05hbWUpID8gY2xhc3NOYW1lLmpvaW4oJyAnKSA6ICcnO1xyXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcclxuICAgICAgICBkb25lICYmICR0aW1lb3V0KGRvbmUsIDAsIGZhbHNlKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjcmVtb3ZlQ2xhc3NcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRhbmltYXRlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogUmVtb3ZlcyB0aGUgcHJvdmlkZWQgY2xhc3NOYW1lIENTUyBjbGFzcyB2YWx1ZSBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50LiBPbmNlIGNvbXBsZXRlLCB0aGUgZG9uZSgpIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgKGlmIHByb3ZpZGVkKS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBoYXZlIHRoZSBjbGFzc05hbWUgdmFsdWUgcmVtb3ZlZCBmcm9tIGl0XHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyB3aGljaCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxyXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gZG9uZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKGlmIHByb3ZpZGVkKSB0aGF0IHdpbGwgYmUgZmlyZWQgYWZ0ZXIgdGhlIGNsYXNzTmFtZSB2YWx1ZSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnRcclxuICAgICAgICovXHJcbiAgICAgIHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XHJcbiAgICAgICAgY2xhc3NOYW1lID0gaXNTdHJpbmcoY2xhc3NOYW1lKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShjbGFzc05hbWUpID8gY2xhc3NOYW1lLmpvaW4oJyAnKSA6ICcnO1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcclxuICAgICAgICBkb25lICYmICR0aW1lb3V0KGRvbmUsIDAsIGZhbHNlKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIGVuYWJsZWQgOiBub29wXHJcbiAgICB9O1xyXG4gIH1dO1xyXG59XTtcclxuXHJcbi8qKlxyXG4gKiAhIFRoaXMgaXMgYSBwcml2YXRlIHVuZG9jdW1lbnRlZCBzZXJ2aWNlICFcclxuICpcclxuICogQG5hbWUgbmcuJGJyb3dzZXJcclxuICogQHJlcXVpcmVzICRsb2dcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgb2JqZWN0IGhhcyB0d28gZ29hbHM6XHJcbiAqXHJcbiAqIC0gaGlkZSBhbGwgdGhlIGdsb2JhbCBzdGF0ZSBpbiB0aGUgYnJvd3NlciBjYXVzZWQgYnkgdGhlIHdpbmRvdyBvYmplY3RcclxuICogLSBhYnN0cmFjdCBhd2F5IGFsbCB0aGUgYnJvd3NlciBzcGVjaWZpYyBmZWF0dXJlcyBhbmQgaW5jb25zaXN0ZW5jaWVzXHJcbiAqXHJcbiAqIEZvciB0ZXN0cyB3ZSBwcm92aWRlIHtAbGluayBuZ01vY2suJGJyb3dzZXIgbW9jayBpbXBsZW1lbnRhdGlvbn0gb2YgdGhlIGAkYnJvd3NlcmBcclxuICogc2VydmljZSwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGNvbnZlbmllbnQgdGVzdGluZyBvZiB0aGUgYXBwbGljYXRpb24gd2l0aG91dCB0aGUgaW50ZXJhY3Rpb24gd2l0aFxyXG4gKiB0aGUgcmVhbCBicm93c2VyIGFwaXMuXHJcbiAqL1xyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IHdpbmRvdyBUaGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudCBqUXVlcnkgd3JhcHBlZCBkb2N1bWVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBYSFIgWE1MSHR0cFJlcXVlc3QgY29uc3RydWN0b3IuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSAkbG9nIGNvbnNvbGUubG9nIG9yIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGludGVyZmFjZS5cclxuICogQHBhcmFtIHtvYmplY3R9ICRzbmlmZmVyICRzbmlmZmVyIHNlcnZpY2VcclxuICovXHJcbmZ1bmN0aW9uIEJyb3dzZXIod2luZG93LCBkb2N1bWVudCwgJGxvZywgJHNuaWZmZXIpIHtcclxuICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgIHJhd0RvY3VtZW50ID0gZG9jdW1lbnRbMF0sXHJcbiAgICAgIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxyXG4gICAgICBoaXN0b3J5ID0gd2luZG93Lmhpc3RvcnksXHJcbiAgICAgIHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCxcclxuICAgICAgY2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dCxcclxuICAgICAgcGVuZGluZ0RlZmVySWRzID0ge307XHJcblxyXG4gIHNlbGYuaXNNb2NrID0gZmFsc2U7XHJcblxyXG4gIHZhciBvdXRzdGFuZGluZ1JlcXVlc3RDb3VudCA9IDA7XHJcbiAgdmFyIG91dHN0YW5kaW5nUmVxdWVzdENhbGxiYWNrcyA9IFtdO1xyXG5cclxuICAvLyBUT0RPKHZvanRhKTogcmVtb3ZlIHRoaXMgdGVtcG9yYXJ5IGFwaVxyXG4gIHNlbGYuJCRjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdCA9IGNvbXBsZXRlT3V0c3RhbmRpbmdSZXF1ZXN0O1xyXG4gIHNlbGYuJCRpbmNPdXRzdGFuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uKCkgeyBvdXRzdGFuZGluZ1JlcXVlc3RDb3VudCsrOyB9O1xyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlcyB0aGUgYGZuYCBmdW5jdGlvbihzdXBwb3J0cyBjdXJyeWluZykgYW5kIGRlY3JlbWVudHMgdGhlIGBvdXRzdGFuZGluZ1JlcXVlc3RDYWxsYmFja3NgXHJcbiAgICogY291bnRlci4gSWYgdGhlIGNvdW50ZXIgcmVhY2hlcyAwLCBhbGwgdGhlIGBvdXRzdGFuZGluZ1JlcXVlc3RDYWxsYmFja3NgIGFyZSBleGVjdXRlZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdChmbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm4uYXBwbHkobnVsbCwgc2xpY2VBcmdzKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgb3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQtLTtcclxuICAgICAgaWYgKG91dHN0YW5kaW5nUmVxdWVzdENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgd2hpbGUob3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgb3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzLnBvcCgpKCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICRsb2cuZXJyb3IoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHVzZWQgb25seSBieSBzY2VuYXJpbyBydW5uZXJcclxuICAgKiBUT0RPKHZvanRhKTogcHJlZml4IHRoaXMgbWV0aG9kIHdpdGggJCQgP1xyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIG5vIG91dHN0YW5kaW5nIHJlcXVlc3RcclxuICAgKi9cclxuICBzZWxmLm5vdGlmeVdoZW5Ob091dHN0YW5kaW5nUmVxdWVzdHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgLy8gZm9yY2UgYnJvd3NlciB0byBleGVjdXRlIGFsbCBwb2xsRm5zIC0gdGhpcyBpcyBuZWVkZWQgc28gdGhhdCBjb29raWVzIGFuZCBvdGhlciBwb2xsZXJzIGZpcmVcclxuICAgIC8vIGF0IHNvbWUgZGV0ZXJtaW5pc3RpYyB0aW1lIGluIHJlc3BlY3QgdG8gdGhlIHRlc3QgcnVubmVyJ3MgYWN0aW9ucy4gTGVhdmluZyB0aGluZ3MgdXAgdG8gdGhlXHJcbiAgICAvLyByZWd1bGFyIHBvbGxlciB3b3VsZCByZXN1bHQgaW4gZmxha3kgdGVzdHMuXHJcbiAgICBmb3JFYWNoKHBvbGxGbnMsIGZ1bmN0aW9uKHBvbGxGbil7IHBvbGxGbigpOyB9KTtcclxuXHJcbiAgICBpZiAob3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQgPT09IDApIHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91dHN0YW5kaW5nUmVxdWVzdENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFBvbGwgV2F0Y2hlciBBUElcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIHZhciBwb2xsRm5zID0gW10sXHJcbiAgICAgIHBvbGxUaW1lb3V0O1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNhZGRQb2xsRm5cclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm4gUG9sbCBmdW5jdGlvbiB0byBhZGRcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEFkZHMgYSBmdW5jdGlvbiB0byB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgdGhhdCBwb2xsZXIgcGVyaW9kaWNhbGx5IGV4ZWN1dGVzLFxyXG4gICAqIGFuZCBzdGFydHMgcG9sbGluZyBpZiBub3Qgc3RhcnRlZCB5ZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKX0gdGhlIGFkZGVkIGZ1bmN0aW9uXHJcbiAgICovXHJcbiAgc2VsZi5hZGRQb2xsRm4gPSBmdW5jdGlvbihmbikge1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKHBvbGxUaW1lb3V0KSkgc3RhcnRQb2xsZXIoMTAwLCBzZXRUaW1lb3V0KTtcclxuICAgIHBvbGxGbnMucHVzaChmbik7XHJcbiAgICByZXR1cm4gZm47XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIEhvdyBvZnRlbiBzaG91bGQgYnJvd3NlciBjYWxsIHBvbGwgZnVuY3Rpb25zIChtcylcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHNldFRpbWVvdXQgUmVmZXJlbmNlIHRvIGEgcmVhbCBvciBmYWtlIGBzZXRUaW1lb3V0YCBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIENvbmZpZ3VyZXMgdGhlIHBvbGxlciB0byBydW4gaW4gdGhlIHNwZWNpZmllZCBpbnRlcnZhbHMsIHVzaW5nIHRoZSBzcGVjaWZpZWRcclxuICAgKiBzZXRUaW1lb3V0IGZuIGFuZCBraWNrcyBpdCBvZmYuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc3RhcnRQb2xsZXIoaW50ZXJ2YWwsIHNldFRpbWVvdXQpIHtcclxuICAgIChmdW5jdGlvbiBjaGVjaygpIHtcclxuICAgICAgZm9yRWFjaChwb2xsRm5zLCBmdW5jdGlvbihwb2xsRm4peyBwb2xsRm4oKTsgfSk7XHJcbiAgICAgIHBvbGxUaW1lb3V0ID0gc2V0VGltZW91dChjaGVjaywgaW50ZXJ2YWwpO1xyXG4gICAgfSkoKTtcclxuICB9XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gVVJMIEFQSVxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gIHZhciBsYXN0QnJvd3NlclVybCA9IGxvY2F0aW9uLmhyZWYsXHJcbiAgICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQuZmluZCgnYmFzZScpLFxyXG4gICAgICByZXBsYWNlZFVybCA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIG5nLiRicm93c2VyI3VybFxyXG4gICAqIEBtZXRob2RPZiBuZy4kYnJvd3NlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogR0VUVEVSOlxyXG4gICAqIFdpdGhvdXQgYW55IGFyZ3VtZW50LCB0aGlzIG1ldGhvZCBqdXN0IHJldHVybnMgY3VycmVudCB2YWx1ZSBvZiBsb2NhdGlvbi5ocmVmLlxyXG4gICAqXHJcbiAgICogU0VUVEVSOlxyXG4gICAqIFdpdGggYXQgbGVhc3Qgb25lIGFyZ3VtZW50LCB0aGlzIG1ldGhvZCBzZXRzIHVybCB0byBuZXcgdmFsdWUuXHJcbiAgICogSWYgaHRtbDUgaGlzdG9yeSBhcGkgc3VwcG9ydGVkLCBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGlzIHVzZWQsIG90aGVyd2lzZVxyXG4gICAqIGxvY2F0aW9uLmhyZWYvbG9jYXRpb24ucmVwbGFjZSBpcyB1c2VkLlxyXG4gICAqIFJldHVybnMgaXRzIG93biBpbnN0YW5jZSB0byBhbGxvdyBjaGFpbmluZ1xyXG4gICAqXHJcbiAgICogTk9URTogdGhpcyBhcGkgaXMgaW50ZW5kZWQgZm9yIHVzZSBvbmx5IGJ5IHRoZSAkbG9jYXRpb24gc2VydmljZS4gUGxlYXNlIHVzZSB0aGVcclxuICAgKiB7QGxpbmsgbmcuJGxvY2F0aW9uICRsb2NhdGlvbiBzZXJ2aWNlfSB0byBjaGFuZ2UgdXJsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBOZXcgdXJsICh3aGVuIHVzZWQgYXMgc2V0dGVyKVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlcGxhY2UgU2hvdWxkIG5ldyB1cmwgcmVwbGFjZSBjdXJyZW50IGhpc3RvcnkgcmVjb3JkID9cclxuICAgKi9cclxuICBzZWxmLnVybCA9IGZ1bmN0aW9uKHVybCwgcmVwbGFjZSkge1xyXG4gICAgLy8gc2V0dGVyXHJcbiAgICBpZiAodXJsKSB7XHJcbiAgICAgIGlmIChsYXN0QnJvd3NlclVybCA9PSB1cmwpIHJldHVybjtcclxuICAgICAgbGFzdEJyb3dzZXJVcmwgPSB1cmw7XHJcbiAgICAgIGlmICgkc25pZmZlci5oaXN0b3J5KSB7XHJcbiAgICAgICAgaWYgKHJlcGxhY2UpIGhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsICcnLCB1cmwpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJycsIHVybCk7XHJcbiAgICAgICAgICAvLyBDcmF6eSBPcGVyYSBCdWc6IGh0dHA6Ly9teS5vcGVyYS5jb20vY29tbXVuaXR5L2ZvcnVtcy90b3BpYy5kbWw/aWQ9MTE4NTQ2MlxyXG4gICAgICAgICAgYmFzZUVsZW1lbnQuYXR0cignaHJlZicsIGJhc2VFbGVtZW50LmF0dHIoJ2hyZWYnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKHVybCk7XHJcbiAgICAgICAgICByZXBsYWNlZFVybCA9IHVybDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgIHJlcGxhY2VkVXJsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICAvLyBnZXR0ZXJcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIC0gdGhlIHJlcGxhY2VkVXJsIGlzIGEgd29ya2Fyb3VuZCBmb3IgYW4gSUU4LTkgaXNzdWUgd2l0aCBsb2NhdGlvbi5yZXBsYWNlIG1ldGhvZCB0aGF0IGRvZXNuJ3QgdXBkYXRlXHJcbiAgICAgIC8vICAgbG9jYXRpb24uaHJlZiBzeW5jaHJvbm91c2x5XHJcbiAgICAgIC8vIC0gdGhlIHJlcGxhY2VtZW50IGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDA3MTcyXHJcbiAgICAgIHJldHVybiByZXBsYWNlZFVybCB8fCBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyUyNy9nLFwiJ1wiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgdXJsQ2hhbmdlTGlzdGVuZXJzID0gW10sXHJcbiAgICAgIHVybENoYW5nZUluaXQgPSBmYWxzZTtcclxuXHJcbiAgZnVuY3Rpb24gZmlyZVVybENoYW5nZSgpIHtcclxuICAgIGlmIChsYXN0QnJvd3NlclVybCA9PSBzZWxmLnVybCgpKSByZXR1cm47XHJcblxyXG4gICAgbGFzdEJyb3dzZXJVcmwgPSBzZWxmLnVybCgpO1xyXG4gICAgZm9yRWFjaCh1cmxDaGFuZ2VMaXN0ZW5lcnMsIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcbiAgICAgIGxpc3RlbmVyKHNlbGYudXJsKCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNvblVybENoYW5nZVxyXG4gICAqIEBtZXRob2RPZiBuZy4kYnJvd3NlclxyXG4gICAqIEBUT0RPKHZvanRhKTogcmVmYWN0b3IgdG8gdXNlIG5vZGUncyBzeW50YXggZm9yIGV2ZW50c1xyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCwgd2hlbiB1cmwgY2hhbmdlcy5cclxuICAgKlxyXG4gICAqIEl0J3Mgb25seSBjYWxsZWQgd2hlbiB0aGUgdXJsIGlzIGNoYW5nZWQgYnkgb3V0c2lkZSBvZiBhbmd1bGFyOlxyXG4gICAqIC0gdXNlciB0eXBlcyBkaWZmZXJlbnQgdXJsIGludG8gYWRkcmVzcyBiYXJcclxuICAgKiAtIHVzZXIgY2xpY2tzIG9uIGhpc3RvcnkgKGZvcndhcmQvYmFjaykgYnV0dG9uXHJcbiAgICogLSB1c2VyIGNsaWNrcyBvbiBhIGxpbmtcclxuICAgKlxyXG4gICAqIEl0J3Mgbm90IGNhbGxlZCB3aGVuIHVybCBpcyBjaGFuZ2VkIGJ5ICRicm93c2VyLnVybCgpIG1ldGhvZFxyXG4gICAqXHJcbiAgICogVGhlIGxpc3RlbmVyIGdldHMgY2FsbGVkIHdpdGggbmV3IHVybCBhcyBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBOT1RFOiB0aGlzIGFwaSBpcyBpbnRlbmRlZCBmb3IgdXNlIG9ubHkgYnkgdGhlICRsb2NhdGlvbiBzZXJ2aWNlLiBQbGVhc2UgdXNlIHRoZVxyXG4gICAqIHtAbGluayBuZy4kbG9jYXRpb24gJGxvY2F0aW9uIHNlcnZpY2V9IHRvIG1vbml0b3IgdXJsIGNoYW5nZXMgaW4gYW5ndWxhciBhcHBzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB1cmwgY2hhbmdlcy5cclxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpfSBSZXR1cm5zIHRoZSByZWdpc3RlcmVkIGxpc3RlbmVyIGZuIC0gaGFuZHkgaWYgdGhlIGZuIGlzIGFub255bW91cy5cclxuICAgKi9cclxuICBzZWxmLm9uVXJsQ2hhbmdlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgIGlmICghdXJsQ2hhbmdlSW5pdCkge1xyXG4gICAgICAvLyBXZSBsaXN0ZW4gb24gYm90aCAoaGFzaGNoYW5nZS9wb3BzdGF0ZSkgd2hlbiBhdmFpbGFibGUsIGFzIHNvbWUgYnJvd3NlcnMgKGUuZy4gT3BlcmEpXHJcbiAgICAgIC8vIGRvbid0IGZpcmUgcG9wc3RhdGUgd2hlbiB1c2VyIGNoYW5nZSB0aGUgYWRkcmVzcyBiYXIgYW5kIGRvbid0IGZpcmUgaGFzaGNoYW5nZSB3aGVuIHVybFxyXG4gICAgICAvLyBjaGFuZ2VkIGJ5IHB1c2gvcmVwbGFjZVN0YXRlXHJcblxyXG4gICAgICAvLyBodG1sNSBoaXN0b3J5IGFwaSAtIHBvcHN0YXRlIGV2ZW50XHJcbiAgICAgIGlmICgkc25pZmZlci5oaXN0b3J5KSBqcUxpdGUod2luZG93KS5vbigncG9wc3RhdGUnLCBmaXJlVXJsQ2hhbmdlKTtcclxuICAgICAgLy8gaGFzaGNoYW5nZSBldmVudFxyXG4gICAgICBpZiAoJHNuaWZmZXIuaGFzaGNoYW5nZSkganFMaXRlKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCBmaXJlVXJsQ2hhbmdlKTtcclxuICAgICAgLy8gcG9sbGluZ1xyXG4gICAgICBlbHNlIHNlbGYuYWRkUG9sbEZuKGZpcmVVcmxDaGFuZ2UpO1xyXG5cclxuICAgICAgdXJsQ2hhbmdlSW5pdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdXJsQ2hhbmdlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrO1xyXG4gIH07XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gTWlzYyBBUElcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgPGJhc2UgaHJlZj5cclxuICAgKiAoYWx3YXlzIHJlbGF0aXZlIC0gd2l0aG91dCBkb21haW4pXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nPX1cclxuICAgKi9cclxuICBzZWxmLmJhc2VIcmVmID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaHJlZiA9IGJhc2VFbGVtZW50LmF0dHIoJ2hyZWYnKTtcclxuICAgIHJldHVybiBocmVmID8gaHJlZi5yZXBsYWNlKC9eaHR0cHM/XFw6XFwvXFwvW15cXC9dKi8sICcnKSA6ICcnO1xyXG4gIH07XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gQ29va2llcyBBUElcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIHZhciBsYXN0Q29va2llcyA9IHt9O1xyXG4gIHZhciBsYXN0Q29va2llU3RyaW5nID0gJyc7XHJcbiAgdmFyIGNvb2tpZVBhdGggPSBzZWxmLmJhc2VIcmVmKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIG5nLiRicm93c2VyI2Nvb2tpZXNcclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBDb29raWUgbmFtZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdmFsdWUgQ29va2llIHZhbHVlXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGUgY29va2llcyBtZXRob2QgcHJvdmlkZXMgYSAncHJpdmF0ZScgbG93IGxldmVsIGFjY2VzcyB0byBicm93c2VyIGNvb2tpZXMuXHJcbiAgICogSXQgaXMgbm90IG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHksIHVzZSB0aGUgJGNvb2tpZSBzZXJ2aWNlIGluc3RlYWQuXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuIHZhbHVlcyB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIG1ldGhvZCB3YXMgY2FsbGVkIHdpdGggYXMgZm9sbG93czpcclxuICAgKiA8dWw+XHJcbiAgICogICA8bGk+Y29va2llcygpIC0+IGhhc2ggb2YgYWxsIGNvb2tpZXMsIHRoaXMgaXMgTk9UIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUsIHNvIGRvIG5vdCBtb2RpZnkgaXQ8L2xpPlxyXG4gICAqICAgPGxpPmNvb2tpZXMobmFtZSwgdmFsdWUpIC0+IHNldCBuYW1lIHRvIHZhbHVlLCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgZGVsZXRlIHRoZSBjb29raWU8L2xpPlxyXG4gICAqICAgPGxpPmNvb2tpZXMobmFtZSkgLT4gdGhlIHNhbWUgYXMgKG5hbWUsIHVuZGVmaW5lZCkgPT0gREVMRVRFUyAobm8gb25lIGNhbGxzIGl0IHJpZ2h0IG5vdyB0aGF0IHdheSk8L2xpPlxyXG4gICAqIDwvdWw+XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIYXNoIG9mIGFsbCBjb29raWVzIChpZiBjYWxsZWQgd2l0aG91dCBhbnkgcGFyYW1ldGVyKVxyXG4gICAqL1xyXG4gIHNlbGYuY29va2llcyA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICB2YXIgY29va2llTGVuZ3RoLCBjb29raWVBcnJheSwgY29va2llLCBpLCBpbmRleDtcclxuXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJhd0RvY3VtZW50LmNvb2tpZSA9IGVzY2FwZShuYW1lKSArIFwiPTtwYXRoPVwiICsgY29va2llUGF0aCArIFwiO2V4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVRcIjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICBjb29raWVMZW5ndGggPSAocmF3RG9jdW1lbnQuY29va2llID0gZXNjYXBlKG5hbWUpICsgJz0nICsgZXNjYXBlKHZhbHVlKSArICc7cGF0aD0nICsgY29va2llUGF0aCkubGVuZ3RoICsgMTtcclxuXHJcbiAgICAgICAgICAvLyBwZXIgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjEwOS50eHQgYnJvd3NlciBtdXN0IGFsbG93IGF0IG1pbmltdW06XHJcbiAgICAgICAgICAvLyAtIDMwMCBjb29raWVzXHJcbiAgICAgICAgICAvLyAtIDIwIGNvb2tpZXMgcGVyIHVuaXF1ZSBkb21haW5cclxuICAgICAgICAgIC8vIC0gNDA5NiBieXRlcyBwZXIgY29va2llXHJcbiAgICAgICAgICBpZiAoY29va2llTGVuZ3RoID4gNDA5Nikge1xyXG4gICAgICAgICAgICAkbG9nLndhcm4oXCJDb29raWUgJ1wiKyBuYW1lICtcIicgcG9zc2libHkgbm90IHNldCBvciBvdmVyZmxvd2VkIGJlY2F1c2UgaXQgd2FzIHRvbyBsYXJnZSAoXCIrXHJcbiAgICAgICAgICAgICAgY29va2llTGVuZ3RoICsgXCIgPiA0MDk2IGJ5dGVzKSFcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocmF3RG9jdW1lbnQuY29va2llICE9PSBsYXN0Q29va2llU3RyaW5nKSB7XHJcbiAgICAgICAgbGFzdENvb2tpZVN0cmluZyA9IHJhd0RvY3VtZW50LmNvb2tpZTtcclxuICAgICAgICBjb29raWVBcnJheSA9IGxhc3RDb29raWVTdHJpbmcuc3BsaXQoXCI7IFwiKTtcclxuICAgICAgICBsYXN0Q29va2llcyA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29va2llQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvb2tpZSA9IGNvb2tpZUFycmF5W2ldO1xyXG4gICAgICAgICAgaW5kZXggPSBjb29raWUuaW5kZXhPZignPScpO1xyXG4gICAgICAgICAgaWYgKGluZGV4ID4gMCkgeyAvL2lnbm9yZSBuYW1lbGVzcyBjb29raWVzXHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdW5lc2NhcGUoY29va2llLnN1YnN0cmluZygwLCBpbmRleCkpO1xyXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgdmFsdWUgdGhhdCBpcyBzZWVuIGZvciBhIGNvb2tpZSBpcyB0aGUgbW9zdFxyXG4gICAgICAgICAgICAvLyBzcGVjaWZpYyBvbmUuICB2YWx1ZXMgZm9yIHRoZSBzYW1lIGNvb2tpZSBuYW1lIHRoYXRcclxuICAgICAgICAgICAgLy8gZm9sbG93IGFyZSBmb3IgbGVzcyBzcGVjaWZpYyBwYXRocy5cclxuICAgICAgICAgICAgaWYgKGxhc3RDb29raWVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBsYXN0Q29va2llc1tuYW1lXSA9IHVuZXNjYXBlKGNvb2tpZS5zdWJzdHJpbmcoaW5kZXggKyAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxhc3RDb29raWVzO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNkZWZlclxyXG4gICAqIEBtZXRob2RPZiBuZy4kYnJvd3NlclxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm4gQSBmdW5jdGlvbiwgd2hvJ3MgZXhlY3V0aW9uIHNob3VsZCBiZSBkZWZlcnJlZC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtkZWxheT0wXSBvZiBtaWxsaXNlY29uZHMgdG8gZGVmZXIgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cclxuICAgKiBAcmV0dXJucyB7Kn0gRGVmZXJJZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgdGFzayB2aWEgYCRicm93c2VyLmRlZmVyLmNhbmNlbCgpYC5cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEV4ZWN1dGVzIGEgZm4gYXN5bmNocm9ub3VzbHkgdmlhIGBzZXRUaW1lb3V0KGZuLCBkZWxheSlgLlxyXG4gICAqXHJcbiAgICogVW5saWtlIHdoZW4gY2FsbGluZyBgc2V0VGltZW91dGAgZGlyZWN0bHksIGluIHRlc3QgdGhpcyBmdW5jdGlvbiBpcyBtb2NrZWQgYW5kIGluc3RlYWQgb2YgdXNpbmdcclxuICAgKiBgc2V0VGltZW91dGAgaW4gdGVzdHMsIHRoZSBmbnMgYXJlIHF1ZXVlZCBpbiBhbiBhcnJheSwgd2hpY2ggY2FuIGJlIHByb2dyYW1tYXRpY2FsbHkgZmx1c2hlZFxyXG4gICAqIHZpYSBgJGJyb3dzZXIuZGVmZXIuZmx1c2goKWAuXHJcbiAgICpcclxuICAgKi9cclxuICBzZWxmLmRlZmVyID0gZnVuY3Rpb24oZm4sIGRlbGF5KSB7XHJcbiAgICB2YXIgdGltZW91dElkO1xyXG4gICAgb3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQrKztcclxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlbGV0ZSBwZW5kaW5nRGVmZXJJZHNbdGltZW91dElkXTtcclxuICAgICAgY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3QoZm4pO1xyXG4gICAgfSwgZGVsYXkgfHwgMCk7XHJcbiAgICBwZW5kaW5nRGVmZXJJZHNbdGltZW91dElkXSA9IHRydWU7XHJcbiAgICByZXR1cm4gdGltZW91dElkO1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNkZWZlci5jYW5jZWxcclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXIuZGVmZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIENhbmNlbHMgYSBkZWZlcnJlZCB0YXNrIGlkZW50aWZpZWQgd2l0aCBgZGVmZXJJZGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGRlZmVySWQgVG9rZW4gcmV0dXJuZWQgYnkgdGhlIGAkYnJvd3Nlci5kZWZlcmAgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0YXNrIGhhc24ndCBleGVjdXRlZCB5ZXQgYW5kIHdhcyBzdWNjZXNzZnVsbHkgY2FuY2VsZWQuXHJcbiAgICovXHJcbiAgc2VsZi5kZWZlci5jYW5jZWwgPSBmdW5jdGlvbihkZWZlcklkKSB7XHJcbiAgICBpZiAocGVuZGluZ0RlZmVySWRzW2RlZmVySWRdKSB7XHJcbiAgICAgIGRlbGV0ZSBwZW5kaW5nRGVmZXJJZHNbZGVmZXJJZF07XHJcbiAgICAgIGNsZWFyVGltZW91dChkZWZlcklkKTtcclxuICAgICAgY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3Qobm9vcCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiAkQnJvd3NlclByb3ZpZGVyKCl7XHJcbiAgdGhpcy4kZ2V0ID0gWyckd2luZG93JywgJyRsb2cnLCAnJHNuaWZmZXInLCAnJGRvY3VtZW50JyxcclxuICAgICAgZnVuY3Rpb24oICR3aW5kb3csICAgJGxvZywgICAkc25pZmZlciwgICAkZG9jdW1lbnQpe1xyXG4gICAgICAgIHJldHVybiBuZXcgQnJvd3Nlcigkd2luZG93LCAkZG9jdW1lbnQsICRsb2csICRzbmlmZmVyKTtcclxuICAgICAgfV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRjYWNoZUZhY3RvcnlcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEZhY3RvcnkgdGhhdCBjb25zdHJ1Y3RzIGNhY2hlIG9iamVjdHMgYW5kIGdpdmVzIGFjY2VzcyB0byB0aGVtLlxyXG4gKiBcclxuICogPHByZT5cclxuICogXHJcbiAqICB2YXIgY2FjaGUgPSAkY2FjaGVGYWN0b3J5KCdjYWNoZUlkJyk7XHJcbiAqICBleHBlY3QoJGNhY2hlRmFjdG9yeS5nZXQoJ2NhY2hlSWQnKSkudG9CZShjYWNoZSk7XHJcbiAqICBleHBlY3QoJGNhY2hlRmFjdG9yeS5nZXQoJ25vU3VjaENhY2hlSWQnKSkubm90LnRvQmVEZWZpbmVkKCk7XHJcbiAqXHJcbiAqICBjYWNoZS5wdXQoXCJrZXlcIiwgXCJ2YWx1ZVwiKTtcclxuICogIGNhY2hlLnB1dChcImFub3RoZXIga2V5XCIsIFwiYW5vdGhlciB2YWx1ZVwiKTtcclxuICogXHJcbiAqICBleHBlY3QoY2FjaGUuaW5mbygpKS50b0VxdWFsKHtpZDogJ2NhY2hlSWQnLCBzaXplOiAyfSk7IC8vIFNpbmNlIHdlJ3ZlIHNwZWNpZmllZCBubyBvcHRpb25zIG9uIGNyZWF0aW9uXHJcbiAqIFxyXG4gKiA8L3ByZT5cclxuICpcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlSWQgTmFtZSBvciBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBjYWNoZS5cclxuICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IHRoYXQgc3BlY2lmaWVzIHRoZSBjYWNoZSBiZWhhdmlvci4gUHJvcGVydGllczpcclxuICpcclxuICogICAtIGB7bnVtYmVyPX1gIGBjYXBhY2l0eWAgw6LigqzigJ0gdHVybnMgdGhlIGNhY2hlIGludG8gTFJVIGNhY2hlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBOZXdseSBjcmVhdGVkIGNhY2hlIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgc2V0IG9mIG1ldGhvZHM6XHJcbiAqXHJcbiAqIC0gYHtvYmplY3R9YCBgaW5mbygpYCDDouKCrOKAnSBSZXR1cm5zIGlkLCBzaXplLCBhbmQgb3B0aW9ucyBvZiBjYWNoZS5cclxuICogLSBge3sqfX1gIGBwdXQoe3N0cmluZ30ga2V5LCB7Kn0gdmFsdWUpYCDDouKCrOKAnSBQdXRzIGEgbmV3IGtleS12YWx1ZSBwYWlyIGludG8gdGhlIGNhY2hlIGFuZCByZXR1cm5zIGl0LlxyXG4gKiAtIGB7eyp9fWAgYGdldCh7c3RyaW5nfSBrZXkpYCDDouKCrOKAnSBSZXR1cm5zIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAgb3IgdW5kZWZpbmVkIGZvciBjYWNoZSBtaXNzLlxyXG4gKiAtIGB7dm9pZH1gIGByZW1vdmUoe3N0cmluZ30ga2V5KWAgw6LigqzigJ0gUmVtb3ZlcyBhIGtleS12YWx1ZSBwYWlyIGZyb20gdGhlIGNhY2hlLlxyXG4gKiAtIGB7dm9pZH1gIGByZW1vdmVBbGwoKWAgw6LigqzigJ0gUmVtb3ZlcyBhbGwgY2FjaGVkIHZhbHVlcy5cclxuICogLSBge3ZvaWR9YCBgZGVzdHJveSgpYCDDouKCrOKAnSBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyBjYWNoZSBmcm9tICRjYWNoZUZhY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiAkQ2FjaGVGYWN0b3J5UHJvdmlkZXIoKSB7XHJcblxyXG4gIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNhY2hlcyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNhY2hlRmFjdG9yeShjYWNoZUlkLCBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChjYWNoZUlkIGluIGNhY2hlcykge1xyXG4gICAgICAgIHRocm93IG1pbkVycignJGNhY2hlRmFjdG9yeScpKCdpaWQnLCBcIkNhY2hlSWQgJ3swfScgaXMgYWxyZWFkeSB0YWtlbiFcIiwgY2FjaGVJZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzaXplID0gMCxcclxuICAgICAgICAgIHN0YXRzID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7aWQ6IGNhY2hlSWR9KSxcclxuICAgICAgICAgIGRhdGEgPSB7fSxcclxuICAgICAgICAgIGNhcGFjaXR5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jYXBhY2l0eSkgfHwgTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgIGxydUhhc2ggPSB7fSxcclxuICAgICAgICAgIGZyZXNoRW5kID0gbnVsbCxcclxuICAgICAgICAgIHN0YWxlRW5kID0gbnVsbDtcclxuXHJcbiAgICAgIHJldHVybiBjYWNoZXNbY2FjaGVJZF0gPSB7XHJcblxyXG4gICAgICAgIHB1dDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGxydUVudHJ5ID0gbHJ1SGFzaFtrZXldIHx8IChscnVIYXNoW2tleV0gPSB7a2V5OiBrZXl9KTtcclxuXHJcbiAgICAgICAgICByZWZyZXNoKGxydUVudHJ5KTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XHJcbiAgICAgICAgICBpZiAoIShrZXkgaW4gZGF0YSkpIHNpemUrKztcclxuICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgIGlmIChzaXplID4gY2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoc3RhbGVFbmQua2V5KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICB2YXIgbHJ1RW50cnkgPSBscnVIYXNoW2tleV07XHJcblxyXG4gICAgICAgICAgaWYgKCFscnVFbnRyeSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIHJlZnJlc2gobHJ1RW50cnkpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICB2YXIgbHJ1RW50cnkgPSBscnVIYXNoW2tleV07XHJcblxyXG4gICAgICAgICAgaWYgKCFscnVFbnRyeSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIGlmIChscnVFbnRyeSA9PSBmcmVzaEVuZCkgZnJlc2hFbmQgPSBscnVFbnRyeS5wO1xyXG4gICAgICAgICAgaWYgKGxydUVudHJ5ID09IHN0YWxlRW5kKSBzdGFsZUVuZCA9IGxydUVudHJ5Lm47XHJcbiAgICAgICAgICBsaW5rKGxydUVudHJ5Lm4sbHJ1RW50cnkucCk7XHJcblxyXG4gICAgICAgICAgZGVsZXRlIGxydUhhc2hba2V5XTtcclxuICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XHJcbiAgICAgICAgICBzaXplLS07XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgICBzaXplID0gMDtcclxuICAgICAgICAgIGxydUhhc2ggPSB7fTtcclxuICAgICAgICAgIGZyZXNoRW5kID0gc3RhbGVFbmQgPSBudWxsO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgc3RhdHMgPSBudWxsO1xyXG4gICAgICAgICAgbHJ1SGFzaCA9IG51bGw7XHJcbiAgICAgICAgICBkZWxldGUgY2FjaGVzW2NhY2hlSWRdO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBpbmZvOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHN0YXRzLCB7c2l6ZTogc2l6ZX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogbWFrZXMgdGhlIGBlbnRyeWAgdGhlIGZyZXNoRW5kIG9mIHRoZSBMUlUgbGlua2VkIGxpc3RcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHJlZnJlc2goZW50cnkpIHtcclxuICAgICAgICBpZiAoZW50cnkgIT0gZnJlc2hFbmQpIHtcclxuICAgICAgICAgIGlmICghc3RhbGVFbmQpIHtcclxuICAgICAgICAgICAgc3RhbGVFbmQgPSBlbnRyeTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhbGVFbmQgPT0gZW50cnkpIHtcclxuICAgICAgICAgICAgc3RhbGVFbmQgPSBlbnRyeS5uO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxpbmsoZW50cnkubiwgZW50cnkucCk7XHJcbiAgICAgICAgICBsaW5rKGVudHJ5LCBmcmVzaEVuZCk7XHJcbiAgICAgICAgICBmcmVzaEVuZCA9IGVudHJ5O1xyXG4gICAgICAgICAgZnJlc2hFbmQubiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIGJpZGlyZWN0aW9uYWxseSBsaW5rcyB0d28gZW50cmllcyBvZiB0aGUgTFJVIGxpbmtlZCBsaXN0XHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiBsaW5rKG5leHRFbnRyeSwgcHJldkVudHJ5KSB7XHJcbiAgICAgICAgaWYgKG5leHRFbnRyeSAhPSBwcmV2RW50cnkpIHtcclxuICAgICAgICAgIGlmIChuZXh0RW50cnkpIG5leHRFbnRyeS5wID0gcHJldkVudHJ5OyAvL3Agc3RhbmRzIGZvciBwcmV2aW91cywgJ3ByZXYnIGRpZG4ndCBtaW5pZnlcclxuICAgICAgICAgIGlmIChwcmV2RW50cnkpIHByZXZFbnRyeS5uID0gbmV4dEVudHJ5OyAvL24gc3RhbmRzIGZvciBuZXh0LCAnbmV4dCcgZGlkbid0IG1pbmlmeVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRjYWNoZUZhY3RvcnkjaW5mb1xyXG4gICAqIEBtZXRob2RPZiBuZy4kY2FjaGVGYWN0b3J5XHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYWxsIHRoZSBvZiB0aGUgY2FjaGVzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0ga2V5LXZhbHVlIG1hcCBvZiBgY2FjaGVJZGAgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBjYWNoZSNpbmZvYFxyXG4gICAqL1xyXG4gICAgY2FjaGVGYWN0b3J5LmluZm8gPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGluZm8gPSB7fTtcclxuICAgICAgZm9yRWFjaChjYWNoZXMsIGZ1bmN0aW9uKGNhY2hlLCBjYWNoZUlkKSB7XHJcbiAgICAgICAgaW5mb1tjYWNoZUlkXSA9IGNhY2hlLmluZm8oKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kY2FjaGVGYWN0b3J5I2dldFxyXG4gICAqIEBtZXRob2RPZiBuZy4kY2FjaGVGYWN0b3J5XHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBHZXQgYWNjZXNzIHRvIGEgY2FjaGUgb2JqZWN0IGJ5IHRoZSBgY2FjaGVJZGAgdXNlZCB3aGVuIGl0IHdhcyBjcmVhdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlSWQgTmFtZSBvciBpZCBvZiBhIGNhY2hlIHRvIGFjY2Vzcy5cclxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWNoZSBvYmplY3QgaWRlbnRpZmllZCBieSB0aGUgY2FjaGVJZCBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCBjYWNoZS5cclxuICAgKi9cclxuICAgIGNhY2hlRmFjdG9yeS5nZXQgPSBmdW5jdGlvbihjYWNoZUlkKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZXNbY2FjaGVJZF07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICByZXR1cm4gY2FjaGVGYWN0b3J5O1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiR0ZW1wbGF0ZUNhY2hlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgZmlyc3QgdGltZSBhIHRlbXBsYXRlIGlzIHVzZWQsIGl0IGlzIGxvYWRlZCBpbiB0aGUgdGVtcGxhdGUgY2FjaGUgZm9yIHF1aWNrIHJldHJpZXZhbC4gWW91IGNhblxyXG4gKiBsb2FkIHRlbXBsYXRlcyBkaXJlY3RseSBpbnRvIHRoZSBjYWNoZSBpbiBhIGBzY3JpcHRgIHRhZywgb3IgYnkgY29uc3VtaW5nIHRoZSBgJHRlbXBsYXRlQ2FjaGVgXHJcbiAqIHNlcnZpY2UgZGlyZWN0bHkuXHJcbiAqIFxyXG4gKiBBZGRpbmcgdmlhIHRoZSBgc2NyaXB0YCB0YWc6XHJcbiAqIDxwcmU+XHJcbiAqIDxodG1sIG5nLWFwcD5cclxuICogPGhlYWQ+XHJcbiAqIDxzY3JpcHQgdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIiBpZD1cInRlbXBsYXRlSWQuaHRtbFwiPlxyXG4gKiAgIFRoaXMgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIHRlbXBsYXRlXHJcbiAqIDwvc2NyaXB0PlxyXG4gKiA8L2hlYWQ+XHJcbiAqICAgLi4uXHJcbiAqIDwvaHRtbD5cclxuICogPC9wcmU+XHJcbiAqIFxyXG4gKiAqKk5vdGU6KiogdGhlIGBzY3JpcHRgIHRhZyBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZSBkb2VzIG5vdCBuZWVkIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBgaGVhZGAgb2YgdGhlIGRvY3VtZW50LCBidXQgXHJcbiAqIGl0IG11c3QgYmUgYmVsb3cgdGhlIGBuZy1hcHBgIGRlZmluaXRpb24uXHJcbiAqIFxyXG4gKiBBZGRpbmcgdmlhIHRoZSAkdGVtcGxhdGVDYWNoZSBzZXJ2aWNlOlxyXG4gKiBcclxuICogPHByZT5cclxuICogdmFyIG15QXBwID0gYW5ndWxhci5tb2R1bGUoJ215QXBwJywgW10pO1xyXG4gKiBteUFwcC5ydW4oZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICogICAkdGVtcGxhdGVDYWNoZS5wdXQoJ3RlbXBsYXRlSWQuaHRtbCcsICdUaGlzIGlzIHRoZSBjb250ZW50IG9mIHRoZSB0ZW1wbGF0ZScpO1xyXG4gKiB9KTtcclxuICogPC9wcmU+XHJcbiAqIFxyXG4gKiBUbyByZXRyaWV2ZSB0aGUgdGVtcGxhdGUgbGF0ZXIsIHNpbXBseSB1c2UgaXQgaW4geW91ciBIVE1MOlxyXG4gKiA8cHJlPlxyXG4gKiA8ZGl2IG5nLWluY2x1ZGU9XCIgJ3RlbXBsYXRlSWQuaHRtbCcgXCI+PC9kaXY+XHJcbiAqIDwvcHJlPlxyXG4gKiBcclxuICogb3IgZ2V0IGl0IHZpYSBKYXZhc2NyaXB0OlxyXG4gKiA8cHJlPlxyXG4gKiAkdGVtcGxhdGVDYWNoZS5nZXQoJ3RlbXBsYXRlSWQuaHRtbCcpXHJcbiAqIDwvcHJlPlxyXG4gKiBcclxuICogU2VlIHtAbGluayBuZy4kY2FjaGVGYWN0b3J5ICRjYWNoZUZhY3Rvcnl9LlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gJFRlbXBsYXRlQ2FjaGVQcm92aWRlcigpIHtcclxuICB0aGlzLiRnZXQgPSBbJyRjYWNoZUZhY3RvcnknLCBmdW5jdGlvbigkY2FjaGVGYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gJGNhY2hlRmFjdG9yeSgndGVtcGxhdGVzJyk7XHJcbiAgfV07XHJcbn1cclxuXHJcbi8qICEgVkFSSUFCTEUvRlVOQ1RJT04gTkFNSU5HIENPTlZFTlRJT05TIFRIQVQgQVBQTFkgVE8gVEhJUyBGSUxFIVxyXG4gKlxyXG4gKiBET00tcmVsYXRlZCB2YXJpYWJsZXM6XHJcbiAqXHJcbiAqIC0gXCJub2RlXCIgLSBET00gTm9kZVxyXG4gKiAtIFwiZWxlbWVudFwiIC0gRE9NIEVsZW1lbnQgb3IgTm9kZVxyXG4gKiAtIFwiJG5vZGVcIiBvciBcIiRlbGVtZW50XCIgLSBqcUxpdGUtd3JhcHBlZCBub2RlIG9yIGVsZW1lbnRcclxuICpcclxuICpcclxuICogQ29tcGlsZXIgcmVsYXRlZCBzdHVmZjpcclxuICpcclxuICogLSBcImxpbmtGblwiIC0gbGlua2luZyBmbiBvZiBhIHNpbmdsZSBkaXJlY3RpdmVcclxuICogLSBcIm5vZGVMaW5rRm5cIiAtIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhbGwgbGlua2luZyBmbnMgZm9yIGEgcGFydGljdWxhciBub2RlXHJcbiAqIC0gXCJjaGlsZExpbmtGblwiIC0gIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhbGwgbGlua2luZyBmbnMgZm9yIGNoaWxkIG5vZGVzIG9mIGEgcGFydGljdWxhciBub2RlXHJcbiAqIC0gXCJjb21wb3NpdGVMaW5rRm5cIiAtIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhbGwgbGlua2luZyBmbnMgZm9yIGEgY29tcGlsYXRpb24gcm9vdCAobm9kZUxpc3QpXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuJGNvbXBpbGVcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb21waWxlcyBhIHBpZWNlIG9mIEhUTUwgc3RyaW5nIG9yIERPTSBpbnRvIGEgdGVtcGxhdGUgYW5kIHByb2R1Y2VzIGEgdGVtcGxhdGUgZnVuY3Rpb24sIHdoaWNoXHJcbiAqIGNhbiB0aGVuIGJlIHVzZWQgdG8gbGluayB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSBzY29wZX0gYW5kIHRoZSB0ZW1wbGF0ZSB0b2dldGhlci5cclxuICpcclxuICogVGhlIGNvbXBpbGF0aW9uIGlzIGEgcHJvY2VzcyBvZiB3YWxraW5nIHRoZSBET00gdHJlZSBhbmQgdHJ5aW5nIHRvIG1hdGNoIERPTSBlbGVtZW50cyB0b1xyXG4gKiB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlciNkaXJlY3RpdmUgZGlyZWN0aXZlc30uIEZvciBlYWNoIG1hdGNoIGl0XHJcbiAqIGV4ZWN1dGVzIGNvcnJlc3BvbmRpbmcgdGVtcGxhdGUgZnVuY3Rpb24gYW5kIGNvbGxlY3RzIHRoZVxyXG4gKiBpbnN0YW5jZSBmdW5jdGlvbnMgaW50byBhIHNpbmdsZSB0ZW1wbGF0ZSBmdW5jdGlvbiB3aGljaCBpcyB0aGVuIHJldHVybmVkLlxyXG4gKlxyXG4gKiBUaGUgdGVtcGxhdGUgZnVuY3Rpb24gY2FuIHRoZW4gYmUgdXNlZCBvbmNlIHRvIHByb2R1Y2UgdGhlIHZpZXcgb3IgYXMgaXQgaXMgdGhlIGNhc2Ugd2l0aFxyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IHJlcGVhdGVyfSBtYW55LXRpbWVzLCBpbiB3aGljaFxyXG4gKiBjYXNlIGVhY2ggY2FsbCByZXN1bHRzIGluIGEgdmlldyB0aGF0IGlzIGEgRE9NIGNsb25lIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cclxuICpcclxuIDxkb2M6ZXhhbXBsZSBtb2R1bGU9XCJjb21waWxlXCI+XHJcbiAgIDxkb2M6c291cmNlPlxyXG4gICAgPHNjcmlwdD5cclxuICAgICAgLy8gZGVjbGFyZSBhIG5ldyBtb2R1bGUsIGFuZCBpbmplY3QgdGhlICRjb21waWxlUHJvdmlkZXJcclxuICAgICAgYW5ndWxhci5tb2R1bGUoJ2NvbXBpbGUnLCBbXSwgZnVuY3Rpb24oJGNvbXBpbGVQcm92aWRlcikge1xyXG4gICAgICAgIC8vIGNvbmZpZ3VyZSBuZXcgJ2NvbXBpbGUnIGRpcmVjdGl2ZSBieSBwYXNzaW5nIGEgZGlyZWN0aXZlXHJcbiAgICAgICAgLy8gZmFjdG9yeSBmdW5jdGlvbi4gVGhlIGZhY3RvcnkgZnVuY3Rpb24gaW5qZWN0cyB0aGUgJyRjb21waWxlJ1xyXG4gICAgICAgICRjb21waWxlUHJvdmlkZXIuZGlyZWN0aXZlKCdjb21waWxlJywgZnVuY3Rpb24oJGNvbXBpbGUpIHtcclxuICAgICAgICAgIC8vIGRpcmVjdGl2ZSBmYWN0b3J5IGNyZWF0ZXMgYSBsaW5rIGZ1bmN0aW9uXHJcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaChcclxuICAgICAgICAgICAgICBmdW5jdGlvbihzY29wZSkge1xyXG4gICAgICAgICAgICAgICAgIC8vIHdhdGNoIHRoZSAnY29tcGlsZScgZXhwcmVzc2lvbiBmb3IgY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLiRldmFsKGF0dHJzLmNvbXBpbGUpO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlICdjb21waWxlJyBleHByZXNzaW9uIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBpdCBpbnRvIHRoZSBjdXJyZW50IERPTVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlIHRoZSBuZXcgRE9NIGFuZCBsaW5rIGl0IHRvIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAvLyBzY29wZS5cclxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIG9ubHkgY29tcGlsZSAuY2hpbGROb2RlcyBzbyB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBnZXQgaW50byBpbmZpbml0ZSBsb29wIGNvbXBpbGluZyBvdXJzZWx2ZXNcclxuICAgICAgICAgICAgICAgICRjb21waWxlKGVsZW1lbnQuY29udGVudHMoKSkoc2NvcGUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICRzY29wZS5uYW1lID0gJ0FuZ3VsYXInO1xyXG4gICAgICAgICRzY29wZS5odG1sID0gJ0hlbGxvIHt7bmFtZX19JztcclxuICAgICAgfVxyXG4gICAgPC9zY3JpcHQ+XHJcbiAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgIDxpbnB1dCBuZy1tb2RlbD1cIm5hbWVcIj4gPGJyPlxyXG4gICAgICA8dGV4dGFyZWEgbmctbW9kZWw9XCJodG1sXCI+PC90ZXh0YXJlYT4gPGJyPlxyXG4gICAgICA8ZGl2IGNvbXBpbGU9XCJodG1sXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgPC9kb2M6c291cmNlPlxyXG4gICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgIGl0KCdzaG91bGQgYXV0byBjb21waWxlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICBleHBlY3QoZWxlbWVudCgnZGl2W2NvbXBpbGVdJykudGV4dCgpKS50b0JlKCdIZWxsbyBBbmd1bGFyJyk7XHJcbiAgICAgICBpbnB1dCgnaHRtbCcpLmVudGVyKCd7e25hbWV9fSEnKTtcclxuICAgICAgIGV4cGVjdChlbGVtZW50KCdkaXZbY29tcGlsZV0nKS50ZXh0KCkpLnRvQmUoJ0FuZ3VsYXIhJyk7XHJcbiAgICAgfSk7XHJcbiAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gPC9kb2M6ZXhhbXBsZT5cclxuXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfERPTUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCBvciBIVE1MIHN0cmluZyB0byBjb21waWxlIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbi5cclxuICogQHBhcmFtIHtmdW5jdGlvbihhbmd1bGFyLlNjb3BlWywgY2xvbmVBdHRhY2hGbl19IHRyYW5zY2x1ZGUgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGRpcmVjdGl2ZXMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhQcmlvcml0eSBvbmx5IGFwcGx5IGRpcmVjdGl2ZXMgbG93ZXIgdGhlbiBnaXZlbiBwcmlvcml0eSAoT25seSBlZmZlY3RzIHRoZVxyXG4gKiAgICAgICAgICAgICAgICAgcm9vdCBlbGVtZW50KHMpLCBub3QgdGhlaXIgY2hpbGRyZW4pXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzY29wZVssIGNsb25lQXR0YWNoRm5dKX0gYSBsaW5rIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgdG8gYmluZCB0ZW1wbGF0ZVxyXG4gKiAoYSBET00gZWxlbWVudC90cmVlKSB0byBhIHNjb3BlLiBXaGVyZTpcclxuICpcclxuICogICogYHNjb3BlYCAtIEEge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUgU2NvcGV9IHRvIGJpbmQgdG8uXHJcbiAqICAqIGBjbG9uZUF0dGFjaEZuYCAtIElmIGBjbG9uZUF0dGFjaEZuYCBpcyBwcm92aWRlZCwgdGhlbiB0aGUgbGluayBmdW5jdGlvbiB3aWxsIGNsb25lIHRoZVxyXG4gKiAgICAgICAgICAgICAgIGB0ZW1wbGF0ZWAgYW5kIGNhbGwgdGhlIGBjbG9uZUF0dGFjaEZuYCBmdW5jdGlvbiBhbGxvd2luZyB0aGUgY2FsbGVyIHRvIGF0dGFjaCB0aGVcclxuICogICAgICAgICAgICAgICBjbG9uZWQgZWxlbWVudHMgdG8gdGhlIERPTSBkb2N1bWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2UuIFRoZSBgY2xvbmVBdHRhY2hGbmAgaXNcclxuICogICAgICAgICAgICAgICBjYWxsZWQgYXM6IDxicj4gYGNsb25lQXR0YWNoRm4oY2xvbmVkRWxlbWVudCwgc2NvcGUpYCB3aGVyZTpcclxuICpcclxuICogICAgICAqIGBjbG9uZWRFbGVtZW50YCAtIGlzIGEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGBlbGVtZW50YCBwYXNzZWQgaW50byB0aGUgY29tcGlsZXIuXHJcbiAqICAgICAgKiBgc2NvcGVgIC0gaXMgdGhlIGN1cnJlbnQgc2NvcGUgd2l0aCB3aGljaCB0aGUgbGlua2luZyBmdW5jdGlvbiBpcyB3b3JraW5nIHdpdGguXHJcbiAqXHJcbiAqIENhbGxpbmcgdGhlIGxpbmtpbmcgZnVuY3Rpb24gcmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgdGVtcGxhdGUuIEl0IGlzIGVpdGhlciB0aGUgb3JpZ2luYWwgZWxlbWVudFxyXG4gKiBwYXNzZWQgaW4sIG9yIHRoZSBjbG9uZSBvZiB0aGUgZWxlbWVudCBpZiB0aGUgYGNsb25lQXR0YWNoRm5gIGlzIHByb3ZpZGVkLlxyXG4gKlxyXG4gKiBBZnRlciBsaW5raW5nIHRoZSB2aWV3IGlzIG5vdCB1cGRhdGVkIHVudGlsIGFmdGVyIGEgY2FsbCB0byAkZGlnZXN0IHdoaWNoIHR5cGljYWxseSBpcyBkb25lIGJ5XHJcbiAqIEFuZ3VsYXIgYXV0b21hdGljYWxseS5cclxuICpcclxuICogSWYgeW91IG5lZWQgYWNjZXNzIHRvIHRoZSBib3VuZCB2aWV3LCB0aGVyZSBhcmUgdHdvIHdheXMgdG8gZG8gaXQ6XHJcbiAqXHJcbiAqIC0gSWYgeW91IGFyZSBub3QgYXNraW5nIHRoZSBsaW5raW5nIGZ1bmN0aW9uIHRvIGNsb25lIHRoZSB0ZW1wbGF0ZSwgY3JlYXRlIHRoZSBET00gZWxlbWVudChzKVxyXG4gKiAgIGJlZm9yZSB5b3Ugc2VuZCB0aGVtIHRvIHRoZSBjb21waWxlciBhbmQga2VlcCB0aGlzIHJlZmVyZW5jZSBhcm91bmQuXHJcbiAqICAgPHByZT5cclxuICogICAgIHZhciBlbGVtZW50ID0gJGNvbXBpbGUoJzxwPnt7dG90YWx9fTwvcD4nKShzY29wZSk7XHJcbiAqICAgPC9wcmU+XHJcbiAqXHJcbiAqIC0gaWYgb24gdGhlIG90aGVyIGhhbmQsIHlvdSBuZWVkIHRoZSBlbGVtZW50IHRvIGJlIGNsb25lZCwgdGhlIHZpZXcgcmVmZXJlbmNlIGZyb20gdGhlIG9yaWdpbmFsXHJcbiAqICAgZXhhbXBsZSB3b3VsZCBub3QgcG9pbnQgdG8gdGhlIGNsb25lLCBidXQgcmF0aGVyIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjbG9uZWQuIEluXHJcbiAqICAgdGhpcyBjYXNlLCB5b3UgY2FuIGFjY2VzcyB0aGUgY2xvbmUgdmlhIHRoZSBjbG9uZUF0dGFjaEZuOlxyXG4gKiAgIDxwcmU+XHJcbiAqICAgICB2YXIgdGVtcGxhdGVIVE1MID0gYW5ndWxhci5lbGVtZW50KCc8cD57e3RvdGFsfX08L3A+JyksXHJcbiAqICAgICAgICAgc2NvcGUgPSAuLi4uO1xyXG4gKlxyXG4gKiAgICAgdmFyIGNsb25lZEVsZW1lbnQgPSAkY29tcGlsZSh0ZW1wbGF0ZUhUTUwpKHNjb3BlLCBmdW5jdGlvbihjbG9uZWRFbGVtZW50LCBzY29wZSkge1xyXG4gKiAgICAgICAvL2F0dGFjaCB0aGUgY2xvbmUgdG8gRE9NIGRvY3VtZW50IGF0IHRoZSByaWdodCBwbGFjZVxyXG4gKiAgICAgfSk7XHJcbiAqXHJcbiAqICAgICAvL25vdyB3ZSBoYXZlIHJlZmVyZW5jZSB0byB0aGUgY2xvbmVkIERPTSB2aWEgYGNsb25lYFxyXG4gKiAgIDwvcHJlPlxyXG4gKlxyXG4gKlxyXG4gKiBGb3IgaW5mb3JtYXRpb24gb24gaG93IHRoZSBjb21waWxlciB3b3Jrcywgc2VlIHRoZVxyXG4gKiB7QGxpbmsgZ3VpZGUvY29tcGlsZXIgQW5ndWxhciBIVE1MIENvbXBpbGVyfSBzZWN0aW9uIG9mIHRoZSBEZXZlbG9wZXIgR3VpZGUuXHJcbiAqL1xyXG5cclxudmFyICRjb21waWxlTWluRXJyID0gbWluRXJyKCckY29tcGlsZScpO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBzZXJ2aWNlXHJcbiAqIEBuYW1lIG5nLiRjb21waWxlUHJvdmlkZXJcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKi9cclxuJENvbXBpbGVQcm92aWRlci4kaW5qZWN0ID0gWyckcHJvdmlkZSddO1xyXG5mdW5jdGlvbiAkQ29tcGlsZVByb3ZpZGVyKCRwcm92aWRlKSB7XHJcbiAgdmFyIGhhc0RpcmVjdGl2ZXMgPSB7fSxcclxuICAgICAgU3VmZml4ID0gJ0RpcmVjdGl2ZScsXHJcbiAgICAgIENPTU1FTlRfRElSRUNUSVZFX1JFR0VYUCA9IC9eXFxzKmRpcmVjdGl2ZVxcOlxccyooW1xcZFxcd1xcLV9dKylcXHMrKC4qKSQvLFxyXG4gICAgICBDTEFTU19ESVJFQ1RJVkVfUkVHRVhQID0gLygoW1xcZFxcd1xcLV9dKykoPzpcXDooW147XSspKT87PykvLFxyXG4gICAgICBhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCA9IC9eXFxzKihodHRwcz98ZnRwfG1haWx0b3xmaWxlKTovLFxyXG4gICAgICBpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3QgPSAvXlxccyooaHR0cHM/fGZ0cHxmaWxlKTp8ZGF0YTppbWFnZVxcLy87XHJcblxyXG4gIC8vIFJlZjogaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy93ZWJhcHBhcGlzLmh0bWwjZXZlbnQtaGFuZGxlci1pZGwtYXR0cmlidXRlc1xyXG4gIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgZnV0dXJlIERPTSBldmVudCBhdHRyaWJ1dGUgbmFtZXMgd2lsbCBiZWdpbiB3aXRoXHJcbiAgLy8gJ29uJyBhbmQgYmUgY29tcG9zZWQgb2Ygb25seSBFbmdsaXNoIGxldHRlcnMuXHJcbiAgdmFyIEVWRU5UX0hBTkRMRVJfQVRUUl9SRUdFWFAgPSAvXihvblthLXpdKnxmb3JtYWN0aW9uKSQvO1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy4kY29tcGlsZVByb3ZpZGVyI2RpcmVjdGl2ZVxyXG4gICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZVByb3ZpZGVyXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBSZWdpc3RlciBhIG5ldyBkaXJlY3RpdmUgd2l0aCB0aGUgY29tcGlsZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBkaXJlY3RpdmUgaW4gY2FtZWwtY2FzZS4gKGllIDxjb2RlPm5nQmluZDwvY29kZT4gd2hpY2ggd2lsbCBtYXRjaCBhc1xyXG4gICAqICAgICAgICAgICAgICAgIDxjb2RlPm5nLWJpbmQ8L2NvZGU+KS5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufEFycmF5fSBkaXJlY3RpdmVGYWN0b3J5IEFuIGluamVjdGFibGUgZGlyZWN0aXZlIGZhY3RvcnkgZnVuY3Rpb24uIFNlZSB7QGxpbmsgZ3VpZGUvZGlyZWN0aXZlfSBmb3IgbW9yZVxyXG4gICAqICAgICAgICAgICAgICAgIGluZm8uXHJcbiAgICogQHJldHVybnMge25nLiRjb21waWxlUHJvdmlkZXJ9IFNlbGYgZm9yIGNoYWluaW5nLlxyXG4gICAqL1xyXG4gICB0aGlzLmRpcmVjdGl2ZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZUZhY3RvcnkpIHtcclxuICAgIGlmIChpc1N0cmluZyhuYW1lKSkge1xyXG4gICAgICBhc3NlcnRBcmcoZGlyZWN0aXZlRmFjdG9yeSwgJ2RpcmVjdGl2ZUZhY3RvcnknKTtcclxuICAgICAgaWYgKCFoYXNEaXJlY3RpdmVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgaGFzRGlyZWN0aXZlc1tuYW1lXSA9IFtdO1xyXG4gICAgICAgICRwcm92aWRlLmZhY3RvcnkobmFtZSArIFN1ZmZpeCwgWyckaW5qZWN0b3InLCAnJGV4Y2VwdGlvbkhhbmRsZXInLFxyXG4gICAgICAgICAgZnVuY3Rpb24oJGluamVjdG9yLCAkZXhjZXB0aW9uSGFuZGxlcikge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3JFYWNoKGhhc0RpcmVjdGl2ZXNbbmFtZV0sIGZ1bmN0aW9uKGRpcmVjdGl2ZUZhY3RvcnkpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9ICRpbmplY3Rvci5pbnZva2UoZGlyZWN0aXZlRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkaXJlY3RpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHsgY29tcGlsZTogdmFsdWVGbihkaXJlY3RpdmUpIH07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkaXJlY3RpdmUuY29tcGlsZSAmJiBkaXJlY3RpdmUubGluaykge1xyXG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuY29tcGlsZSA9IHZhbHVlRm4oZGlyZWN0aXZlLmxpbmspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLnByaW9yaXR5ID0gZGlyZWN0aXZlLnByaW9yaXR5IHx8IDA7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUubmFtZSA9IGRpcmVjdGl2ZS5uYW1lIHx8IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUucmVxdWlyZSA9IGRpcmVjdGl2ZS5yZXF1aXJlIHx8IChkaXJlY3RpdmUuY29udHJvbGxlciAmJiBkaXJlY3RpdmUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUucmVzdHJpY3QgPSBkaXJlY3RpdmUucmVzdHJpY3QgfHwgJ0EnO1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXM7XHJcbiAgICAgICAgICB9XSk7XHJcbiAgICAgIH1cclxuICAgICAgaGFzRGlyZWN0aXZlc1tuYW1lXS5wdXNoKGRpcmVjdGl2ZUZhY3RvcnkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yRWFjaChuYW1lLCByZXZlcnNlUGFyYW1zKHJlZ2lzdGVyRGlyZWN0aXZlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuJGNvbXBpbGVQcm92aWRlciNhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdFxyXG4gICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZVByb3ZpZGVyXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBSZXRyaWV2ZXMgb3Igb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgZm9yIHdoaXRlbGlzdGluZyBvZiBzYWZlXHJcbiAgICogdXJscyBkdXJpbmcgYVtocmVmXSBzYW5pdGl6YXRpb24uXHJcbiAgICpcclxuICAgKiBUaGUgc2FuaXRpemF0aW9uIGlzIGEgc2VjdXJpdHkgbWVhc3VyZSBhaW1lZCBhdCBwcmV2ZW50IFhTUyBhdHRhY2tzIHZpYSBodG1sIGxpbmtzLlxyXG4gICAqXHJcbiAgICogQW55IHVybCBhYm91dCB0byBiZSBhc3NpZ25lZCB0byBhW2hyZWZdIHZpYSBkYXRhLWJpbmRpbmcgaXMgZmlyc3Qgbm9ybWFsaXplZCBhbmQgdHVybmVkIGludG9cclxuICAgKiBhbiBhYnNvbHV0ZSB1cmwuIEFmdGVyd2FyZHMsIHRoZSB1cmwgaXMgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3RgXHJcbiAgICogcmVndWxhciBleHByZXNzaW9uLiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgb3JpZ2luYWwgdXJsIGlzIHdyaXR0ZW4gaW50byB0aGUgZG9tLiBPdGhlcndpc2UsXHJcbiAgICogdGhlIGFic29sdXRlIHVybCBpcyBwcmVmaXhlZCB3aXRoIGAndW5zYWZlOidgIHN0cmluZyBhbmQgb25seSB0aGVuIGlzIGl0IHdyaXR0ZW4gaW50byB0aGUgRE9NLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWdFeHA9fSByZWdleHAgTmV3IHJlZ2V4cCB0byB3aGl0ZWxpc3QgdXJscyB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHtSZWdFeHB8bmcuJGNvbXBpbGVQcm92aWRlcn0gQ3VycmVudCBSZWdFeHAgaWYgY2FsbGVkIHdpdGhvdXQgdmFsdWUgb3Igc2VsZiBmb3JcclxuICAgKiAgICBjaGFpbmluZyBvdGhlcndpc2UuXHJcbiAgICovXHJcbiAgdGhpcy5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCA9IGZ1bmN0aW9uKHJlZ2V4cCkge1xyXG4gICAgaWYgKGlzRGVmaW5lZChyZWdleHApKSB7XHJcbiAgICAgIGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gcmVnZXhwO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdDtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuJGNvbXBpbGVQcm92aWRlciNpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3RcclxuICAgKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGVQcm92aWRlclxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmV0cmlldmVzIG9yIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBpcyB1c2VkIGZvciB3aGl0ZWxpc3Rpbmcgb2Ygc2FmZVxyXG4gICAqIHVybHMgZHVyaW5nIGltZ1tzcmNdIHNhbml0aXphdGlvbi5cclxuICAgKlxyXG4gICAqIFRoZSBzYW5pdGl6YXRpb24gaXMgYSBzZWN1cml0eSBtZWFzdXJlIGFpbWVkIGF0IHByZXZlbnQgWFNTIGF0dGFja3MgdmlhIGh0bWwgbGlua3MuXHJcbiAgICpcclxuICAgKiBBbnkgdXJsIGFib3V0IHRvIGJlIGFzc2lnbmVkIHRvIGltZ1tzcmNdIHZpYSBkYXRhLWJpbmRpbmcgaXMgZmlyc3Qgbm9ybWFsaXplZCBhbmQgdHVybmVkIGludG8gYW5cclxuICAgKiBhYnNvbHV0ZSB1cmwuIEFmdGVyd2FyZHMsIHRoZSB1cmwgaXMgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0YCByZWd1bGFyXHJcbiAgICogZXhwcmVzc2lvbi4gSWYgYSBtYXRjaCBpcyBmb3VuZCwgdGhlIG9yaWdpbmFsIHVybCBpcyB3cml0dGVuIGludG8gdGhlIGRvbS4gT3RoZXJ3aXNlLCB0aGVcclxuICAgKiBhYnNvbHV0ZSB1cmwgaXMgcHJlZml4ZWQgd2l0aCBgJ3Vuc2FmZTonYCBzdHJpbmcgYW5kIG9ubHkgdGhlbiBpcyBpdCB3cml0dGVuIGludG8gdGhlIERPTS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnRXhwPX0gcmVnZXhwIE5ldyByZWdleHAgdG8gd2hpdGVsaXN0IHVybHMgd2l0aC5cclxuICAgKiBAcmV0dXJucyB7UmVnRXhwfG5nLiRjb21waWxlUHJvdmlkZXJ9IEN1cnJlbnQgUmVnRXhwIGlmIGNhbGxlZCB3aXRob3V0IHZhbHVlIG9yIHNlbGYgZm9yXHJcbiAgICogICAgY2hhaW5pbmcgb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIHRoaXMuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gZnVuY3Rpb24ocmVnZXhwKSB7XHJcbiAgICBpZiAoaXNEZWZpbmVkKHJlZ2V4cCkpIHtcclxuICAgICAgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gcmVnZXhwO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3Q7XHJcbiAgfTtcclxuXHJcblxyXG4gIHRoaXMuJGdldCA9IFtcclxuICAgICAgICAgICAgJyRpbmplY3RvcicsICckaW50ZXJwb2xhdGUnLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJHBhcnNlJyxcclxuICAgICAgICAgICAgJyRjb250cm9sbGVyJywgJyRyb290U2NvcGUnLCAnJGRvY3VtZW50JywgJyRzY2UnLCAnJCR1cmxVdGlscycsICckYW5pbWF0ZScsXHJcbiAgICBmdW5jdGlvbigkaW5qZWN0b3IsICAgJGludGVycG9sYXRlLCAgICRleGNlcHRpb25IYW5kbGVyLCAgICRodHRwLCAgICR0ZW1wbGF0ZUNhY2hlLCAgICRwYXJzZSxcclxuICAgICAgICAgICAgICRjb250cm9sbGVyLCAgICRyb290U2NvcGUsICAgJGRvY3VtZW50LCAgICRzY2UsICAgJCR1cmxVdGlscywgJGFuaW1hdGUpIHtcclxuXHJcbiAgICB2YXIgQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgdGhpcy4kJGVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICB0aGlzLiRhdHRyID0gYXR0ciB8fCB7fTtcclxuICAgIH07XHJcblxyXG4gICAgQXR0cmlidXRlcy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICRub3JtYWxpemU6IGRpcmVjdGl2ZU5vcm1hbGl6ZSxcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzIyRhZGRDbGFzc1xyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXNcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBBZGRzIHRoZSBDU1MgY2xhc3MgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBjbGFzc1ZhbCBwYXJhbWV0ZXIgdG8gdGhlIGVsZW1lbnQuIElmIGFuaW1hdGlvbnNcclxuICAgICAgICogYXJlIGVuYWJsZWQgdGhlbiBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgZm9yIHRoZSBjbGFzcyBhZGRpdGlvbi5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVmFsIFRoZSBjbGFzc05hbWUgdmFsdWUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgICAqL1xyXG4gICAgICAkYWRkQ2xhc3MgOiBmdW5jdGlvbihjbGFzc1ZhbCkge1xyXG4gICAgICAgIGlmKGNsYXNzVmFsICYmIGNsYXNzVmFsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKHRoaXMuJCRlbGVtZW50LCBjbGFzc1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkcmVtb3ZlQ2xhc3NcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogUmVtb3ZlcyB0aGUgQ1NTIGNsYXNzIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgY2xhc3NWYWwgcGFyYW1ldGVyIGZyb20gdGhlIGVsZW1lbnQuIElmIGFuaW1hdGlvbnNcclxuICAgICAgICogYXJlIGVuYWJsZWQgdGhlbiBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgZm9yIHRoZSBjbGFzcyByZW1vdmFsLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NWYWwgVGhlIGNsYXNzTmFtZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50XHJcbiAgICAgICAqL1xyXG4gICAgICAkcmVtb3ZlQ2xhc3MgOiBmdW5jdGlvbihjbGFzc1ZhbCkge1xyXG4gICAgICAgIGlmKGNsYXNzVmFsICYmIGNsYXNzVmFsLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKHRoaXMuJCRlbGVtZW50LCBjbGFzc1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCBhIG5vcm1hbGl6ZWQgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IGluIGEgd2F5IHN1Y2ggdGhhdCBhbGwgZGlyZWN0aXZlc1xyXG4gICAgICAgKiBjYW4gc2hhcmUgdGhlIGF0dHJpYnV0ZS4gVGhpcyBmdW5jdGlvbiBwcm9wZXJseSBoYW5kbGVzIGJvb2xlYW4gYXR0cmlidXRlcy5cclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBOb3JtYWxpemVkIGtleS4gKGllIG5nQXR0cmlidXRlKVxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBJZiBgbnVsbGAgYXR0cmlidXRlIHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gd3JpdGVBdHRyIElmIGZhbHNlLCBkb2VzIG5vdCB3cml0ZSB0aGUgdmFsdWUgdG8gRE9NIGVsZW1lbnQgYXR0cmlidXRlLlxyXG4gICAgICAgKiAgICAgRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyTmFtZSBPcHRpb25hbCBub25lIG5vcm1hbGl6ZWQgbmFtZS4gRGVmYXVsdHMgdG8ga2V5LlxyXG4gICAgICAgKi9cclxuICAgICAgJHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgd3JpdGVBdHRyLCBhdHRyTmFtZSkge1xyXG4gICAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciBjbGFzcyBhdHRyaWJ1dGUgYWRkaXRpb24gKyByZW1vdmFsXHJcbiAgICAgICAgLy9zbyB0aGF0IGNsYXNzIGNoYW5nZXMgY2FuIHRhcCBpbnRvIHRoZSBhbmltYXRpb25cclxuICAgICAgICAvL2hvb2tzIHByb3ZpZGVkIGJ5IHRoZSAkYW5pbWF0ZSBzZXJ2aWNlXHJcbiAgICAgICAgaWYoa2V5ID09ICdjbGFzcycpIHtcclxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgJyc7XHJcbiAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuJCRlbGVtZW50LmF0dHIoJ2NsYXNzJykgfHwgJyc7XHJcbiAgICAgICAgICB0aGlzLiRyZW1vdmVDbGFzcyh0b2tlbkRpZmZlcmVuY2UoY3VycmVudCwgdmFsdWUpLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICB0aGlzLiRhZGRDbGFzcyh0b2tlbkRpZmZlcmVuY2UodmFsdWUsIGN1cnJlbnQpLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBib29sZWFuS2V5ID0gZ2V0Qm9vbGVhbkF0dHJOYW1lKHRoaXMuJCRlbGVtZW50WzBdLCBrZXkpLFxyXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWwsXHJcbiAgICAgICAgICAgICAgbm9kZU5hbWU7XHJcblxyXG4gICAgICAgICAgaWYgKGJvb2xlYW5LZXkpIHtcclxuICAgICAgICAgICAgdGhpcy4kJGVsZW1lbnQucHJvcChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgYXR0ck5hbWUgPSBib29sZWFuS2V5O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgIC8vIHRyYW5zbGF0ZSBub3JtYWxpemVkIGtleSB0byBhY3R1YWwga2V5XHJcbiAgICAgICAgICBpZiAoYXR0ck5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy4kYXR0cltrZXldID0gYXR0ck5hbWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhdHRyTmFtZSA9IHRoaXMuJGF0dHJba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFhdHRyTmFtZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuJGF0dHJba2V5XSA9IGF0dHJOYW1lID0gc25ha2VfY2FzZShrZXksICctJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBub2RlTmFtZSA9IG5vZGVOYW1lXyh0aGlzLiQkZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgLy8gc2FuaXRpemUgYVtocmVmXSBhbmQgaW1nW3NyY10gdmFsdWVzXHJcbiAgICAgICAgICBpZiAoKG5vZGVOYW1lID09PSAnQScgJiYga2V5ID09PSAnaHJlZicpIHx8XHJcbiAgICAgICAgICAgICAgKG5vZGVOYW1lID09PSAnSU1HJyAmJiBrZXkgPT09ICdzcmMnKSkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiAkJHVybFV0aWxzLnJlc29sdmUoKSBkb2Vzbid0IHN1cHBvcnQgSUUgPCA4IHNvIHdlIGRvbid0IHNhbml0aXplIGZvciB0aGF0IGNhc2UuXHJcbiAgICAgICAgICAgIGlmICghbXNpZSB8fCBtc2llID49IDggKSB7XHJcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbCA9ICQkdXJsVXRpbHMucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRWYWwgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGtleSA9PT0gJ2hyZWYnICYmICFub3JtYWxpemVkVmFsLm1hdGNoKGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoa2V5ID09PSAnc3JjJyAmJiAhbm9ybWFsaXplZFZhbC5tYXRjaChpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3QpKSkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZSA9ICd1bnNhZmU6JyArIG5vcm1hbGl6ZWRWYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHdyaXRlQXR0ciAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICB0aGlzLiQkZWxlbWVudC5yZW1vdmVBdHRyKGF0dHJOYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLiQkZWxlbWVudC5hdHRyKGF0dHJOYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpcmUgb2JzZXJ2ZXJzXHJcbiAgICAgICAgdmFyICQkb2JzZXJ2ZXJzID0gdGhpcy4kJG9ic2VydmVycztcclxuICAgICAgICAkJG9ic2VydmVycyAmJiBmb3JFYWNoKCQkb2JzZXJ2ZXJzW2tleV0sIGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbih2YWx1ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB0b2tlbkRpZmZlcmVuY2Uoc3RyMSwgc3RyMikge1xyXG4gICAgICAgICAgdmFyIHZhbHVlcyA9IFtdLFxyXG4gICAgICAgICAgICAgIHRva2VuczEgPSBzdHIxLnNwbGl0KC9cXHMrLyksXHJcbiAgICAgICAgICAgICAgdG9rZW5zMiA9IHN0cjIuc3BsaXQoL1xccysvKTtcclxuXHJcbiAgICAgICAgICBvdXRlcjpcclxuICAgICAgICAgIGZvcih2YXIgaT0wO2k8dG9rZW5zMS5sZW5ndGg7aSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2VuczFbaV07XHJcbiAgICAgICAgICAgIGZvcih2YXIgaj0wO2o8dG9rZW5zMi5sZW5ndGg7aisrKSB7XHJcbiAgICAgICAgICAgICAgaWYodG9rZW4gPT0gdG9rZW5zMltqXSkgY29udGludWUgb3V0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWVzLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBPYnNlcnZlIGFuIGludGVycG9sYXRlZCBhdHRyaWJ1dGUuXHJcbiAgICAgICAqIFRoZSBvYnNlcnZlciB3aWxsIG5ldmVyIGJlIGNhbGxlZCwgaWYgZ2l2ZW4gYXR0cmlidXRlIGlzIG5vdCBpbnRlcnBvbGF0ZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgTm9ybWFsaXplZCBrZXkuIChpZSBuZ0F0dHJpYnV0ZSkgLlxyXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBmbiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBhdHRyaWJ1dGUgdmFsdWUgY2hhbmdlcy5cclxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKCopfSB0aGUgYGZuYCBGdW5jdGlvbiBwYXNzZWQgaW4uXHJcbiAgICAgICAqL1xyXG4gICAgICAkb2JzZXJ2ZTogZnVuY3Rpb24oa2V5LCBmbikge1xyXG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMsXHJcbiAgICAgICAgICAgICQkb2JzZXJ2ZXJzID0gKGF0dHJzLiQkb2JzZXJ2ZXJzIHx8IChhdHRycy4kJG9ic2VydmVycyA9IHt9KSksXHJcbiAgICAgICAgICAgIGxpc3RlbmVycyA9ICgkJG9ic2VydmVyc1trZXldIHx8ICgkJG9ic2VydmVyc1trZXldID0gW10pKTtcclxuXHJcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goZm4pO1xyXG4gICAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICghbGlzdGVuZXJzLiQkaW50ZXIpIHtcclxuICAgICAgICAgICAgLy8gbm8gb25lIHJlZ2lzdGVyZWQgYXR0cmlidXRlIGludGVycG9sYXRpb24gZnVuY3Rpb24sIHNvIGxldHMgY2FsbCBpdCBtYW51YWxseVxyXG4gICAgICAgICAgICBmbihhdHRyc1trZXldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHVybFNhbml0aXphdGlvbk5vZGUgPSAkZG9jdW1lbnRbMF0uY3JlYXRlRWxlbWVudCgnYScpLFxyXG4gICAgICAgIHN0YXJ0U3ltYm9sID0gJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCksXHJcbiAgICAgICAgZW5kU3ltYm9sID0gJGludGVycG9sYXRlLmVuZFN5bWJvbCgpLFxyXG4gICAgICAgIGRlbm9ybWFsaXplVGVtcGxhdGUgPSAoc3RhcnRTeW1ib2wgPT0gJ3t7JyB8fCBlbmRTeW1ib2wgID09ICd9fScpXHJcbiAgICAgICAgICAgID8gaWRlbnRpdHlcclxuICAgICAgICAgICAgOiBmdW5jdGlvbiBkZW5vcm1hbGl6ZVRlbXBsYXRlKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xce1xcey9nLCBzdGFydFN5bWJvbCkucmVwbGFjZSgvfX0vZywgZW5kU3ltYm9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIE5HX0FUVFJfQklORElORyA9IC9ebmdBdHRyW0EtWl0vO1xyXG5cclxuXHJcbiAgICByZXR1cm4gY29tcGlsZTtcclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGlsZSgkY29tcGlsZU5vZGVzLCB0cmFuc2NsdWRlRm4sIG1heFByaW9yaXR5LCBpZ25vcmVEaXJlY3RpdmUpIHtcclxuICAgICAgaWYgKCEoJGNvbXBpbGVOb2RlcyBpbnN0YW5jZW9mIGpxTGl0ZSkpIHtcclxuICAgICAgICAvLyBqcXVlcnkgYWx3YXlzIHJld3JhcHMsIHdoZXJlYXMgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc2VsZWN0b3Igc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IGl0LlxyXG4gICAgICAgICRjb21waWxlTm9kZXMgPSBqcUxpdGUoJGNvbXBpbGVOb2Rlcyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gV2UgY2FuIG5vdCBjb21waWxlIHRvcCBsZXZlbCB0ZXh0IGVsZW1lbnRzIHNpbmNlIHRleHQgbm9kZXMgY2FuIGJlIG1lcmdlZCBhbmQgd2Ugd2lsbFxyXG4gICAgICAvLyBub3QgYmUgYWJsZSB0byBhdHRhY2ggc2NvcGUgZGF0YSB0byB0aGVtLCBzbyB3ZSB3aWxsIHdyYXAgdGhlbSBpbiA8c3Bhbj5cclxuICAgICAgZm9yRWFjaCgkY29tcGlsZU5vZGVzLCBmdW5jdGlvbihub2RlLCBpbmRleCl7XHJcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAvKiB0ZXh0IG5vZGUgKi8gJiYgbm9kZS5ub2RlVmFsdWUubWF0Y2goL1xcUysvKSAvKiBub24tZW1wdHkgKi8gKSB7XHJcbiAgICAgICAgICAkY29tcGlsZU5vZGVzW2luZGV4XSA9IG5vZGUgPSBqcUxpdGUobm9kZSkud3JhcCgnPHNwYW4+PC9zcGFuPicpLnBhcmVudCgpWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBjb21wb3NpdGVMaW5rRm4gPSBjb21waWxlTm9kZXMoJGNvbXBpbGVOb2RlcywgdHJhbnNjbHVkZUZuLCAkY29tcGlsZU5vZGVzLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlKTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHB1YmxpY0xpbmtGbihzY29wZSwgY2xvbmVDb25uZWN0Rm4pe1xyXG4gICAgICAgIGFzc2VydEFyZyhzY29wZSwgJ3Njb3BlJyk7XHJcbiAgICAgICAgLy8gaW1wb3J0YW50ISE6IHdlIG11c3QgY2FsbCBvdXIganFMaXRlLmNsb25lKCkgc2luY2UgdGhlIGpRdWVyeSBvbmUgaXMgdHJ5aW5nIHRvIGJlIHNtYXJ0XHJcbiAgICAgICAgLy8gYW5kIHNvbWV0aW1lcyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIERPTS5cclxuICAgICAgICB2YXIgJGxpbmtOb2RlID0gY2xvbmVDb25uZWN0Rm5cclxuICAgICAgICAgID8gSlFMaXRlUHJvdG90eXBlLmNsb25lLmNhbGwoJGNvbXBpbGVOb2RlcykgLy8gSU1QT1JUQU5UISEhXHJcbiAgICAgICAgICA6ICRjb21waWxlTm9kZXM7XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCBzY29wZSBvbmx5IHRvIG5vbi10ZXh0IG5vZGVzLlxyXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGlpID0gJGxpbmtOb2RlLmxlbmd0aDsgaTxpaTsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgbm9kZSA9ICRsaW5rTm9kZVtpXTtcclxuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgLyogZWxlbWVudCAqLyB8fCBub2RlLm5vZGVUeXBlID09IDkgLyogZG9jdW1lbnQgKi8pIHtcclxuICAgICAgICAgICAgJGxpbmtOb2RlLmVxKGkpLmRhdGEoJyRzY29wZScsIHNjb3BlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2FmZUFkZENsYXNzKCRsaW5rTm9kZSwgJ25nLXNjb3BlJyk7XHJcbiAgICAgICAgaWYgKGNsb25lQ29ubmVjdEZuKSBjbG9uZUNvbm5lY3RGbigkbGlua05vZGUsIHNjb3BlKTtcclxuICAgICAgICBpZiAoY29tcG9zaXRlTGlua0ZuKSBjb21wb3NpdGVMaW5rRm4oc2NvcGUsICRsaW5rTm9kZSwgJGxpbmtOb2RlKTtcclxuICAgICAgICByZXR1cm4gJGxpbmtOb2RlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNhZmVBZGRDbGFzcygkZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgLy8gaWdub3JlLCBzaW5jZSBpdCBtZWFucyB0aGF0IHdlIGFyZSB0cnlpbmcgdG8gc2V0IGNsYXNzIG9uXHJcbiAgICAgICAgLy8gU1ZHIGVsZW1lbnQsIHdoZXJlIGNsYXNzIG5hbWUgaXMgcmVhZC1vbmx5LlxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21waWxlIGZ1bmN0aW9uIG1hdGNoZXMgZWFjaCBub2RlIGluIG5vZGVMaXN0IGFnYWluc3QgdGhlIGRpcmVjdGl2ZXMuIE9uY2UgYWxsIGRpcmVjdGl2ZXNcclxuICAgICAqIGZvciBhIHBhcnRpY3VsYXIgbm9kZSBhcmUgY29sbGVjdGVkIHRoZWlyIGNvbXBpbGUgZnVuY3Rpb25zIGFyZSBleGVjdXRlZC4gVGhlIGNvbXBpbGVcclxuICAgICAqIGZ1bmN0aW9ucyByZXR1cm4gdmFsdWVzIC0gdGhlIGxpbmtpbmcgZnVuY3Rpb25zIC0gYXJlIGNvbWJpbmVkIGludG8gYSBjb21wb3NpdGUgbGlua2luZ1xyXG4gICAgICogZnVuY3Rpb24sIHdoaWNoIGlzIHRoZSBhIGxpbmtpbmcgZnVuY3Rpb24gZm9yIHRoZSBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0IGFuIGFycmF5IG9mIG5vZGVzIG9yIE5vZGVMaXN0IHRvIGNvbXBpbGVcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oYW5ndWxhci5TY29wZVssIGNsb25lQXR0YWNoRm5dfSB0cmFuc2NsdWRlRm4gQSBsaW5raW5nIGZ1bmN0aW9uLCB3aGVyZSB0aGVcclxuICAgICAqICAgICAgICBzY29wZSBhcmd1bWVudCBpcyBhdXRvLWdlbmVyYXRlZCB0byB0aGUgbmV3IGNoaWxkIG9mIHRoZSB0cmFuc2NsdWRlZCBwYXJlbnQgc2NvcGUuXHJcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnQ9fSAkcm9vdEVsZW1lbnQgSWYgdGhlIG5vZGVMaXN0IGlzIHRoZSByb290IG9mIHRoZSBjb21waWxhdGlvbiB0cmVlIHRoZW4gdGhlXHJcbiAgICAgKiAgICAgICAgcm9vdEVsZW1lbnQgbXVzdCBiZSBzZXQgdGhlIGpxTGl0ZSBjb2xsZWN0aW9uIG9mIHRoZSBjb21waWxlIHJvb3QuIFRoaXMgaXNcclxuICAgICAqICAgICAgICBuZWVkZWQgc28gdGhhdCB0aGUganFMaXRlIGNvbGxlY3Rpb24gaXRlbXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggd2lkZ2V0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWF4IGRpcmVjdGl2ZSBwcmlvcml0eVxyXG4gICAgICogQHJldHVybnMgez9mdW5jdGlvbn0gQSBjb21wb3NpdGUgbGlua2luZyBmdW5jdGlvbiBvZiBhbGwgb2YgdGhlIG1hdGNoZWQgZGlyZWN0aXZlcyBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb21waWxlTm9kZXMobm9kZUxpc3QsIHRyYW5zY2x1ZGVGbiwgJHJvb3RFbGVtZW50LCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlKSB7XHJcbiAgICAgIHZhciBsaW5rRm5zID0gW10sXHJcbiAgICAgICAgICBub2RlTGlua0ZuLCBjaGlsZExpbmtGbiwgZGlyZWN0aXZlcywgYXR0cnMsIGxpbmtGbkZvdW5kO1xyXG5cclxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXR0cnMgPSBuZXcgQXR0cmlidXRlcygpO1xyXG5cclxuICAgICAgICAvLyB3ZSBtdXN0IGFsd2F5cyByZWZlciB0byBub2RlTGlzdFtpXSBzaW5jZSB0aGUgbm9kZXMgY2FuIGJlIHJlcGxhY2VkIHVuZGVybmVhdGggdXMuXHJcbiAgICAgICAgZGlyZWN0aXZlcyA9IGNvbGxlY3REaXJlY3RpdmVzKG5vZGVMaXN0W2ldLCBbXSwgYXR0cnMsIGkgPT0gMCA/IG1heFByaW9yaXR5IDogdW5kZWZpbmVkLCBpZ25vcmVEaXJlY3RpdmUpO1xyXG5cclxuICAgICAgICBub2RlTGlua0ZuID0gKGRpcmVjdGl2ZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICA/IGFwcGx5RGlyZWN0aXZlc1RvTm9kZShkaXJlY3RpdmVzLCBub2RlTGlzdFtpXSwgYXR0cnMsIHRyYW5zY2x1ZGVGbiwgJHJvb3RFbGVtZW50KVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcblxyXG4gICAgICAgIGNoaWxkTGlua0ZuID0gKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCB8fCAhbm9kZUxpc3RbaV0uY2hpbGROb2RlcyB8fCAhbm9kZUxpc3RbaV0uY2hpbGROb2Rlcy5sZW5ndGgpXHJcbiAgICAgICAgICAgID8gbnVsbFxyXG4gICAgICAgICAgICA6IGNvbXBpbGVOb2Rlcyhub2RlTGlzdFtpXS5jaGlsZE5vZGVzLFxyXG4gICAgICAgICAgICAgICAgIG5vZGVMaW5rRm4gPyBub2RlTGlua0ZuLnRyYW5zY2x1ZGUgOiB0cmFuc2NsdWRlRm4pO1xyXG5cclxuICAgICAgICBsaW5rRm5zLnB1c2gobm9kZUxpbmtGbik7XHJcbiAgICAgICAgbGlua0Zucy5wdXNoKGNoaWxkTGlua0ZuKTtcclxuICAgICAgICBsaW5rRm5Gb3VuZCA9IChsaW5rRm5Gb3VuZCB8fCBub2RlTGlua0ZuIHx8IGNoaWxkTGlua0ZuKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmV0dXJuIGEgbGlua2luZyBmdW5jdGlvbiBpZiB3ZSBoYXZlIGZvdW5kIGFueXRoaW5nLCBudWxsIG90aGVyd2lzZVxyXG4gICAgICByZXR1cm4gbGlua0ZuRm91bmQgPyBjb21wb3NpdGVMaW5rRm4gOiBudWxsO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcG9zaXRlTGlua0ZuKHNjb3BlLCBub2RlTGlzdCwgJHJvb3RFbGVtZW50LCBib3VuZFRyYW5zY2x1ZGVGbikge1xyXG4gICAgICAgIHZhciBub2RlTGlua0ZuLCBjaGlsZExpbmtGbiwgbm9kZSwgY2hpbGRTY29wZSwgY2hpbGRUcmFuc2NsdWRlRm4sIGksIGlpLCBuO1xyXG5cclxuICAgICAgICAvLyBjb3B5IG5vZGVMaXN0IHNvIHRoYXQgbGlua2luZyBkb2Vzbid0IGJyZWFrIGR1ZSB0byBsaXZlIGxpc3QgdXBkYXRlcy5cclxuICAgICAgICB2YXIgc3RhYmxlTm9kZUxpc3QgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG5vZGVMaXN0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgIHN0YWJsZU5vZGVMaXN0LnB1c2gobm9kZUxpc3RbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKGkgPSAwLCBuID0gMCwgaWkgPSBsaW5rRm5zLmxlbmd0aDsgaSA8IGlpOyBuKyspIHtcclxuICAgICAgICAgIG5vZGUgPSBzdGFibGVOb2RlTGlzdFtuXTtcclxuICAgICAgICAgIG5vZGVMaW5rRm4gPSBsaW5rRm5zW2krK107XHJcbiAgICAgICAgICBjaGlsZExpbmtGbiA9IGxpbmtGbnNbaSsrXTtcclxuXHJcbiAgICAgICAgICBpZiAobm9kZUxpbmtGbikge1xyXG4gICAgICAgICAgICBpZiAobm9kZUxpbmtGbi5zY29wZSkge1xyXG4gICAgICAgICAgICAgIGNoaWxkU2NvcGUgPSBzY29wZS4kbmV3KGlzT2JqZWN0KG5vZGVMaW5rRm4uc2NvcGUpKTtcclxuICAgICAgICAgICAgICBqcUxpdGUobm9kZSkuZGF0YSgnJHNjb3BlJywgY2hpbGRTY29wZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY2hpbGRTY29wZSA9IHNjb3BlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkVHJhbnNjbHVkZUZuID0gbm9kZUxpbmtGbi50cmFuc2NsdWRlO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRUcmFuc2NsdWRlRm4gfHwgKCFib3VuZFRyYW5zY2x1ZGVGbiAmJiB0cmFuc2NsdWRlRm4pKSB7XHJcbiAgICAgICAgICAgICAgbm9kZUxpbmtGbihjaGlsZExpbmtGbiwgY2hpbGRTY29wZSwgbm9kZSwgJHJvb3RFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAoZnVuY3Rpb24odHJhbnNjbHVkZUZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNsb25lRm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2NsdWRlU2NvcGUgPSBzY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2NsdWRlU2NvcGUuJCR0cmFuc2NsdWRlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zY2x1ZGVGbih0cmFuc2NsdWRlU2NvcGUsIGNsb25lRm4pLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uKCckZGVzdHJveScsIGJpbmQodHJhbnNjbHVkZVNjb3BlLCB0cmFuc2NsdWRlU2NvcGUuJGRlc3Ryb3kpKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICB9KShjaGlsZFRyYW5zY2x1ZGVGbiB8fCB0cmFuc2NsdWRlRm4pXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBub2RlTGlua0ZuKGNoaWxkTGlua0ZuLCBjaGlsZFNjb3BlLCBub2RlLCB1bmRlZmluZWQsIGJvdW5kVHJhbnNjbHVkZUZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGlsZExpbmtGbikge1xyXG4gICAgICAgICAgICBjaGlsZExpbmtGbihzY29wZSwgbm9kZS5jaGlsZE5vZGVzLCB1bmRlZmluZWQsIGJvdW5kVHJhbnNjbHVkZUZuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rcyBmb3IgZGlyZWN0aXZlcyBvbiB0aGUgZ2l2ZW4gbm9kZSBhbmQgYWRkcyB0aGVtIHRvIHRoZSBkaXJlY3RpdmUgY29sbGVjdGlvbiB3aGljaCBpc1xyXG4gICAgICogc29ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBub2RlIE5vZGUgdG8gc2VhcmNoLlxyXG4gICAgICogQHBhcmFtIGRpcmVjdGl2ZXMgQW4gYXJyYXkgdG8gd2hpY2ggdGhlIGRpcmVjdGl2ZXMgYXJlIGFkZGVkIHRvLiBUaGlzIGFycmF5IGlzIHNvcnRlZCBiZWZvcmVcclxuICAgICAqICAgICAgICB0aGUgZnVuY3Rpb24gcmV0dXJucy5cclxuICAgICAqIEBwYXJhbSBhdHRycyBUaGUgc2hhcmVkIGF0dHJzIG9iamVjdCB3aGljaCBpcyB1c2VkIHRvIHBvcHVsYXRlIHRoZSBub3JtYWxpemVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG1heFByaW9yaXR5IE1heCBkaXJlY3RpdmUgcHJpb3JpdHkuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3REaXJlY3RpdmVzKG5vZGUsIGRpcmVjdGl2ZXMsIGF0dHJzLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlKSB7XHJcbiAgICAgIHZhciBub2RlVHlwZSA9IG5vZGUubm9kZVR5cGUsXHJcbiAgICAgICAgICBhdHRyc01hcCA9IGF0dHJzLiRhdHRyLFxyXG4gICAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgICBjbGFzc05hbWU7XHJcblxyXG4gICAgICBzd2l0Y2gobm9kZVR5cGUpIHtcclxuICAgICAgICBjYXNlIDE6IC8qIEVsZW1lbnQgKi9cclxuICAgICAgICAgIC8vIHVzZSB0aGUgbm9kZSBuYW1lOiA8ZGlyZWN0aXZlPlxyXG4gICAgICAgICAgYWRkRGlyZWN0aXZlKGRpcmVjdGl2ZXMsXHJcbiAgICAgICAgICAgICAgZGlyZWN0aXZlTm9ybWFsaXplKG5vZGVOYW1lXyhub2RlKS50b0xvd2VyQ2FzZSgpKSwgJ0UnLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlKTtcclxuXHJcbiAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGF0dHJpYnV0ZXNcclxuICAgICAgICAgIGZvciAodmFyIGF0dHIsIG5hbWUsIG5OYW1lLCBuZ0F0dHJOYW1lLCB2YWx1ZSwgbkF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgaiA9IDAsIGpqID0gbkF0dHJzICYmIG5BdHRycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRyU3RhcnROYW1lO1xyXG4gICAgICAgICAgICB2YXIgYXR0ckVuZE5hbWU7XHJcbiAgICAgICAgICAgIHZhciBpbmRleDtcclxuXHJcbiAgICAgICAgICAgIGF0dHIgPSBuQXR0cnNbal07XHJcbiAgICAgICAgICAgIGlmICghbXNpZSB8fCBtc2llID49IDggfHwgYXR0ci5zcGVjaWZpZWQpIHtcclxuICAgICAgICAgICAgICBuYW1lID0gYXR0ci5uYW1lO1xyXG4gICAgICAgICAgICAgIC8vIHN1cHBvcnQgbmdBdHRyIGF0dHJpYnV0ZSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgbmdBdHRyTmFtZSA9IGRpcmVjdGl2ZU5vcm1hbGl6ZShuYW1lKTtcclxuICAgICAgICAgICAgICBpZiAoTkdfQVRUUl9CSU5ESU5HLnRlc3QobmdBdHRyTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuZ0F0dHJOYW1lLnN1YnN0cig2KS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoKGluZGV4ID0gbmdBdHRyTmFtZS5sYXN0SW5kZXhPZignU3RhcnQnKSkgIT0gLTEgJiYgaW5kZXggPT0gbmdBdHRyTmFtZS5sZW5ndGggLSA1KSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyU3RhcnROYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIGF0dHJFbmROYW1lID0gbmFtZS5zdWJzdHIoMCwgbmFtZS5sZW5ndGggLSA1KSArICdlbmQnO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gNik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG5OYW1lID0gZGlyZWN0aXZlTm9ybWFsaXplKG5hbWUudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgYXR0cnNNYXBbbk5hbWVdID0gbmFtZTtcclxuICAgICAgICAgICAgICBhdHRyc1tuTmFtZV0gPSB2YWx1ZSA9IHRyaW0oKG1zaWUgJiYgbmFtZSA9PSAnaHJlZicpXHJcbiAgICAgICAgICAgICAgICA/IGRlY29kZVVSSUNvbXBvbmVudChub2RlLmdldEF0dHJpYnV0ZShuYW1lLCAyKSlcclxuICAgICAgICAgICAgICAgIDogYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgaWYgKGdldEJvb2xlYW5BdHRyTmFtZShub2RlLCBuTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJzW25OYW1lXSA9IHRydWU7IC8vIHByZXNlbmNlIG1lYW5zIHRydWVcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYWRkQXR0ckludGVycG9sYXRlRGlyZWN0aXZlKG5vZGUsIGRpcmVjdGl2ZXMsIHZhbHVlLCBuTmFtZSk7XHJcbiAgICAgICAgICAgICAgYWRkRGlyZWN0aXZlKGRpcmVjdGl2ZXMsIG5OYW1lLCAnQScsIG1heFByaW9yaXR5LCBpZ25vcmVEaXJlY3RpdmUsIGF0dHJTdGFydE5hbWUsIGF0dHJFbmROYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHVzZSBjbGFzcyBhcyBkaXJlY3RpdmVcclxuICAgICAgICAgIGNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNsYXNzTmFtZSkgJiYgY2xhc3NOYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBDTEFTU19ESVJFQ1RJVkVfUkVHRVhQLmV4ZWMoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICAgIG5OYW1lID0gZGlyZWN0aXZlTm9ybWFsaXplKG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgICBpZiAoYWRkRGlyZWN0aXZlKGRpcmVjdGl2ZXMsIG5OYW1lLCAnQycsIG1heFByaW9yaXR5LCBpZ25vcmVEaXJlY3RpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyc1tuTmFtZV0gPSB0cmltKG1hdGNoWzNdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnN1YnN0cihtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzogLyogVGV4dCBOb2RlICovXHJcbiAgICAgICAgICBhZGRUZXh0SW50ZXJwb2xhdGVEaXJlY3RpdmUoZGlyZWN0aXZlcywgbm9kZS5ub2RlVmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA4OiAvKiBDb21tZW50ICovXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBtYXRjaCA9IENPTU1FTlRfRElSRUNUSVZFX1JFR0VYUC5leGVjKG5vZGUubm9kZVZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgbk5hbWUgPSBkaXJlY3RpdmVOb3JtYWxpemUobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICAgIGlmIChhZGREaXJlY3RpdmUoZGlyZWN0aXZlcywgbk5hbWUsICdNJywgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJzW25OYW1lXSA9IHRyaW0obWF0Y2hbMl0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyB0dXJucyBvdXQgdGhhdCB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMgSUU5IHRocm93cyBlcnJvcnMgd2hlbiBvbmUgYXR0ZW1wdHMgdG8gcmVhZCBjb21tZW50J3Mgbm9kZSB2YWx1ZS5cclxuICAgICAgICAgICAgLy8gSnVzdCBpZ25vcmUgaXQgYW5kIGNvbnRpbnVlLiAoQ2FuJ3Qgc2VlbSB0byByZXByb2R1Y2UgaW4gdGVzdCBjYXNlLilcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXJlY3RpdmVzLnNvcnQoYnlQcmlvcml0eSk7XHJcbiAgICAgIHJldHVybiBkaXJlY3RpdmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBub2RlIHdpdGggYW4gZGlyZWN0aXZlLXN0YXJ0IGl0IGNvbGxlY3RzIGFsbCBvZiB0aGUgc2libGluZ3MgdW50aWwgaXQgZmluZCBkaXJlY3RpdmUtZW5kLlxyXG4gICAgICogQHBhcmFtIG5vZGVcclxuICAgICAqIEBwYXJhbSBhdHRyU3RhcnRcclxuICAgICAqIEBwYXJhbSBhdHRyRW5kXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ3JvdXBTY2FuKG5vZGUsIGF0dHJTdGFydCwgYXR0ckVuZCkge1xyXG4gICAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgICAgdmFyIGRlcHRoID0gMDtcclxuICAgICAgaWYgKGF0dHJTdGFydCAmJiBub2RlLmhhc0F0dHJpYnV0ZSAmJiBub2RlLmhhc0F0dHJpYnV0ZShhdHRyU3RhcnQpKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCd1dGVyZGlyJywgXCJVbnRlcm1pbmF0ZWQgYXR0cmlidXRlLCBmb3VuZCAnezB9JyBidXQgbm8gbWF0Y2hpbmcgJ3sxfScgZm91bmQuXCIsIGF0dHJTdGFydCwgYXR0ckVuZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxIC8qKiBFbGVtZW50ICoqLykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0clN0YXJ0KSkgZGVwdGgrKztcclxuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJFbmQpKSBkZXB0aC0tO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH0gd2hpbGUgKGRlcHRoID4gMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ganFMaXRlKG5vZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgZm9yIGxpbmtpbmcgZnVuY3Rpb24gd2hpY2ggY29udmVydHMgbm9ybWFsIGxpbmtpbmcgZnVuY3Rpb24gaW50byBhIGdyb3VwZWRcclxuICAgICAqIGxpbmtpbmcgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gbGlua0ZuXHJcbiAgICAgKiBAcGFyYW0gYXR0clN0YXJ0XHJcbiAgICAgKiBAcGFyYW0gYXR0ckVuZFxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBncm91cEVsZW1lbnRzTGlua0ZuV3JhcHBlcihsaW5rRm4sIGF0dHJTdGFydCwgYXR0ckVuZCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250cm9sbGVycykge1xyXG4gICAgICAgIGVsZW1lbnQgPSBncm91cFNjYW4oZWxlbWVudFswXSwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcclxuICAgICAgICByZXR1cm4gbGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcnMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmNlIHRoZSBkaXJlY3RpdmVzIGhhdmUgYmVlbiBjb2xsZWN0ZWQsIHRoZWlyIGNvbXBpbGUgZnVuY3Rpb25zIGFyZSBleGVjdXRlZC4gVGhpcyBtZXRob2RcclxuICAgICAqIGlzIHJlc3BvbnNpYmxlIGZvciBpbmxpbmluZyBkaXJlY3RpdmUgdGVtcGxhdGVzIGFzIHdlbGwgYXMgdGVybWluYXRpbmcgdGhlIGFwcGxpY2F0aW9uXHJcbiAgICAgKiBvZiB0aGUgZGlyZWN0aXZlcyBpZiB0aGUgdGVybWluYWwgZGlyZWN0aXZlIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGlyZWN0aXZlcyBBcnJheSBvZiBjb2xsZWN0ZWQgZGlyZWN0aXZlcyB0byBleGVjdXRlIHRoZWlyIGNvbXBpbGUgZnVuY3Rpb24uXHJcbiAgICAgKiAgICAgICAgdGhpcyBuZWVkcyB0byBiZSBwcmUtc29ydGVkIGJ5IHByaW9yaXR5IG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb21waWxlTm9kZSBUaGUgcmF3IERPTSBub2RlIHRvIGFwcGx5IHRoZSBjb21waWxlIGZ1bmN0aW9ucyB0b1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlQXR0cnMgVGhlIHNoYXJlZCBhdHRyaWJ1dGUgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oYW5ndWxhci5TY29wZVssIGNsb25lQXR0YWNoRm5dfSB0cmFuc2NsdWRlRm4gQSBsaW5raW5nIGZ1bmN0aW9uLCB3aGVyZSB0aGVcclxuICAgICAqICAgICAgICBzY29wZSBhcmd1bWVudCBpcyBhdXRvLWdlbmVyYXRlZCB0byB0aGUgbmV3IGNoaWxkIG9mIHRoZSB0cmFuc2NsdWRlZCBwYXJlbnQgc2NvcGUuXHJcbiAgICAgKiBAcGFyYW0ge0pRTGl0ZX0ganFDb2xsZWN0aW9uIElmIHdlIGFyZSB3b3JraW5nIG9uIHRoZSByb290IG9mIHRoZSBjb21waWxlIHRyZWUgdGhlbiB0aGlzXHJcbiAgICAgKiAgICAgICAgYXJndW1lbnQgaGFzIHRoZSByb290IGpxTGl0ZSBhcnJheSBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIG5vZGVzIG9uIGl0LlxyXG4gICAgICogQHJldHVybnMgbGlua0ZuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFwcGx5RGlyZWN0aXZlc1RvTm9kZShkaXJlY3RpdmVzLCBjb21waWxlTm9kZSwgdGVtcGxhdGVBdHRycywgdHJhbnNjbHVkZUZuLCBqcUNvbGxlY3Rpb24sIG9yaWdpbmFsUmVwbGFjZURpcmVjdGl2ZSkge1xyXG4gICAgICB2YXIgdGVybWluYWxQcmlvcml0eSA9IC1OdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgcHJlTGlua0ZucyA9IFtdLFxyXG4gICAgICAgICAgcG9zdExpbmtGbnMgPSBbXSxcclxuICAgICAgICAgIG5ld1Njb3BlRGlyZWN0aXZlID0gbnVsbCxcclxuICAgICAgICAgIG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSA9IG51bGwsXHJcbiAgICAgICAgICB0ZW1wbGF0ZURpcmVjdGl2ZSA9IG51bGwsXHJcbiAgICAgICAgICAkY29tcGlsZU5vZGUgPSB0ZW1wbGF0ZUF0dHJzLiQkZWxlbWVudCA9IGpxTGl0ZShjb21waWxlTm9kZSksXHJcbiAgICAgICAgICBkaXJlY3RpdmUsXHJcbiAgICAgICAgICBkaXJlY3RpdmVOYW1lLFxyXG4gICAgICAgICAgJHRlbXBsYXRlLFxyXG4gICAgICAgICAgdHJhbnNjbHVkZURpcmVjdGl2ZSxcclxuICAgICAgICAgIHJlcGxhY2VEaXJlY3RpdmUgPSBvcmlnaW5hbFJlcGxhY2VEaXJlY3RpdmUsXHJcbiAgICAgICAgICBjaGlsZFRyYW5zY2x1ZGVGbiA9IHRyYW5zY2x1ZGVGbixcclxuICAgICAgICAgIGNvbnRyb2xsZXJEaXJlY3RpdmVzLFxyXG4gICAgICAgICAgbGlua0ZuLFxyXG4gICAgICAgICAgZGlyZWN0aXZlVmFsdWU7XHJcblxyXG4gICAgICAvLyBleGVjdXRlcyBhbGwgZGlyZWN0aXZlcyBvbiB0aGUgY3VycmVudCBlbGVtZW50XHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIGlpID0gZGlyZWN0aXZlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgZGlyZWN0aXZlID0gZGlyZWN0aXZlc1tpXTtcclxuICAgICAgICB2YXIgYXR0clN0YXJ0ID0gZGlyZWN0aXZlLiQkc3RhcnQ7XHJcbiAgICAgICAgdmFyIGF0dHJFbmQgPSBkaXJlY3RpdmUuJCRlbmQ7XHJcblxyXG4gICAgICAgIC8vIGNvbGxlY3QgbXVsdGlibG9jayBzZWN0aW9uc1xyXG4gICAgICAgIGlmIChhdHRyU3RhcnQpIHtcclxuICAgICAgICAgICRjb21waWxlTm9kZSA9IGdyb3VwU2Nhbihjb21waWxlTm9kZSwgYXR0clN0YXJ0LCBhdHRyRW5kKVxyXG4gICAgICAgIH1cclxuICAgICAgICAkdGVtcGxhdGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICh0ZXJtaW5hbFByaW9yaXR5ID4gZGlyZWN0aXZlLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICBicmVhazsgLy8gcHJldmVudCBmdXJ0aGVyIHByb2Nlc3Npbmcgb2YgZGlyZWN0aXZlc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVZhbHVlID0gZGlyZWN0aXZlLnNjb3BlKSB7XHJcbiAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZSgnaXNvbGF0ZWQgc2NvcGUnLCBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUsIGRpcmVjdGl2ZSwgJGNvbXBpbGVOb2RlKTtcclxuICAgICAgICAgIGlmIChpc09iamVjdChkaXJlY3RpdmVWYWx1ZSkpIHtcclxuICAgICAgICAgICAgc2FmZUFkZENsYXNzKCRjb21waWxlTm9kZSwgJ25nLWlzb2xhdGUtc2NvcGUnKTtcclxuICAgICAgICAgICAgbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2FmZUFkZENsYXNzKCRjb21waWxlTm9kZSwgJ25nLXNjb3BlJyk7XHJcbiAgICAgICAgICBuZXdTY29wZURpcmVjdGl2ZSA9IG5ld1Njb3BlRGlyZWN0aXZlIHx8IGRpcmVjdGl2ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVZhbHVlID0gZGlyZWN0aXZlLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgIGNvbnRyb2xsZXJEaXJlY3RpdmVzID0gY29udHJvbGxlckRpcmVjdGl2ZXMgfHwge307XHJcbiAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZShcIidcIiArIGRpcmVjdGl2ZU5hbWUgKyBcIicgY29udHJvbGxlclwiLFxyXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJEaXJlY3RpdmVzW2RpcmVjdGl2ZU5hbWVdLCBkaXJlY3RpdmUsICRjb21waWxlTm9kZSk7XHJcbiAgICAgICAgICBjb250cm9sbGVyRGlyZWN0aXZlc1tkaXJlY3RpdmVOYW1lXSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVWYWx1ZSA9IGRpcmVjdGl2ZS50cmFuc2NsdWRlKSB7XHJcbiAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZSgndHJhbnNjbHVzaW9uJywgdHJhbnNjbHVkZURpcmVjdGl2ZSwgZGlyZWN0aXZlLCAkY29tcGlsZU5vZGUpO1xyXG4gICAgICAgICAgdHJhbnNjbHVkZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgIHRlcm1pbmFsUHJpb3JpdHkgPSBkaXJlY3RpdmUucHJpb3JpdHk7XHJcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlVmFsdWUgPT0gJ2VsZW1lbnQnKSB7XHJcbiAgICAgICAgICAgICR0ZW1wbGF0ZSA9IGdyb3VwU2Nhbihjb21waWxlTm9kZSwgYXR0clN0YXJ0LCBhdHRyRW5kKVxyXG4gICAgICAgICAgICAkY29tcGlsZU5vZGUgPSB0ZW1wbGF0ZUF0dHJzLiQkZWxlbWVudCA9XHJcbiAgICAgICAgICAgICAgICBqcUxpdGUoZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnICcgKyBkaXJlY3RpdmVOYW1lICsgJzogJyArIHRlbXBsYXRlQXR0cnNbZGlyZWN0aXZlTmFtZV0gKyAnICcpKTtcclxuICAgICAgICAgICAgY29tcGlsZU5vZGUgPSAkY29tcGlsZU5vZGVbMF07XHJcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoKGpxQ29sbGVjdGlvbiwganFMaXRlKHNsaWNlQXJncygkdGVtcGxhdGUpKSwgY29tcGlsZU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgY2hpbGRUcmFuc2NsdWRlRm4gPSBjb21waWxlKCR0ZW1wbGF0ZSwgdHJhbnNjbHVkZUZuLCB0ZXJtaW5hbFByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZURpcmVjdGl2ZSAmJiByZXBsYWNlRGlyZWN0aXZlLm5hbWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJHRlbXBsYXRlID0ganFMaXRlKEpRTGl0ZUNsb25lKGNvbXBpbGVOb2RlKSkuY29udGVudHMoKTtcclxuICAgICAgICAgICAgJGNvbXBpbGVOb2RlLmh0bWwoJycpOyAvLyBjbGVhciBjb250ZW50c1xyXG4gICAgICAgICAgICBjaGlsZFRyYW5zY2x1ZGVGbiA9IGNvbXBpbGUoJHRlbXBsYXRlLCB0cmFuc2NsdWRlRm4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZS50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgYXNzZXJ0Tm9EdXBsaWNhdGUoJ3RlbXBsYXRlJywgdGVtcGxhdGVEaXJlY3RpdmUsIGRpcmVjdGl2ZSwgJGNvbXBpbGVOb2RlKTtcclxuICAgICAgICAgIHRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG5cclxuICAgICAgICAgIGRpcmVjdGl2ZVZhbHVlID0gKGlzRnVuY3Rpb24oZGlyZWN0aXZlLnRlbXBsYXRlKSlcclxuICAgICAgICAgICAgICA/IGRpcmVjdGl2ZS50ZW1wbGF0ZSgkY29tcGlsZU5vZGUsIHRlbXBsYXRlQXR0cnMpXHJcbiAgICAgICAgICAgICAgOiBkaXJlY3RpdmUudGVtcGxhdGU7XHJcblxyXG4gICAgICAgICAgZGlyZWN0aXZlVmFsdWUgPSBkZW5vcm1hbGl6ZVRlbXBsYXRlKGRpcmVjdGl2ZVZhbHVlKTtcclxuXHJcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgcmVwbGFjZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgICAgJHRlbXBsYXRlID0ganFMaXRlKCc8ZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmltKGRpcmVjdGl2ZVZhbHVlKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JykuY29udGVudHMoKTtcclxuICAgICAgICAgICAgY29tcGlsZU5vZGUgPSAkdGVtcGxhdGVbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoJHRlbXBsYXRlLmxlbmd0aCAhPSAxIHx8IGNvbXBpbGVOb2RlLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ3RwbHJ0JywgXCJUZW1wbGF0ZSBmb3IgZGlyZWN0aXZlICd7MH0nIG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIHsxfVwiLCBkaXJlY3RpdmVOYW1lLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoKGpxQ29sbGVjdGlvbiwgJGNvbXBpbGVOb2RlLCBjb21waWxlTm9kZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV3VGVtcGxhdGVBdHRycyA9IHskYXR0cjoge319O1xyXG5cclxuICAgICAgICAgICAgLy8gY29tYmluZSBkaXJlY3RpdmVzIGZyb20gdGhlIG9yaWdpbmFsIG5vZGUgYW5kIGZyb20gdGhlIHRlbXBsYXRlOlxyXG4gICAgICAgICAgICAvLyAtIHRha2UgdGhlIGFycmF5IG9mIGRpcmVjdGl2ZXMgZm9yIHRoaXMgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyAtIHNwbGl0IGl0IGludG8gdHdvIHBhcnRzLCB0aG9zZSB0aGF0IHdlcmUgYWxyZWFkeSBhcHBsaWVkIGFuZCB0aG9zZSB0aGF0IHdlcmVuJ3RcclxuICAgICAgICAgICAgLy8gLSBjb2xsZWN0IGRpcmVjdGl2ZXMgZnJvbSB0aGUgdGVtcGxhdGUsIGFkZCB0aGVtIHRvIHRoZSBzZWNvbmQgZ3JvdXAgYW5kIHNvcnQgdGhlbVxyXG4gICAgICAgICAgICAvLyAtIGFwcGVuZCB0aGUgc2Vjb25kIGdyb3VwIHdpdGggbmV3IGRpcmVjdGl2ZXMgdG8gdGhlIGZpcnN0IGdyb3VwXHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzLmNvbmNhdChcclxuICAgICAgICAgICAgICAgIGNvbGxlY3REaXJlY3RpdmVzKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVOb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMuc3BsaWNlKGkgKyAxLCBkaXJlY3RpdmVzLmxlbmd0aCAtIChpICsgMSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1RlbXBsYXRlQXR0cnNcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbWVyZ2VUZW1wbGF0ZUF0dHJpYnV0ZXModGVtcGxhdGVBdHRycywgbmV3VGVtcGxhdGVBdHRycyk7XHJcblxyXG4gICAgICAgICAgICBpaSA9IGRpcmVjdGl2ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJGNvbXBpbGVOb2RlLmh0bWwoZGlyZWN0aXZlVmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZS50ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgYXNzZXJ0Tm9EdXBsaWNhdGUoJ3RlbXBsYXRlJywgdGVtcGxhdGVEaXJlY3RpdmUsIGRpcmVjdGl2ZSwgJGNvbXBpbGVOb2RlKTtcclxuICAgICAgICAgIHRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG5cclxuICAgICAgICAgIGlmIChkaXJlY3RpdmUucmVwbGFjZSkge1xyXG4gICAgICAgICAgICByZXBsYWNlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbm9kZUxpbmtGbiA9IGNvbXBpbGVUZW1wbGF0ZVVybChkaXJlY3RpdmVzLnNwbGljZShpLCBkaXJlY3RpdmVzLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICAgIG5vZGVMaW5rRm4sICRjb21waWxlTm9kZSwgdGVtcGxhdGVBdHRycywganFDb2xsZWN0aW9uLCBjaGlsZFRyYW5zY2x1ZGVGbik7XHJcbiAgICAgICAgICBpaSA9IGRpcmVjdGl2ZXMubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aXZlLmNvbXBpbGUpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxpbmtGbiA9IGRpcmVjdGl2ZS5jb21waWxlKCRjb21waWxlTm9kZSwgdGVtcGxhdGVBdHRycywgY2hpbGRUcmFuc2NsdWRlRm4pO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihsaW5rRm4pKSB7XHJcbiAgICAgICAgICAgICAgYWRkTGlua0ZucyhudWxsLCBsaW5rRm4sIGF0dHJTdGFydCwgYXR0ckVuZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlua0ZuKSB7XHJcbiAgICAgICAgICAgICAgYWRkTGlua0ZucyhsaW5rRm4ucHJlLCBsaW5rRm4ucG9zdCwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlLCBzdGFydGluZ1RhZygkY29tcGlsZU5vZGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3RpdmUudGVybWluYWwpIHtcclxuICAgICAgICAgIG5vZGVMaW5rRm4udGVybWluYWwgPSB0cnVlO1xyXG4gICAgICAgICAgdGVybWluYWxQcmlvcml0eSA9IE1hdGgubWF4KHRlcm1pbmFsUHJpb3JpdHksIGRpcmVjdGl2ZS5wcmlvcml0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgbm9kZUxpbmtGbi5zY29wZSA9IG5ld1Njb3BlRGlyZWN0aXZlICYmIG5ld1Njb3BlRGlyZWN0aXZlLnNjb3BlO1xyXG4gICAgICBub2RlTGlua0ZuLnRyYW5zY2x1ZGUgPSB0cmFuc2NsdWRlRGlyZWN0aXZlICYmIGNoaWxkVHJhbnNjbHVkZUZuO1xyXG5cclxuICAgICAgLy8gbWlnaHQgYmUgbm9ybWFsIG9yIGRlbGF5ZWQgbm9kZUxpbmtGbiBkZXBlbmRpbmcgb24gaWYgdGVtcGxhdGVVcmwgaXMgcHJlc2VudFxyXG4gICAgICByZXR1cm4gbm9kZUxpbmtGbjtcclxuXHJcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gICAgICBmdW5jdGlvbiBhZGRMaW5rRm5zKHByZSwgcG9zdCwgYXR0clN0YXJ0LCBhdHRyRW5kKSB7XHJcbiAgICAgICAgaWYgKHByZSkge1xyXG4gICAgICAgICAgaWYgKGF0dHJTdGFydCkgcHJlID0gZ3JvdXBFbGVtZW50c0xpbmtGbldyYXBwZXIocHJlLCBhdHRyU3RhcnQsIGF0dHJFbmQpO1xyXG4gICAgICAgICAgcHJlLnJlcXVpcmUgPSBkaXJlY3RpdmUucmVxdWlyZTtcclxuICAgICAgICAgIHByZUxpbmtGbnMucHVzaChwcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zdCkge1xyXG4gICAgICAgICAgaWYgKGF0dHJTdGFydCkgcG9zdCA9IGdyb3VwRWxlbWVudHNMaW5rRm5XcmFwcGVyKHBvc3QsIGF0dHJTdGFydCwgYXR0ckVuZCk7XHJcbiAgICAgICAgICBwb3N0LnJlcXVpcmUgPSBkaXJlY3RpdmUucmVxdWlyZTtcclxuICAgICAgICAgIHBvc3RMaW5rRm5zLnB1c2gocG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0Q29udHJvbGxlcnMocmVxdWlyZSwgJGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgdmFsdWUsIHJldHJpZXZhbE1ldGhvZCA9ICdkYXRhJywgb3B0aW9uYWwgPSBmYWxzZTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcocmVxdWlyZSkpIHtcclxuICAgICAgICAgIHdoaWxlKCh2YWx1ZSA9IHJlcXVpcmUuY2hhckF0KDApKSA9PSAnXicgfHwgdmFsdWUgPT0gJz8nKSB7XHJcbiAgICAgICAgICAgIHJlcXVpcmUgPSByZXF1aXJlLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09ICdeJykge1xyXG4gICAgICAgICAgICAgIHJldHJpZXZhbE1ldGhvZCA9ICdpbmhlcml0ZWREYXRhJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25hbCA9IG9wdGlvbmFsIHx8IHZhbHVlID09ICc/JztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhbHVlID0gJGVsZW1lbnRbcmV0cmlldmFsTWV0aG9kXSgnJCcgKyByZXF1aXJlICsgJ0NvbnRyb2xsZXInKTtcclxuICAgICAgICAgIGlmICghdmFsdWUgJiYgIW9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCdjdHJlcScsIFwiQ29udHJvbGxlciAnezB9JywgcmVxdWlyZWQgYnkgZGlyZWN0aXZlICd7MX0nLCBjYW4ndCBiZSBmb3VuZCFcIiwgcmVxdWlyZSwgZGlyZWN0aXZlTmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlcXVpcmUpKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgZm9yRWFjaChyZXF1aXJlLCBmdW5jdGlvbihyZXF1aXJlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZ2V0Q29udHJvbGxlcnMocmVxdWlyZSwgJGVsZW1lbnQpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBub2RlTGlua0ZuKGNoaWxkTGlua0ZuLCBzY29wZSwgbGlua05vZGUsICRyb290RWxlbWVudCwgYm91bmRUcmFuc2NsdWRlRm4pIHtcclxuICAgICAgICB2YXIgYXR0cnMsICRlbGVtZW50LCBpLCBpaSwgbGlua0ZuLCBjb250cm9sbGVyO1xyXG5cclxuICAgICAgICBpZiAoY29tcGlsZU5vZGUgPT09IGxpbmtOb2RlKSB7XHJcbiAgICAgICAgICBhdHRycyA9IHRlbXBsYXRlQXR0cnM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGF0dHJzID0gc2hhbGxvd0NvcHkodGVtcGxhdGVBdHRycywgbmV3IEF0dHJpYnV0ZXMoanFMaXRlKGxpbmtOb2RlKSwgdGVtcGxhdGVBdHRycy4kYXR0cikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkZWxlbWVudCA9IGF0dHJzLiQkZWxlbWVudDtcclxuXHJcbiAgICAgICAgaWYgKG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgdmFyIExPQ0FMX1JFR0VYUCA9IC9eXFxzKihbQD0mXSkoXFw/PylcXHMqKFxcdyopXFxzKiQvO1xyXG5cclxuICAgICAgICAgIHZhciBwYXJlbnRTY29wZSA9IHNjb3BlLiRwYXJlbnQgfHwgc2NvcGU7XHJcblxyXG4gICAgICAgICAgZm9yRWFjaChuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUuc2NvcGUsIGZ1bmN0aW9uKGRlZmluaXRpb24sIHNjb3BlTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBkZWZpbml0aW9uLm1hdGNoKExPQ0FMX1JFR0VYUCkgfHwgW10sXHJcbiAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IG1hdGNoWzNdIHx8IHNjb3BlTmFtZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0gKG1hdGNoWzJdID09ICc/JyksXHJcbiAgICAgICAgICAgICAgICBtb2RlID0gbWF0Y2hbMV0sIC8vIEAsID0sIG9yICZcclxuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSxcclxuICAgICAgICAgICAgICAgIHBhcmVudEdldCwgcGFyZW50U2V0O1xyXG5cclxuICAgICAgICAgICAgc2NvcGUuJCRpc29sYXRlQmluZGluZ3Nbc2NvcGVOYW1lXSA9IG1vZGUgKyBhdHRyTmFtZTtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG5cclxuICAgICAgICAgICAgICBjYXNlICdAJzoge1xyXG4gICAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoYXR0ck5hbWUsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHNjb3BlW3Njb3BlTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXR0cnMuJCRvYnNlcnZlcnNbYXR0ck5hbWVdLiQkc2NvcGUgPSBwYXJlbnRTY29wZTtcclxuICAgICAgICAgICAgICAgIGlmKCBhdHRyc1thdHRyTmFtZV0gKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUgaGFzIGJlZW4gcHJvdmlkZWQgdGhlbiB3ZSB0cmlnZ2VyIGFuIGludGVycG9sYXRpb24gdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyB0aGVyZSBmb3IgdXNlIGluIHRoZSBsaW5rIGZuXHJcbiAgICAgICAgICAgICAgICAgIHNjb3BlW3Njb3BlTmFtZV0gPSAkaW50ZXJwb2xhdGUoYXR0cnNbYXR0ck5hbWVdKShwYXJlbnRTY29wZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGNhc2UgJz0nOiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwgJiYgIWF0dHJzW2F0dHJOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRHZXQgPSAkcGFyc2UoYXR0cnNbYXR0ck5hbWVdKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudFNldCA9IHBhcmVudEdldC5hc3NpZ24gfHwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBjaGFuZ2UsIG9yIHdlIHdpbGwgdGhyb3cgdGhpcyBleGNlcHRpb24gb24gZXZlcnkgJGRpZ2VzdFxyXG4gICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBzY29wZVtzY29wZU5hbWVdID0gcGFyZW50R2V0KHBhcmVudFNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ25vbmFzc2lnbicsIFwiRXhwcmVzc2lvbiAnezB9JyB1c2VkIHdpdGggZGlyZWN0aXZlICd7MX0nIGlzIG5vbi1hc3NpZ25hYmxlIVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnNbYXR0ck5hbWVdLCBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gc2NvcGVbc2NvcGVOYW1lXSA9IHBhcmVudEdldChwYXJlbnRTY29wZSk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gcGFyZW50VmFsdWVXYXRjaCgpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFZhbHVlID0gcGFyZW50R2V0KHBhcmVudFNjb3BlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRWYWx1ZSAhPT0gc2NvcGVbc2NvcGVOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBvdXQgb2Ygc3luYyBhbmQgbmVlZCB0byBjb3B5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBjaGFuZ2VkIGFuZCBpdCBoYXMgcHJlY2VkZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gc2NvcGVbc2NvcGVOYW1lXSA9IHBhcmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGNhbiBiZSBhc3NpZ25lZCB0aGVuIGRvIHNvXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRTZXQocGFyZW50U2NvcGUsIHBhcmVudFZhbHVlID0gbGFzdFZhbHVlID0gc2NvcGVbc2NvcGVOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBjYXNlICcmJzoge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50R2V0ID0gJHBhcnNlKGF0dHJzW2F0dHJOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICBzY29wZVtzY29wZU5hbWVdID0gZnVuY3Rpb24obG9jYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRHZXQocGFyZW50U2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycignaXNjcCcsIFwiSW52YWxpZCBpc29sYXRlIHNjb3BlIGRlZmluaXRpb24gZm9yIGRpcmVjdGl2ZSAnezB9Jy4gRGVmaW5pdGlvbjogey4uLiB7MX06ICd7Mn0nIC4uLn1cIixcclxuICAgICAgICAgICAgICAgICAgICBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUubmFtZSwgc2NvcGVOYW1lLCBkZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJEaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICBmb3JFYWNoKGNvbnRyb2xsZXJEaXJlY3RpdmVzLCBmdW5jdGlvbihkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FscyA9IHtcclxuICAgICAgICAgICAgICAkc2NvcGU6IHNjb3BlLFxyXG4gICAgICAgICAgICAgICRlbGVtZW50OiAkZWxlbWVudCxcclxuICAgICAgICAgICAgICAkYXR0cnM6IGF0dHJzLFxyXG4gICAgICAgICAgICAgICR0cmFuc2NsdWRlOiBib3VuZFRyYW5zY2x1ZGVGblxyXG4gICAgICAgICAgICB9LCBjb250cm9sbGVySW5zdGFuY2U7XHJcblxyXG4gICAgICAgICAgICBjb250cm9sbGVyID0gZGlyZWN0aXZlLmNvbnRyb2xsZXI7XHJcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyID09ICdAJykge1xyXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBhdHRyc1tkaXJlY3RpdmUubmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXJJbnN0YW5jZSA9ICRjb250cm9sbGVyKGNvbnRyb2xsZXIsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgICRlbGVtZW50LmRhdGEoXHJcbiAgICAgICAgICAgICAgICAnJCcgKyBkaXJlY3RpdmUubmFtZSArICdDb250cm9sbGVyJyxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuY29udHJvbGxlckFzKSB7XHJcbiAgICAgICAgICAgICAgbG9jYWxzLiRzY29wZVtkaXJlY3RpdmUuY29udHJvbGxlckFzXSA9IGNvbnRyb2xsZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQUkVMSU5LSU5HXHJcbiAgICAgICAgZm9yKGkgPSAwLCBpaSA9IHByZUxpbmtGbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGlua0ZuID0gcHJlTGlua0Zuc1tpXTtcclxuICAgICAgICAgICAgbGlua0ZuKHNjb3BlLCAkZWxlbWVudCwgYXR0cnMsXHJcbiAgICAgICAgICAgICAgICBsaW5rRm4ucmVxdWlyZSAmJiBnZXRDb250cm9sbGVycyhsaW5rRm4ucmVxdWlyZSwgJGVsZW1lbnQpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSwgc3RhcnRpbmdUYWcoJGVsZW1lbnQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJFQ1VSU0lPTlxyXG4gICAgICAgIGNoaWxkTGlua0ZuICYmIGNoaWxkTGlua0ZuKHNjb3BlLCBsaW5rTm9kZS5jaGlsZE5vZGVzLCB1bmRlZmluZWQsIGJvdW5kVHJhbnNjbHVkZUZuKTtcclxuXHJcbiAgICAgICAgLy8gUE9TVExJTktJTkdcclxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gcG9zdExpbmtGbnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGlua0ZuID0gcG9zdExpbmtGbnNbaV07XHJcbiAgICAgICAgICAgIGxpbmtGbihzY29wZSwgJGVsZW1lbnQsIGF0dHJzLFxyXG4gICAgICAgICAgICAgICAgbGlua0ZuLnJlcXVpcmUgJiYgZ2V0Q29udHJvbGxlcnMobGlua0ZuLnJlcXVpcmUsICRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUsIHN0YXJ0aW5nVGFnKCRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogbG9va3MgdXAgdGhlIGRpcmVjdGl2ZSBhbmQgZGVjb3JhdGVzIGl0IHdpdGggZXhjZXB0aW9uIGhhbmRsaW5nIGFuZCBwcm9wZXIgcGFyYW1ldGVycy4gV2VcclxuICAgICAqIGNhbGwgdGhpcyB0aGUgYm91bmREaXJlY3RpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgZGlyZWN0aXZlIHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gVGhlIGRpcmVjdGl2ZSBtdXN0IGJlIGZvdW5kIGluIHNwZWNpZmljIGZvcm1hdC5cclxuICAgICAqICAgU3RyaW5nIGNvbnRhaW5pbmcgYW55IG9mIHRoZXNlcyBjaGFyYWN0ZXJzOlxyXG4gICAgICpcclxuICAgICAqICAgKiBgRWA6IGVsZW1lbnQgbmFtZVxyXG4gICAgICogICAqIGBBJzogYXR0cmlidXRlXHJcbiAgICAgKiAgICogYENgOiBjbGFzc1xyXG4gICAgICogICAqIGBNYDogY29tbWVudFxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBkaXJlY3RpdmUgd2FzIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGREaXJlY3RpdmUodERpcmVjdGl2ZXMsIG5hbWUsIGxvY2F0aW9uLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlLCBzdGFydEF0dHJOYW1lLCBlbmRBdHRyTmFtZSkge1xyXG4gICAgICBpZiAobmFtZSA9PT0gaWdub3JlRGlyZWN0aXZlKSByZXR1cm4gbnVsbDtcclxuICAgICAgdmFyIG1hdGNoID0gbnVsbDtcclxuICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICBmb3IodmFyIGRpcmVjdGl2ZSwgZGlyZWN0aXZlcyA9ICRpbmplY3Rvci5nZXQobmFtZSArIFN1ZmZpeCksXHJcbiAgICAgICAgICAgIGkgPSAwLCBpaSA9IGRpcmVjdGl2ZXMubGVuZ3RoOyBpPGlpOyBpKyspIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IGRpcmVjdGl2ZXNbaV07XHJcbiAgICAgICAgICAgIGlmICggKG1heFByaW9yaXR5ID09PSB1bmRlZmluZWQgfHwgbWF4UHJpb3JpdHkgPiBkaXJlY3RpdmUucHJpb3JpdHkpICYmXHJcbiAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLnJlc3RyaWN0LmluZGV4T2YobG9jYXRpb24pICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0QXR0ck5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZSA9IGluaGVyaXQoZGlyZWN0aXZlLCB7JCRzdGFydDogc3RhcnRBdHRyTmFtZSwgJCRlbmQ6IGVuZEF0dHJOYW1lfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHREaXJlY3RpdmVzLnB1c2goZGlyZWN0aXZlKTtcclxuICAgICAgICAgICAgICBtYXRjaCA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaChlKSB7ICRleGNlcHRpb25IYW5kbGVyKGUpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRoZSBlbGVtZW50IGlzIHJlcGxhY2VkIHdpdGggSFRNTCB0ZW1wbGF0ZSB0aGVuIHRoZSBuZXcgYXR0cmlidXRlc1xyXG4gICAgICogb24gdGhlIHRlbXBsYXRlIG5lZWQgdG8gYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIERPTS5cclxuICAgICAqIFRoZSBkZXNpcmVkIGVmZmVjdCBpcyB0byBoYXZlIGJvdGggb2YgdGhlIGF0dHJpYnV0ZXMgcHJlc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZHN0IGRlc3RpbmF0aW9uIGF0dHJpYnV0ZXMgKG9yaWdpbmFsIERPTSlcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzcmMgc291cmNlIGF0dHJpYnV0ZXMgKGZyb20gdGhlIGRpcmVjdGl2ZSB0ZW1wbGF0ZSlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWVyZ2VUZW1wbGF0ZUF0dHJpYnV0ZXMoZHN0LCBzcmMpIHtcclxuICAgICAgdmFyIHNyY0F0dHIgPSBzcmMuJGF0dHIsXHJcbiAgICAgICAgICBkc3RBdHRyID0gZHN0LiRhdHRyLFxyXG4gICAgICAgICAgJGVsZW1lbnQgPSBkc3QuJCRlbGVtZW50O1xyXG5cclxuICAgICAgLy8gcmVhcHBseSB0aGUgb2xkIGF0dHJpYnV0ZXMgdG8gdGhlIG5ldyBlbGVtZW50XHJcbiAgICAgIGZvckVhY2goZHN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgIT0gJyQnKSB7XHJcbiAgICAgICAgICBpZiAoc3JjW2tleV0pIHtcclxuICAgICAgICAgICAgdmFsdWUgKz0gKGtleSA9PT0gJ3N0eWxlJyA/ICc7JyA6ICcgJykgKyBzcmNba2V5XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRzdC4kc2V0KGtleSwgdmFsdWUsIHRydWUsIHNyY0F0dHJba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIGNvcHkgdGhlIG5ldyBhdHRyaWJ1dGVzIG9uIHRoZSBvbGQgYXR0cnMgb2JqZWN0XHJcbiAgICAgIGZvckVhY2goc3JjLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICBzYWZlQWRkQ2xhc3MoJGVsZW1lbnQsIHZhbHVlKTtcclxuICAgICAgICAgIGRzdFsnY2xhc3MnXSA9IChkc3RbJ2NsYXNzJ10gPyBkc3RbJ2NsYXNzJ10gKyAnICcgOiAnJykgKyB2YWx1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgICAkZWxlbWVudC5hdHRyKCdzdHlsZScsICRlbGVtZW50LmF0dHIoJ3N0eWxlJykgKyAnOycgKyB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChrZXkuY2hhckF0KDApICE9ICckJyAmJiAhZHN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgIGRzdFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICBkc3RBdHRyW2tleV0gPSBzcmNBdHRyW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGlsZVRlbXBsYXRlVXJsKGRpcmVjdGl2ZXMsIGJlZm9yZVRlbXBsYXRlTm9kZUxpbmtGbiwgJGNvbXBpbGVOb2RlLCB0QXR0cnMsXHJcbiAgICAgICAgJHJvb3RFbGVtZW50LCBjaGlsZFRyYW5zY2x1ZGVGbikge1xyXG4gICAgICB2YXIgbGlua1F1ZXVlID0gW10sXHJcbiAgICAgICAgICBhZnRlclRlbXBsYXRlTm9kZUxpbmtGbixcclxuICAgICAgICAgIGFmdGVyVGVtcGxhdGVDaGlsZExpbmtGbixcclxuICAgICAgICAgIGJlZm9yZVRlbXBsYXRlQ29tcGlsZU5vZGUgPSAkY29tcGlsZU5vZGVbMF0sXHJcbiAgICAgICAgICBvcmlnQXN5bmNEaXJlY3RpdmUgPSBkaXJlY3RpdmVzLnNoaWZ0KCksXHJcbiAgICAgICAgICAvLyBUaGUgZmFjdCB0aGF0IHdlIGhhdmUgdG8gY29weSBhbmQgcGF0Y2ggdGhlIGRpcmVjdGl2ZSBzZWVtcyB3cm9uZyFcclxuICAgICAgICAgIGRlcml2ZWRTeW5jRGlyZWN0aXZlID0gZXh0ZW5kKHt9LCBvcmlnQXN5bmNEaXJlY3RpdmUsIHtcclxuICAgICAgICAgICAgY29udHJvbGxlcjogbnVsbCwgdGVtcGxhdGVVcmw6IG51bGwsIHRyYW5zY2x1ZGU6IG51bGwsIHNjb3BlOiBudWxsLCByZXBsYWNlOiBudWxsXHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIHRlbXBsYXRlVXJsID0gKGlzRnVuY3Rpb24ob3JpZ0FzeW5jRGlyZWN0aXZlLnRlbXBsYXRlVXJsKSlcclxuICAgICAgICAgICAgICA/IG9yaWdBc3luY0RpcmVjdGl2ZS50ZW1wbGF0ZVVybCgkY29tcGlsZU5vZGUsIHRBdHRycylcclxuICAgICAgICAgICAgICA6IG9yaWdBc3luY0RpcmVjdGl2ZS50ZW1wbGF0ZVVybDtcclxuXHJcbiAgICAgICRjb21waWxlTm9kZS5odG1sKCcnKTtcclxuXHJcbiAgICAgICRodHRwLmdldCgkc2NlLmdldFRydXN0ZWRSZXNvdXJjZVVybCh0ZW1wbGF0ZVVybCksIHtjYWNoZTogJHRlbXBsYXRlQ2FjaGV9KS5cclxuICAgICAgICBzdWNjZXNzKGZ1bmN0aW9uKGNvbnRlbnQpIHtcclxuICAgICAgICAgIHZhciBjb21waWxlTm9kZSwgdGVtcFRlbXBsYXRlQXR0cnMsICR0ZW1wbGF0ZTtcclxuXHJcbiAgICAgICAgICBjb250ZW50ID0gZGVub3JtYWxpemVUZW1wbGF0ZShjb250ZW50KTtcclxuXHJcbiAgICAgICAgICBpZiAob3JpZ0FzeW5jRGlyZWN0aXZlLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgJHRlbXBsYXRlID0ganFMaXRlKCc8ZGl2PicgKyB0cmltKGNvbnRlbnQpICsgJzwvZGl2PicpLmNvbnRlbnRzKCk7XHJcbiAgICAgICAgICAgIGNvbXBpbGVOb2RlID0gJHRlbXBsYXRlWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCR0ZW1wbGF0ZS5sZW5ndGggIT0gMSB8fCBjb21waWxlTm9kZS5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCd0cGxydCcsIFwiVGVtcGxhdGUgZm9yIGRpcmVjdGl2ZSAnezB9JyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiB7MX1cIixcclxuICAgICAgICAgICAgICAgICAgb3JpZ0FzeW5jRGlyZWN0aXZlLm5hbWUsIHRlbXBsYXRlVXJsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGVtcFRlbXBsYXRlQXR0cnMgPSB7JGF0dHI6IHt9fTtcclxuICAgICAgICAgICAgcmVwbGFjZVdpdGgoJHJvb3RFbGVtZW50LCAkY29tcGlsZU5vZGUsIGNvbXBpbGVOb2RlKTtcclxuICAgICAgICAgICAgY29sbGVjdERpcmVjdGl2ZXMoY29tcGlsZU5vZGUsIGRpcmVjdGl2ZXMsIHRlbXBUZW1wbGF0ZUF0dHJzKTtcclxuICAgICAgICAgICAgbWVyZ2VUZW1wbGF0ZUF0dHJpYnV0ZXModEF0dHJzLCB0ZW1wVGVtcGxhdGVBdHRycyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb21waWxlTm9kZSA9IGJlZm9yZVRlbXBsYXRlQ29tcGlsZU5vZGU7XHJcbiAgICAgICAgICAgICRjb21waWxlTm9kZS5odG1sKGNvbnRlbnQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRpcmVjdGl2ZXMudW5zaGlmdChkZXJpdmVkU3luY0RpcmVjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgYWZ0ZXJUZW1wbGF0ZU5vZGVMaW5rRm4gPSBhcHBseURpcmVjdGl2ZXNUb05vZGUoZGlyZWN0aXZlcywgY29tcGlsZU5vZGUsIHRBdHRycywgY2hpbGRUcmFuc2NsdWRlRm4sICRjb21waWxlTm9kZSwgb3JpZ0FzeW5jRGlyZWN0aXZlKTtcclxuICAgICAgICAgIGZvckVhY2goJHJvb3RFbGVtZW50LCBmdW5jdGlvbihub2RlLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09IGNvbXBpbGVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgJHJvb3RFbGVtZW50W2ldID0gJGNvbXBpbGVOb2RlWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGFmdGVyVGVtcGxhdGVDaGlsZExpbmtGbiA9IGNvbXBpbGVOb2RlcygkY29tcGlsZU5vZGVbMF0uY2hpbGROb2RlcywgY2hpbGRUcmFuc2NsdWRlRm4pO1xyXG5cclxuXHJcbiAgICAgICAgICB3aGlsZShsaW5rUXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IGxpbmtRdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgYmVmb3JlVGVtcGxhdGVMaW5rTm9kZSA9IGxpbmtRdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgbGlua1Jvb3RFbGVtZW50ID0gbGlua1F1ZXVlLnNoaWZ0KCksXHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gbGlua1F1ZXVlLnNoaWZ0KCksXHJcbiAgICAgICAgICAgICAgICBsaW5rTm9kZSA9ICRjb21waWxlTm9kZVswXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiZWZvcmVUZW1wbGF0ZUxpbmtOb2RlICE9PSBiZWZvcmVUZW1wbGF0ZUNvbXBpbGVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgLy8gaXQgd2FzIGNsb25lZCB0aGVyZWZvcmUgd2UgaGF2ZSB0byBjbG9uZSBhcyB3ZWxsLlxyXG4gICAgICAgICAgICAgIGxpbmtOb2RlID0gSlFMaXRlQ2xvbmUoY29tcGlsZU5vZGUpO1xyXG4gICAgICAgICAgICAgIHJlcGxhY2VXaXRoKGxpbmtSb290RWxlbWVudCwganFMaXRlKGJlZm9yZVRlbXBsYXRlTGlua05vZGUpLCBsaW5rTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFmdGVyVGVtcGxhdGVOb2RlTGlua0ZuKFxyXG4gICAgICAgICAgICAgIGJlZm9yZVRlbXBsYXRlTm9kZUxpbmtGbihhZnRlclRlbXBsYXRlQ2hpbGRMaW5rRm4sIHNjb3BlLCBsaW5rTm9kZSwgJHJvb3RFbGVtZW50LCBjb250cm9sbGVyKSxcclxuICAgICAgICAgICAgICBzY29wZSwgbGlua05vZGUsICRyb290RWxlbWVudCwgY29udHJvbGxlclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGlua1F1ZXVlID0gbnVsbDtcclxuICAgICAgICB9KS5cclxuICAgICAgICBlcnJvcihmdW5jdGlvbihyZXNwb25zZSwgY29kZSwgaGVhZGVycywgY29uZmlnKSB7XHJcbiAgICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycigndHBsb2FkJywgJ0ZhaWxlZCB0byBsb2FkIHRlbXBsYXRlOiB7MH0nLCBjb25maWcudXJsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiBkZWxheWVkTm9kZUxpbmtGbihpZ25vcmVDaGlsZExpbmtGbiwgc2NvcGUsIG5vZGUsIHJvb3RFbGVtZW50LCBjb250cm9sbGVyKSB7XHJcbiAgICAgICAgaWYgKGxpbmtRdWV1ZSkge1xyXG4gICAgICAgICAgbGlua1F1ZXVlLnB1c2goc2NvcGUpO1xyXG4gICAgICAgICAgbGlua1F1ZXVlLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICBsaW5rUXVldWUucHVzaChyb290RWxlbWVudCk7XHJcbiAgICAgICAgICBsaW5rUXVldWUucHVzaChjb250cm9sbGVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWZ0ZXJUZW1wbGF0ZU5vZGVMaW5rRm4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGJlZm9yZVRlbXBsYXRlTm9kZUxpbmtGbihhZnRlclRlbXBsYXRlQ2hpbGRMaW5rRm4sIHNjb3BlLCBub2RlLCByb290RWxlbWVudCwgY29udHJvbGxlcik7XHJcbiAgICAgICAgICB9LCBzY29wZSwgbm9kZSwgcm9vdEVsZW1lbnQsIGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0aW5nIGZ1bmN0aW9uIGZvciBib3VuZCBkaXJlY3RpdmVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBieVByaW9yaXR5KGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBhc3NlcnROb0R1cGxpY2F0ZSh3aGF0LCBwcmV2aW91c0RpcmVjdGl2ZSwgZGlyZWN0aXZlLCBlbGVtZW50KSB7XHJcbiAgICAgIGlmIChwcmV2aW91c0RpcmVjdGl2ZSkge1xyXG4gICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCdtdWx0aWRpcicsICdNdWx0aXBsZSBkaXJlY3RpdmVzIFt7MH0sIHsxfV0gYXNraW5nIGZvciB7Mn0gb246IHszfScsXHJcbiAgICAgICAgICAgIHByZXZpb3VzRGlyZWN0aXZlLm5hbWUsIGRpcmVjdGl2ZS5uYW1lLCB3aGF0LCBzdGFydGluZ1RhZyhlbGVtZW50KSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVGV4dEludGVycG9sYXRlRGlyZWN0aXZlKGRpcmVjdGl2ZXMsIHRleHQpIHtcclxuICAgICAgdmFyIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUodGV4dCwgdHJ1ZSk7XHJcbiAgICAgIGlmIChpbnRlcnBvbGF0ZUZuKSB7XHJcbiAgICAgICAgZGlyZWN0aXZlcy5wdXNoKHtcclxuICAgICAgICAgIHByaW9yaXR5OiAwLFxyXG4gICAgICAgICAgY29tcGlsZTogdmFsdWVGbihmdW5jdGlvbiB0ZXh0SW50ZXJwb2xhdGVMaW5rRm4oc2NvcGUsIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50KCksXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5ncyA9IHBhcmVudC5kYXRhKCckYmluZGluZycpIHx8IFtdO1xyXG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKGludGVycG9sYXRlRm4pO1xyXG4gICAgICAgICAgICBzYWZlQWRkQ2xhc3MocGFyZW50LmRhdGEoJyRiaW5kaW5nJywgYmluZGluZ3MpLCAnbmctYmluZGluZycpO1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goaW50ZXJwb2xhdGVGbiwgZnVuY3Rpb24gaW50ZXJwb2xhdGVGbldhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgbm9kZVswXS5ub2RlVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRydXN0ZWRDb250ZXh0KG5vZGUsIGF0dHJOb3JtYWxpemVkTmFtZSkge1xyXG4gICAgICAvLyBtYWN0aW9uW3hsaW5rOmhyZWZdIGNhbiBzb3VyY2UgU1ZHLiAgSXQncyBub3QgbGltaXRlZCB0byA8bWFjdGlvbj4uXHJcbiAgICAgIGlmIChhdHRyTm9ybWFsaXplZE5hbWUgPT0gXCJ4bGlua0hyZWZcIiB8fFxyXG4gICAgICAgICAgKG5vZGVOYW1lXyhub2RlKSAhPSBcIklNR1wiICYmIChhdHRyTm9ybWFsaXplZE5hbWUgPT0gXCJzcmNcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ck5vcm1hbGl6ZWROYW1lID09IFwibmdTcmNcIikpKSB7XHJcbiAgICAgICAgcmV0dXJuICRzY2UuUkVTT1VSQ0VfVVJMO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEF0dHJJbnRlcnBvbGF0ZURpcmVjdGl2ZShub2RlLCBkaXJlY3RpdmVzLCB2YWx1ZSwgbmFtZSkge1xyXG4gICAgICB2YXIgaW50ZXJwb2xhdGVGbiA9ICRpbnRlcnBvbGF0ZSh2YWx1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAvLyBubyBpbnRlcnBvbGF0aW9uIGZvdW5kIC0+IGlnbm9yZVxyXG4gICAgICBpZiAoIWludGVycG9sYXRlRm4pIHJldHVybjtcclxuXHJcblxyXG4gICAgICBpZiAobmFtZSA9PT0gXCJtdWx0aXBsZVwiICYmIG5vZGVOYW1lXyhub2RlKSA9PT0gXCJTRUxFQ1RcIikge1xyXG4gICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKFwic2VsbXVsdGlcIiwgXCJCaW5kaW5nIHRvIHRoZSAnbXVsdGlwbGUnIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkLiBFbGVtZW50OiB7MH1cIixcclxuICAgICAgICAgICAgc3RhcnRpbmdUYWcobm9kZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXJlY3RpdmVzLnB1c2goe1xyXG4gICAgICAgIHByaW9yaXR5OiAxMDAsXHJcbiAgICAgICAgY29tcGlsZTogdmFsdWVGbihmdW5jdGlvbiBhdHRySW50ZXJwb2xhdGVMaW5rRm4oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgICAgIHZhciAkJG9ic2VydmVycyA9IChhdHRyLiQkb2JzZXJ2ZXJzIHx8IChhdHRyLiQkb2JzZXJ2ZXJzID0ge30pKTtcclxuXHJcbiAgICAgICAgICBpZiAoRVZFTlRfSEFORExFUl9BVFRSX1JFR0VYUC50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCdub2RvbWV2ZW50cycsXHJcbiAgICAgICAgICAgICAgICBcIkludGVycG9sYXRpb25zIGZvciBIVE1MIERPTSBldmVudCBhdHRyaWJ1dGVzIGFyZSBkaXNhbGxvd2VkLiAgUGxlYXNlIHVzZSB0aGUgbmctIFwiICtcclxuICAgICAgICAgICAgICAgIFwidmVyc2lvbnMgKHN1Y2ggYXMgbmctY2xpY2sgaW5zdGVhZCBvZiBvbmNsaWNrKSBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGludGVycG9sYXRlIGFnYWluLCBpbiBjYXNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgICAgLy8gKGUuZy4gYnkgYW5vdGhlciBkaXJlY3RpdmUncyBjb21waWxlIGZ1bmN0aW9uKVxyXG4gICAgICAgICAgaW50ZXJwb2xhdGVGbiA9ICRpbnRlcnBvbGF0ZShhdHRyW25hbWVdLCB0cnVlLCBnZXRUcnVzdGVkQ29udGV4dChub2RlLCBuYW1lKSk7XHJcblxyXG4gICAgICAgICAgLy8gaWYgYXR0cmlidXRlIHdhcyB1cGRhdGVkIHNvIHRoYXQgdGhlcmUgaXMgbm8gaW50ZXJwb2xhdGlvbiBnb2luZyBvbiB3ZSBkb24ndCB3YW50IHRvXHJcbiAgICAgICAgICAvLyByZWdpc3RlciBhbnkgb2JzZXJ2ZXJzXHJcbiAgICAgICAgICBpZiAoIWludGVycG9sYXRlRm4pIHJldHVybjtcclxuXHJcbiAgICAgICAgICBhdHRyW25hbWVdID0gaW50ZXJwb2xhdGVGbihzY29wZSk7XHJcbiAgICAgICAgICAoJCRvYnNlcnZlcnNbbmFtZV0gfHwgKCQkb2JzZXJ2ZXJzW25hbWVdID0gW10pKS4kJGludGVyID0gdHJ1ZTtcclxuICAgICAgICAgIChhdHRyLiQkb2JzZXJ2ZXJzICYmIGF0dHIuJCRvYnNlcnZlcnNbbmFtZV0uJCRzY29wZSB8fCBzY29wZSkuXHJcbiAgICAgICAgICAgICR3YXRjaChpbnRlcnBvbGF0ZUZuLCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUZuV2F0Y2hBY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICBhdHRyLiRzZXQobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGEgc3BlY2lhbCBqcUxpdGUucmVwbGFjZVdpdGgsIHdoaWNoIGNhbiByZXBsYWNlIGl0ZW1zIHdoaWNoXHJcbiAgICAgKiBoYXZlIG5vIHBhcmVudHMsIHByb3ZpZGVkIHRoYXQgdGhlIGNvbnRhaW5pbmcganFMaXRlIGNvbGxlY3Rpb24gaXMgcHJvdmlkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKcUxpdGU9fSAkcm9vdEVsZW1lbnQgVGhlIHJvb3Qgb2YgdGhlIGNvbXBpbGUgdHJlZS4gVXNlZCBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIG5vZGVzXHJcbiAgICAgKiAgICBpbiB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cclxuICAgICAqIEBwYXJhbSB7SnFMaXRlfSBlbGVtZW50c1RvUmVtb3ZlIFRoZSBqcUxpdGUgZWxlbWVudCB3aGljaCB3ZSBhcmUgZ29pbmcgdG8gcmVwbGFjZS4gV2Uga2VlcCB0aGUgc2hlbGwsXHJcbiAgICAgKiAgICBidXQgcmVwbGFjZSBpdHMgRE9NIG5vZGUgcmVmZXJlbmNlLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIFRoZSBuZXcgRE9NIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VXaXRoKCRyb290RWxlbWVudCwgZWxlbWVudHNUb1JlbW92ZSwgbmV3Tm9kZSkge1xyXG4gICAgICB2YXIgZmlyc3RFbGVtZW50VG9SZW1vdmUgPSBlbGVtZW50c1RvUmVtb3ZlWzBdLFxyXG4gICAgICAgICAgcmVtb3ZlQ291bnQgPSBlbGVtZW50c1RvUmVtb3ZlLmxlbmd0aCxcclxuICAgICAgICAgIHBhcmVudCA9IGZpcnN0RWxlbWVudFRvUmVtb3ZlLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICBpLCBpaTtcclxuXHJcbiAgICAgIGlmICgkcm9vdEVsZW1lbnQpIHtcclxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gJHJvb3RFbGVtZW50Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgIGlmICgkcm9vdEVsZW1lbnRbaV0gPT0gZmlyc3RFbGVtZW50VG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgJHJvb3RFbGVtZW50W2krK10gPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSwgajIgPSBqICsgcmVtb3ZlQ291bnQgLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgICBqaiA9ICRyb290RWxlbWVudC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgaiA8IGpqOyBqKyssIGoyKyspIHtcclxuICAgICAgICAgICAgICBpZiAoajIgPCBqaikge1xyXG4gICAgICAgICAgICAgICAgJHJvb3RFbGVtZW50W2pdID0gJHJvb3RFbGVtZW50W2oyXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlICRyb290RWxlbWVudFtqXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHJvb3RFbGVtZW50Lmxlbmd0aCAtPSByZW1vdmVDb3VudCAtIDE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgZmlyc3RFbGVtZW50VG9SZW1vdmUpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZmlyc3RFbGVtZW50VG9SZW1vdmUpO1xyXG4gICAgICBuZXdOb2RlW2pxTGl0ZS5leHBhbmRvXSA9IGZpcnN0RWxlbWVudFRvUmVtb3ZlW2pxTGl0ZS5leHBhbmRvXTtcclxuICAgICAgZm9yICh2YXIgayA9IDEsIGtrID0gZWxlbWVudHNUb1JlbW92ZS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1RvUmVtb3ZlW2tdO1xyXG4gICAgICAgIGpxTGl0ZShlbGVtZW50KS5yZW1vdmUoKTsgLy8gbXVzdCBkbyB0aGlzIHdheSB0byBjbGVhbiB1cCBleHBhbmRvXHJcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgZGVsZXRlIGVsZW1lbnRzVG9SZW1vdmVba107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1lbnRzVG9SZW1vdmVbMF0gPSBuZXdOb2RlO1xyXG4gICAgICBlbGVtZW50c1RvUmVtb3ZlLmxlbmd0aCA9IDFcclxuICAgIH1cclxuICB9XTtcclxufVxyXG5cclxudmFyIFBSRUZJWF9SRUdFWFAgPSAvXih4W1xcOlxcLV9dfGRhdGFbXFw6XFwtX10pL2k7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbGwgYWNjZXB0ZWQgZGlyZWN0aXZlcyBmb3JtYXQgaW50byBwcm9wZXIgZGlyZWN0aXZlIG5hbWUuXHJcbiAqIEFsbCBvZiB0aGVzZSB3aWxsIGJlY29tZSAnbXlEaXJlY3RpdmUnOlxyXG4gKiAgIG15OkRpcmVjdGl2ZVxyXG4gKiAgIG15LWRpcmVjdGl2ZVxyXG4gKiAgIHgtbXktZGlyZWN0aXZlXHJcbiAqICAgZGF0YS1teTpkaXJlY3RpdmVcclxuICpcclxuICogQWxzbyB0aGVyZSBpcyBzcGVjaWFsIGNhc2UgZm9yIE1veiBwcmVmaXggc3RhcnRpbmcgd2l0aCB1cHBlciBjYXNlIGxldHRlci5cclxuICogQHBhcmFtIG5hbWUgTmFtZSB0byBub3JtYWxpemVcclxuICovXHJcbmZ1bmN0aW9uIGRpcmVjdGl2ZU5vcm1hbGl6ZShuYW1lKSB7XHJcbiAgcmV0dXJuIGNhbWVsQ2FzZShuYW1lLnJlcGxhY2UoUFJFRklYX1JFR0VYUCwgJycpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXNcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIEEgc2hhcmVkIG9iamVjdCBiZXR3ZWVuIGRpcmVjdGl2ZSBjb21waWxlIC8gbGlua2luZyBmdW5jdGlvbnMgd2hpY2ggY29udGFpbnMgbm9ybWFsaXplZCBET00gZWxlbWVudFxyXG4gKiBhdHRyaWJ1dGVzLiBUaGUgdGhlIHZhbHVlcyByZWZsZWN0IGN1cnJlbnQgYmluZGluZyBzdGF0ZSBge3sgfX1gLiBUaGUgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWRcclxuICogc2luY2UgYWxsIG9mIHRoZXNlIGFyZSB0cmVhdGVkIGFzIGVxdWl2YWxlbnQgaW4gQW5ndWxhcjpcclxuICpcclxuICogICAgICAgICAgPHNwYW4gbmc6YmluZD1cImFcIiBuZy1iaW5kPVwiYVwiIGRhdGEtbmctYmluZD1cImFcIiB4LW5nLWJpbmQ9XCJhXCI+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkYXR0clxyXG4gKiBAcHJvcGVydHlPZiBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlc1xyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBBIG1hcCBvZiBET00gZWxlbWVudCBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlIG5vcm1hbGl6ZWQgbmFtZS4gVGhpcyBpc1xyXG4gKiAgICAgICAgICBuZWVkZWQgdG8gZG8gcmV2ZXJzZSBsb29rdXAgZnJvbSBub3JtYWxpemVkIG5hbWUgYmFjayB0byBhY3R1YWwgbmFtZS5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkc2V0XHJcbiAqIEBtZXRob2RPZiBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlc1xyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNldCBET00gZWxlbWVudCBhdHRyaWJ1dGUgdmFsdWUuXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5vcm1hbGl6ZWQgZWxlbWVudCBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gbW9kaWZ5LiBUaGUgbmFtZSBpc1xyXG4gKiAgICAgICAgICByZXZlcnMgdHJhbnNsYXRlZCB1c2luZyB0aGUge0BsaW5rIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzIyRhdHRyICRhdHRyfVxyXG4gKiAgICAgICAgICBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHNldCB0aGUgYXR0cmlidXRlIHRvLiBUaGUgdmFsdWUgY2FuIGJlIGFuIGludGVycG9sYXRlZCBzdHJpbmcuXHJcbiAqL1xyXG5cclxuXHJcblxyXG4vKipcclxuICogQ2xvc3VyZSBjb21waWxlciB0eXBlIGluZm9ybWF0aW9uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbm9kZXNldExpbmtpbmdGbihcclxuICAvKiBhbmd1bGFyLlNjb3BlICovIHNjb3BlLFxyXG4gIC8qIE5vZGVMaXN0ICovIG5vZGVMaXN0LFxyXG4gIC8qIEVsZW1lbnQgKi8gcm9vdEVsZW1lbnQsXHJcbiAgLyogZnVuY3Rpb24oRnVuY3Rpb24pICovIGJvdW5kVHJhbnNjbHVkZUZuXHJcbil7fVxyXG5cclxuZnVuY3Rpb24gZGlyZWN0aXZlTGlua2luZ0ZuKFxyXG4gIC8qIG5vZGVzZXRMaW5raW5nRm4gKi8gbm9kZXNldExpbmtpbmdGbixcclxuICAvKiBhbmd1bGFyLlNjb3BlICovIHNjb3BlLFxyXG4gIC8qIE5vZGUgKi8gbm9kZSxcclxuICAvKiBFbGVtZW50ICovIHJvb3RFbGVtZW50LFxyXG4gIC8qIGZ1bmN0aW9uKEZ1bmN0aW9uKSAqLyBib3VuZFRyYW5zY2x1ZGVGblxyXG4pe31cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRjb250cm9sbGVyUHJvdmlkZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSB7QGxpbmsgbmcuJGNvbnRyb2xsZXIgJGNvbnRyb2xsZXIgc2VydmljZX0gaXMgdXNlZCBieSBBbmd1bGFyIHRvIGNyZWF0ZSBuZXdcclxuICogY29udHJvbGxlcnMuXHJcbiAqXHJcbiAqIFRoaXMgcHJvdmlkZXIgYWxsb3dzIGNvbnRyb2xsZXIgcmVnaXN0cmF0aW9uIHZpYSB0aGVcclxuICoge0BsaW5rIG5nLiRjb250cm9sbGVyUHJvdmlkZXIjcmVnaXN0ZXIgcmVnaXN0ZXJ9IG1ldGhvZC5cclxuICovXHJcbmZ1bmN0aW9uICRDb250cm9sbGVyUHJvdmlkZXIoKSB7XHJcbiAgdmFyIGNvbnRyb2xsZXJzID0ge30sXHJcbiAgICAgIENOVFJMX1JFRyA9IC9eKFxcUyspKFxccythc1xccysoXFx3KykpPyQvO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuJGNvbnRyb2xsZXJQcm92aWRlciNyZWdpc3RlclxyXG4gICAqIEBtZXRob2RPZiBuZy4kY29udHJvbGxlclByb3ZpZGVyXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ29udHJvbGxlciBuYW1lXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheX0gY29uc3RydWN0b3IgQ29udHJvbGxlciBjb25zdHJ1Y3RvciBmbiAob3B0aW9uYWxseSBkZWNvcmF0ZWQgd2l0aCBESVxyXG4gICAqICAgIGFubm90YXRpb25zIGluIHRoZSBhcnJheSBub3RhdGlvbikuXHJcbiAgICovXHJcbiAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGNvbnN0cnVjdG9yKSB7XHJcbiAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcclxuICAgICAgZXh0ZW5kKGNvbnRyb2xsZXJzLCBuYW1lKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udHJvbGxlcnNbbmFtZV0gPSBjb25zdHJ1Y3RvcjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRpbmplY3RvciwgJHdpbmRvdykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBuZy4kY29udHJvbGxlclxyXG4gICAgICogQHJlcXVpcmVzICRpbmplY3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBjb25zdHJ1Y3RvciBJZiBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uIHRoZW4gaXQncyBjb25zaWRlcmVkIHRvIGJlIHRoZVxyXG4gICAgICogICAgY29udHJvbGxlciBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gT3RoZXJ3aXNlIGl0J3MgY29uc2lkZXJlZCB0byBiZSBhIHN0cmluZyB3aGljaCBpcyB1c2VkXHJcbiAgICAgKiAgICB0byByZXRyaWV2ZSB0aGUgY29udHJvbGxlciBjb25zdHJ1Y3RvciB1c2luZyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxyXG4gICAgICpcclxuICAgICAqICAgICogY2hlY2sgaWYgYSBjb250cm9sbGVyIHdpdGggZ2l2ZW4gbmFtZSBpcyByZWdpc3RlcmVkIHZpYSBgJGNvbnRyb2xsZXJQcm92aWRlcmBcclxuICAgICAqICAgICogY2hlY2sgaWYgZXZhbHVhdGluZyB0aGUgc3RyaW5nIG9uIHRoZSBjdXJyZW50IHNjb3BlIHJldHVybnMgYSBjb25zdHJ1Y3RvclxyXG4gICAgICogICAgKiBjaGVjayBgd2luZG93W2NvbnN0cnVjdG9yXWAgb24gdGhlIGdsb2JhbCBgd2luZG93YCBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIEluamVjdGlvbiBsb2NhbHMgZm9yIENvbnRyb2xsZXIuXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEluc3RhbmNlIG9mIGdpdmVuIGNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBgJGNvbnRyb2xsZXJgIHNlcnZpY2UgaXMgcmVzcG9uc2libGUgZm9yIGluc3RhbnRpYXRpbmcgY29udHJvbGxlcnMuXHJcbiAgICAgKlxyXG4gICAgICogSXQncyBqdXN0IGEgc2ltcGxlIGNhbGwgdG8ge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0sIGJ1dCBleHRyYWN0ZWQgaW50b1xyXG4gICAgICogYSBzZXJ2aWNlLCBzbyB0aGF0IG9uZSBjYW4gb3ZlcnJpZGUgdGhpcyBzZXJ2aWNlIHdpdGgge0BsaW5rIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE2NDk3ODhcclxuICAgICAqIEJDIHZlcnNpb259LlxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oZXhwcmVzc2lvbiwgbG9jYWxzKSB7XHJcbiAgICAgIHZhciBpbnN0YW5jZSwgbWF0Y2gsIGNvbnN0cnVjdG9yLCBpZGVudGlmaWVyO1xyXG5cclxuICAgICAgaWYoaXNTdHJpbmcoZXhwcmVzc2lvbikpIHtcclxuICAgICAgICBtYXRjaCA9IGV4cHJlc3Npb24ubWF0Y2goQ05UUkxfUkVHKSxcclxuICAgICAgICBjb25zdHJ1Y3RvciA9IG1hdGNoWzFdLFxyXG4gICAgICAgIGlkZW50aWZpZXIgPSBtYXRjaFszXTtcclxuICAgICAgICBleHByZXNzaW9uID0gY29udHJvbGxlcnMuaGFzT3duUHJvcGVydHkoY29uc3RydWN0b3IpXHJcbiAgICAgICAgICAgID8gY29udHJvbGxlcnNbY29uc3RydWN0b3JdXHJcbiAgICAgICAgICAgIDogZ2V0dGVyKGxvY2Fscy4kc2NvcGUsIGNvbnN0cnVjdG9yLCB0cnVlKSB8fCBnZXR0ZXIoJHdpbmRvdywgY29uc3RydWN0b3IsIHRydWUpO1xyXG5cclxuICAgICAgICBhc3NlcnRBcmdGbihleHByZXNzaW9uLCBjb25zdHJ1Y3RvciwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluc3RhbmNlID0gJGluamVjdG9yLmluc3RhbnRpYXRlKGV4cHJlc3Npb24sIGxvY2Fscyk7XHJcblxyXG4gICAgICBpZiAoaWRlbnRpZmllcikge1xyXG4gICAgICAgIGlmICghKGxvY2FscyAmJiB0eXBlb2YgbG9jYWxzLiRzY29wZSA9PSAnb2JqZWN0JykpIHtcclxuICAgICAgICAgIHRocm93IG1pbkVycignJGNvbnRyb2xsZXInKSgnbm9zY3AnLCBcIkNhbm5vdCBleHBvcnQgY29udHJvbGxlciAnezB9JyBhcyAnezF9JyEgTm8gJHNjb3BlIG9iamVjdCBwcm92aWRlZCB2aWEgYGxvY2Fsc2AuXCIsIGNvbnN0cnVjdG9yIHx8IGV4cHJlc3Npb24ubmFtZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb2NhbHMuJHNjb3BlW2lkZW50aWZpZXJdID0gaW5zdGFuY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH07XHJcbiAgfV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRkb2N1bWVudFxyXG4gKiBAcmVxdWlyZXMgJHdpbmRvd1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSB7QGxpbmsgYW5ndWxhci5lbGVtZW50IGpRdWVyeSAobGl0ZSl9LXdyYXBwZWQgcmVmZXJlbmNlIHRvIHRoZSBicm93c2VyJ3MgYHdpbmRvdy5kb2N1bWVudGBcclxuICogZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uICREb2N1bWVudFByb3ZpZGVyKCl7XHJcbiAgdGhpcy4kZ2V0ID0gWyckd2luZG93JywgZnVuY3Rpb24od2luZG93KXtcclxuICAgIHJldHVybiBqcUxpdGUod2luZG93LmRvY3VtZW50KTtcclxuICB9XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy4kZXhjZXB0aW9uSGFuZGxlclxyXG4gKiBAcmVxdWlyZXMgJGxvZ1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQW55IHVuY2F1Z2h0IGV4Y2VwdGlvbiBpbiBhbmd1bGFyIGV4cHJlc3Npb25zIGlzIGRlbGVnYXRlZCB0byB0aGlzIHNlcnZpY2UuXHJcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSBkZWxlZ2F0ZXMgdG8gYCRsb2cuZXJyb3JgIHdoaWNoIGxvZ3MgaXQgaW50b1xyXG4gKiB0aGUgYnJvd3NlciBjb25zb2xlLlxyXG4gKlxyXG4gKiBJbiB1bml0IHRlc3RzLCBpZiBgYW5ndWxhci1tb2Nrcy5qc2AgaXMgbG9hZGVkLCB0aGlzIHNlcnZpY2UgaXMgb3ZlcnJpZGRlbiBieVxyXG4gKiB7QGxpbmsgbmdNb2NrLiRleGNlcHRpb25IYW5kbGVyIG1vY2sgJGV4Y2VwdGlvbkhhbmRsZXJ9IHdoaWNoIGFpZHMgaW4gdGVzdGluZy5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gZXhjZXB0aW9uIEV4Y2VwdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IGNhdXNlIG9wdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb250ZXh0IGluIHdoaWNoXHJcbiAqICAgICAgIHRoZSBlcnJvciB3YXMgdGhyb3duLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gJEV4Y2VwdGlvbkhhbmRsZXJQcm92aWRlcigpIHtcclxuICB0aGlzLiRnZXQgPSBbJyRsb2cnLCBmdW5jdGlvbigkbG9nKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYXVzZSkge1xyXG4gICAgICAkbG9nLmVycm9yLmFwcGx5KCRsb2csIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH1dO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgaGVhZGVycyBpbnRvIGtleSB2YWx1ZSBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlcnMgUmF3IGhlYWRlcnMgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge09iamVjdH0gUGFyc2VkIGhlYWRlcnMgYXMga2V5IHZhbHVlIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcclxuICB2YXIgcGFyc2VkID0ge30sIGtleSwgdmFsLCBpO1xyXG5cclxuICBpZiAoIWhlYWRlcnMpIHJldHVybiBwYXJzZWQ7XHJcblxyXG4gIGZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcclxuICAgIGtleSA9IGxvd2VyY2FzZSh0cmltKGxpbmUuc3Vic3RyKDAsIGkpKSk7XHJcbiAgICB2YWwgPSB0cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XHJcblxyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICBpZiAocGFyc2VkW2tleV0pIHtcclxuICAgICAgICBwYXJzZWRba2V5XSArPSAnLCAnICsgdmFsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnNlZFtrZXldID0gdmFsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBwYXJzZWQ7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIHBhcnNlZCBoZWFkZXJzLlxyXG4gKlxyXG4gKiBIZWFkZXJzIGFyZSBsYXp5IHBhcnNlZCB3aGVuIGZpcnN0IHJlcXVlc3RlZC5cclxuICogQHNlZSBwYXJzZUhlYWRlcnNcclxuICpcclxuICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCl9IGhlYWRlcnMgSGVhZGVycyB0byBwcm92aWRlIGFjY2VzcyB0by5cclxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZz0pfSBSZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIHdoaWNoIGlmIGNhbGxlZCB3aXRoOlxyXG4gKlxyXG4gKiAgIC0gaWYgY2FsbGVkIHdpdGggc2luZ2xlIGFuIGFyZ3VtZW50IHJldHVybnMgYSBzaW5nbGUgaGVhZGVyIHZhbHVlIG9yIG51bGxcclxuICogICAtIGlmIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCBoZWFkZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gaGVhZGVyc0dldHRlcihoZWFkZXJzKSB7XHJcbiAgdmFyIGhlYWRlcnNPYmogPSBpc09iamVjdChoZWFkZXJzKSA/IGhlYWRlcnMgOiB1bmRlZmluZWQ7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBpZiAoIWhlYWRlcnNPYmopIGhlYWRlcnNPYmogPSAgcGFyc2VIZWFkZXJzKGhlYWRlcnMpO1xyXG5cclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIHJldHVybiBoZWFkZXJzT2JqW2xvd2VyY2FzZShuYW1lKV0gfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGVhZGVyc09iajtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENoYWluIGFsbCBnaXZlbiBmdW5jdGlvbnNcclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciBib3RoIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHRyYW5zZm9ybWluZ1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IGRhdGEgRGF0YSB0byB0cmFuc2Zvcm0uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nPSl9IGhlYWRlcnMgSHR0cCBoZWFkZXJzIGdldHRlciBmbi5cclxuICogQHBhcmFtIHsoZnVuY3Rpb258QXJyYXkuPGZ1bmN0aW9uPil9IGZucyBGdW5jdGlvbiBvciBhbiBhcnJheSBvZiBmdW5jdGlvbnMuXHJcbiAqIEByZXR1cm5zIHsqfSBUcmFuc2Zvcm1lZCBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcclxuICBpZiAoaXNGdW5jdGlvbihmbnMpKVxyXG4gICAgcmV0dXJuIGZucyhkYXRhLCBoZWFkZXJzKTtcclxuXHJcbiAgZm9yRWFjaChmbnMsIGZ1bmN0aW9uKGZuKSB7XHJcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaXNTdWNjZXNzKHN0YXR1cykge1xyXG4gIHJldHVybiAyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8IDMwMDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uICRIdHRwUHJvdmlkZXIoKSB7XHJcbiAgdmFyIEpTT05fU1RBUlQgPSAvXlxccyooXFxbfFxce1teXFx7XSkvLFxyXG4gICAgICBKU09OX0VORCA9IC9bXFx9XFxdXVxccyokLyxcclxuICAgICAgUFJPVEVDVElPTl9QUkVGSVggPSAvXlxcKVxcXVxcfScsP1xcbi8sXHJcbiAgICAgIENPTlRFTlRfVFlQRV9BUFBMSUNBVElPTl9KU09OID0geydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04J307XHJcblxyXG4gIHZhciBkZWZhdWx0cyA9IHRoaXMuZGVmYXVsdHMgPSB7XHJcbiAgICAvLyB0cmFuc2Zvcm0gaW5jb21pbmcgcmVzcG9uc2UgZGF0YVxyXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIGlmIChpc1N0cmluZyhkYXRhKSkge1xyXG4gICAgICAgIC8vIHN0cmlwIGpzb24gdnVsbmVyYWJpbGl0eSBwcm90ZWN0aW9uIHByZWZpeFxyXG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoUFJPVEVDVElPTl9QUkVGSVgsICcnKTtcclxuICAgICAgICBpZiAoSlNPTl9TVEFSVC50ZXN0KGRhdGEpICYmIEpTT05fRU5ELnRlc3QoZGF0YSkpXHJcbiAgICAgICAgICBkYXRhID0gZnJvbUpzb24oZGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XSxcclxuXHJcbiAgICAvLyB0cmFuc2Zvcm0gb3V0Z29pbmcgcmVxdWVzdCBkYXRhXHJcbiAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24oZCkge1xyXG4gICAgICByZXR1cm4gaXNPYmplY3QoZCkgJiYgIWlzRmlsZShkKSA/IHRvSnNvbihkKSA6IGQ7XHJcbiAgICB9XSxcclxuXHJcbiAgICAvLyBkZWZhdWx0IGhlYWRlcnNcclxuICAgIGhlYWRlcnM6IHtcclxuICAgICAgY29tbW9uOiB7XHJcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXHJcbiAgICAgIH0sXHJcbiAgICAgIHBvc3Q6ICAgQ09OVEVOVF9UWVBFX0FQUExJQ0FUSU9OX0pTT04sXHJcbiAgICAgIHB1dDogICAgQ09OVEVOVF9UWVBFX0FQUExJQ0FUSU9OX0pTT04sXHJcbiAgICAgIHBhdGNoOiAgQ09OVEVOVF9UWVBFX0FQUExJQ0FUSU9OX0pTT05cclxuICAgIH0sXHJcblxyXG4gICAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcclxuICAgIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFyZSBvcmRlciBieSByZXF1ZXN0LiBJLkUuIHRoZXkgYXJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXNcclxuICAgKiBhcnJheSBvbiByZXF1ZXN0LCBidXQgcmV2ZXJzIG9yZGVyIG9uIHJlc3BvbnNlLlxyXG4gICAqL1xyXG4gIHZhciBpbnRlcmNlcHRvckZhY3RvcmllcyA9IHRoaXMuaW50ZXJjZXB0b3JzID0gW107XHJcbiAgLyoqXHJcbiAgICogRm9yIGhpc3RvcmljYWwgcmVhc29ucywgcmVzcG9uc2UgaW50ZXJjZXB0b3JzIG9yZGVyZWQgYnkgdGhlIG9yZGVyIGluIHdoaWNoXHJcbiAgICogdGhleSBhcmUgYXBwbGllZCB0byByZXNwb25zZS4gKFRoaXMgaXMgaW4gcmV2ZXJzIHRvIGludGVyY2VwdG9yRmFjdG9yaWVzKVxyXG4gICAqL1xyXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yRmFjdG9yaWVzID0gdGhpcy5yZXNwb25zZUludGVyY2VwdG9ycyA9IFtdO1xyXG5cclxuICB0aGlzLiRnZXQgPSBbJyRodHRwQmFja2VuZCcsICckYnJvd3NlcicsICckY2FjaGVGYWN0b3J5JywgJyRyb290U2NvcGUnLCAnJHEnLCAnJGluamVjdG9yJywgJyQkdXJsVXRpbHMnLFxyXG4gICAgICBmdW5jdGlvbigkaHR0cEJhY2tlbmQsICRicm93c2VyLCAkY2FjaGVGYWN0b3J5LCAkcm9vdFNjb3BlLCAkcSwgJGluamVjdG9yLCAkJHVybFV0aWxzKSB7XHJcblxyXG4gICAgdmFyIGRlZmF1bHRDYWNoZSA9ICRjYWNoZUZhY3RvcnkoJyRodHRwJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcmNlcHRvcnMgc3RvcmVkIGluIHJldmVyc2Ugb3JkZXIuIElubmVyIGludGVyY2VwdG9ycyBiZWZvcmUgb3V0ZXIgaW50ZXJjZXB0b3JzLlxyXG4gICAgICogVGhlIHJldmVyc2FsIGlzIG5lZWRlZCBzbyB0aGF0IHdlIGNhbiBidWlsZCB1cCB0aGUgaW50ZXJjZXB0aW9uIGNoYWluIGFyb3VuZCB0aGVcclxuICAgICAqIHNlcnZlciByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgcmV2ZXJzZWRJbnRlcmNlcHRvcnMgPSBbXTtcclxuXHJcbiAgICBmb3JFYWNoKGludGVyY2VwdG9yRmFjdG9yaWVzLCBmdW5jdGlvbihpbnRlcmNlcHRvckZhY3RvcnkpIHtcclxuICAgICAgcmV2ZXJzZWRJbnRlcmNlcHRvcnMudW5zaGlmdChpc1N0cmluZyhpbnRlcmNlcHRvckZhY3RvcnkpXHJcbiAgICAgICAgICA/ICRpbmplY3Rvci5nZXQoaW50ZXJjZXB0b3JGYWN0b3J5KSA6ICRpbmplY3Rvci5pbnZva2UoaW50ZXJjZXB0b3JGYWN0b3J5KSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3JFYWNoKHJlc3BvbnNlSW50ZXJjZXB0b3JGYWN0b3JpZXMsIGZ1bmN0aW9uKGludGVyY2VwdG9yRmFjdG9yeSwgaW5kZXgpIHtcclxuICAgICAgdmFyIHJlc3BvbnNlRm4gPSBpc1N0cmluZyhpbnRlcmNlcHRvckZhY3RvcnkpXHJcbiAgICAgICAgICA/ICRpbmplY3Rvci5nZXQoaW50ZXJjZXB0b3JGYWN0b3J5KVxyXG4gICAgICAgICAgOiAkaW5qZWN0b3IuaW52b2tlKGludGVyY2VwdG9yRmFjdG9yeSk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmVzcG9uc2UgaW50ZXJjZXB0b3JzIGdvIGJlZm9yZSBcImFyb3VuZFwiIGludGVyY2VwdG9ycyAobm8gcmVhbCByZWFzb24sIGp1c3RcclxuICAgICAgICogaGFkIHRvIHBpY2sgb25lLikgQnV0IHRoZXkgYXJlIGFscmVhZHkgcmV2ZXJzZWQsIHNvIHdlIGNhbid0IHVzZSB1bnNoaWZ0LCBoZW5jZVxyXG4gICAgICAgKiB0aGUgc3BsaWNlLlxyXG4gICAgICAgKi9cclxuICAgICAgcmV2ZXJzZWRJbnRlcmNlcHRvcnMuc3BsaWNlKGluZGV4LCAwLCB7XHJcbiAgICAgICAgcmVzcG9uc2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VGbigkcS53aGVuKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNwb25zZUVycm9yOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlRm4oJHEucmVqZWN0KHJlc3BvbnNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgbmcuJGh0dHBcclxuICAgICAqIEByZXF1aXJlcyAkaHR0cEJhY2tlbmRcclxuICAgICAqIEByZXF1aXJlcyAkYnJvd3NlclxyXG4gICAgICogQHJlcXVpcmVzICRjYWNoZUZhY3RvcnlcclxuICAgICAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXHJcbiAgICAgKiBAcmVxdWlyZXMgJHFcclxuICAgICAqIEByZXF1aXJlcyAkaW5qZWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFRoZSBgJGh0dHBgIHNlcnZpY2UgaXMgYSBjb3JlIEFuZ3VsYXIgc2VydmljZSB0aGF0IGZhY2lsaXRhdGVzIGNvbW11bmljYXRpb24gd2l0aCB0aGUgcmVtb3RlXHJcbiAgICAgKiBIVFRQIHNlcnZlcnMgdmlhIHRoZSBicm93c2VyJ3Mge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL3htbGh0dHByZXF1ZXN0XHJcbiAgICAgKiBYTUxIdHRwUmVxdWVzdH0gb2JqZWN0IG9yIHZpYSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KU09OUCBKU09OUH0uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHVuaXQgdGVzdGluZyBhcHBsaWNhdGlvbnMgdGhhdCB1c2UgYCRodHRwYCBzZXJ2aWNlLCBzZWVcclxuICAgICAqIHtAbGluayBuZ01vY2suJGh0dHBCYWNrZW5kICRodHRwQmFja2VuZCBtb2NrfS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgYSBoaWdoZXIgbGV2ZWwgb2YgYWJzdHJhY3Rpb24sIHBsZWFzZSBjaGVjayBvdXQgdGhlIHtAbGluayBuZ1Jlc291cmNlLiRyZXNvdXJjZVxyXG4gICAgICogJHJlc291cmNlfSBzZXJ2aWNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSAkaHR0cCBBUEkgaXMgYmFzZWQgb24gdGhlIHtAbGluayBuZy4kcSBkZWZlcnJlZC9wcm9taXNlIEFQSXN9IGV4cG9zZWQgYnlcclxuICAgICAqIHRoZSAkcSBzZXJ2aWNlLiBXaGlsZSBmb3Igc2ltcGxlIHVzYWdlIHBhdHRlcm5zIHRoaXMgZG9lc24ndCBtYXR0ZXIgbXVjaCwgZm9yIGFkdmFuY2VkIHVzYWdlXHJcbiAgICAgKiBpdCBpcyBpbXBvcnRhbnQgdG8gZmFtaWxpYXJpemUgeW91cnNlbGYgd2l0aCB0aGVzZSBBUElzIGFuZCB0aGUgZ3VhcmFudGVlcyB0aGV5IHByb3ZpZGUuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgR2VuZXJhbCB1c2FnZVxyXG4gICAgICogVGhlIGAkaHR0cGAgc2VydmljZSBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50IMOi4oKs4oCdIGEgY29uZmlndXJhdGlvbiBvYmplY3Qgw6LigqzigJ1cclxuICAgICAqIHRoYXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBhbiBIVFRQIHJlcXVlc3QgYW5kIHJldHVybnMgIGEge0BsaW5rIG5nLiRxIHByb21pc2V9XHJcbiAgICAgKiB3aXRoIHR3byAkaHR0cCBzcGVjaWZpYyBtZXRob2RzOiBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAuXHJcbiAgICAgKlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgJGh0dHAoe21ldGhvZDogJ0dFVCcsIHVybDogJy9zb21lVXJsJ30pLlxyXG4gICAgICogICAgIHN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcclxuICAgICAqICAgICAgIC8vIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHlcclxuICAgICAqICAgICAgIC8vIHdoZW4gdGhlIHJlc3BvbnNlIGlzIGF2YWlsYWJsZVxyXG4gICAgICogICAgIH0pLlxyXG4gICAgICogICAgIGVycm9yKGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XHJcbiAgICAgKiAgICAgICAvLyBjYWxsZWQgYXN5bmNocm9ub3VzbHkgaWYgYW4gZXJyb3Igb2NjdXJzXHJcbiAgICAgKiAgICAgICAvLyBvciBzZXJ2ZXIgcmV0dXJucyByZXNwb25zZSB3aXRoIGFuIGVycm9yIHN0YXR1cy5cclxuICAgICAqICAgICB9KTtcclxuICAgICAqIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIFNpbmNlIHRoZSByZXR1cm5lZCB2YWx1ZSBvZiBjYWxsaW5nIHRoZSAkaHR0cCBmdW5jdGlvbiBpcyBhIGBwcm9taXNlYCwgeW91IGNhbiBhbHNvIHVzZVxyXG4gICAgICogdGhlIGB0aGVuYCBtZXRob2QgdG8gcmVnaXN0ZXIgY2FsbGJhY2tzLCBhbmQgdGhlc2UgY2FsbGJhY2tzIHdpbGwgcmVjZWl2ZSBhIHNpbmdsZSBhcmd1bWVudCDDouKCrOKAnFxyXG4gICAgICogYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVzcG9uc2UuIFNlZSB0aGUgQVBJIHNpZ25hdHVyZSBhbmQgdHlwZSBpbmZvIGJlbG93IGZvciBtb3JlXHJcbiAgICAgKiBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqIEEgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgYmV0d2VlbiAyMDAgYW5kIDI5OSBpcyBjb25zaWRlcmVkIGEgc3VjY2VzcyBzdGF0dXMgYW5kXHJcbiAgICAgKiB3aWxsIHJlc3VsdCBpbiB0aGUgc3VjY2VzcyBjYWxsYmFjayBiZWluZyBjYWxsZWQuIE5vdGUgdGhhdCBpZiB0aGUgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCxcclxuICAgICAqIFhNTEh0dHBSZXF1ZXN0IHdpbGwgdHJhbnNwYXJlbnRseSBmb2xsb3cgaXQsIG1lYW5pbmcgdGhhdCB0aGUgZXJyb3IgY2FsbGJhY2sgd2lsbCBub3QgYmVcclxuICAgICAqIGNhbGxlZCBmb3Igc3VjaCByZXNwb25zZXMuXHJcbiAgICAgKlxyXG4gICAgICogIyBTaG9ydGN1dCBtZXRob2RzXHJcbiAgICAgKlxyXG4gICAgICogU2luY2UgYWxsIGludm9jYXRpb25zIG9mIHRoZSAkaHR0cCBzZXJ2aWNlIHJlcXVpcmUgcGFzc2luZyBpbiBhbiBIVFRQIG1ldGhvZCBhbmQgVVJMLCBhbmRcclxuICAgICAqIFBPU1QvUFVUIHJlcXVlc3RzIHJlcXVpcmUgcmVxdWVzdCBkYXRhIHRvIGJlIHByb3ZpZGVkIGFzIHdlbGwsIHNob3J0Y3V0IG1ldGhvZHNcclxuICAgICAqIHdlcmUgY3JlYXRlZDpcclxuICAgICAqXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICogICAkaHR0cC5nZXQoJy9zb21lVXJsJykuc3VjY2VzcyhzdWNjZXNzQ2FsbGJhY2spO1xyXG4gICAgICogICAkaHR0cC5wb3N0KCcvc29tZVVybCcsIGRhdGEpLnN1Y2Nlc3Moc3VjY2Vzc0NhbGxiYWNrKTtcclxuICAgICAqIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIENvbXBsZXRlIGxpc3Qgb2Ygc2hvcnRjdXQgbWV0aG9kczpcclxuICAgICAqXHJcbiAgICAgKiAtIHtAbGluayBuZy4kaHR0cCNnZXQgJGh0dHAuZ2V0fVxyXG4gICAgICogLSB7QGxpbmsgbmcuJGh0dHAjaGVhZCAkaHR0cC5oZWFkfVxyXG4gICAgICogLSB7QGxpbmsgbmcuJGh0dHAjcG9zdCAkaHR0cC5wb3N0fVxyXG4gICAgICogLSB7QGxpbmsgbmcuJGh0dHAjcHV0ICRodHRwLnB1dH1cclxuICAgICAqIC0ge0BsaW5rIG5nLiRodHRwI2RlbGV0ZSAkaHR0cC5kZWxldGV9XHJcbiAgICAgKiAtIHtAbGluayBuZy4kaHR0cCNqc29ucCAkaHR0cC5qc29ucH1cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogIyBTZXR0aW5nIEhUVFAgSGVhZGVyc1xyXG4gICAgICpcclxuICAgICAqIFRoZSAkaHR0cCBzZXJ2aWNlIHdpbGwgYXV0b21hdGljYWxseSBhZGQgY2VydGFpbiBIVFRQIGhlYWRlcnMgdG8gYWxsIHJlcXVlc3RzLiBUaGVzZSBkZWZhdWx0c1xyXG4gICAgICogY2FuIGJlIGZ1bGx5IGNvbmZpZ3VyZWQgYnkgYWNjZXNzaW5nIHRoZSBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzYCBjb25maWd1cmF0aW9uXHJcbiAgICAgKiBvYmplY3QsIHdoaWNoIGN1cnJlbnRseSBjb250YWlucyB0aGlzIGRlZmF1bHQgY29uZmlndXJhdGlvbjpcclxuICAgICAqXHJcbiAgICAgKiAtIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uYCAoaGVhZGVycyB0aGF0IGFyZSBjb21tb24gZm9yIGFsbCByZXF1ZXN0cyk6XHJcbiAgICAgKiAgIC0gYEFjY2VwdDogYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKiAvICpgXHJcbiAgICAgKiAtIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMucG9zdGA6IChoZWFkZXIgZGVmYXVsdHMgZm9yIFBPU1QgcmVxdWVzdHMpXHJcbiAgICAgKiAgIC0gYENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbmBcclxuICAgICAqIC0gYCRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5wdXRgIChoZWFkZXIgZGVmYXVsdHMgZm9yIFBVVCByZXF1ZXN0cylcclxuICAgICAqICAgLSBgQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uYFxyXG4gICAgICpcclxuICAgICAqIFRvIGFkZCBvciBvdmVyd3JpdGUgdGhlc2UgZGVmYXVsdHMsIHNpbXBseSBhZGQgb3IgcmVtb3ZlIGEgcHJvcGVydHkgZnJvbSB0aGVzZSBjb25maWd1cmF0aW9uXHJcbiAgICAgKiBvYmplY3RzLiBUbyBhZGQgaGVhZGVycyBmb3IgYW4gSFRUUCBtZXRob2Qgb3RoZXIgdGhhbiBQT1NUIG9yIFBVVCwgc2ltcGx5IGFkZCBhIG5ldyBvYmplY3RcclxuICAgICAqIHdpdGggdGhlIGxvd2VyY2FzZWQgSFRUUCBtZXRob2QgbmFtZSBhcyB0aGUga2V5LCBlLmcuXHJcbiAgICAgKiBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmdldFsnTXktSGVhZGVyJ109J3ZhbHVlJ2AuXHJcbiAgICAgKlxyXG4gICAgICogQWRkaXRpb25hbGx5LCB0aGUgZGVmYXVsdHMgY2FuIGJlIHNldCBhdCBydW50aW1lIHZpYSB0aGUgYCRodHRwLmRlZmF1bHRzYCBvYmplY3QgaW4gdGhlIHNhbWVcclxuICAgICAqIGZhc2hpb24uXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgVHJhbnNmb3JtaW5nIFJlcXVlc3RzIGFuZCBSZXNwb25zZXNcclxuICAgICAqXHJcbiAgICAgKiBCb3RoIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgY2FuIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRyYW5zZm9ybSBmdW5jdGlvbnMuIEJ5IGRlZmF1bHQsIEFuZ3VsYXJcclxuICAgICAqIGFwcGxpZXMgdGhlc2UgdHJhbnNmb3JtYXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIFJlcXVlc3QgdHJhbnNmb3JtYXRpb25zOlxyXG4gICAgICpcclxuICAgICAqIC0gSWYgdGhlIGBkYXRhYCBwcm9wZXJ0eSBvZiB0aGUgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWlucyBhbiBvYmplY3QsIHNlcmlhbGl6ZSBpdCBpbnRvXHJcbiAgICAgKiAgIEpTT04gZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIFJlc3BvbnNlIHRyYW5zZm9ybWF0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiAgLSBJZiBYU1JGIHByZWZpeCBpcyBkZXRlY3RlZCwgc3RyaXAgaXQgKHNlZSBTZWN1cml0eSBDb25zaWRlcmF0aW9ucyBzZWN0aW9uIGJlbG93KS5cclxuICAgICAqICAtIElmIEpTT04gcmVzcG9uc2UgaXMgZGV0ZWN0ZWQsIGRlc2VyaWFsaXplIGl0IHVzaW5nIGEgSlNPTiBwYXJzZXIuXHJcbiAgICAgKlxyXG4gICAgICogVG8gZ2xvYmFsbHkgYXVnbWVudCBvciBvdmVycmlkZSB0aGUgZGVmYXVsdCB0cmFuc2Zvcm1zLCBtb2RpZnkgdGhlIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLnRyYW5zZm9ybVJlcXVlc3RgIGFuZFxyXG4gICAgICogYCRodHRwUHJvdmlkZXIuZGVmYXVsdHMudHJhbnNmb3JtUmVzcG9uc2VgIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIGJ5IGRlZmF1bHQgYW5cclxuICAgICAqIGFycmF5IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMsIHdoaWNoIGFsbG93cyB5b3UgdG8gYHB1c2hgIG9yIGB1bnNoaWZ0YCBhIG5ldyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiBpbnRvIHRoZVxyXG4gICAgICogdHJhbnNmb3JtYXRpb24gY2hhaW4uIFlvdSBjYW4gYWxzbyBkZWNpZGUgdG8gY29tcGxldGVseSBvdmVycmlkZSBhbnkgZGVmYXVsdCB0cmFuc2Zvcm1hdGlvbnMgYnkgYXNzaWduaW5nIHlvdXJcclxuICAgICAqIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byB0aGVzZSBwcm9wZXJ0aWVzIGRpcmVjdGx5IHdpdGhvdXQgdGhlIGFycmF5IHdyYXBwZXIuXHJcbiAgICAgKlxyXG4gICAgICogU2ltaWxhcmx5LCB0byBsb2NhbGx5IG92ZXJyaWRlIHRoZSByZXF1ZXN0L3Jlc3BvbnNlIHRyYW5zZm9ybXMsIGF1Z21lbnQgdGhlIGB0cmFuc2Zvcm1SZXF1ZXN0YCBhbmQvb3JcclxuICAgICAqIGB0cmFuc2Zvcm1SZXNwb25zZWAgcHJvcGVydGllcyBvZiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcGFzc2VkIGludG8gYCRodHRwYC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogIyBDYWNoaW5nXHJcbiAgICAgKlxyXG4gICAgICogVG8gZW5hYmxlIGNhY2hpbmcsIHNldCB0aGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBgY2FjaGVgIHRvIGB0cnVlYC4gV2hlbiB0aGUgY2FjaGUgaXNcclxuICAgICAqIGVuYWJsZWQsIGAkaHR0cGAgc3RvcmVzIHRoZSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gbG9jYWwgY2FjaGUuIE5leHQgdGltZSB0aGVcclxuICAgICAqIHJlc3BvbnNlIGlzIHNlcnZlZCBmcm9tIHRoZSBjYWNoZSB3aXRob3V0IHNlbmRpbmcgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IGV2ZW4gaWYgdGhlIHJlc3BvbnNlIGlzIHNlcnZlZCBmcm9tIGNhY2hlLCBkZWxpdmVyeSBvZiB0aGUgZGF0YSBpcyBhc3luY2hyb25vdXMgaW5cclxuICAgICAqIHRoZSBzYW1lIHdheSB0aGF0IHJlYWwgcmVxdWVzdHMgYXJlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBHRVQgcmVxdWVzdHMgZm9yIHRoZSBzYW1lIFVSTCB0aGF0IHNob3VsZCBiZSBjYWNoZWQgdXNpbmcgdGhlIHNhbWVcclxuICAgICAqIGNhY2hlLCBidXQgdGhlIGNhY2hlIGlzIG5vdCBwb3B1bGF0ZWQgeWV0LCBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgd2lsbCBiZSBtYWRlIGFuZFxyXG4gICAgICogdGhlIHJlbWFpbmluZyByZXF1ZXN0cyB3aWxsIGJlIGZ1bGZpbGxlZCB1c2luZyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgZmlyc3QgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBBIGN1c3RvbSBkZWZhdWx0IGNhY2hlIGJ1aWx0IHdpdGggJGNhY2hlRmFjdG9yeSBjYW4gYmUgcHJvdmlkZWQgaW4gJGh0dHAuZGVmYXVsdHMuY2FjaGUuXHJcbiAgICAgKiBUbyBza2lwIGl0LCBzZXQgY29uZmlndXJhdGlvbiBwcm9wZXJ0eSBgY2FjaGVgIHRvIGBmYWxzZWAuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgSW50ZXJjZXB0b3JzXHJcbiAgICAgKlxyXG4gICAgICogQmVmb3JlIHlvdSBzdGFydCBjcmVhdGluZyBpbnRlcmNlcHRvcnMsIGJlIHN1cmUgdG8gdW5kZXJzdGFuZCB0aGVcclxuICAgICAqIHtAbGluayBuZy4kcSAkcSBhbmQgZGVmZXJyZWQvcHJvbWlzZSBBUElzfS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgcHVycG9zZXMgb2YgZ2xvYmFsIGVycm9yIGhhbmRsaW5nLCBhdXRoZW50aWNhdGlvbiwgb3IgYW55IGtpbmQgb2Ygc3luY2hyb25vdXMgb3JcclxuICAgICAqIGFzeW5jaHJvbm91cyBwcmUtcHJvY2Vzc2luZyBvZiByZXF1ZXN0IG9yIHBvc3Rwcm9jZXNzaW5nIG9mIHJlc3BvbnNlcywgaXQgaXMgZGVzaXJhYmxlIHRvIGJlXHJcbiAgICAgKiBhYmxlIHRvIGludGVyY2VwdCByZXF1ZXN0cyBiZWZvcmUgdGhleSBhcmUgaGFuZGVkIHRvIHRoZSBzZXJ2ZXIgYW5kXHJcbiAgICAgKiByZXNwb25zZXMgYmVmb3JlIHRoZXkgYXJlIGhhbmRlZCBvdmVyIHRvIHRoZSBhcHBsaWNhdGlvbiBjb2RlIHRoYXRcclxuICAgICAqIGluaXRpYXRlZCB0aGVzZSByZXF1ZXN0cy4gVGhlIGludGVyY2VwdG9ycyBsZXZlcmFnZSB0aGUge0BsaW5rIG5nLiRxXHJcbiAgICAgKiBwcm9taXNlIEFQSXN9IHRvIGZ1bGZpbGwgdGhpcyBuZWVkIGZvciBib3RoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcHJlLXByb2Nlc3NpbmcuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGludGVyY2VwdG9ycyBhcmUgc2VydmljZSBmYWN0b3JpZXMgdGhhdCBhcmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBgJGh0dHBQcm92aWRlcmAgYnlcclxuICAgICAqIGFkZGluZyB0aGVtIHRvIHRoZSBgJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnNgIGFycmF5LiBUaGUgZmFjdG9yeSBpcyBjYWxsZWQgYW5kXHJcbiAgICAgKiBpbmplY3RlZCB3aXRoIGRlcGVuZGVuY2llcyAoaWYgc3BlY2lmaWVkKSBhbmQgcmV0dXJucyB0aGUgaW50ZXJjZXB0b3IuXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmUgYXJlIHR3byBraW5kcyBvZiBpbnRlcmNlcHRvcnMgKGFuZCB0d28ga2luZHMgb2YgcmVqZWN0aW9uIGludGVyY2VwdG9ycyk6XHJcbiAgICAgKlxyXG4gICAgICogICAqIGByZXF1ZXN0YDogaW50ZXJjZXB0b3JzIGdldCBjYWxsZWQgd2l0aCBodHRwIGBjb25maWdgIG9iamVjdC4gVGhlIGZ1bmN0aW9uIGlzIGZyZWUgdG8gbW9kaWZ5XHJcbiAgICAgKiAgICAgdGhlIGBjb25maWdgIG9yIGNyZWF0ZSBhIG5ldyBvbmUuIFRoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gdGhlIGBjb25maWdgIGRpcmVjdGx5IG9yIGFzIGFcclxuICAgICAqICAgICBwcm9taXNlLlxyXG4gICAgICogICAqIGByZXF1ZXN0RXJyb3JgOiBpbnRlcmNlcHRvciBnZXRzIGNhbGxlZCB3aGVuIGEgcHJldmlvdXMgaW50ZXJjZXB0b3IgdGhyZXcgYW4gZXJyb3Igb3IgcmVzb2x2ZWRcclxuICAgICAqICAgICAgd2l0aCBhIHJlamVjdGlvbi5cclxuICAgICAqICAgKiBgcmVzcG9uc2VgOiBpbnRlcmNlcHRvcnMgZ2V0IGNhbGxlZCB3aXRoIGh0dHAgYHJlc3BvbnNlYCBvYmplY3QuIFRoZSBmdW5jdGlvbiBpcyBmcmVlIHRvIG1vZGlmeVxyXG4gICAgICogICAgIHRoZSBgcmVzcG9uc2VgIG9yIGNyZWF0ZSBhIG5ldyBvbmUuIFRoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gdGhlIGByZXNwb25zZWAgZGlyZWN0bHkgb3IgYXMgYVxyXG4gICAgICogICAgIHByb21pc2UuXHJcbiAgICAgKiAgICogYHJlc3BvbnNlRXJyb3JgOiBpbnRlcmNlcHRvciBnZXRzIGNhbGxlZCB3aGVuIGEgcHJldmlvdXMgaW50ZXJjZXB0b3IgdGhyZXcgYW4gZXJyb3Igb3IgcmVzb2x2ZWRcclxuICAgICAqICAgICAgd2l0aCBhIHJlamVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgLy8gcmVnaXN0ZXIgdGhlIGludGVyY2VwdG9yIGFzIGEgc2VydmljZVxyXG4gICAgICogICAkcHJvdmlkZS5mYWN0b3J5KCdteUh0dHBJbnRlcmNlcHRvcicsIGZ1bmN0aW9uKCRxLCBkZXBlbmRlbmN5MSwgZGVwZW5kZW5jeTIpIHtcclxuICAgICAqICAgICByZXR1cm4ge1xyXG4gICAgICogICAgICAgLy8gb3B0aW9uYWwgbWV0aG9kXHJcbiAgICAgKiAgICAgICAncmVxdWVzdCc6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gc3VjY2Vzc1xyXG4gICAgICogICAgICAgICByZXR1cm4gY29uZmlnIHx8ICRxLndoZW4oY29uZmlnKTtcclxuICAgICAqICAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gb3B0aW9uYWwgbWV0aG9kXHJcbiAgICAgKiAgICAgICdyZXF1ZXN0RXJyb3InOiBmdW5jdGlvbihyZWplY3Rpb24pIHtcclxuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXHJcbiAgICAgKiAgICAgICAgIGlmIChjYW5SZWNvdmVyKHJlamVjdGlvbikpIHtcclxuICAgICAqICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VPck5ld1Byb21pc2VcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlamVjdGlvbik7XHJcbiAgICAgKiAgICAgICB9LFxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gb3B0aW9uYWwgbWV0aG9kXHJcbiAgICAgKiAgICAgICAncmVzcG9uc2UnOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gc3VjY2Vzc1xyXG4gICAgICogICAgICAgICByZXR1cm4gcmVzcG9uc2UgfHwgJHEud2hlbihyZXNwb25zZSk7XHJcbiAgICAgKiAgICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxyXG4gICAgICogICAgICAncmVzcG9uc2VFcnJvcic6IGZ1bmN0aW9uKHJlamVjdGlvbikge1xyXG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gZXJyb3JcclxuICAgICAqICAgICAgICAgaWYgKGNhblJlY292ZXIocmVqZWN0aW9uKSkge1xyXG4gICAgICogICAgICAgICAgIHJldHVybiByZXNwb25zZU9yTmV3UHJvbWlzZVxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgICAgIHJldHVybiAkcS5yZWplY3QocmVqZWN0aW9uKTtcclxuICAgICAqICAgICAgIH07XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgICRodHRwUHJvdmlkZXIuaW50ZXJjZXB0b3JzLnB1c2goJ215SHR0cEludGVyY2VwdG9yJyk7XHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICAgLy8gcmVnaXN0ZXIgdGhlIGludGVyY2VwdG9yIHZpYSBhbiBhbm9ueW1vdXMgZmFjdG9yeVxyXG4gICAgICogICAkaHR0cFByb3ZpZGVyLmludGVyY2VwdG9ycy5wdXNoKGZ1bmN0aW9uKCRxLCBkZXBlbmRlbmN5MSwgZGVwZW5kZW5jeTIpIHtcclxuICAgICAqICAgICByZXR1cm4ge1xyXG4gICAgICogICAgICAncmVxdWVzdCc6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICogICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxyXG4gICAgICogICAgICAgfSxcclxuICAgICAqICAgICAgICdyZXNwb25zZSc6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgKiAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlXHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKlxyXG4gICAgICogIyBSZXNwb25zZSBpbnRlcmNlcHRvcnMgKERFUFJFQ0FURUQpXHJcbiAgICAgKlxyXG4gICAgICogQmVmb3JlIHlvdSBzdGFydCBjcmVhdGluZyBpbnRlcmNlcHRvcnMsIGJlIHN1cmUgdG8gdW5kZXJzdGFuZCB0aGVcclxuICAgICAqIHtAbGluayBuZy4kcSAkcSBhbmQgZGVmZXJyZWQvcHJvbWlzZSBBUElzfS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgcHVycG9zZXMgb2YgZ2xvYmFsIGVycm9yIGhhbmRsaW5nLCBhdXRoZW50aWNhdGlvbiBvciBhbnkga2luZCBvZiBzeW5jaHJvbm91cyBvclxyXG4gICAgICogYXN5bmNocm9ub3VzIHByZXByb2Nlc3Npbmcgb2YgcmVjZWl2ZWQgcmVzcG9uc2VzLCBpdCBpcyBkZXNpcmFibGUgdG8gYmUgYWJsZSB0byBpbnRlcmNlcHRcclxuICAgICAqIHJlc3BvbnNlcyBmb3IgaHR0cCByZXF1ZXN0cyBiZWZvcmUgdGhleSBhcmUgaGFuZGVkIG92ZXIgdG8gdGhlIGFwcGxpY2F0aW9uIGNvZGUgdGhhdFxyXG4gICAgICogaW5pdGlhdGVkIHRoZXNlIHJlcXVlc3RzLiBUaGUgcmVzcG9uc2UgaW50ZXJjZXB0b3JzIGxldmVyYWdlIHRoZSB7QGxpbmsgbmcuJHFcclxuICAgICAqIHByb21pc2UgYXBpc30gdG8gZnVsZmlsIHRoaXMgbmVlZCBmb3IgYm90aCBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHByZXByb2Nlc3NpbmcuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGludGVyY2VwdG9ycyBhcmUgc2VydmljZSBmYWN0b3JpZXMgdGhhdCBhcmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSAkaHR0cFByb3ZpZGVyIGJ5XHJcbiAgICAgKiBhZGRpbmcgdGhlbSB0byB0aGUgYCRodHRwUHJvdmlkZXIucmVzcG9uc2VJbnRlcmNlcHRvcnNgIGFycmF5LiBUaGUgZmFjdG9yeSBpcyBjYWxsZWQgYW5kXHJcbiAgICAgKiBpbmplY3RlZCB3aXRoIGRlcGVuZGVuY2llcyAoaWYgc3BlY2lmaWVkKSBhbmQgcmV0dXJucyB0aGUgaW50ZXJjZXB0b3IgIMOi4oKs4oCdIGEgZnVuY3Rpb24gdGhhdFxyXG4gICAgICogdGFrZXMgYSB7QGxpbmsgbmcuJHEgcHJvbWlzZX0gYW5kIHJldHVybnMgdGhlIG9yaWdpbmFsIG9yIGEgbmV3IHByb21pc2UuXHJcbiAgICAgKlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgLy8gcmVnaXN0ZXIgdGhlIGludGVyY2VwdG9yIGFzIGEgc2VydmljZVxyXG4gICAgICogICAkcHJvdmlkZS5mYWN0b3J5KCdteUh0dHBJbnRlcmNlcHRvcicsIGZ1bmN0aW9uKCRxLCBkZXBlbmRlbmN5MSwgZGVwZW5kZW5jeTIpIHtcclxuICAgICAqICAgICByZXR1cm4gZnVuY3Rpb24ocHJvbWlzZSkge1xyXG4gICAgICogICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gc3VjY2Vzc1xyXG4gICAgICogICAgICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICAgKiAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gZXJyb3JcclxuICAgICAqICAgICAgICAgaWYgKGNhblJlY292ZXIocmVzcG9uc2UpKSB7XHJcbiAgICAgKiAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlT3JOZXdQcm9taXNlXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgcmV0dXJuICRxLnJlamVjdChyZXNwb25zZSk7XHJcbiAgICAgKiAgICAgICB9KTtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICpcclxuICAgICAqICAgJGh0dHBQcm92aWRlci5yZXNwb25zZUludGVyY2VwdG9ycy5wdXNoKCdteUh0dHBJbnRlcmNlcHRvcicpO1xyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIHJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciB2aWEgYW4gYW5vbnltb3VzIGZhY3RvcnlcclxuICAgICAqICAgJGh0dHBQcm92aWRlci5yZXNwb25zZUludGVyY2VwdG9ycy5wdXNoKGZ1bmN0aW9uKCRxLCBkZXBlbmRlbmN5MSwgZGVwZW5kZW5jeTIpIHtcclxuICAgICAqICAgICByZXR1cm4gZnVuY3Rpb24ocHJvbWlzZSkge1xyXG4gICAgICogICAgICAgLy8gc2FtZSBhcyBhYm92ZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfSk7XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogIyBTZWN1cml0eSBDb25zaWRlcmF0aW9uc1xyXG4gICAgICpcclxuICAgICAqIFdoZW4gZGVzaWduaW5nIHdlYiBhcHBsaWNhdGlvbnMsIGNvbnNpZGVyIHNlY3VyaXR5IHRocmVhdHMgZnJvbTpcclxuICAgICAqXHJcbiAgICAgKiAtIHtAbGluayBodHRwOi8vaGFhY2tlZC5jb20vYXJjaGl2ZS8yMDA4LzExLzIwL2FuYXRvbXktb2YtYS1zdWJ0bGUtanNvbi12dWxuZXJhYmlsaXR5LmFzcHhcclxuICAgICAqICAgSlNPTiB2dWxuZXJhYmlsaXR5fVxyXG4gICAgICogLSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Dcm9zcy1zaXRlX3JlcXVlc3RfZm9yZ2VyeSBYU1JGfVxyXG4gICAgICpcclxuICAgICAqIEJvdGggc2VydmVyIGFuZCB0aGUgY2xpZW50IG11c3QgY29vcGVyYXRlIGluIG9yZGVyIHRvIGVsaW1pbmF0ZSB0aGVzZSB0aHJlYXRzLiBBbmd1bGFyIGNvbWVzXHJcbiAgICAgKiBwcmUtY29uZmlndXJlZCB3aXRoIHN0cmF0ZWdpZXMgdGhhdCBhZGRyZXNzIHRoZXNlIGlzc3VlcywgYnV0IGZvciB0aGlzIHRvIHdvcmsgYmFja2VuZCBzZXJ2ZXJcclxuICAgICAqIGNvb3BlcmF0aW9uIGlzIHJlcXVpcmVkLlxyXG4gICAgICpcclxuICAgICAqICMjIEpTT04gVnVsbmVyYWJpbGl0eSBQcm90ZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQSB7QGxpbmsgaHR0cDovL2hhYWNrZWQuY29tL2FyY2hpdmUvMjAwOC8xMS8yMC9hbmF0b215LW9mLWEtc3VidGxlLWpzb24tdnVsbmVyYWJpbGl0eS5hc3B4XHJcbiAgICAgKiBKU09OIHZ1bG5lcmFiaWxpdHl9IGFsbG93cyB0aGlyZCBwYXJ0eSB3ZWJzaXRlIHRvIHR1cm4geW91ciBKU09OIHJlc291cmNlIFVSTCBpbnRvXHJcbiAgICAgKiB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KU09OUCBKU09OUH0gcmVxdWVzdCB1bmRlciBzb21lIGNvbmRpdGlvbnMuIFRvXHJcbiAgICAgKiBjb3VudGVyIHRoaXMgeW91ciBzZXJ2ZXIgY2FuIHByZWZpeCBhbGwgSlNPTiByZXF1ZXN0cyB3aXRoIGZvbGxvd2luZyBzdHJpbmcgYFwiKV19JyxcXG5cImAuXHJcbiAgICAgKiBBbmd1bGFyIHdpbGwgYXV0b21hdGljYWxseSBzdHJpcCB0aGUgcHJlZml4IGJlZm9yZSBwcm9jZXNzaW5nIGl0IGFzIEpTT04uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUgaWYgeW91ciBzZXJ2ZXIgbmVlZHMgdG8gcmV0dXJuOlxyXG4gICAgICogPHByZT5cclxuICAgICAqIFsnb25lJywndHdvJ11cclxuICAgICAqIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIHdoaWNoIGlzIHZ1bG5lcmFibGUgdG8gYXR0YWNrLCB5b3VyIHNlcnZlciBjYW4gcmV0dXJuOlxyXG4gICAgICogPHByZT5cclxuICAgICAqICldfScsXHJcbiAgICAgKiBbJ29uZScsJ3R3byddXHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiBBbmd1bGFyIHdpbGwgc3RyaXAgdGhlIHByZWZpeCwgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIEpTT04uXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMjIENyb3NzIFNpdGUgUmVxdWVzdCBGb3JnZXJ5IChYU1JGKSBQcm90ZWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICoge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3Mtc2l0ZV9yZXF1ZXN0X2ZvcmdlcnkgWFNSRn0gaXMgYSB0ZWNobmlxdWUgYnkgd2hpY2hcclxuICAgICAqIGFuIHVuYXV0aG9yaXplZCBzaXRlIGNhbiBnYWluIHlvdXIgdXNlcidzIHByaXZhdGUgZGF0YS4gQW5ndWxhciBwcm92aWRlcyBhIG1lY2hhbmlzbVxyXG4gICAgICogdG8gY291bnRlciBYU1JGLiBXaGVuIHBlcmZvcm1pbmcgWEhSIHJlcXVlc3RzLCB0aGUgJGh0dHAgc2VydmljZSByZWFkcyBhIHRva2VuIGZyb20gYSBjb29raWVcclxuICAgICAqIChieSBkZWZhdWx0LCBgWFNSRi1UT0tFTmApIGFuZCBzZXRzIGl0IGFzIGFuIEhUVFAgaGVhZGVyIChgWC1YU1JGLVRPS0VOYCkuIFNpbmNlIG9ubHlcclxuICAgICAqIEphdmFTY3JpcHQgdGhhdCBydW5zIG9uIHlvdXIgZG9tYWluIGNvdWxkIHJlYWQgdGhlIGNvb2tpZSwgeW91ciBzZXJ2ZXIgY2FuIGJlIGFzc3VyZWQgdGhhdFxyXG4gICAgICogdGhlIFhIUiBjYW1lIGZyb20gSmF2YVNjcmlwdCBydW5uaW5nIG9uIHlvdXIgZG9tYWluLiBUaGUgaGVhZGVyIHdpbGwgbm90IGJlIHNldCBmb3JcclxuICAgICAqIGNyb3NzLWRvbWFpbiByZXF1ZXN0cy5cclxuICAgICAqXHJcbiAgICAgKiBUbyB0YWtlIGFkdmFudGFnZSBvZiB0aGlzLCB5b3VyIHNlcnZlciBuZWVkcyB0byBzZXQgYSB0b2tlbiBpbiBhIEphdmFTY3JpcHQgcmVhZGFibGUgc2Vzc2lvblxyXG4gICAgICogY29va2llIGNhbGxlZCBgWFNSRi1UT0tFTmAgb24gdGhlIGZpcnN0IEhUVFAgR0VUIHJlcXVlc3QuIE9uIHN1YnNlcXVlbnQgWEhSIHJlcXVlc3RzIHRoZVxyXG4gICAgICogc2VydmVyIGNhbiB2ZXJpZnkgdGhhdCB0aGUgY29va2llIG1hdGNoZXMgYFgtWFNSRi1UT0tFTmAgSFRUUCBoZWFkZXIsIGFuZCB0aGVyZWZvcmUgYmUgc3VyZVxyXG4gICAgICogdGhhdCBvbmx5IEphdmFTY3JpcHQgcnVubmluZyBvbiB5b3VyIGRvbWFpbiBjb3VsZCBoYXZlIHNlbnQgdGhlIHJlcXVlc3QuIFRoZSB0b2tlbiBtdXN0IGJlXHJcbiAgICAgKiB1bmlxdWUgZm9yIGVhY2ggdXNlciBhbmQgbXVzdCBiZSB2ZXJpZmlhYmxlIGJ5IHRoZSBzZXJ2ZXIgKHRvIHByZXZlbnQgdGhlIEphdmFTY3JpcHQgZnJvbSBtYWtpbmdcclxuICAgICAqIHVwIGl0cyBvd24gdG9rZW5zKS4gV2UgcmVjb21tZW5kIHRoYXQgdGhlIHRva2VuIGlzIGEgZGlnZXN0IG9mIHlvdXIgc2l0ZSdzIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBjb29raWUgd2l0aCBhIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TYWx0XyhjcnlwdG9ncmFwaHkpIHNhbHR9IGZvciBhZGRlZCBzZWN1cml0eS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaGVhZGVycyBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIHRoZSB4c3JmSGVhZGVyTmFtZSBhbmQgeHNyZkNvb2tpZU5hbWVcclxuICAgICAqIHByb3BlcnRpZXMgb2YgZWl0aGVyICRodHRwUHJvdmlkZXIuZGVmYXVsdHMsIG9yIHRoZSBwZXItcmVxdWVzdCBjb25maWcgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIE9iamVjdCBkZXNjcmliaW5nIHRoZSByZXF1ZXN0IHRvIGJlIG1hZGUgYW5kIGhvdyBpdCBzaG91bGQgYmVcclxuICAgICAqICAgIHByb2Nlc3NlZC4gVGhlIG9iamVjdCBoYXMgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKlxyXG4gICAgICogICAgLSAqKm1ldGhvZCoqIMOi4oKs4oCcIGB7c3RyaW5nfWAgw6LigqzigJwgSFRUUCBtZXRob2QgKGUuZy4gJ0dFVCcsICdQT1NUJywgZXRjKVxyXG4gICAgICogICAgLSAqKnVybCoqIMOi4oKs4oCcIGB7c3RyaW5nfWAgw6LigqzigJwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIG9mIHRoZSByZXNvdXJjZSB0aGF0IGlzIGJlaW5nIHJlcXVlc3RlZC5cclxuICAgICAqICAgIC0gKipwYXJhbXMqKiDDouKCrOKAnCBge09iamVjdC48c3RyaW5nfE9iamVjdD59YCDDouKCrOKAnCBNYXAgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHdoaWNoIHdpbGwgYmUgdHVybmVkIHRvXHJcbiAgICAgKiAgICAgIGA/a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTJgIGFmdGVyIHRoZSB1cmwuIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcsIGl0IHdpbGwgYmUgSlNPTmlmaWVkLlxyXG4gICAgICogICAgLSAqKmRhdGEqKiDDouKCrOKAnCBge3N0cmluZ3xPYmplY3R9YCDDouKCrOKAnCBEYXRhIHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QgbWVzc2FnZSBkYXRhLlxyXG4gICAgICogICAgLSAqKmhlYWRlcnMqKiDDouKCrOKAnCBge09iamVjdH1gIMOi4oKs4oCcIE1hcCBvZiBzdHJpbmdzIG9yIGZ1bmN0aW9ucyB3aGljaCByZXR1cm4gc3RyaW5ncyByZXByZXNlbnRpbmdcclxuICAgICAqICAgICAgSFRUUCBoZWFkZXJzIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gSWYgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIGlzIG51bGwsIHRoZSBoZWFkZXIgd2lsbFxyXG4gICAgICogICAgICBub3QgYmUgc2VudC5cclxuICAgICAqICAgIC0gKip4c3JmSGVhZGVyTmFtZSoqIMOi4oKs4oCcIGB7c3RyaW5nfWAgw6LigqzigJwgTmFtZSBvZiBIVFRQIGhlYWRlciB0byBwb3B1bGF0ZSB3aXRoIHRoZSBYU1JGIHRva2VuLlxyXG4gICAgICogICAgLSAqKnhzcmZDb29raWVOYW1lKiogw6LigqzigJwgYHtzdHJpbmd9YCDDouKCrOKAnCBOYW1lIG9mIGNvb2tpZSBjb250YWluaW5nIHRoZSBYU1JGIHRva2VuLlxyXG4gICAgICogICAgLSAqKnRyYW5zZm9ybVJlcXVlc3QqKiDDouKCrOKAnCBge2Z1bmN0aW9uKGRhdGEsIGhlYWRlcnNHZXR0ZXIpfEFycmF5LjxmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKT59YCDDouKCrOKAnFxyXG4gICAgICogICAgICB0cmFuc2Zvcm0gZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMuIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGFrZXMgdGhlIGh0dHBcclxuICAgICAqICAgICAgcmVxdWVzdCBib2R5IGFuZCBoZWFkZXJzIGFuZCByZXR1cm5zIGl0cyB0cmFuc2Zvcm1lZCAodHlwaWNhbGx5IHNlcmlhbGl6ZWQpIHZlcnNpb24uXHJcbiAgICAgKiAgICAtICoqdHJhbnNmb3JtUmVzcG9uc2UqKiDDouKCrOKAnCBge2Z1bmN0aW9uKGRhdGEsIGhlYWRlcnNHZXR0ZXIpfEFycmF5LjxmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKT59YCDDouKCrOKAnFxyXG4gICAgICogICAgICB0cmFuc2Zvcm0gZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMuIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGFrZXMgdGhlIGh0dHBcclxuICAgICAqICAgICAgcmVzcG9uc2UgYm9keSBhbmQgaGVhZGVycyBhbmQgcmV0dXJucyBpdHMgdHJhbnNmb3JtZWQgKHR5cGljYWxseSBkZXNlcmlhbGl6ZWQpIHZlcnNpb24uXHJcbiAgICAgKiAgICAtICoqY2FjaGUqKiDDouKCrOKAnCBge2Jvb2xlYW58Q2FjaGV9YCDDouKCrOKAnCBJZiB0cnVlLCBhIGRlZmF1bHQgJGh0dHAgY2FjaGUgd2lsbCBiZSB1c2VkIHRvIGNhY2hlIHRoZVxyXG4gICAgICogICAgICBHRVQgcmVxdWVzdCwgb3RoZXJ3aXNlIGlmIGEgY2FjaGUgaW5zdGFuY2UgYnVpbHQgd2l0aFxyXG4gICAgICogICAgICB7QGxpbmsgbmcuJGNhY2hlRmFjdG9yeSAkY2FjaGVGYWN0b3J5fSwgdGhpcyBjYWNoZSB3aWxsIGJlIHVzZWQgZm9yXHJcbiAgICAgKiAgICAgIGNhY2hpbmcuXHJcbiAgICAgKiAgICAtICoqdGltZW91dCoqIMOi4oKs4oCcIGB7bnVtYmVyfFByb21pc2V9YCDDouKCrOKAnCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcywgb3Ige0BsaW5rIG5nLiRxIHByb21pc2V9XHJcbiAgICAgKiAgICAgIHRoYXQgc2hvdWxkIGFib3J0IHRoZSByZXF1ZXN0IHdoZW4gcmVzb2x2ZWQuXHJcbiAgICAgKiAgICAtICoqd2l0aENyZWRlbnRpYWxzKiogLSBge2Jvb2xlYW59YCAtIHdoZXRoZXIgdG8gdG8gc2V0IHRoZSBgd2l0aENyZWRlbnRpYWxzYCBmbGFnIG9uIHRoZVxyXG4gICAgICogICAgICBYSFIgb2JqZWN0LiBTZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2h0dHBfYWNjZXNzX2NvbnRyb2wjc2VjdGlvbl81XHJcbiAgICAgKiAgICAgIHJlcXVlc3RzIHdpdGggY3JlZGVudGlhbHN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogICAgLSAqKnJlc3BvbnNlVHlwZSoqIC0gYHtzdHJpbmd9YCAtIHNlZSB7QGxpbmtcclxuICAgICAqICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vWE1MSHR0cFJlcXVlc3QjcmVzcG9uc2VUeXBlIHJlcXVlc3RUeXBlfS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IFJldHVybnMgYSB7QGxpbmsgbmcuJHEgcHJvbWlzZX0gb2JqZWN0IHdpdGggdGhlXHJcbiAgICAgKiAgIHN0YW5kYXJkIGB0aGVuYCBtZXRob2QgYW5kIHR3byBodHRwIHNwZWNpZmljIG1ldGhvZHM6IGBzdWNjZXNzYCBhbmQgYGVycm9yYC4gVGhlIGB0aGVuYFxyXG4gICAgICogICBtZXRob2QgdGFrZXMgdHdvIGFyZ3VtZW50cyBhIHN1Y2Nlc3MgYW5kIGFuIGVycm9yIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYVxyXG4gICAgICogICByZXNwb25zZSBvYmplY3QuIFRoZSBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgbWV0aG9kcyB0YWtlIGEgc2luZ2xlIGFyZ3VtZW50IC0gYSBmdW5jdGlvbiB0aGF0XHJcbiAgICAgKiAgIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3Qgc3VjY2VlZHMgb3IgZmFpbHMgcmVzcGVjdGl2ZWx5LiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvXHJcbiAgICAgKiAgIHRoZXNlIGZ1bmN0aW9ucyBhcmUgZGVzdHJ1Y3R1cmVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXNwb25zZSBvYmplY3QgcGFzc2VkIGludG8gdGhlXHJcbiAgICAgKiAgIGB0aGVuYCBtZXRob2QuIFRoZSByZXNwb25zZSBvYmplY3QgaGFzIHRoZXNlIHByb3BlcnRpZXM6XHJcbiAgICAgKlxyXG4gICAgICogICAtICoqZGF0YSoqIMOi4oKs4oCcIGB7c3RyaW5nfE9iamVjdH1gIMOi4oKs4oCcIFRoZSByZXNwb25zZSBib2R5IHRyYW5zZm9ybWVkIHdpdGggdGhlIHRyYW5zZm9ybSBmdW5jdGlvbnMuXHJcbiAgICAgKiAgIC0gKipzdGF0dXMqKiDDouKCrOKAnCBge251bWJlcn1gIMOi4oKs4oCcIEhUVFAgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlLlxyXG4gICAgICogICAtICoqaGVhZGVycyoqIMOi4oKs4oCcIGB7ZnVuY3Rpb24oW2hlYWRlck5hbWVdKX1gIMOi4oKs4oCcIEhlYWRlciBnZXR0ZXIgZnVuY3Rpb24uXHJcbiAgICAgKiAgIC0gKipjb25maWcqKiDDouKCrOKAnCBge09iamVjdH1gIMOi4oKs4oCcIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE9iamVjdD59IHBlbmRpbmdSZXF1ZXN0cyBBcnJheSBvZiBjb25maWcgb2JqZWN0cyBmb3IgY3VycmVudGx5IHBlbmRpbmdcclxuICAgICAqICAgcmVxdWVzdHMuIFRoaXMgaXMgcHJpbWFyaWx5IG1lYW50IHRvIGJlIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAgPGV4YW1wbGU+XHJcbiAgICAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkZldGNoQ3RybFwiPlxyXG4gICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwibWV0aG9kXCI+XHJcbiAgICAgICAgICAgICAgPG9wdGlvbj5HRVQ8L29wdGlvbj5cclxuICAgICAgICAgICAgICA8b3B0aW9uPkpTT05QPC9vcHRpb24+XHJcbiAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInVybFwiIHNpemU9XCI4MFwiLz5cclxuICAgICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cImZldGNoKClcIj5mZXRjaDwvYnV0dG9uPjxicj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cInVwZGF0ZU1vZGVsKCdHRVQnLCAnaHR0cC1oZWxsby5odG1sJylcIj5TYW1wbGUgR0VUPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCJ1cGRhdGVNb2RlbCgnSlNPTlAnLCAnaHR0cDovL2FuZ3VsYXJqcy5vcmcvZ3JlZXQucGhwP2NhbGxiYWNrPUpTT05fQ0FMTEJBQ0smbmFtZT1TdXBlciUyMEhlcm8nKVwiPlNhbXBsZSBKU09OUDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIG5nLWNsaWNrPVwidXBkYXRlTW9kZWwoJ0pTT05QJywgJ2h0dHA6Ly9hbmd1bGFyanMub3JnL2RvZXNudGV4aXN0JmNhbGxiYWNrPUpTT05fQ0FMTEJBQ0snKVwiPkludmFsaWQgSlNPTlA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPHByZT5odHRwIHN0YXR1cyBjb2RlOiB7e3N0YXR1c319PC9wcmU+XHJcbiAgICAgICAgICAgIDxwcmU+aHR0cCByZXNwb25zZSBkYXRhOiB7e2RhdGF9fTwvcHJlPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9maWxlPlxyXG4gICAgICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cclxuICAgICAgICAgIGZ1bmN0aW9uIEZldGNoQ3RybCgkc2NvcGUsICRodHRwLCAkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAgICAgICAkc2NvcGUubWV0aG9kID0gJ0dFVCc7XHJcbiAgICAgICAgICAgICRzY29wZS51cmwgPSAnaHR0cC1oZWxsby5odG1sJztcclxuXHJcbiAgICAgICAgICAgICRzY29wZS5mZXRjaCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAkc2NvcGUucmVzcG9uc2UgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAkaHR0cCh7bWV0aG9kOiAkc2NvcGUubWV0aG9kLCB1cmw6ICRzY29wZS51cmwsIGNhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLlxyXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhmdW5jdGlvbihkYXRhLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfSkuXHJcbiAgICAgICAgICAgICAgICBlcnJvcihmdW5jdGlvbihkYXRhLCBzdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEgPSBkYXRhIHx8IFwiUmVxdWVzdCBmYWlsZWRcIjtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICRzY29wZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICAgICAgICAkc2NvcGUudXJsID0gdXJsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIDwvZmlsZT5cclxuICAgICAgICA8ZmlsZSBuYW1lPVwiaHR0cC1oZWxsby5odG1sXCI+XHJcbiAgICAgICAgICBIZWxsbywgJGh0dHAhXHJcbiAgICAgICAgPC9maWxlPlxyXG4gICAgICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBtYWtlIGFuIHhociBHRVQgcmVxdWVzdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbGVtZW50KCc6YnV0dG9uOmNvbnRhaW5zKFwiU2FtcGxlIEdFVFwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQoJzpidXR0b246Y29udGFpbnMoXCJmZXRjaFwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdzdGF0dXMnKSkudG9CZSgnMjAwJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdkYXRhJykpLnRvTWF0Y2goL0hlbGxvLCBcXCRodHRwIS8pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBtYWtlIGEgSlNPTlAgcmVxdWVzdCB0byBhbmd1bGFyanMub3JnJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQoJzpidXR0b246Y29udGFpbnMoXCJTYW1wbGUgSlNPTlBcIiknKS5jbGljaygpO1xyXG4gICAgICAgICAgICBlbGVtZW50KCc6YnV0dG9uOmNvbnRhaW5zKFwiZmV0Y2hcIiknKS5jbGljaygpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnc3RhdHVzJykpLnRvQmUoJzIwMCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnZGF0YScpKS50b01hdGNoKC9TdXBlciBIZXJvIS8pO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBtYWtlIEpTT05QIHJlcXVlc3QgdG8gaW52YWxpZCBVUkwgYW5kIGludm9rZSB0aGUgZXJyb3IgaGFuZGxlcicsXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQoJzpidXR0b246Y29udGFpbnMoXCJJbnZhbGlkIEpTT05QXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcImZldGNoXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3N0YXR1cycpKS50b0JlKCcwJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdkYXRhJykpLnRvQmUoJ1JlcXVlc3QgZmFpbGVkJyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICA8L2ZpbGU+XHJcbiAgICAgIDwvZXhhbXBsZT5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gJGh0dHAocmVxdWVzdENvbmZpZykge1xyXG4gICAgICB2YXIgY29uZmlnID0ge1xyXG4gICAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGRlZmF1bHRzLnRyYW5zZm9ybVJlcXVlc3QsXHJcbiAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRzLnRyYW5zZm9ybVJlc3BvbnNlXHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBoZWFkZXJzID0gbWVyZ2VIZWFkZXJzKHJlcXVlc3RDb25maWcpO1xyXG5cclxuICAgICAgZXh0ZW5kKGNvbmZpZywgcmVxdWVzdENvbmZpZyk7XHJcbiAgICAgIGNvbmZpZy5oZWFkZXJzID0gaGVhZGVycztcclxuICAgICAgY29uZmlnLm1ldGhvZCA9IHVwcGVyY2FzZShjb25maWcubWV0aG9kKTtcclxuXHJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAkJHVybFV0aWxzLmlzU2FtZU9yaWdpbihjb25maWcudXJsKVxyXG4gICAgICAgICAgPyAkYnJvd3Nlci5jb29raWVzKClbY29uZmlnLnhzcmZDb29raWVOYW1lIHx8IGRlZmF1bHRzLnhzcmZDb29raWVOYW1lXVxyXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcclxuICAgICAgICBoZWFkZXJzWyhjb25maWcueHNyZkhlYWRlck5hbWUgfHwgZGVmYXVsdHMueHNyZkhlYWRlck5hbWUpXSA9IHhzcmZWYWx1ZTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHZhciBzZXJ2ZXJSZXF1ZXN0ID0gZnVuY3Rpb24oY29uZmlnKSB7XHJcbiAgICAgICAgaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xyXG4gICAgICAgIHZhciByZXFEYXRhID0gdHJhbnNmb3JtRGF0YShjb25maWcuZGF0YSwgaGVhZGVyc0dldHRlcihoZWFkZXJzKSwgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3QpO1xyXG5cclxuICAgICAgICAvLyBzdHJpcCBjb250ZW50LXR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoY29uZmlnLmRhdGEpKSB7XHJcbiAgICAgICAgICBmb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBoZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZShoZWFkZXIpID09PSAnY29udGVudC10eXBlJykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykgJiYgIWlzVW5kZWZpbmVkKGRlZmF1bHRzLndpdGhDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgIGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgPSBkZWZhdWx0cy53aXRoQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzZW5kIHJlcXVlc3RcclxuICAgICAgICByZXR1cm4gc2VuZFJlcShjb25maWcsIHJlcURhdGEsIGhlYWRlcnMpLnRoZW4odHJhbnNmb3JtUmVzcG9uc2UsIHRyYW5zZm9ybVJlc3BvbnNlKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBjaGFpbiA9IFtzZXJ2ZXJSZXF1ZXN0LCB1bmRlZmluZWRdO1xyXG4gICAgICB2YXIgcHJvbWlzZSA9ICRxLndoZW4oY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIGFwcGx5IGludGVyY2VwdG9yc1xyXG4gICAgICBmb3JFYWNoKHJldmVyc2VkSW50ZXJjZXB0b3JzLCBmdW5jdGlvbihpbnRlcmNlcHRvcikge1xyXG4gICAgICAgIGlmIChpbnRlcmNlcHRvci5yZXF1ZXN0IHx8IGludGVyY2VwdG9yLnJlcXVlc3RFcnJvcikge1xyXG4gICAgICAgICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5yZXF1ZXN0LCBpbnRlcmNlcHRvci5yZXF1ZXN0RXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50ZXJjZXB0b3IucmVzcG9uc2UgfHwgaW50ZXJjZXB0b3IucmVzcG9uc2VFcnJvcikge1xyXG4gICAgICAgICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5yZXNwb25zZSwgaW50ZXJjZXB0b3IucmVzcG9uc2VFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHdoaWxlKGNoYWluLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciB0aGVuRm4gPSBjaGFpbi5zaGlmdCgpO1xyXG4gICAgICAgIHZhciByZWplY3RGbiA9IGNoYWluLnNoaWZ0KCk7XHJcblxyXG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4odGhlbkZuLCByZWplY3RGbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHByb21pc2Uuc3VjY2VzcyA9IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICBmbihyZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMsIGNvbmZpZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBwcm9taXNlLmVycm9yID0gZnVuY3Rpb24oZm4pIHtcclxuICAgICAgICBwcm9taXNlLnRoZW4obnVsbCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgIGZuKHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuaGVhZGVycywgY29uZmlnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBwcm9taXNlO1xyXG5cclxuICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgICAgICAvLyBtYWtlIGEgY29weSBzaW5jZSB0aGUgcmVzcG9uc2UgbXVzdCBiZSBjYWNoZWFibGVcclxuICAgICAgICB2YXIgcmVzcCA9IGV4dGVuZCh7fSwgcmVzcG9uc2UsIHtcclxuICAgICAgICAgIGRhdGE6IHRyYW5zZm9ybURhdGEocmVzcG9uc2UuZGF0YSwgcmVzcG9uc2UuaGVhZGVycywgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoaXNTdWNjZXNzKHJlc3BvbnNlLnN0YXR1cykpXHJcbiAgICAgICAgICA/IHJlc3BcclxuICAgICAgICAgIDogJHEucmVqZWN0KHJlc3ApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBtZXJnZUhlYWRlcnMoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGRlZkhlYWRlcnMgPSBkZWZhdWx0cy5oZWFkZXJzLFxyXG4gICAgICAgICAgICByZXFIZWFkZXJzID0gZXh0ZW5kKHt9LCBjb25maWcuaGVhZGVycyksXHJcbiAgICAgICAgICAgIGRlZkhlYWRlck5hbWUsIGxvd2VyY2FzZURlZkhlYWRlck5hbWUsIHJlcUhlYWRlck5hbWU7XHJcblxyXG4gICAgICAgIGRlZkhlYWRlcnMgPSBleHRlbmQoe30sIGRlZkhlYWRlcnMuY29tbW9uLCBkZWZIZWFkZXJzW2xvd2VyY2FzZShjb25maWcubWV0aG9kKV0pO1xyXG5cclxuICAgICAgICAvLyBleGVjdXRlIGlmIGhlYWRlciB2YWx1ZSBpcyBmdW5jdGlvblxyXG4gICAgICAgIGV4ZWNIZWFkZXJzKGRlZkhlYWRlcnMpO1xyXG4gICAgICAgIGV4ZWNIZWFkZXJzKHJlcUhlYWRlcnMpO1xyXG5cclxuICAgICAgICAvLyB1c2luZyBmb3ItaW4gaW5zdGVhZCBvZiBmb3JFYWNoIHRvIGF2b2lkIHVuZWNlc3NhcnkgaXRlcmF0aW9uIGFmdGVyIGhlYWRlciBoYXMgYmVlbiBmb3VuZFxyXG4gICAgICAgIGRlZmF1bHRIZWFkZXJzSXRlcmF0aW9uOlxyXG4gICAgICAgIGZvciAoZGVmSGVhZGVyTmFtZSBpbiBkZWZIZWFkZXJzKSB7XHJcbiAgICAgICAgICBsb3dlcmNhc2VEZWZIZWFkZXJOYW1lID0gbG93ZXJjYXNlKGRlZkhlYWRlck5hbWUpO1xyXG5cclxuICAgICAgICAgIGZvciAocmVxSGVhZGVyTmFtZSBpbiByZXFIZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChsb3dlcmNhc2UocmVxSGVhZGVyTmFtZSkgPT09IGxvd2VyY2FzZURlZkhlYWRlck5hbWUpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZSBkZWZhdWx0SGVhZGVyc0l0ZXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJlcUhlYWRlcnNbZGVmSGVhZGVyTmFtZV0gPSBkZWZIZWFkZXJzW2RlZkhlYWRlck5hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcUhlYWRlcnM7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWNIZWFkZXJzKGhlYWRlcnMpIHtcclxuICAgICAgICAgIHZhciBoZWFkZXJDb250ZW50O1xyXG5cclxuICAgICAgICAgIGZvckVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyRm4sIGhlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoZWFkZXJGbikpIHtcclxuICAgICAgICAgICAgICBoZWFkZXJDb250ZW50ID0gaGVhZGVyRm4oKTtcclxuICAgICAgICAgICAgICBpZiAoaGVhZGVyQ29udGVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlcl0gPSBoZWFkZXJDb250ZW50O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgJGh0dHAucGVuZGluZ1JlcXVlc3RzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNnZXRcclxuICAgICAqIEBtZXRob2RPZiBuZy4kaHR0cFxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRjdXQgbWV0aG9kIHRvIHBlcmZvcm0gYEdFVGAgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNkZWxldGVcclxuICAgICAqIEBtZXRob2RPZiBuZy4kaHR0cFxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRjdXQgbWV0aG9kIHRvIHBlcmZvcm0gYERFTEVURWAgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNoZWFkXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBIRUFEYCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgUmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMIHNwZWNpZnlpbmcgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBGdXR1cmUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRodHRwI2pzb25wXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBKU09OUGAgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgU2hvdWxkIGNvbnRhaW4gYEpTT05fQ0FMTEJBQ0tgIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgY3JlYXRlU2hvcnRNZXRob2RzKCdnZXQnLCAnZGVsZXRlJywgJ2hlYWQnLCAnanNvbnAnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRodHRwI3Bvc3RcclxuICAgICAqIEBtZXRob2RPZiBuZy4kaHR0cFxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRjdXQgbWV0aG9kIHRvIHBlcmZvcm0gYFBPU1RgIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBSZXF1ZXN0IGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJGh0dHAjcHV0XHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBQVVRgIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBSZXF1ZXN0IGNvbnRlbnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgY3JlYXRlU2hvcnRNZXRob2RzV2l0aERhdGEoJ3Bvc3QnLCAncHV0Jyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gICAgICAgICAqIEBuYW1lIG5nLiRodHRwI2RlZmF1bHRzXHJcbiAgICAgICAgICogQHByb3BlcnR5T2YgbmcuJGh0dHBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqIFJ1bnRpbWUgZXF1aXZhbGVudCBvZiB0aGUgYCRodHRwUHJvdmlkZXIuZGVmYXVsdHNgIHByb3BlcnR5LiBBbGxvd3MgY29uZmlndXJhdGlvbiBvZlxyXG4gICAgICAgICAqIGRlZmF1bHQgaGVhZGVycywgd2l0aENyZWRlbnRpYWxzIGFzIHdlbGwgYXMgcmVxdWVzdCBhbmQgcmVzcG9uc2UgdHJhbnNmb3JtYXRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogU2VlIFwiU2V0dGluZyBIVFRQIEhlYWRlcnNcIiBhbmQgXCJUcmFuc2Zvcm1pbmcgUmVxdWVzdHMgYW5kIFJlc3BvbnNlc1wiIHNlY3Rpb25zIGFib3ZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgJGh0dHAuZGVmYXVsdHMgPSBkZWZhdWx0cztcclxuXHJcblxyXG4gICAgcmV0dXJuICRodHRwO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTaG9ydE1ldGhvZHMobmFtZXMpIHtcclxuICAgICAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAkaHR0cFtuYW1lXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XHJcbiAgICAgICAgICByZXR1cm4gJGh0dHAoZXh0ZW5kKGNvbmZpZyB8fCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IG5hbWUsXHJcbiAgICAgICAgICAgIHVybDogdXJsXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNob3J0TWV0aG9kc1dpdGhEYXRhKG5hbWUpIHtcclxuICAgICAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAkaHR0cFtuYW1lXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XHJcbiAgICAgICAgICByZXR1cm4gJGh0dHAoZXh0ZW5kKGNvbmZpZyB8fCB7fSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IG5hbWUsXHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgdGhlIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogISEhIEFDQ0VTU0VTIENMT1NVUkUgVkFSUzpcclxuICAgICAqICRodHRwQmFja2VuZCwgZGVmYXVsdHMsICRsb2csICRyb290U2NvcGUsIGRlZmF1bHRDYWNoZSwgJGh0dHAucGVuZGluZ1JlcXVlc3RzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNlbmRSZXEoY29uZmlnLCByZXFEYXRhLCByZXFIZWFkZXJzKSB7XHJcbiAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXHJcbiAgICAgICAgICBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSxcclxuICAgICAgICAgIGNhY2hlLFxyXG4gICAgICAgICAgY2FjaGVkUmVzcCxcclxuICAgICAgICAgIHVybCA9IGJ1aWxkVXJsKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMpO1xyXG5cclxuICAgICAgJGh0dHAucGVuZGluZ1JlcXVlc3RzLnB1c2goY29uZmlnKTtcclxuICAgICAgcHJvbWlzZS50aGVuKHJlbW92ZVBlbmRpbmdSZXEsIHJlbW92ZVBlbmRpbmdSZXEpO1xyXG5cclxuXHJcbiAgICAgIGlmICgoY29uZmlnLmNhY2hlIHx8IGRlZmF1bHRzLmNhY2hlKSAmJiBjb25maWcuY2FjaGUgIT09IGZhbHNlICYmIGNvbmZpZy5tZXRob2QgPT0gJ0dFVCcpIHtcclxuICAgICAgICBjYWNoZSA9IGlzT2JqZWN0KGNvbmZpZy5jYWNoZSkgPyBjb25maWcuY2FjaGVcclxuICAgICAgICAgICAgICA6IGlzT2JqZWN0KGRlZmF1bHRzLmNhY2hlKSA/IGRlZmF1bHRzLmNhY2hlXHJcbiAgICAgICAgICAgICAgOiBkZWZhdWx0Q2FjaGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlZFJlc3AgPSBjYWNoZS5nZXQodXJsKTtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGNhY2hlZFJlc3ApKSB7XHJcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzcC50aGVuKSB7XHJcbiAgICAgICAgICAgIC8vIGNhY2hlZCByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gc2VudCwgYnV0IHRoZXJlIGlzIG5vIHJlc3BvbnNlIHlldFxyXG4gICAgICAgICAgICBjYWNoZWRSZXNwLnRoZW4ocmVtb3ZlUGVuZGluZ1JlcSwgcmVtb3ZlUGVuZGluZ1JlcSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXNwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc2VydmluZyBmcm9tIGNhY2hlXHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGNhY2hlZFJlc3ApKSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoY2FjaGVkUmVzcFsxXSwgY2FjaGVkUmVzcFswXSwgY29weShjYWNoZWRSZXNwWzJdKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoY2FjaGVkUmVzcCwgMjAwLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gcHV0IHRoZSBwcm9taXNlIGZvciB0aGUgbm9uLXRyYW5zZm9ybWVkIHJlc3BvbnNlIGludG8gY2FjaGUgYXMgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgY2FjaGUucHV0KHVybCwgcHJvbWlzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiB3ZSB3b24ndCBoYXZlIHRoZSByZXNwb25zZSBpbiBjYWNoZSwgc2VuZCB0aGUgcmVxdWVzdCB0byB0aGUgYmFja2VuZFxyXG4gICAgICBpZiAoaXNVbmRlZmluZWQoY2FjaGVkUmVzcCkpIHtcclxuICAgICAgICAkaHR0cEJhY2tlbmQoY29uZmlnLm1ldGhvZCwgdXJsLCByZXFEYXRhLCBkb25lLCByZXFIZWFkZXJzLCBjb25maWcudGltZW91dCxcclxuICAgICAgICAgICAgY29uZmlnLndpdGhDcmVkZW50aWFscywgY29uZmlnLnJlc3BvbnNlVHlwZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwcm9taXNlO1xyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHRvICRodHRwQmFja2VuZCgpOlxyXG4gICAgICAgKiAgLSBjYWNoZXMgdGhlIHJlc3BvbnNlIGlmIGRlc2lyZWRcclxuICAgICAgICogIC0gcmVzb2x2ZXMgdGhlIHJhdyAkaHR0cCBwcm9taXNlXHJcbiAgICAgICAqICAtIGNhbGxzICRhcHBseVxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gZG9uZShzdGF0dXMsIHJlc3BvbnNlLCBoZWFkZXJzU3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgICBpZiAoaXNTdWNjZXNzKHN0YXR1cykpIHtcclxuICAgICAgICAgICAgY2FjaGUucHV0KHVybCwgW3N0YXR1cywgcmVzcG9uc2UsIHBhcnNlSGVhZGVycyhoZWFkZXJzU3RyaW5nKV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHByb21pc2UgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICAgICAgY2FjaGUucmVtb3ZlKHVybCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXNvbHZlUHJvbWlzZShyZXNwb25zZSwgc3RhdHVzLCBoZWFkZXJzU3RyaW5nKTtcclxuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkgJHJvb3RTY29wZS4kYXBwbHkoKTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZXNvbHZlcyB0aGUgcmF3ICRodHRwIHByb21pc2UuXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZShyZXNwb25zZSwgc3RhdHVzLCBoZWFkZXJzKSB7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIGludGVybmFsIHN0YXR1c2VzIHRvIDBcclxuICAgICAgICBzdGF0dXMgPSBNYXRoLm1heChzdGF0dXMsIDApO1xyXG5cclxuICAgICAgICAoaXNTdWNjZXNzKHN0YXR1cykgPyBkZWZlcnJlZC5yZXNvbHZlIDogZGVmZXJyZWQucmVqZWN0KSh7XHJcbiAgICAgICAgICBkYXRhOiByZXNwb25zZSxcclxuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxyXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVyc0dldHRlcihoZWFkZXJzKSxcclxuICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiByZW1vdmVQZW5kaW5nUmVxKCkge1xyXG4gICAgICAgIHZhciBpZHggPSBpbmRleE9mKCRodHRwLnBlbmRpbmdSZXF1ZXN0cywgY29uZmlnKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkgJGh0dHAucGVuZGluZ1JlcXVlc3RzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVXJsKHVybCwgcGFyYW1zKSB7XHJcbiAgICAgICAgICBpZiAoIXBhcmFtcykgcmV0dXJuIHVybDtcclxuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgZm9yRWFjaFNvcnRlZChwYXJhbXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT0gdW5kZWZpbmVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gW3ZhbHVlXTtcclxuXHJcbiAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodikpIHtcclxuICAgICAgICAgICAgICAgIHYgPSB0b0pzb24odik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVXJpUXVlcnkoa2V5KSArICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVcmlRdWVyeSh2KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gdXJsICsgKCh1cmwuaW5kZXhPZignPycpID09IC0xKSA/ICc/JyA6ICcmJykgKyBwYXJ0cy5qb2luKCcmJyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgfV07XHJcbn1cclxuXHJcbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFAuNi4wXCIpOyB9IGNhdGNoIChlMSkge31cclxuICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUC4zLjBcIik7IH0gY2F0Y2ggKGUyKSB7fVxyXG4gIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpOyB9IGNhdGNoIChlMykge31cclxuICB0aHJvdyBtaW5FcnIoJyRodHRwQmFja2VuZCcpKCdub3hocicsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QuXCIpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRodHRwQmFja2VuZFxyXG4gKiBAcmVxdWlyZXMgJGJyb3dzZXJcclxuICogQHJlcXVpcmVzICR3aW5kb3dcclxuICogQHJlcXVpcmVzICRkb2N1bWVudFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogSFRUUCBiYWNrZW5kIHVzZWQgYnkgdGhlIHtAbGluayBuZy4kaHR0cCBzZXJ2aWNlfSB0aGF0IGRlbGVnYXRlcyB0b1xyXG4gKiBYTUxIdHRwUmVxdWVzdCBvYmplY3Qgb3IgSlNPTlAgYW5kIGRlYWxzIHdpdGggYnJvd3NlciBpbmNvbXBhdGliaWxpdGllcy5cclxuICpcclxuICogWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIHVzZSB0aGlzIHNlcnZpY2UgZGlyZWN0bHksIGluc3RlYWQgdXNlIHRoZSBoaWdoZXItbGV2ZWwgYWJzdHJhY3Rpb25zOlxyXG4gKiB7QGxpbmsgbmcuJGh0dHAgJGh0dHB9IG9yIHtAbGluayBuZ1Jlc291cmNlLiRyZXNvdXJjZSAkcmVzb3VyY2V9LlxyXG4gKlxyXG4gKiBEdXJpbmcgdGVzdGluZyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIHN3YXBwZWQgd2l0aCB7QGxpbmsgbmdNb2NrLiRodHRwQmFja2VuZCBtb2NrXHJcbiAqICRodHRwQmFja2VuZH0gd2hpY2ggY2FuIGJlIHRyYWluZWQgd2l0aCByZXNwb25zZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiAkSHR0cEJhY2tlbmRQcm92aWRlcigpIHtcclxuICB0aGlzLiRnZXQgPSBbJyRicm93c2VyJywgJyR3aW5kb3cnLCAnJGRvY3VtZW50JywgZnVuY3Rpb24oJGJyb3dzZXIsICR3aW5kb3csICRkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUh0dHBCYWNrZW5kKCRicm93c2VyLCBYSFIsICRicm93c2VyLmRlZmVyLCAkd2luZG93LmFuZ3VsYXIuY2FsbGJhY2tzLFxyXG4gICAgICAgICRkb2N1bWVudFswXSwgJHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpKTtcclxuICB9XTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSHR0cEJhY2tlbmQoJGJyb3dzZXIsIFhIUiwgJGJyb3dzZXJEZWZlciwgY2FsbGJhY2tzLCByYXdEb2N1bWVudCwgbG9jYXRpb25Qcm90b2NvbCkge1xyXG4gIC8vIFRPRE8odm9qdGEpOiBmaXggdGhlIHNpZ25hdHVyZVxyXG4gIHJldHVybiBmdW5jdGlvbihtZXRob2QsIHVybCwgcG9zdCwgY2FsbGJhY2ssIGhlYWRlcnMsIHRpbWVvdXQsIHdpdGhDcmVkZW50aWFscywgcmVzcG9uc2VUeXBlKSB7XHJcbiAgICB2YXIgc3RhdHVzO1xyXG4gICAgJGJyb3dzZXIuJCRpbmNPdXRzdGFuZGluZ1JlcXVlc3RDb3VudCgpO1xyXG4gICAgdXJsID0gdXJsIHx8ICRicm93c2VyLnVybCgpO1xyXG5cclxuICAgIGlmIChsb3dlcmNhc2UobWV0aG9kKSA9PSAnanNvbnAnKSB7XHJcbiAgICAgIHZhciBjYWxsYmFja0lkID0gJ18nICsgKGNhbGxiYWNrcy5jb3VudGVyKyspLnRvU3RyaW5nKDM2KTtcclxuICAgICAgY2FsbGJhY2tzW2NhbGxiYWNrSWRdID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIGNhbGxiYWNrc1tjYWxsYmFja0lkXS5kYXRhID0gZGF0YTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHZhciBqc29ucERvbmUgPSBqc29ucFJlcSh1cmwucmVwbGFjZSgnSlNPTl9DQUxMQkFDSycsICdhbmd1bGFyLmNhbGxiYWNrcy4nICsgY2FsbGJhY2tJZCksXHJcbiAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2tzW2NhbGxiYWNrSWRdLmRhdGEpIHtcclxuICAgICAgICAgIGNvbXBsZXRlUmVxdWVzdChjYWxsYmFjaywgMjAwLCBjYWxsYmFja3NbY2FsbGJhY2tJZF0uZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbXBsZXRlUmVxdWVzdChjYWxsYmFjaywgc3RhdHVzIHx8IC0yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGNhbGxiYWNrc1tjYWxsYmFja0lkXTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgeGhyID0gbmV3IFhIUigpO1xyXG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XHJcbiAgICAgIGZvckVhY2goaGVhZGVycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gSW4gSUU2IGFuZCA3LCB0aGlzIG1pZ2h0IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IHdoZW4geGhyLnNlbmQgYmVsb3cgaXMgY2FsbGVkIGFuZCB0aGVcclxuICAgICAgLy8gcmVzcG9uc2UgaXMgaW4gdGhlIGNhY2hlLiB0aGUgcHJvbWlzZSBhcGkgd2lsbCBlbnN1cmUgdGhhdCB0byB0aGUgYXBwIGNvZGUgdGhlIGFwaSBpc1xyXG4gICAgICAvLyBhbHdheXMgYXN5bmNcclxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XHJcbiAgICAgICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xyXG5cclxuICAgICAgICAgIC8vIFRPRE8odm9qdGEpOiByZW1vdmUgb25jZSBGaXJlZm94IDIxIGdldHMgcmVsZWFzZWQuXHJcbiAgICAgICAgICAvLyBiZWdpbjogd29ya2Fyb3VuZCB0byBvdmVyY29tZSBGaXJlZm94IENPUlMgaHR0cCByZXNwb25zZSBoZWFkZXJzIGJ1Z1xyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjA4NzM1XHJcbiAgICAgICAgICAvLyBGaXJlZm94IGFscmVhZHkgcGF0Y2hlZCBpbiBuaWdodGx5LiBTaG91bGQgbGFuZCBpbiBGaXJlZm94IDIxLlxyXG5cclxuICAgICAgICAgIC8vIENPUlMgXCJzaW1wbGUgcmVzcG9uc2UgaGVhZGVyc1wiIGh0dHA6Ly93d3cudzMub3JnL1RSL2NvcnMvXHJcbiAgICAgICAgICB2YXIgdmFsdWUsXHJcbiAgICAgICAgICAgICAgc2ltcGxlSGVhZGVycyA9IFtcIkNhY2hlLUNvbnRyb2xcIiwgXCJDb250ZW50LUxhbmd1YWdlXCIsIFwiQ29udGVudC1UeXBlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkV4cGlyZXNcIiwgXCJMYXN0LU1vZGlmaWVkXCIsIFwiUHJhZ21hXCJdO1xyXG4gICAgICAgICAgaWYgKCFyZXNwb25zZUhlYWRlcnMpIHtcclxuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0gXCJcIjtcclxuICAgICAgICAgICAgZm9yRWFjaChzaW1wbGVIZWFkZXJzLCBmdW5jdGlvbiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyArPSBoZWFkZXIgKyBcIjogXCIgKyB2YWx1ZSArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGVuZCBvZiB0aGUgd29ya2Fyb3VuZC5cclxuXHJcbiAgICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgdGhlIG9sZC1zY2hvb2wgd2F5IG9mIHJldHJpZXZpbmcgcmVzcG9uc2UgKHN1cHBvcnRlZCBieSBJRTggJiA5KVxyXG4gICAgICAgICAgLy8gcmVzcG9uc2UgYW5kIHJlc3BvbnNlVHlwZSBwcm9wZXJ0aWVzIHdlcmUgaW50cm9kdWNlZCBpbiBYSFIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZCBieSBJRTEwKVxyXG4gICAgICAgICAgY29tcGxldGVSZXF1ZXN0KGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgIHN0YXR1cyB8fCB4aHIuc3RhdHVzLFxyXG4gICAgICAgICAgICAgICh4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dCksXHJcbiAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAod2l0aENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZXNwb25zZVR5cGUpIHtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4aHIuc2VuZChwb3N0IHx8ICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgdmFyIHRpbWVvdXRJZCA9ICRicm93c2VyRGVmZXIodGltZW91dFJlcXVlc3QsIHRpbWVvdXQpO1xyXG4gICAgfSBlbHNlIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQudGhlbikge1xyXG4gICAgICB0aW1lb3V0LnRoZW4odGltZW91dFJlcXVlc3QpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0UmVxdWVzdCgpIHtcclxuICAgICAgc3RhdHVzID0gLTE7XHJcbiAgICAgIGpzb25wRG9uZSAmJiBqc29ucERvbmUoKTtcclxuICAgICAgeGhyICYmIHhoci5hYm9ydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdChjYWxsYmFjaywgc3RhdHVzLCByZXNwb25zZSwgaGVhZGVyc1N0cmluZykge1xyXG4gICAgICAvLyBVUkxfTUFUQ0ggaXMgZGVmaW5lZCBpbiBzcmMvc2VydmljZS9sb2NhdGlvbi5qc1xyXG4gICAgICB2YXIgcHJvdG9jb2wgPSAodXJsLm1hdGNoKFNFUlZFUl9NQVRDSCkgfHwgWycnLCBsb2NhdGlvblByb3RvY29sXSlbMV07XHJcblxyXG4gICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc3Vic2VxdWVudCB0aW1lb3V0IHByb21pc2UgcmVzb2x1dGlvblxyXG4gICAgICB0aW1lb3V0SWQgJiYgJGJyb3dzZXJEZWZlci5jYW5jZWwodGltZW91dElkKTtcclxuICAgICAganNvbnBEb25lID0geGhyID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSBmb3IgZmlsZSBwcm90b2NvbCAoaXQncyBhbHdheXMgMClcclxuICAgICAgc3RhdHVzID0gKHByb3RvY29sID09ICdmaWxlJykgPyAocmVzcG9uc2UgPyAyMDAgOiA0MDQpIDogc3RhdHVzO1xyXG5cclxuICAgICAgLy8gbm9ybWFsaXplIElFIGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcclxuICAgICAgc3RhdHVzID0gc3RhdHVzID09IDEyMjMgPyAyMDQgOiBzdGF0dXM7XHJcblxyXG4gICAgICBjYWxsYmFjayhzdGF0dXMsIHJlc3BvbnNlLCBoZWFkZXJzU3RyaW5nKTtcclxuICAgICAgJGJyb3dzZXIuJCRjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdChub29wKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBqc29ucFJlcSh1cmwsIGRvbmUpIHtcclxuICAgIC8vIHdlIGNhbid0IHVzZSBqUXVlcnkvanFMaXRlIGhlcmUgYmVjYXVzZSBqUXVlcnkgZG9lcyBjcmF6eSBzaGl0IHdpdGggc2NyaXB0IGVsZW1lbnRzLCBlLmcuOlxyXG4gICAgLy8gLSBmZXRjaGVzIGxvY2FsIHNjcmlwdHMgdmlhIFhIUiBhbmQgZXZhbHMgdGhlbVxyXG4gICAgLy8gLSBhZGRzIGFuZCBpbW1lZGlhdGVseSByZW1vdmVzIHNjcmlwdCBlbGVtZW50cyBmcm9tIHRoZSBkb2N1bWVudFxyXG4gICAgdmFyIHNjcmlwdCA9IHJhd0RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxyXG4gICAgICAgIGRvbmVXcmFwcGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByYXdEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcmlwdCk7XHJcbiAgICAgICAgICBpZiAoZG9uZSkgZG9uZSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgIHNjcmlwdC5zcmMgPSB1cmw7XHJcblxyXG4gICAgaWYgKG1zaWUpIHtcclxuICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICgvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkgZG9uZVdyYXBwZXIoKTtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25lcnJvciA9IGRvbmVXcmFwcGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHJhd0RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgIHJldHVybiBkb25lV3JhcHBlcjtcclxuICB9XHJcbn1cclxuXHJcbnZhciAkaW50ZXJwb2xhdGVNaW5FcnIgPSBtaW5FcnIoJyRpbnRlcnBvbGF0ZScpO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJGludGVycG9sYXRlUHJvdmlkZXJcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBVc2VkIGZvciBjb25maWd1cmluZyB0aGUgaW50ZXJwb2xhdGlvbiBtYXJrdXAuIERlZmF1bHRzIHRvIGB7e2AgYW5kIGB9fWAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZSBtb2R1bGU9XCJjdXN0b21JbnRlcnBvbGF0aW9uQXBwXCI+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgdmFyIGN1c3RvbUludGVycG9sYXRpb25BcHAgPSBhbmd1bGFyLm1vZHVsZSgnY3VzdG9tSW50ZXJwb2xhdGlvbkFwcCcsIFtdKTtcclxuXHJcbiAgICAgICAgY3VzdG9tSW50ZXJwb2xhdGlvbkFwcC5jb25maWcoZnVuY3Rpb24oJGludGVycG9sYXRlUHJvdmlkZXIpIHtcclxuICAgICAgICAgICRpbnRlcnBvbGF0ZVByb3ZpZGVyLnN0YXJ0U3ltYm9sKCcvLycpO1xyXG4gICAgICAgICAgJGludGVycG9sYXRlUHJvdmlkZXIuZW5kU3ltYm9sKCcvLycpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgY3VzdG9tSW50ZXJwb2xhdGlvbkFwcC5jb250cm9sbGVyKCdEZW1vQ29udHJvbGxlcicsIGZ1bmN0aW9uIERlbW9Db250cm9sbGVyKCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gXCJUaGlzIGJpbmRpbmdzIGlzIGJyb3VnaHQgeW91IHlvdSBieSAvLyBpbnRlcnBvbGF0aW9uIHN5bWJvbHMuXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIDwvc2NyaXB0PlxyXG4gICAgICA8ZGl2IG5nLWFwcD1cIkFwcFwiIG5nLWNvbnRyb2xsZXI9XCJEZW1vQ29udHJvbGxlciBhcyBkZW1vXCI+XHJcbiAgICAgICAgICAvL2RlbW8ubGFiZWwvL1xyXG4gICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgaW50ZXJwb2xhdGUgYmluZGluZyB3aXRoIGN1c3RvbSBzeW1ib2xzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdkZW1vLmxhYmVsJykpLnRvQmUoJ1RoaXMgYmluZGluZ3MgaXMgYnJvdWdodCB5b3UgeW91IGJ5IC8vIGludGVycG9sYXRpb24gc3ltYm9scy4nKTtcclxuICAgICAgIH0pO1xyXG4gPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5mdW5jdGlvbiAkSW50ZXJwb2xhdGVQcm92aWRlcigpIHtcclxuICB2YXIgc3RhcnRTeW1ib2wgPSAne3snO1xyXG4gIHZhciBlbmRTeW1ib2wgPSAnfX0nO1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGludGVycG9sYXRlUHJvdmlkZXIjc3RhcnRTeW1ib2xcclxuICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlUHJvdmlkZXJcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBTeW1ib2wgdG8gZGVub3RlIHN0YXJ0IG9mIGV4cHJlc3Npb24gaW4gdGhlIGludGVycG9sYXRlZCBzdHJpbmcuIERlZmF1bHRzIHRvIGB7e2AuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHZhbHVlIG5ldyB2YWx1ZSB0byBzZXQgdGhlIHN0YXJ0aW5nIHN5bWJvbCB0by5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHNlbGZ9IFJldHVybnMgdGhlIHN5bWJvbCB3aGVuIHVzZWQgYXMgZ2V0dGVyIGFuZCBzZWxmIGlmIHVzZWQgYXMgc2V0dGVyLlxyXG4gICAqL1xyXG4gIHRoaXMuc3RhcnRTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgc3RhcnRTeW1ib2wgPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gc3RhcnRTeW1ib2w7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyI2VuZFN5bWJvbFxyXG4gICAqIEBtZXRob2RPZiBuZy4kaW50ZXJwb2xhdGVQcm92aWRlclxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFN5bWJvbCB0byBkZW5vdGUgdGhlIGVuZCBvZiBleHByZXNzaW9uIGluIHRoZSBpbnRlcnBvbGF0ZWQgc3RyaW5nLiBEZWZhdWx0cyB0byBgfX1gLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB2YWx1ZSBuZXcgdmFsdWUgdG8gc2V0IHRoZSBlbmRpbmcgc3ltYm9sIHRvLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8c2VsZn0gUmV0dXJucyB0aGUgc3ltYm9sIHdoZW4gdXNlZCBhcyBnZXR0ZXIgYW5kIHNlbGYgaWYgdXNlZCBhcyBzZXR0ZXIuXHJcbiAgICovXHJcbiAgdGhpcy5lbmRTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgZW5kU3ltYm9sID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGVuZFN5bWJvbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckcGFyc2UnLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCAnJHNjZScsIGZ1bmN0aW9uKCRwYXJzZSwgJGV4Y2VwdGlvbkhhbmRsZXIsICRzY2UpIHtcclxuICAgIHZhciBzdGFydFN5bWJvbExlbmd0aCA9IHN0YXJ0U3ltYm9sLmxlbmd0aCxcclxuICAgICAgICBlbmRTeW1ib2xMZW5ndGggPSBlbmRTeW1ib2wubGVuZ3RoO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBuZy4kaW50ZXJwb2xhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZXF1aXJlcyAkcGFyc2VcclxuICAgICAqIEByZXF1aXJlcyAkc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQ29tcGlsZXMgYSBzdHJpbmcgd2l0aCBtYXJrdXAgaW50byBhbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLiBUaGlzIHNlcnZpY2UgaXMgdXNlZCBieSB0aGVcclxuICAgICAqIEhUTUwge0BsaW5rIG5nLiRjb21waWxlICRjb21waWxlfSBzZXJ2aWNlIGZvciBkYXRhIGJpbmRpbmcuIFNlZVxyXG4gICAgICoge0BsaW5rIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyICRpbnRlcnBvbGF0ZVByb3ZpZGVyfSBmb3IgY29uZmlndXJpbmcgdGhlXHJcbiAgICAgKiBpbnRlcnBvbGF0aW9uIG1hcmt1cC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICAgPHByZT5cclxuICAgICAgICAgdmFyICRpbnRlcnBvbGF0ZSA9IC4uLjsgLy8gaW5qZWN0ZWRcclxuICAgICAgICAgdmFyIGV4cCA9ICRpbnRlcnBvbGF0ZSgnSGVsbG8ge3tuYW1lfX0hJyk7XHJcbiAgICAgICAgIGV4cGVjdChleHAoe25hbWU6J0FuZ3VsYXInfSkudG9FcXVhbCgnSGVsbG8gQW5ndWxhciEnKTtcclxuICAgICAgIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB3aXRoIG1hcmt1cCB0byBpbnRlcnBvbGF0ZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG11c3RIYXZlRXhwcmVzc2lvbiBpZiBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBpbnRlcnBvbGF0aW9uIHN0cmluZyBtdXN0IGhhdmVcclxuICAgICAqICAgIGVtYmVkZGVkIGV4cHJlc3Npb24gaW4gb3JkZXIgdG8gcmV0dXJuIGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24uIFN0cmluZ3Mgd2l0aCBub1xyXG4gICAgICogICAgZW1iZWRkZWQgZXhwcmVzc2lvbiB3aWxsIHJldHVybiBudWxsIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHJ1c3RlZENvbnRleHQgd2hlbiBwcm92aWRlZCwgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHBhc3NlcyB0aGUgaW50ZXJwb2xhdGVkXHJcbiAgICAgKiAgICByZXN1bHQgdGhyb3VnaCB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkICRzY2UuZ2V0VHJ1c3RlZChpbnRlcnBvbGF0ZWRSZXN1bHQsXHJcbiAgICAgKiAgICB0cnVzdGVkQ29udGV4dCl9IGJlZm9yZSByZXR1cm5pbmcgaXQuICBSZWZlciB0byB0aGUge0BsaW5rIG5nLiRzY2UgJHNjZX0gc2VydmljZSB0aGF0XHJcbiAgICAgKiAgICBwcm92aWRlcyBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyBmb3IgZGV0YWlscy5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0KX0gYW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlIGludGVycG9sYXRlZFxyXG4gICAgICogICAgc3RyaW5nLiBUaGUgZnVuY3Rpb24gaGFzIHRoZXNlIHBhcmFtZXRlcnM6XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGA6IGFuIG9iamVjdCBhZ2FpbnN0IHdoaWNoIGFueSBleHByZXNzaW9ucyBlbWJlZGRlZCBpbiB0aGUgc3RyaW5ncyBhcmUgZXZhbHVhdGVkXHJcbiAgICAgKiAgICAgIGFnYWluc3QuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiAkaW50ZXJwb2xhdGUodGV4dCwgbXVzdEhhdmVFeHByZXNzaW9uLCB0cnVzdGVkQ29udGV4dCkge1xyXG4gICAgICB2YXIgc3RhcnRJbmRleCxcclxuICAgICAgICAgIGVuZEluZGV4LFxyXG4gICAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgICAgcGFydHMgPSBbXSxcclxuICAgICAgICAgIGxlbmd0aCA9IHRleHQubGVuZ3RoLFxyXG4gICAgICAgICAgaGFzSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxyXG4gICAgICAgICAgZm4sXHJcbiAgICAgICAgICBleHAsXHJcbiAgICAgICAgICBjb25jYXQgPSBbXTtcclxuXHJcbiAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCAoKHN0YXJ0SW5kZXggPSB0ZXh0LmluZGV4T2Yoc3RhcnRTeW1ib2wsIGluZGV4KSkgIT0gLTEpICYmXHJcbiAgICAgICAgICAgICAoKGVuZEluZGV4ID0gdGV4dC5pbmRleE9mKGVuZFN5bWJvbCwgc3RhcnRJbmRleCArIHN0YXJ0U3ltYm9sTGVuZ3RoKSkgIT0gLTEpICkge1xyXG4gICAgICAgICAgKGluZGV4ICE9IHN0YXJ0SW5kZXgpICYmIHBhcnRzLnB1c2godGV4dC5zdWJzdHJpbmcoaW5kZXgsIHN0YXJ0SW5kZXgpKTtcclxuICAgICAgICAgIHBhcnRzLnB1c2goZm4gPSAkcGFyc2UoZXhwID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRJbmRleCArIHN0YXJ0U3ltYm9sTGVuZ3RoLCBlbmRJbmRleCkpKTtcclxuICAgICAgICAgIGZuLmV4cCA9IGV4cDtcclxuICAgICAgICAgIGluZGV4ID0gZW5kSW5kZXggKyBlbmRTeW1ib2xMZW5ndGg7XHJcbiAgICAgICAgICBoYXNJbnRlcnBvbGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gd2UgZGlkIG5vdCBmaW5kIGFueXRoaW5nLCBzbyB3ZSBoYXZlIHRvIGFkZCB0aGUgcmVtYWluZGVyIHRvIHRoZSBwYXJ0cyBhcnJheVxyXG4gICAgICAgICAgKGluZGV4ICE9IGxlbmd0aCkgJiYgcGFydHMucHVzaCh0ZXh0LnN1YnN0cmluZyhpbmRleCkpO1xyXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShsZW5ndGggPSBwYXJ0cy5sZW5ndGgpKSB7XHJcbiAgICAgICAgLy8gd2UgYWRkZWQsIG5vdGhpbmcsIG11c3QgaGF2ZSBiZWVuIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAgICBwYXJ0cy5wdXNoKCcnKTtcclxuICAgICAgICBsZW5ndGggPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb25jYXRlbmF0aW5nIGV4cHJlc3Npb25zIG1ha2VzIGl0IGhhcmQgdG8gcmVhc29uIGFib3V0IHdoZXRoZXIgc29tZSBjb21iaW5hdGlvbiBvZiBjb25jYXRlbmF0ZWRcclxuICAgICAgLy8gdmFsdWVzIGFyZSB1bnNhZmUgdG8gdXNlIGFuZCBjb3VsZCBlYXNpbHkgbGVhZCB0byBYU1MuICBCeSByZXF1aXJpbmcgdGhhdCBhIHNpbmdsZVxyXG4gICAgICAvLyBleHByZXNzaW9uIGJlIHVzZWQgZm9yIGlmcmFtZVtzcmNdLCBvYmplY3Rbc3JjXSwgZXRjLiwgd2UgZW5zdXJlIHRoYXQgdGhlIHZhbHVlIHRoYXQncyB1c2VkXHJcbiAgICAgIC8vIGlzIGFzc2lnbmVkIG9yIGNvbnN0cnVjdGVkIGJ5IHNvbWUgSlMgY29kZSBzb21ld2hlcmUgdGhhdCBpcyBtb3JlIHRlc3RhYmxlIG9yIG1ha2UgaXRcclxuICAgICAgLy8gb2J2aW91cyB0aGF0IHlvdSBib3VuZCB0aGUgdmFsdWUgdG8gc29tZSB1c2VyIGNvbnRyb2xsZWQgdmFsdWUuICBUaGlzIGhlbHBzIHJlZHVjZSB0aGUgbG9hZFxyXG4gICAgICAvLyB3aGVuIGF1ZGl0aW5nIGZvciBYU1MgaXNzdWVzLlxyXG4gICAgICBpZiAodHJ1c3RlZENvbnRleHQgJiYgcGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgdGhyb3cgJGludGVycG9sYXRlTWluRXJyKCdub2NvbmNhdCcsXHJcbiAgICAgICAgICAgICAgXCJFcnJvciB3aGlsZSBpbnRlcnBvbGF0aW5nOiB7MH1cXG5TdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyBkaXNhbGxvd3MgXCIgK1xyXG4gICAgICAgICAgICAgIFwiaW50ZXJwb2xhdGlvbnMgdGhhdCBjb25jYXRlbmF0ZSBtdWx0aXBsZSBleHByZXNzaW9ucyB3aGVuIGEgdHJ1c3RlZCB2YWx1ZSBpcyBcIiArXHJcbiAgICAgICAgICAgICAgXCJyZXF1aXJlZC4gIFNlZSBodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy4kc2NlXCIsIHRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW11c3RIYXZlRXhwcmVzc2lvbiAgfHwgaGFzSW50ZXJwb2xhdGlvbikge1xyXG4gICAgICAgIGNvbmNhdC5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgZm4gPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBpaSA9IGxlbmd0aCwgcGFydDsgaTxpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocGFydCA9IHBhcnRzW2ldKSA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0cnVzdGVkQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gJHNjZS5nZXRUcnVzdGVkKHRydXN0ZWRDb250ZXh0LCBwYXJ0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSAkc2NlLnZhbHVlT2YocGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PSBudWxsIHx8IHBhcnQgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnQgIT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgcGFydCA9IHRvSnNvbihwYXJ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29uY2F0W2ldID0gcGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0LmpvaW4oJycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdFcnIgPSAkaW50ZXJwb2xhdGVNaW5FcnIoJ2ludGVycicsIFwiQ2FuJ3QgaW50ZXJwb2xhdGU6IHswfVxcbnsxfVwiLCB0ZXh0LCBlcnIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKG5ld0Vycik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmbi5leHAgPSB0ZXh0O1xyXG4gICAgICAgIGZuLnBhcnRzID0gcGFydHM7XHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJGludGVycG9sYXRlI3N0YXJ0U3ltYm9sXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFN5bWJvbCB0byBkZW5vdGUgdGhlIHN0YXJ0IG9mIGV4cHJlc3Npb24gaW4gdGhlIGludGVycG9sYXRlZCBzdHJpbmcuIERlZmF1bHRzIHRvIGB7e2AuXHJcbiAgICAgKlxyXG4gICAgICogVXNlIHtAbGluayBuZy4kaW50ZXJwb2xhdGVQcm92aWRlciNzdGFydFN5bWJvbCAkaW50ZXJwb2xhdGVQcm92aWRlciNzdGFydFN5bWJvbH0gdG8gY2hhbmdlXHJcbiAgICAgKiB0aGUgc3ltYm9sLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0YXJ0IHN5bWJvbC5cclxuICAgICAqL1xyXG4gICAgJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBzdGFydFN5bWJvbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kaW50ZXJwb2xhdGUjZW5kU3ltYm9sXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFN5bWJvbCB0byBkZW5vdGUgdGhlIGVuZCBvZiBleHByZXNzaW9uIGluIHRoZSBpbnRlcnBvbGF0ZWQgc3RyaW5nLiBEZWZhdWx0cyB0byBgfX1gLlxyXG4gICAgICpcclxuICAgICAqIFVzZSB7QGxpbmsgbmcuJGludGVycG9sYXRlUHJvdmlkZXIjZW5kU3ltYm9sICRpbnRlcnBvbGF0ZVByb3ZpZGVyI2VuZFN5bWJvbH0gdG8gY2hhbmdlXHJcbiAgICAgKiB0aGUgc3ltYm9sLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHN0YXJ0IHN5bWJvbC5cclxuICAgICAqL1xyXG4gICAgJGludGVycG9sYXRlLmVuZFN5bWJvbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gZW5kU3ltYm9sO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAkaW50ZXJwb2xhdGU7XHJcbiAgfV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRsb2NhbGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICRsb2NhbGUgc2VydmljZSBwcm92aWRlcyBsb2NhbGl6YXRpb24gcnVsZXMgZm9yIHZhcmlvdXMgQW5ndWxhciBjb21wb25lbnRzLiBBcyBvZiByaWdodCBub3cgdGhlXHJcbiAqIG9ubHkgcHVibGljIGFwaSBpczpcclxuICpcclxuICogKiBgaWRgIMOi4oKs4oCcIGB7c3RyaW5nfWAgw6LigqzigJwgbG9jYWxlIGlkIGZvcm1hdHRlZCBhcyBgbGFuZ3VhZ2VJZC1jb3VudHJ5SWRgIChlLmcuIGBlbi11c2ApXHJcbiAqL1xyXG5mdW5jdGlvbiAkTG9jYWxlUHJvdmlkZXIoKXtcclxuICB0aGlzLiRnZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiAnZW4tdXMnLFxyXG5cclxuICAgICAgTlVNQkVSX0ZPUk1BVFM6IHtcclxuICAgICAgICBERUNJTUFMX1NFUDogJy4nLFxyXG4gICAgICAgIEdST1VQX1NFUDogJywnLFxyXG4gICAgICAgIFBBVFRFUk5TOiBbXHJcbiAgICAgICAgICB7IC8vIERlY2ltYWwgUGF0dGVyblxyXG4gICAgICAgICAgICBtaW5JbnQ6IDEsXHJcbiAgICAgICAgICAgIG1pbkZyYWM6IDAsXHJcbiAgICAgICAgICAgIG1heEZyYWM6IDMsXHJcbiAgICAgICAgICAgIHBvc1ByZTogJycsXHJcbiAgICAgICAgICAgIHBvc1N1ZjogJycsXHJcbiAgICAgICAgICAgIG5lZ1ByZTogJy0nLFxyXG4gICAgICAgICAgICBuZWdTdWY6ICcnLFxyXG4gICAgICAgICAgICBnU2l6ZTogMyxcclxuICAgICAgICAgICAgbGdTaXplOiAzXHJcbiAgICAgICAgICB9LHsgLy9DdXJyZW5jeSBQYXR0ZXJuXHJcbiAgICAgICAgICAgIG1pbkludDogMSxcclxuICAgICAgICAgICAgbWluRnJhYzogMixcclxuICAgICAgICAgICAgbWF4RnJhYzogMixcclxuICAgICAgICAgICAgcG9zUHJlOiAnXFx1MDBBNCcsXHJcbiAgICAgICAgICAgIHBvc1N1ZjogJycsXHJcbiAgICAgICAgICAgIG5lZ1ByZTogJyhcXHUwMEE0JyxcclxuICAgICAgICAgICAgbmVnU3VmOiAnKScsXHJcbiAgICAgICAgICAgIGdTaXplOiAzLFxyXG4gICAgICAgICAgICBsZ1NpemU6IDNcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIENVUlJFTkNZX1NZTTogJyQnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBEQVRFVElNRV9GT1JNQVRTOiB7XHJcbiAgICAgICAgTU9OVEg6ICdKYW51YXJ5LEZlYnJ1YXJ5LE1hcmNoLEFwcmlsLE1heSxKdW5lLEp1bHksQXVndXN0LFNlcHRlbWJlcixPY3RvYmVyLE5vdmVtYmVyLERlY2VtYmVyJ1xyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcsJyksXHJcbiAgICAgICAgU0hPUlRNT05USDogICdKYW4sRmViLE1hcixBcHIsTWF5LEp1bixKdWwsQXVnLFNlcCxPY3QsTm92LERlYycuc3BsaXQoJywnKSxcclxuICAgICAgICBEQVk6ICdTdW5kYXksTW9uZGF5LFR1ZXNkYXksV2VkbmVzZGF5LFRodXJzZGF5LEZyaWRheSxTYXR1cmRheScuc3BsaXQoJywnKSxcclxuICAgICAgICBTSE9SVERBWTogJ1N1bixNb24sVHVlLFdlZCxUaHUsRnJpLFNhdCcuc3BsaXQoJywnKSxcclxuICAgICAgICBBTVBNUzogWydBTScsJ1BNJ10sXHJcbiAgICAgICAgbWVkaXVtOiAnTU1NIGQsIHkgaDptbTpzcyBhJyxcclxuICAgICAgICBzaG9ydDogJ00vZC95eSBoOm1tIGEnLFxyXG4gICAgICAgIGZ1bGxEYXRlOiAnRUVFRSwgTU1NTSBkLCB5JyxcclxuICAgICAgICBsb25nRGF0ZTogJ01NTU0gZCwgeScsXHJcbiAgICAgICAgbWVkaXVtRGF0ZTogJ01NTSBkLCB5JyxcclxuICAgICAgICBzaG9ydERhdGU6ICdNL2QveXknLFxyXG4gICAgICAgIG1lZGl1bVRpbWU6ICdoOm1tOnNzIGEnLFxyXG4gICAgICAgIHNob3J0VGltZTogJ2g6bW0gYSdcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHBsdXJhbENhdDogZnVuY3Rpb24obnVtKSB7XHJcbiAgICAgICAgaWYgKG51bSA9PT0gMSkge1xyXG4gICAgICAgICAgcmV0dXJuICdvbmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ290aGVyJztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcblxyXG52YXIgU0VSVkVSX01BVENIID0gL14oW146XSspOlxcL1xcLyhcXHcrOnswLDF9XFx3KkApPyhcXHs/W1xcd1xcLi1dKlxcfT8pKDooWzAtOV0rKSk/KFxcL1teXFw/I10qKT8oXFw/KFteI10qKSk/KCMoLiopKT8kLyxcclxuICAgIFBBVEhfTUFUQ0ggPSAvXihbXlxcPyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8kLyxcclxuICAgIERFRkFVTFRfUE9SVFMgPSB7J2h0dHAnOiA4MCwgJ2h0dHBzJzogNDQzLCAnZnRwJzogMjF9O1xyXG52YXIgJGxvY2F0aW9uTWluRXJyID0gbWluRXJyKCckbG9jYXRpb24nKTtcclxuXHJcblxyXG4vKipcclxuICogRW5jb2RlIHBhdGggdXNpbmcgZW5jb2RlVXJpU2VnbWVudCwgaWdub3JpbmcgZm9yd2FyZCBzbGFzaGVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gZW5jb2RlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcclxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJyksXHJcbiAgICAgIGkgPSBzZWdtZW50cy5sZW5ndGg7XHJcblxyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIHNlZ21lbnRzW2ldID0gZW5jb2RlVXJpU2VnbWVudChzZWdtZW50c1tpXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2VnbWVudHMuam9pbignLycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaFVybCh1cmwsIG9iaikge1xyXG4gIHZhciBtYXRjaCA9IFNFUlZFUl9NQVRDSC5leGVjKHVybCk7XHJcblxyXG4gIG9iai4kJHByb3RvY29sID0gbWF0Y2hbMV07XHJcbiAgb2JqLiQkaG9zdCA9IG1hdGNoWzNdO1xyXG4gIG9iai4kJHBvcnQgPSBpbnQobWF0Y2hbNV0pIHx8IERFRkFVTFRfUE9SVFNbbWF0Y2hbMV1dIHx8IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoQXBwVXJsKHVybCwgb2JqKSB7XHJcbiAgdmFyIG1hdGNoID0gUEFUSF9NQVRDSC5leGVjKHVybCk7XHJcblxyXG4gIG9iai4kJHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pO1xyXG4gIG9iai4kJHNlYXJjaCA9IHBhcnNlS2V5VmFsdWUobWF0Y2hbM10pO1xyXG4gIG9iai4kJGhhc2ggPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbNV0gfHwgJycpO1xyXG5cclxuICAvLyBtYWtlIHN1cmUgcGF0aCBzdGFydHMgd2l0aCAnLyc7XHJcbiAgaWYgKG9iai4kJHBhdGggJiYgb2JqLiQkcGF0aC5jaGFyQXQoMCkgIT0gJy8nKSBvYmouJCRwYXRoID0gJy8nICsgb2JqLiQkcGF0aDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VQcm90b2NvbEhvc3RQb3J0KHByb3RvY29sLCBob3N0LCBwb3J0KSB7XHJcbiAgcmV0dXJuIHByb3RvY29sICsgJzovLycgKyBob3N0ICsgKHBvcnQgPT0gREVGQVVMVF9QT1JUU1twcm90b2NvbF0gPyAnJyA6ICc6JyArIHBvcnQpO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGJlZ2luXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB3aG9sZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3RoZXJ3aXNlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgdGV4dCBmcm9tIHdob2xlIGFmdGVyIGJlZ2luIG9yIG90aGVyd2lzZSBpZiBpdCBkb2VzIG5vdCBiZWdpbiB3aXRoIGV4cGVjdGVkIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGJlZ2luc1dpdGgoYmVnaW4sIHdob2xlLCBvdGhlcndpc2UpIHtcclxuICByZXR1cm4gd2hvbGUuaW5kZXhPZihiZWdpbikgPT0gMCA/IHdob2xlLnN1YnN0cihiZWdpbi5sZW5ndGgpIDogb3RoZXJ3aXNlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3RyaXBIYXNoKHVybCkge1xyXG4gIHZhciBpbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XHJcbiAgcmV0dXJuIGluZGV4ID09IC0xID8gdXJsIDogdXJsLnN1YnN0cigwLCBpbmRleCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBzdHJpcEZpbGUodXJsKSB7XHJcbiAgcmV0dXJuIHVybC5zdWJzdHIoMCwgc3RyaXBIYXNoKHVybCkubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG59XHJcblxyXG4vKiByZXR1cm4gdGhlIHNlcnZlciBvbmx5IChzY2hlbWU6Ly9ob3N0OnBvcnQpICovXHJcbmZ1bmN0aW9uIHNlcnZlckJhc2UodXJsKSB7XHJcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmluZGV4T2YoJy8nLCB1cmwuaW5kZXhPZignLy8nKSArIDIpKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2NhdGlvbkh0bWw1VXJsIHJlcHJlc2VudHMgYW4gdXJsXHJcbiAqIFRoaXMgb2JqZWN0IGlzIGV4cG9zZWQgYXMgJGxvY2F0aW9uIHNlcnZpY2Ugd2hlbiBIVE1MNSBtb2RlIGlzIGVuYWJsZWQgYW5kIHN1cHBvcnRlZFxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IGFwcEJhc2UgYXBwbGljYXRpb24gYmFzZSBVUkxcclxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQcmVmaXggdXJsIHBhdGggcHJlZml4XHJcbiAqL1xyXG5mdW5jdGlvbiBMb2NhdGlvbkh0bWw1VXJsKGFwcEJhc2UsIGJhc2VQcmVmaXgpIHtcclxuICB0aGlzLiQkaHRtbDUgPSB0cnVlO1xyXG4gIGJhc2VQcmVmaXggPSBiYXNlUHJlZml4IHx8ICcnO1xyXG4gIHZhciBhcHBCYXNlTm9GaWxlID0gc3RyaXBGaWxlKGFwcEJhc2UpO1xyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGdpdmVuIGh0bWw1IChyZWd1bGFyKSB1cmwgc3RyaW5nIGludG8gcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdBYnNvbHV0ZVVybCBIVE1MNSB1cmxcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHRoaXMuJCRwYXJzZSA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgdmFyIHBhcnNlZCA9IHt9XHJcbiAgICBtYXRjaFVybCh1cmwsIHBhcnNlZCk7XHJcbiAgICB2YXIgcGF0aFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZU5vRmlsZSwgdXJsKTtcclxuICAgIGlmICghaXNTdHJpbmcocGF0aFVybCkpIHtcclxuICAgICAgdGhyb3cgJGxvY2F0aW9uTWluRXJyKCdpcHRocHJmeCcsICdJbnZhbGlkIHVybCBcInswfVwiLCBtaXNzaW5nIHBhdGggcHJlZml4IFwiezF9XCIuJywgdXJsLCBhcHBCYXNlTm9GaWxlKTtcclxuICAgIH1cclxuICAgIG1hdGNoQXBwVXJsKHBhdGhVcmwsIHBhcnNlZCk7XHJcbiAgICBleHRlbmQodGhpcywgcGFyc2VkKTtcclxuICAgIGlmICghdGhpcy4kJHBhdGgpIHtcclxuICAgICAgdGhpcy4kJHBhdGggPSAnLyc7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kJGNvbXBvc2UoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDb21wb3NlIHVybCBhbmQgdXBkYXRlIGBhYnNVcmxgIHByb3BlcnR5XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB0aGlzLiQkY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlYXJjaCA9IHRvS2V5VmFsdWUodGhpcy4kJHNlYXJjaCksXHJcbiAgICAgICAgaGFzaCA9IHRoaXMuJCRoYXNoID8gJyMnICsgZW5jb2RlVXJpU2VnbWVudCh0aGlzLiQkaGFzaCkgOiAnJztcclxuXHJcbiAgICB0aGlzLiQkdXJsID0gZW5jb2RlUGF0aCh0aGlzLiQkcGF0aCkgKyAoc2VhcmNoID8gJz8nICsgc2VhcmNoIDogJycpICsgaGFzaDtcclxuICAgIHRoaXMuJCRhYnNVcmwgPSBhcHBCYXNlTm9GaWxlICsgdGhpcy4kJHVybC5zdWJzdHIoMSk7IC8vIGZpcnN0IGNoYXIgaXMgYWx3YXlzICcvJ1xyXG4gIH07XHJcblxyXG4gIHRoaXMuJCRyZXdyaXRlID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgICB2YXIgYXBwVXJsLCBwcmV2QXBwVXJsO1xyXG5cclxuICAgIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZSwgdXJsKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgcHJldkFwcFVybCA9IGFwcFVybDtcclxuICAgICAgaWYgKCAoYXBwVXJsID0gYmVnaW5zV2l0aChiYXNlUHJlZml4LCBhcHBVcmwpKSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgIHJldHVybiBhcHBCYXNlTm9GaWxlICsgKGJlZ2luc1dpdGgoJy8nLCBhcHBVcmwpIHx8IGFwcFVybCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcEJhc2UgKyBwcmV2QXBwVXJsO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCAoYXBwVXJsID0gYmVnaW5zV2l0aChhcHBCYXNlTm9GaWxlLCB1cmwpKSAhPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICByZXR1cm4gYXBwQmFzZU5vRmlsZSArIGFwcFVybDtcclxuICAgIH0gZWxzZSBpZiAoYXBwQmFzZU5vRmlsZSA9PSB1cmwgKyAnLycpIHtcclxuICAgICAgcmV0dXJuIGFwcEJhc2VOb0ZpbGU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIExvY2F0aW9uSGFzaGJhbmdVcmwgcmVwcmVzZW50cyB1cmxcclxuICogVGhpcyBvYmplY3QgaXMgZXhwb3NlZCBhcyAkbG9jYXRpb24gc2VydmljZSB3aGVuIGRldmVsb3BlciBkb2Vzbid0IG9wdCBpbnRvIGh0bWw1IG1vZGUuXHJcbiAqIEl0IGFsc28gc2VydmVzIGFzIHRoZSBiYXNlIGNsYXNzIGZvciBodG1sNSBtb2RlIGZhbGxiYWNrIG9uIGxlZ2FjeSBicm93c2Vycy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCYXNlIGFwcGxpY2F0aW9uIGJhc2UgVVJMXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoUHJlZml4IGhhc2hiYW5nIHByZWZpeFxyXG4gKi9cclxuZnVuY3Rpb24gTG9jYXRpb25IYXNoYmFuZ1VybChhcHBCYXNlLCBoYXNoUHJlZml4KSB7XHJcbiAgdmFyIGFwcEJhc2VOb0ZpbGUgPSBzdHJpcEZpbGUoYXBwQmFzZSk7XHJcblxyXG4gIG1hdGNoVXJsKGFwcEJhc2UsIHRoaXMpO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgZ2l2ZW4gaGFzaGJhbmcgdXJsIGludG8gcHJvcGVydGllc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSGFzaGJhbmcgdXJsXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB0aGlzLiQkcGFyc2UgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgIHZhciB3aXRob3V0QmFzZVVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZSwgdXJsKSB8fCBiZWdpbnNXaXRoKGFwcEJhc2VOb0ZpbGUsIHVybCk7XHJcbiAgICB2YXIgd2l0aG91dEhhc2hVcmwgPSB3aXRob3V0QmFzZVVybC5jaGFyQXQoMCkgPT0gJyMnXHJcbiAgICAgICAgPyBiZWdpbnNXaXRoKGhhc2hQcmVmaXgsIHdpdGhvdXRCYXNlVXJsKVxyXG4gICAgICAgIDogKHRoaXMuJCRodG1sNSlcclxuICAgICAgICAgID8gd2l0aG91dEJhc2VVcmxcclxuICAgICAgICAgIDogJyc7XHJcblxyXG4gICAgaWYgKCFpc1N0cmluZyh3aXRob3V0SGFzaFVybCkpIHtcclxuICAgICAgdGhyb3cgJGxvY2F0aW9uTWluRXJyKCdpaHNocHJmeCcsICdJbnZhbGlkIHVybCBcInswfVwiLCBtaXNzaW5nIGhhc2ggcHJlZml4IFwiezF9XCIuJywgdXJsLCBoYXNoUHJlZml4KTtcclxuICAgIH1cclxuICAgIG1hdGNoQXBwVXJsKHdpdGhvdXRIYXNoVXJsLCB0aGlzKTtcclxuICAgIHRoaXMuJCRjb21wb3NlKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcG9zZSBoYXNoYmFuZyB1cmwgYW5kIHVwZGF0ZSBgYWJzVXJsYCBwcm9wZXJ0eVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgdGhpcy4kJGNvbXBvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWFyY2ggPSB0b0tleVZhbHVlKHRoaXMuJCRzZWFyY2gpLFxyXG4gICAgICAgIGhhc2ggPSB0aGlzLiQkaGFzaCA/ICcjJyArIGVuY29kZVVyaVNlZ21lbnQodGhpcy4kJGhhc2gpIDogJyc7XHJcblxyXG4gICAgdGhpcy4kJHVybCA9IGVuY29kZVBhdGgodGhpcy4kJHBhdGgpICsgKHNlYXJjaCA/ICc/JyArIHNlYXJjaCA6ICcnKSArIGhhc2g7XHJcbiAgICB0aGlzLiQkYWJzVXJsID0gYXBwQmFzZSArICh0aGlzLiQkdXJsID8gaGFzaFByZWZpeCArIHRoaXMuJCR1cmwgOiAnJyk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy4kJHJld3JpdGUgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgIGlmKHN0cmlwSGFzaChhcHBCYXNlKSA9PSBzdHJpcEhhc2godXJsKSkge1xyXG4gICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2NhdGlvbkhhc2hiYW5nVXJsIHJlcHJlc2VudHMgdXJsXHJcbiAqIFRoaXMgb2JqZWN0IGlzIGV4cG9zZWQgYXMgJGxvY2F0aW9uIHNlcnZpY2Ugd2hlbiBodG1sNSBoaXN0b3J5IGFwaSBpcyBlbmFibGVkIGJ1dCB0aGUgYnJvd3NlclxyXG4gKiBkb2VzIG5vdCBzdXBwb3J0IGl0LlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IGFwcEJhc2UgYXBwbGljYXRpb24gYmFzZSBVUkxcclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2hQcmVmaXggaGFzaGJhbmcgcHJlZml4XHJcbiAqL1xyXG5mdW5jdGlvbiBMb2NhdGlvbkhhc2hiYW5nSW5IdG1sNVVybChhcHBCYXNlLCBoYXNoUHJlZml4KSB7XHJcbiAgdGhpcy4kJGh0bWw1ID0gdHJ1ZTtcclxuICBMb2NhdGlvbkhhc2hiYW5nVXJsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gIHZhciBhcHBCYXNlTm9GaWxlID0gc3RyaXBGaWxlKGFwcEJhc2UpO1xyXG5cclxuICB0aGlzLiQkcmV3cml0ZSA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgdmFyIGFwcFVybDtcclxuXHJcbiAgICBpZiAoIGFwcEJhc2UgPT0gc3RyaXBIYXNoKHVybCkgKSB7XHJcbiAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9IGVsc2UgaWYgKCAoYXBwVXJsID0gYmVnaW5zV2l0aChhcHBCYXNlTm9GaWxlLCB1cmwpKSApIHtcclxuICAgICAgcmV0dXJuIGFwcEJhc2UgKyBoYXNoUHJlZml4ICsgYXBwVXJsO1xyXG4gICAgfSBlbHNlIGlmICggYXBwQmFzZU5vRmlsZSA9PT0gdXJsICsgJy8nKSB7XHJcbiAgICAgIHJldHVybiBhcHBCYXNlTm9GaWxlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbkxvY2F0aW9uSGFzaGJhbmdJbkh0bWw1VXJsLnByb3RvdHlwZSA9XHJcbiAgTG9jYXRpb25IYXNoYmFuZ1VybC5wcm90b3R5cGUgPVxyXG4gIExvY2F0aW9uSHRtbDVVcmwucHJvdG90eXBlID0ge1xyXG5cclxuICAvKipcclxuICAgKiBBcmUgd2UgaW4gaHRtbDUgbW9kZT9cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gICQkaHRtbDU6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBIYXMgYW55IGNoYW5nZSBiZWVuIHJlcGxhY2luZyA/XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICAkJHJlcGxhY2U6IGZhbHNlLFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI2Fic1VybFxyXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGZ1bGwgdXJsIHJlcHJlc2VudGF0aW9uIHdpdGggYWxsIHNlZ21lbnRzIGVuY29kZWQgYWNjb3JkaW5nIHRvIHJ1bGVzIHNwZWNpZmllZCBpblxyXG4gICAqIHtAbGluayBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzOTg2LnR4dCBSRkMgMzk4Nn0uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGwgdXJsXHJcbiAgICovXHJcbiAgYWJzVXJsOiBsb2NhdGlvbkdldHRlcignJCRhYnNVcmwnKSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiN1cmxcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgLyBzZXR0ZXIuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gdXJsIChlLmcuIGAvcGF0aD9hPWIjaGFzaGApIHdoZW4gY2FsbGVkIHdpdGhvdXQgYW55IHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIENoYW5nZSBwYXRoLCBzZWFyY2ggYW5kIGhhc2gsIHdoZW4gY2FsbGVkIHdpdGggcGFyYW1ldGVyIGFuZCByZXR1cm4gYCRsb2NhdGlvbmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHVybCBOZXcgdXJsIHdpdGhvdXQgYmFzZSBwcmVmaXggKGUuZy4gYC9wYXRoP2E9YiNoYXNoYClcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHJlcGxhY2UgVGhlIHBhdGggdGhhdCB3aWxsIGJlIGNoYW5nZWRcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHVybFxyXG4gICAqL1xyXG4gIHVybDogZnVuY3Rpb24odXJsLCByZXBsYWNlKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQodXJsKSlcclxuICAgICAgcmV0dXJuIHRoaXMuJCR1cmw7XHJcblxyXG4gICAgdmFyIG1hdGNoID0gUEFUSF9NQVRDSC5leGVjKHVybCk7XHJcbiAgICBpZiAobWF0Y2hbMV0pIHRoaXMucGF0aChkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pKTtcclxuICAgIGlmIChtYXRjaFsyXSB8fCBtYXRjaFsxXSkgdGhpcy5zZWFyY2gobWF0Y2hbM10gfHwgJycpO1xyXG4gICAgdGhpcy5oYXNoKG1hdGNoWzVdIHx8ICcnLCByZXBsYWNlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3Byb3RvY29sXHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIG9ubHkuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gcHJvdG9jb2wgb2YgY3VycmVudCB1cmwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHByb3RvY29sIG9mIGN1cnJlbnQgdXJsXHJcbiAgICovXHJcbiAgcHJvdG9jb2w6IGxvY2F0aW9uR2V0dGVyKCckJHByb3RvY29sJyksXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb24jaG9zdFxyXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGhvc3Qgb2YgY3VycmVudCB1cmwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGhvc3Qgb2YgY3VycmVudCB1cmwuXHJcbiAgICovXHJcbiAgaG9zdDogbG9jYXRpb25HZXR0ZXIoJyQkaG9zdCcpLFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3BvcnRcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgb25seS5cclxuICAgKlxyXG4gICAqIFJldHVybiBwb3J0IG9mIGN1cnJlbnQgdXJsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3J0XHJcbiAgICovXHJcbiAgcG9ydDogbG9jYXRpb25HZXR0ZXIoJyQkcG9ydCcpLFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3BhdGhcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgLyBzZXR0ZXIuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gcGF0aCBvZiBjdXJyZW50IHVybCB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBDaGFuZ2UgcGF0aCB3aGVuIGNhbGxlZCB3aXRoIHBhcmFtZXRlciBhbmQgcmV0dXJuIGAkbG9jYXRpb25gLlxyXG4gICAqXHJcbiAgICogTm90ZTogUGF0aCBzaG91bGQgYWx3YXlzIGJlZ2luIHdpdGggZm9yd2FyZCBzbGFzaCAoLyksIHRoaXMgbWV0aG9kIHdpbGwgYWRkIHRoZSBmb3J3YXJkIHNsYXNoXHJcbiAgICogaWYgaXQgaXMgbWlzc2luZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcGF0aCBOZXcgcGF0aFxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcGF0aFxyXG4gICAqL1xyXG4gIHBhdGg6IGxvY2F0aW9uR2V0dGVyU2V0dGVyKCckJHBhdGgnLCBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XHJcbiAgfSksXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb24jc2VhcmNoXHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIC8gc2V0dGVyLlxyXG4gICAqXHJcbiAgICogUmV0dXJuIHNlYXJjaCBwYXJ0IChhcyBvYmplY3QpIG9mIGN1cnJlbnQgdXJsIHdoZW4gY2FsbGVkIHdpdGhvdXQgYW55IHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIENoYW5nZSBzZWFyY2ggcGFydCB3aGVuIGNhbGxlZCB3aXRoIHBhcmFtZXRlciBhbmQgcmV0dXJuIGAkbG9jYXRpb25gLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmc+fE9iamVjdC48QXJyYXkuPHN0cmluZz4+fSBzZWFyY2ggTmV3IHNlYXJjaCBwYXJhbXMgLSBzdHJpbmcgb3IgaGFzaCBvYmplY3QuIEhhc2ggb2JqZWN0XHJcbiAgICogICAgbWF5IGNvbnRhaW4gYW4gYXJyYXkgb2YgdmFsdWVzLCB3aGljaCB3aWxsIGJlIGRlY29kZWQgYXMgZHVwbGljYXRlcyBpbiB0aGUgdXJsLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcGFyYW1WYWx1ZSBJZiBgc2VhcmNoYCBpcyBhIHN0cmluZywgdGhlbiBgcGFyYW1WYWx1ZWAgd2lsbCBvdmVycmlkZSBvbmx5IGFcclxuICAgKiAgICBzaW5nbGUgc2VhcmNoIHBhcmFtZXRlci4gSWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgdGhlIHBhcmFtZXRlciB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHNlYXJjaFxyXG4gICAqL1xyXG4gIHNlYXJjaDogZnVuY3Rpb24oc2VhcmNoLCBwYXJhbVZhbHVlKSB7XHJcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIHJldHVybiB0aGlzLiQkc2VhcmNoO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHNlYXJjaCkpIHtcclxuICAgICAgICAgIHRoaXMuJCRzZWFyY2ggPSBwYXJzZUtleVZhbHVlKHNlYXJjaCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzZWFyY2gpKSB7XHJcbiAgICAgICAgICB0aGlzLiQkc2VhcmNoID0gc2VhcmNoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyAkbG9jYXRpb25NaW5FcnIoJ2lzcmNoYXJnJywgJ1RoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgYCRsb2NhdGlvbiNzZWFyY2goKWAgY2FsbCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgaWYgKHBhcmFtVmFsdWUgPT0gdW5kZWZpbmVkIHx8IHBhcmFtVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuJCRzZWFyY2hbc2VhcmNoXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy4kJHNlYXJjaFtzZWFyY2hdID0gcGFyYW1WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kJGNvbXBvc2UoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb24jaGFzaFxyXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciAvIHNldHRlci5cclxuICAgKlxyXG4gICAqIFJldHVybiBoYXNoIGZyYWdtZW50IHdoZW4gY2FsbGVkIHdpdGhvdXQgYW55IHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIENoYW5nZSBoYXNoIGZyYWdtZW50IHdoZW4gY2FsbGVkIHdpdGggcGFyYW1ldGVyIGFuZCByZXR1cm4gYCRsb2NhdGlvbmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IGhhc2ggTmV3IGhhc2ggZnJhZ21lbnRcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGhhc2hcclxuICAgKi9cclxuICBoYXNoOiBsb2NhdGlvbkdldHRlclNldHRlcignJCRoYXNoJywgaWRlbnRpdHkpLFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3JlcGxhY2VcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBJZiBjYWxsZWQsIGFsbCBjaGFuZ2VzIHRvICRsb2NhdGlvbiBkdXJpbmcgY3VycmVudCBgJGRpZ2VzdGAgd2lsbCBiZSByZXBsYWNpbmcgY3VycmVudCBoaXN0b3J5XHJcbiAgICogcmVjb3JkLCBpbnN0ZWFkIG9mIGFkZGluZyBuZXcgb25lLlxyXG4gICAqL1xyXG4gIHJlcGxhY2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy4kJHJlcGxhY2UgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gbG9jYXRpb25HZXR0ZXIocHJvcGVydHkpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGxvY2F0aW9uR2V0dGVyU2V0dGVyKHByb3BlcnR5LCBwcmVwcm9jZXNzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxyXG4gICAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XHJcblxyXG4gICAgdGhpc1twcm9wZXJ0eV0gPSBwcmVwcm9jZXNzKHZhbHVlKTtcclxuICAgIHRoaXMuJCRjb21wb3NlKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRsb2NhdGlvblxyXG4gKlxyXG4gKiBAcmVxdWlyZXMgJGJyb3dzZXJcclxuICogQHJlcXVpcmVzICRzbmlmZmVyXHJcbiAqIEByZXF1aXJlcyAkcm9vdEVsZW1lbnRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSAkbG9jYXRpb24gc2VydmljZSBwYXJzZXMgdGhlIFVSTCBpbiB0aGUgYnJvd3NlciBhZGRyZXNzIGJhciAoYmFzZWQgb24gdGhlXHJcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi93aW5kb3cubG9jYXRpb24gd2luZG93LmxvY2F0aW9ufSkgYW5kIG1ha2VzIHRoZSBVUkxcclxuICogYXZhaWxhYmxlIHRvIHlvdXIgYXBwbGljYXRpb24uIENoYW5nZXMgdG8gdGhlIFVSTCBpbiB0aGUgYWRkcmVzcyBiYXIgYXJlIHJlZmxlY3RlZCBpbnRvXHJcbiAqICRsb2NhdGlvbiBzZXJ2aWNlIGFuZCBjaGFuZ2VzIHRvICRsb2NhdGlvbiBhcmUgcmVmbGVjdGVkIGludG8gdGhlIGJyb3dzZXIgYWRkcmVzcyBiYXIuXHJcbiAqXHJcbiAqICoqVGhlICRsb2NhdGlvbiBzZXJ2aWNlOioqXHJcbiAqXHJcbiAqIC0gRXhwb3NlcyB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGJyb3dzZXIgYWRkcmVzcyBiYXIsIHNvIHlvdSBjYW5cclxuICogICAtIFdhdGNoIGFuZCBvYnNlcnZlIHRoZSBVUkwuXHJcbiAqICAgLSBDaGFuZ2UgdGhlIFVSTC5cclxuICogLSBTeW5jaHJvbml6ZXMgdGhlIFVSTCB3aXRoIHRoZSBicm93c2VyIHdoZW4gdGhlIHVzZXJcclxuICogICAtIENoYW5nZXMgdGhlIGFkZHJlc3MgYmFyLlxyXG4gKiAgIC0gQ2xpY2tzIHRoZSBiYWNrIG9yIGZvcndhcmQgYnV0dG9uIChvciBjbGlja3MgYSBIaXN0b3J5IGxpbmspLlxyXG4gKiAgIC0gQ2xpY2tzIG9uIGEgbGluay5cclxuICogLSBSZXByZXNlbnRzIHRoZSBVUkwgb2JqZWN0IGFzIGEgc2V0IG9mIG1ldGhvZHMgKHByb3RvY29sLCBob3N0LCBwb3J0LCBwYXRoLCBzZWFyY2gsIGhhc2gpLlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUge0BsaW5rIGd1aWRlL2Rldl9ndWlkZS5zZXJ2aWNlcy4kbG9jYXRpb24gRGV2ZWxvcGVyIEd1aWRlOiBBbmd1bGFyXHJcbiAqIFNlcnZpY2VzOiBVc2luZyAkbG9jYXRpb259XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJGxvY2F0aW9uUHJvdmlkZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFVzZSB0aGUgYCRsb2NhdGlvblByb3ZpZGVyYCB0byBjb25maWd1cmUgaG93IHRoZSBhcHBsaWNhdGlvbiBkZWVwIGxpbmtpbmcgcGF0aHMgYXJlIHN0b3JlZC5cclxuICovXHJcbmZ1bmN0aW9uICRMb2NhdGlvblByb3ZpZGVyKCl7XHJcbiAgdmFyIGhhc2hQcmVmaXggPSAnJyxcclxuICAgICAgaHRtbDVNb2RlID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvblByb3ZpZGVyI2hhc2hQcmVmaXhcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uUHJvdmlkZXJcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHByZWZpeCBQcmVmaXggZm9yIGhhc2ggcGFydCAoY29udGFpbmluZyBwYXRoIGFuZCBzZWFyY2gpXHJcbiAgICogQHJldHVybnMgeyp9IGN1cnJlbnQgdmFsdWUgaWYgdXNlZCBhcyBnZXR0ZXIgb3IgaXRzZWxmIChjaGFpbmluZykgaWYgdXNlZCBhcyBzZXR0ZXJcclxuICAgKi9cclxuICB0aGlzLmhhc2hQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIGlmIChpc0RlZmluZWQocHJlZml4KSkge1xyXG4gICAgICBoYXNoUHJlZml4ID0gcHJlZml4O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBoYXNoUHJlZml4O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvblByb3ZpZGVyI2h0bWw1TW9kZVxyXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25Qcm92aWRlclxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbW9kZSBVc2UgSFRNTDUgc3RyYXRlZ3kgaWYgYXZhaWxhYmxlLlxyXG4gICAqIEByZXR1cm5zIHsqfSBjdXJyZW50IHZhbHVlIGlmIHVzZWQgYXMgZ2V0dGVyIG9yIGl0c2VsZiAoY2hhaW5pbmcpIGlmIHVzZWQgYXMgc2V0dGVyXHJcbiAgICovXHJcbiAgdGhpcy5odG1sNU1vZGUgPSBmdW5jdGlvbihtb2RlKSB7XHJcbiAgICBpZiAoaXNEZWZpbmVkKG1vZGUpKSB7XHJcbiAgICAgIGh0bWw1TW9kZSA9IG1vZGU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGh0bWw1TW9kZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB0aGlzLiRnZXQgPSBbJyRyb290U2NvcGUnLCAnJGJyb3dzZXInLCAnJHNuaWZmZXInLCAnJHJvb3RFbGVtZW50JyxcclxuICAgICAgZnVuY3Rpb24oICRyb290U2NvcGUsICAgJGJyb3dzZXIsICAgJHNuaWZmZXIsICAgJHJvb3RFbGVtZW50KSB7XHJcbiAgICB2YXIgJGxvY2F0aW9uLFxyXG4gICAgICAgIExvY2F0aW9uTW9kZSxcclxuICAgICAgICBiYXNlSHJlZiA9ICRicm93c2VyLmJhc2VIcmVmKCksIC8vIGlmIGJhc2VbaHJlZl0gaXMgdW5kZWZpbmVkLCBpdCBkZWZhdWx0cyB0byAnJ1xyXG4gICAgICAgIGluaXRpYWxVcmwgPSAkYnJvd3Nlci51cmwoKSxcclxuICAgICAgICBhcHBCYXNlO1xyXG5cclxuICAgIGlmIChodG1sNU1vZGUpIHtcclxuICAgICAgYXBwQmFzZSA9IHNlcnZlckJhc2UoaW5pdGlhbFVybCkgKyAoYmFzZUhyZWYgfHwgJy8nKTtcclxuICAgICAgTG9jYXRpb25Nb2RlID0gJHNuaWZmZXIuaGlzdG9yeSA/IExvY2F0aW9uSHRtbDVVcmwgOiBMb2NhdGlvbkhhc2hiYW5nSW5IdG1sNVVybDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFwcEJhc2UgPSBzdHJpcEhhc2goaW5pdGlhbFVybCk7XHJcbiAgICAgIExvY2F0aW9uTW9kZSA9IExvY2F0aW9uSGFzaGJhbmdVcmw7XHJcbiAgICB9XHJcbiAgICAkbG9jYXRpb24gPSBuZXcgTG9jYXRpb25Nb2RlKGFwcEJhc2UsICcjJyArIGhhc2hQcmVmaXgpO1xyXG4gICAgJGxvY2F0aW9uLiQkcGFyc2UoJGxvY2F0aW9uLiQkcmV3cml0ZShpbml0aWFsVXJsKSk7XHJcblxyXG4gICAgJHJvb3RFbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIC8vIFRPRE8odm9qdGEpOiByZXdyaXRlIGxpbmsgd2hlbiBvcGVuaW5nIGluIG5ldyB0YWIvd2luZG93IChpbiBsZWdhY3kgYnJvd3NlcilcclxuICAgICAgLy8gY3VycmVudGx5IHdlIG9wZW4gbmljZSB1cmwgbGluayBhbmQgcmVkaXJlY3QgdGhlblxyXG5cclxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC53aGljaCA9PSAyKSByZXR1cm47XHJcblxyXG4gICAgICB2YXIgZWxtID0ganFMaXRlKGV2ZW50LnRhcmdldCk7XHJcblxyXG4gICAgICAvLyB0cmF2ZXJzZSB0aGUgRE9NIHVwIHRvIGZpbmQgZmlyc3QgQSB0YWdcclxuICAgICAgd2hpbGUgKGxvd2VyY2FzZShlbG1bMF0ubm9kZU5hbWUpICE9PSAnYScpIHtcclxuICAgICAgICAvLyBpZ25vcmUgcmV3cml0aW5nIGlmIG5vIEEgdGFnIChyZWFjaGVkIHJvb3QgZWxlbWVudCwgb3Igbm8gcGFyZW50IC0gcmVtb3ZlZCBmcm9tIGRvY3VtZW50KVxyXG4gICAgICAgIGlmIChlbG1bMF0gPT09ICRyb290RWxlbWVudFswXSB8fCAhKGVsbSA9IGVsbS5wYXJlbnQoKSlbMF0pIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGFic0hyZWYgPSBlbG0ucHJvcCgnaHJlZicpO1xyXG4gICAgICB2YXIgcmV3cml0dGVuVXJsID0gJGxvY2F0aW9uLiQkcmV3cml0ZShhYnNIcmVmKTtcclxuXHJcbiAgICAgIGlmIChhYnNIcmVmICYmICFlbG0uYXR0cigndGFyZ2V0JykgJiYgcmV3cml0dGVuVXJsICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKHJld3JpdHRlblVybCAhPSAkYnJvd3Nlci51cmwoKSkge1xyXG4gICAgICAgICAgLy8gdXBkYXRlIGxvY2F0aW9uIG1hbnVhbGx5XHJcbiAgICAgICAgICAkbG9jYXRpb24uJCRwYXJzZShyZXdyaXR0ZW5VcmwpO1xyXG4gICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcclxuICAgICAgICAgIC8vIGhhY2sgdG8gd29yayBhcm91bmQgRkY2IGJ1ZyA2ODQyMDggd2hlbiBzY2VuYXJpbyBydW5uZXIgY2xpY2tzIG9uIGxpbmtzXHJcbiAgICAgICAgICB3aW5kb3cuYW5ndWxhclsnZmYtNjg0MjA4LXByZXZlbnREZWZhdWx0J10gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIHJld3JpdGUgaGFzaGJhbmcgdXJsIDw+IGh0bWw1IHVybFxyXG4gICAgaWYgKCRsb2NhdGlvbi5hYnNVcmwoKSAhPSBpbml0aWFsVXJsKSB7XHJcbiAgICAgICRicm93c2VyLnVybCgkbG9jYXRpb24uYWJzVXJsKCksIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSAkbG9jYXRpb24gd2hlbiAkYnJvd3NlciB1cmwgY2hhbmdlc1xyXG4gICAgJGJyb3dzZXIub25VcmxDaGFuZ2UoZnVuY3Rpb24obmV3VXJsKSB7XHJcbiAgICAgIGlmICgkbG9jYXRpb24uYWJzVXJsKCkgIT0gbmV3VXJsKSB7XHJcbiAgICAgICAgaWYgKCRyb290U2NvcGUuJGJyb2FkY2FzdCgnJGxvY2F0aW9uQ2hhbmdlU3RhcnQnLCBuZXdVcmwsICRsb2NhdGlvbi5hYnNVcmwoKSkuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgJGJyb3dzZXIudXJsKCRsb2NhdGlvbi5hYnNVcmwoKSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBvbGRVcmwgPSAkbG9jYXRpb24uYWJzVXJsKCk7XHJcblxyXG4gICAgICAgICAgJGxvY2F0aW9uLiQkcGFyc2UobmV3VXJsKTtcclxuICAgICAgICAgIGFmdGVyTG9jYXRpb25DaGFuZ2Uob2xkVXJsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkgJHJvb3RTY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBicm93c2VyXHJcbiAgICB2YXIgY2hhbmdlQ291bnRlciA9IDA7XHJcbiAgICAkcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAkbG9jYXRpb25XYXRjaCgpIHtcclxuICAgICAgdmFyIG9sZFVybCA9ICRicm93c2VyLnVybCgpO1xyXG4gICAgICB2YXIgY3VycmVudFJlcGxhY2UgPSAkbG9jYXRpb24uJCRyZXBsYWNlO1xyXG5cclxuICAgICAgaWYgKCFjaGFuZ2VDb3VudGVyIHx8IG9sZFVybCAhPSAkbG9jYXRpb24uYWJzVXJsKCkpIHtcclxuICAgICAgICBjaGFuZ2VDb3VudGVyKys7XHJcbiAgICAgICAgJHJvb3RTY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJGJyb2FkY2FzdCgnJGxvY2F0aW9uQ2hhbmdlU3RhcnQnLCAkbG9jYXRpb24uYWJzVXJsKCksIG9sZFVybCkuXHJcbiAgICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAkbG9jYXRpb24uJCRwYXJzZShvbGRVcmwpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJGJyb3dzZXIudXJsKCRsb2NhdGlvbi5hYnNVcmwoKSwgY3VycmVudFJlcGxhY2UpO1xyXG4gICAgICAgICAgICBhZnRlckxvY2F0aW9uQ2hhbmdlKG9sZFVybCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgJGxvY2F0aW9uLiQkcmVwbGFjZSA9IGZhbHNlO1xyXG5cclxuICAgICAgcmV0dXJuIGNoYW5nZUNvdW50ZXI7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gJGxvY2F0aW9uO1xyXG5cclxuICAgIGZ1bmN0aW9uIGFmdGVyTG9jYXRpb25DaGFuZ2Uob2xkVXJsKSB7XHJcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsICRsb2NhdGlvbi5hYnNVcmwoKSwgb2xkVXJsKTtcclxuICAgIH1cclxufV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRsb2dcclxuICogQHJlcXVpcmVzICR3aW5kb3dcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNpbXBsZSBzZXJ2aWNlIGZvciBsb2dnaW5nLiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHdyaXRlcyB0aGUgbWVzc2FnZVxyXG4gKiBpbnRvIHRoZSBicm93c2VyJ3MgY29uc29sZSAoaWYgcHJlc2VudCkuXHJcbiAqXHJcbiAqIFRoZSBtYWluIHB1cnBvc2Ugb2YgdGhpcyBzZXJ2aWNlIGlzIHRvIHNpbXBsaWZ5IGRlYnVnZ2luZyBhbmQgdHJvdWJsZXNob290aW5nLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZXhhbXBsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XHJcbiAgICAgICBmdW5jdGlvbiBMb2dDdHJsKCRzY29wZSwgJGxvZykge1xyXG4gICAgICAgICAkc2NvcGUuJGxvZyA9ICRsb2c7XHJcbiAgICAgICAgICRzY29wZS5tZXNzYWdlID0gJ0hlbGxvIFdvcmxkISc7XHJcbiAgICAgICB9XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJMb2dDdHJsXCI+XHJcbiAgICAgICAgIDxwPlJlbG9hZCB0aGlzIHBhZ2Ugd2l0aCBvcGVuIGNvbnNvbGUsIGVudGVyIHRleHQgYW5kIGhpdCB0aGUgbG9nIGJ1dHRvbi4uLjwvcD5cclxuICAgICAgICAgTWVzc2FnZTpcclxuICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJtZXNzYWdlXCIvPlxyXG4gICAgICAgICA8YnV0dG9uIG5nLWNsaWNrPVwiJGxvZy5sb2cobWVzc2FnZSlcIj5sb2c8L2J1dHRvbj5cclxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cIiRsb2cud2FybihtZXNzYWdlKVwiPndhcm48L2J1dHRvbj5cclxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cIiRsb2cuaW5mbyhtZXNzYWdlKVwiPmluZm88L2J1dHRvbj5cclxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cIiRsb2cuZXJyb3IobWVzc2FnZSlcIj5lcnJvcjwvYnV0dG9uPlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9maWxlPlxyXG4gICA8L2V4YW1wbGU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJGxvZ1Byb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBVc2UgdGhlIGAkbG9nUHJvdmlkZXJgIHRvIGNvbmZpZ3VyZSBob3cgdGhlIGFwcGxpY2F0aW9uIGxvZ3MgbWVzc2FnZXNcclxuICovXHJcbmZ1bmN0aW9uICRMb2dQcm92aWRlcigpe1xyXG4gIHZhciBkZWJ1ZyA9IHRydWUsXHJcbiAgICAgIHNlbGYgPSB0aGlzO1xyXG4gIFxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gICAqIEBuYW1lIG5nLiRsb2dQcm92aWRlciNkZWJ1Z0VuYWJsZWRcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1Byb3ZpZGVyXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBmbGFnIGVuYWJsZSBvciBkaXNhYmxlIGRlYnVnIGxldmVsIG1lc3NhZ2VzXHJcbiAgICogQHJldHVybnMgeyp9IGN1cnJlbnQgdmFsdWUgaWYgdXNlZCBhcyBnZXR0ZXIgb3IgaXRzZWxmIChjaGFpbmluZykgaWYgdXNlZCBhcyBzZXR0ZXJcclxuICAgKi9cclxuICB0aGlzLmRlYnVnRW5hYmxlZCA9IGZ1bmN0aW9uKGZsYWcpIHtcclxuXHQgIGlmIChpc0RlZmluZWQoZmxhZykpIHtcclxuXHRcdCAgZGVidWcgPSBmbGFnO1xyXG5cdFx0ICByZXR1cm4gdGhpcztcclxuXHQgIH0gZWxzZSB7XHJcblx0XHQgIHJldHVybiBkZWJ1ZztcclxuXHQgIH1cclxuICB9O1xyXG4gIFxyXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsIGZ1bmN0aW9uKCR3aW5kb3cpe1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICogQG5hbWUgbmcuJGxvZyNsb2dcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFdyaXRlIGEgbG9nIG1lc3NhZ2VcclxuICAgICAgICovXHJcbiAgICAgIGxvZzogY29uc29sZUxvZygnbG9nJyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgKiBAbmFtZSBuZy4kbG9nI2luZm9cclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFdyaXRlIGFuIGluZm9ybWF0aW9uIG1lc3NhZ2VcclxuICAgICAgICovXHJcbiAgICAgIGluZm86IGNvbnNvbGVMb2coJ2luZm8nKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjd2FyblxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1xyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2VcclxuICAgICAgICovXHJcbiAgICAgIHdhcm46IGNvbnNvbGVMb2coJ3dhcm4nKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjZXJyb3JcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFdyaXRlIGFuIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICovXHJcbiAgICAgIGVycm9yOiBjb25zb2xlTG9nKCdlcnJvcicpLFxyXG4gICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICogQG5hbWUgbmcuJGxvZyNkZWJ1Z1xyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1xyXG4gICAgICAgKiBcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFdyaXRlIGEgZGVidWcgbWVzc2FnZVxyXG4gICAgICAgKi9cclxuICAgICAgZGVidWc6IChmdW5jdGlvbiAoKSB7XHJcbiAgICBcdHZhciBmbiA9IGNvbnNvbGVMb2coJ2RlYnVnJyk7XHJcbiAgICBcdFxyXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICBcdFx0aWYgKGRlYnVnKSB7XHJcbiAgICBcdFx0XHRmbi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fVxyXG4gICAgICB9KCkpXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGZvcm1hdEVycm9yKGFyZykge1xyXG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICBpZiAoYXJnLnN0YWNrKSB7XHJcbiAgICAgICAgICBhcmcgPSAoYXJnLm1lc3NhZ2UgJiYgYXJnLnN0YWNrLmluZGV4T2YoYXJnLm1lc3NhZ2UpID09PSAtMSlcclxuICAgICAgICAgICAgICA/ICdFcnJvcjogJyArIGFyZy5tZXNzYWdlICsgJ1xcbicgKyBhcmcuc3RhY2tcclxuICAgICAgICAgICAgICA6IGFyZy5zdGFjaztcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZy5zb3VyY2VVUkwpIHtcclxuICAgICAgICAgIGFyZyA9IGFyZy5tZXNzYWdlICsgJ1xcbicgKyBhcmcuc291cmNlVVJMICsgJzonICsgYXJnLmxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcmc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29uc29sZUxvZyh0eXBlKSB7XHJcbiAgICAgIHZhciBjb25zb2xlID0gJHdpbmRvdy5jb25zb2xlIHx8IHt9LFxyXG4gICAgICAgICAgbG9nRm4gPSBjb25zb2xlW3R5cGVdIHx8IGNvbnNvbGUubG9nIHx8IG5vb3A7XHJcblxyXG4gICAgICBpZiAobG9nRm4uYXBwbHkpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goZm9ybWF0RXJyb3IoYXJnKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybiBsb2dGbi5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB3ZSBhcmUgSUUgd2hpY2ggZWl0aGVyIGRvZXNuJ3QgaGF2ZSB3aW5kb3cuY29uc29sZSA9PiB0aGlzIGlzIG5vb3AgYW5kIHdlIGRvIG5vdGhpbmcsXHJcbiAgICAgIC8vIG9yIHdlIGFyZSBJRSB3aGVyZSBjb25zb2xlLmxvZyBkb2Vzbid0IGhhdmUgYXBwbHkgc28gd2UgbG9nIGF0IGxlYXN0IGZpcnN0IDIgYXJnc1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJnMSwgYXJnMikge1xyXG4gICAgICAgIGxvZ0ZuKGFyZzEsIGFyZzIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfV07XHJcbn1cclxuXHJcbnZhciAkcGFyc2VNaW5FcnIgPSBtaW5FcnIoJyRwYXJzZScpO1xyXG5cclxuLy8gU2FuZGJveGluZyBBbmd1bGFyIEV4cHJlc3Npb25zXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBBbmd1bGFyIGV4cHJlc3Npb25zIGFyZSBnZW5lcmFsbHkgY29uc2lkZXJlZCBzYWZlIGJlY2F1c2UgdGhlc2UgZXhwcmVzc2lvbnMgb25seSBoYXZlIGRpcmVjdCBhY2Nlc3MgdG8gJHNjb3BlIGFuZFxyXG4vLyBsb2NhbHMuIEhvd2V2ZXIsIG9uZSBjYW4gb2J0YWluIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IEpTIGNvZGUgYnkgb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIG5hdGl2ZSBKU1xyXG4vLyBmdW5jdGlvbnMgc3VjaCBhcyB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3IuXHJcbi8vXHJcbi8vIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgQW5ndWxhciBleHByZXNzaW9uOlxyXG4vL1xyXG4vLyAgIHt9LnRvU3RyaW5nLmNvbnN0cnVjdG9yKGFsZXJ0KFwiZXZpbCBKUyBjb2RlXCIpKVxyXG4vL1xyXG4vLyBXZSB3YW50IHRvIHByZXZlbnQgdGhpcyB0eXBlIG9mIGFjY2Vzcy4gRm9yIHRoZSBzYWtlIG9mIHBlcmZvcm1hbmNlLCBkdXJpbmcgdGhlIGxleGluZyBwaGFzZSB3ZSBkaXNhbGxvdyBhbnkgXCJkb3R0ZWRcIlxyXG4vLyBhY2Nlc3MgdG8gYW55IG1lbWJlciBuYW1lZCBcImNvbnN0cnVjdG9yXCIuXHJcbi8vXHJcbi8vIEZvciByZWZsZWN0aXZlIGNhbGxzIChhW2JdKSB3ZSBjaGVjayB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgbG9va3VwIGlzIG5vdCB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3Igd2hpbGUgZXZhbHVhdGluZ1xyXG4vLyB0aGUgZXhwcmVzc2lvbiwgd2hpY2ggaXMgYSBzdHJvbmdlciBidXQgbW9yZSBleHBlbnNpdmUgdGVzdC4gU2luY2UgcmVmbGVjdGl2ZSBjYWxscyBhcmUgZXhwZW5zaXZlIGFueXdheSwgdGhpcyBpcyBub3RcclxuLy8gc3VjaCBhIGJpZyBkZWFsIGNvbXBhcmVkIHRvIHN0YXRpYyBkZXJlZmVyZW5jaW5nLlxyXG4vL1xyXG4vLyBUaGlzIHNhbmRib3hpbmcgdGVjaG5pcXVlIGlzIG5vdCBwZXJmZWN0IGFuZCBkb2Vzbid0IGFpbSB0byBiZS4gVGhlIGdvYWwgaXMgdG8gcHJldmVudCBleHBsb2l0cyBhZ2FpbnN0IHRoZVxyXG4vLyBleHByZXNzaW9uIGxhbmd1YWdlLCBidXQgbm90IHRvIHByZXZlbnQgZXhwbG9pdHMgdGhhdCB3ZXJlIGVuYWJsZWQgYnkgZXhwb3Npbmcgc2Vuc2l0aXZlIEphdmFTY3JpcHQgb3IgYnJvd3NlciBhcGlzXHJcbi8vIG9uIFNjb3BlLiBFeHBvc2luZyBzdWNoIG9iamVjdHMgb24gYSBTY29wZSBpcyBuZXZlciBhIGdvb2QgcHJhY3RpY2UgYW5kIHRoZXJlZm9yZSB3ZSBhcmUgbm90IGV2ZW4gdHJ5aW5nIHRvIHByb3RlY3RcclxuLy8gYWdhaW5zdCBpbnRlcmFjdGlvbiB3aXRoIGFuIG9iamVjdCBleHBsaWNpdGx5IGV4cG9zZWQgaW4gdGhpcyB3YXkuXHJcbi8vXHJcbi8vIEEgZGV2ZWxvcGVyIGNvdWxkIGZvaWwgdGhlIG5hbWUgY2hlY2sgYnkgYWxpYXNpbmcgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIHVuZGVyIGEgZGlmZmVyZW50IG5hbWUgb24gdGhlIHNjb3BlLlxyXG4vL1xyXG4vLyBJbiBnZW5lcmFsLCBpdCBpcyBub3QgcG9zc2libGUgdG8gYWNjZXNzIGEgV2luZG93IG9iamVjdCBmcm9tIGFuIGFuZ3VsYXIgZXhwcmVzc2lvbiB1bmxlc3MgYSB3aW5kb3cgb3Igc29tZSBET01cclxuLy8gb2JqZWN0IHRoYXQgaGFzIGEgcmVmZXJlbmNlIHRvIHdpbmRvdyBpcyBwdWJsaXNoZWQgb250byBhIFNjb3BlLlxyXG5cclxuZnVuY3Rpb24gZW5zdXJlU2FmZU1lbWJlck5hbWUobmFtZSwgZnVsbEV4cHJlc3Npb24pIHtcclxuICBpZiAobmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XHJcbiAgICB0aHJvdyAkcGFyc2VNaW5FcnIoJ2lzZWNmbGQnLFxyXG4gICAgICAgICdSZWZlcmVuY2luZyBcImNvbnN0cnVjdG9yXCIgZmllbGQgaW4gQW5ndWxhciBleHByZXNzaW9ucyBpcyBkaXNhbGxvd2VkISBFeHByZXNzaW9uOiB7MH0nLCBmdWxsRXhwcmVzc2lvbik7XHJcbiAgfVxyXG4gIHJldHVybiBuYW1lO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZW5zdXJlU2FmZU9iamVjdChvYmosIGZ1bGxFeHByZXNzaW9uKSB7XHJcbiAgLy8gbmlmdHkgY2hlY2sgaWYgb2JqIGlzIEZ1bmN0aW9uIHRoYXQgaXMgZmFzdCBhbmQgd29ya3MgYWNyb3NzIGlmcmFtZXMgYW5kIG90aGVyIGNvbnRleHRzXHJcbiAgaWYgKG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IG9iaikge1xyXG4gICAgdGhyb3cgJHBhcnNlTWluRXJyKCdpc2VjZm4nLFxyXG4gICAgICAgICdSZWZlcmVuY2luZyBGdW5jdGlvbiBpbiBBbmd1bGFyIGV4cHJlc3Npb25zIGlzIGRpc2FsbG93ZWQhIEV4cHJlc3Npb246IHswfScsIGZ1bGxFeHByZXNzaW9uKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9XHJcbn1cclxuXHJcblxyXG52YXIgT1BFUkFUT1JTID0ge1xyXG4gICAgJ251bGwnOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw7fSxcclxuICAgICd0cnVlJzpmdW5jdGlvbigpe3JldHVybiB0cnVlO30sXHJcbiAgICAnZmFsc2UnOmZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlO30sXHJcbiAgICB1bmRlZmluZWQ6bm9vcCxcclxuICAgICcrJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7XHJcbiAgICAgIGE9YShzZWxmLCBsb2NhbHMpOyBiPWIoc2VsZiwgbG9jYWxzKTtcclxuICAgICAgaWYgKGlzRGVmaW5lZChhKSkge1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQoYikpIHtcclxuICAgICAgICAgIHJldHVybiBhICsgYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlzRGVmaW5lZChiKT9iOnVuZGVmaW5lZDt9LFxyXG4gICAgJy0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXthPWEoc2VsZiwgbG9jYWxzKTsgYj1iKHNlbGYsIGxvY2Fscyk7IHJldHVybiAoaXNEZWZpbmVkKGEpP2E6MCktKGlzRGVmaW5lZChiKT9iOjApO30sXHJcbiAgICAnKic6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscykqYihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnLyc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscykvYihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnJSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscyklYihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnXic6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscyleYihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnPSc6bm9vcCxcclxuICAgICc9PT0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSwgYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKT09PWIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJyE9PSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLCBiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpIT09YihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnPT0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpPT1iKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICchPSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscykhPWIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJzwnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpPGIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJz4nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpPmIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJzw9JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKTw9YihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnPj0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpPj1iKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICcmJic6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscykmJmIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJ3x8JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKXx8YihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnJic6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscykmYihzZWxmLCBsb2NhbHMpO30sXHJcbi8vICAgICd8JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGF8Yjt9LFxyXG4gICAgJ3wnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYihzZWxmLCBsb2NhbHMpKHNlbGYsIGxvY2FscywgYShzZWxmLCBsb2NhbHMpKTt9LFxyXG4gICAgJyEnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSl7cmV0dXJuICFhKHNlbGYsIGxvY2Fscyk7fVxyXG59O1xyXG52YXIgRVNDQVBFID0ge1wiblwiOlwiXFxuXCIsIFwiZlwiOlwiXFxmXCIsIFwiclwiOlwiXFxyXCIsIFwidFwiOlwiXFx0XCIsIFwidlwiOlwiXFx2XCIsIFwiJ1wiOlwiJ1wiLCAnXCInOidcIid9O1xyXG5cclxuZnVuY3Rpb24gbGV4KHRleHQsIGNzcCl7XHJcbiAgdmFyIHRva2VucyA9IFtdLFxyXG4gICAgICB0b2tlbixcclxuICAgICAgaW5kZXggPSAwLFxyXG4gICAgICBqc29uID0gW10sXHJcbiAgICAgIGNoLFxyXG4gICAgICBsYXN0Q2ggPSAnOic7IC8vIGNhbiBzdGFydCByZWdleHBcclxuXHJcbiAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgIGNoID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xyXG4gICAgaWYgKGlzKCdcIlxcJycpKSB7XHJcbiAgICAgIHJlYWRTdHJpbmcoY2gpO1xyXG4gICAgfSBlbHNlIGlmIChpc051bWJlcihjaCkgfHwgaXMoJy4nKSAmJiBpc051bWJlcihwZWVrKCkpKSB7XHJcbiAgICAgIHJlYWROdW1iZXIoKTtcclxuICAgIH0gZWxzZSBpZiAoaXNJZGVudChjaCkpIHtcclxuICAgICAgcmVhZElkZW50KCk7XHJcbiAgICAgIC8vIGlkZW50aWZpZXJzIGNhbiBvbmx5IGJlIGlmIHRoZSBwcmVjZWRpbmcgY2hhciB3YXMgYSB7IG9yICxcclxuICAgICAgaWYgKHdhcygneywnKSAmJiBqc29uWzBdPT0neycgJiZcclxuICAgICAgICAgKHRva2VuPXRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdKSkge1xyXG4gICAgICAgIHRva2VuLmpzb24gPSB0b2tlbi50ZXh0LmluZGV4T2YoJy4nKSA9PSAtMTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpcygnKCl7fVtdLiw7Oj8nKSkge1xyXG4gICAgICB0b2tlbnMucHVzaCh7XHJcbiAgICAgICAgaW5kZXg6aW5kZXgsXHJcbiAgICAgICAgdGV4dDpjaCxcclxuICAgICAgICBqc29uOih3YXMoJzpbLCcpICYmIGlzKCd7WycpKSB8fCBpcygnfV06LCcpXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoaXMoJ3tbJykpIGpzb24udW5zaGlmdChjaCk7XHJcbiAgICAgIGlmIChpcygnfV0nKSkganNvbi5zaGlmdCgpO1xyXG4gICAgICBpbmRleCsrO1xyXG4gICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoY2gpKSB7XHJcbiAgICAgIGluZGV4Kys7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGNoMiA9IGNoICsgcGVlaygpLFxyXG4gICAgICAgICAgY2gzID0gY2gyICsgcGVlaygyKSxcclxuICAgICAgICAgIGZuID0gT1BFUkFUT1JTW2NoXSxcclxuICAgICAgICAgIGZuMiA9IE9QRVJBVE9SU1tjaDJdLFxyXG4gICAgICAgICAgZm4zID0gT1BFUkFUT1JTW2NoM107XHJcbiAgICAgIGlmIChmbjMpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7aW5kZXg6aW5kZXgsIHRleHQ6Y2gzLCBmbjpmbjN9KTtcclxuICAgICAgICBpbmRleCArPSAzO1xyXG4gICAgICB9IGVsc2UgaWYgKGZuMikge1xyXG4gICAgICAgIHRva2Vucy5wdXNoKHtpbmRleDppbmRleCwgdGV4dDpjaDIsIGZuOmZuMn0pO1xyXG4gICAgICAgIGluZGV4ICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoZm4pIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7aW5kZXg6aW5kZXgsIHRleHQ6Y2gsIGZuOmZuLCBqc29uOiB3YXMoJ1ssOicpICYmIGlzKCcrLScpfSk7XHJcbiAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvd0Vycm9yKFwiVW5leHBlY3RlZCBuZXh0IGNoYXJhY3RlciBcIiwgaW5kZXgsIGluZGV4KzEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsYXN0Q2ggPSBjaDtcclxuICB9XHJcbiAgcmV0dXJuIHRva2VucztcclxuXHJcbiAgZnVuY3Rpb24gaXMoY2hhcnMpIHtcclxuICAgIHJldHVybiBjaGFycy5pbmRleE9mKGNoKSAhPSAtMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdhcyhjaGFycykge1xyXG4gICAgcmV0dXJuIGNoYXJzLmluZGV4T2YobGFzdENoKSAhPSAtMTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZWsoaSkge1xyXG4gICAgdmFyIG51bSA9IGkgfHwgMTtcclxuICAgIHJldHVybiBpbmRleCArIG51bSA8IHRleHQubGVuZ3RoID8gdGV4dC5jaGFyQXQoaW5kZXggKyBudW0pIDogZmFsc2U7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKGNoKSB7XHJcbiAgICByZXR1cm4gJzAnIDw9IGNoICYmIGNoIDw9ICc5JztcclxuICB9XHJcbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNoKSB7XHJcbiAgICByZXR1cm4gY2ggPT0gJyAnIHx8IGNoID09ICdcXHInIHx8IGNoID09ICdcXHQnIHx8XHJcbiAgICAgICAgICAgY2ggPT0gJ1xcbicgfHwgY2ggPT0gJ1xcdicgfHwgY2ggPT0gJ1xcdTAwQTAnOyAvLyBJRSB0cmVhdHMgbm9uLWJyZWFraW5nIHNwYWNlIGFzIFxcdTAwQTBcclxuICB9XHJcbiAgZnVuY3Rpb24gaXNJZGVudChjaCkge1xyXG4gICAgcmV0dXJuICdhJyA8PSBjaCAmJiBjaCA8PSAneicgfHxcclxuICAgICAgICAgICAnQScgPD0gY2ggJiYgY2ggPD0gJ1onIHx8XHJcbiAgICAgICAgICAgJ18nID09IGNoIHx8IGNoID09ICckJztcclxuICB9XHJcbiAgZnVuY3Rpb24gaXNFeHBPcGVyYXRvcihjaCkge1xyXG4gICAgcmV0dXJuIGNoID09ICctJyB8fCBjaCA9PSAnKycgfHwgaXNOdW1iZXIoY2gpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGhyb3dFcnJvcihlcnJvciwgc3RhcnQsIGVuZCkge1xyXG4gICAgZW5kID0gZW5kIHx8IGluZGV4O1xyXG4gICAgdmFyIGNvbFN0ciA9IChpc0RlZmluZWQoc3RhcnQpID9cclxuICAgICAgICBcInMgXCIgKyBzdGFydCArICBcIi1cIiArIGluZGV4ICsgXCIgW1wiICsgdGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCkgKyBcIl1cIlxyXG4gICAgICAgIDogXCIgXCIgKyBlbmQpO1xyXG4gICAgdGhyb3cgJHBhcnNlTWluRXJyKCdsZXhlcnInLCBcIkxleGVyIEVycm9yOiB7MH0gYXQgY29sdW1uezF9IGluIGV4cHJlc3Npb24gW3syfV0uXCIsXHJcbiAgICAgICAgZXJyb3IsIGNvbFN0ciwgdGV4dCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWFkTnVtYmVyKCkge1xyXG4gICAgdmFyIG51bWJlciA9IFwiXCI7XHJcbiAgICB2YXIgc3RhcnQgPSBpbmRleDtcclxuICAgIHdoaWxlIChpbmRleCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBjaCA9IGxvd2VyY2FzZSh0ZXh0LmNoYXJBdChpbmRleCkpO1xyXG4gICAgICBpZiAoY2ggPT0gJy4nIHx8IGlzTnVtYmVyKGNoKSkge1xyXG4gICAgICAgIG51bWJlciArPSBjaDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcGVla0NoID0gcGVlaygpO1xyXG4gICAgICAgIGlmIChjaCA9PSAnZScgJiYgaXNFeHBPcGVyYXRvcihwZWVrQ2gpKSB7XHJcbiAgICAgICAgICBudW1iZXIgKz0gY2g7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0V4cE9wZXJhdG9yKGNoKSAmJlxyXG4gICAgICAgICAgICBwZWVrQ2ggJiYgaXNOdW1iZXIocGVla0NoKSAmJlxyXG4gICAgICAgICAgICBudW1iZXIuY2hhckF0KG51bWJlci5sZW5ndGggLSAxKSA9PSAnZScpIHtcclxuICAgICAgICAgIG51bWJlciArPSBjaDtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRXhwT3BlcmF0b3IoY2gpICYmXHJcbiAgICAgICAgICAgICghcGVla0NoIHx8ICFpc051bWJlcihwZWVrQ2gpKSAmJlxyXG4gICAgICAgICAgICBudW1iZXIuY2hhckF0KG51bWJlci5sZW5ndGggLSAxKSA9PSAnZScpIHtcclxuICAgICAgICAgIHRocm93RXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGluZGV4Kys7XHJcbiAgICB9XHJcbiAgICBudW1iZXIgPSAxICogbnVtYmVyO1xyXG4gICAgdG9rZW5zLnB1c2goe2luZGV4OnN0YXJ0LCB0ZXh0Om51bWJlciwganNvbjp0cnVlLFxyXG4gICAgICBmbjpmdW5jdGlvbigpIHtyZXR1cm4gbnVtYmVyO319KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVhZElkZW50KCkge1xyXG4gICAgdmFyIGlkZW50ID0gXCJcIixcclxuICAgICAgICBzdGFydCA9IGluZGV4LFxyXG4gICAgICAgIGxhc3REb3QsIHBlZWtJbmRleCwgbWV0aG9kTmFtZSwgY2g7XHJcblxyXG4gICAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgY2ggPSB0ZXh0LmNoYXJBdChpbmRleCk7XHJcbiAgICAgIGlmIChjaCA9PSAnLicgfHwgaXNJZGVudChjaCkgfHwgaXNOdW1iZXIoY2gpKSB7XHJcbiAgICAgICAgaWYgKGNoID09ICcuJykgbGFzdERvdCA9IGluZGV4O1xyXG4gICAgICAgIGlkZW50ICs9IGNoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGluZGV4Kys7XHJcbiAgICB9XHJcblxyXG4gICAgLy9jaGVjayBpZiB0aGlzIGlzIG5vdCBhIG1ldGhvZCBpbnZvY2F0aW9uIGFuZCBpZiBpdCBpcyBiYWNrIG91dCB0byBsYXN0IGRvdFxyXG4gICAgaWYgKGxhc3REb3QpIHtcclxuICAgICAgcGVla0luZGV4ID0gaW5kZXg7XHJcbiAgICAgIHdoaWxlKHBlZWtJbmRleCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChwZWVrSW5kZXgpO1xyXG4gICAgICAgIGlmIChjaCA9PSAnKCcpIHtcclxuICAgICAgICAgIG1ldGhvZE5hbWUgPSBpZGVudC5zdWJzdHIobGFzdERvdCAtIHN0YXJ0ICsgMSk7XHJcbiAgICAgICAgICBpZGVudCA9IGlkZW50LnN1YnN0cigwLCBsYXN0RG90IC0gc3RhcnQpO1xyXG4gICAgICAgICAgaW5kZXggPSBwZWVrSW5kZXg7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoaXNXaGl0ZXNwYWNlKGNoKSkge1xyXG4gICAgICAgICAgcGVla0luZGV4Kys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgdG9rZW4gPSB7XHJcbiAgICAgIGluZGV4OnN0YXJ0LFxyXG4gICAgICB0ZXh0OmlkZW50XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChPUEVSQVRPUlMuaGFzT3duUHJvcGVydHkoaWRlbnQpKSB7XHJcbiAgICAgIHRva2VuLmZuID0gdG9rZW4uanNvbiA9IE9QRVJBVE9SU1tpZGVudF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZ2V0dGVyID0gZ2V0dGVyRm4oaWRlbnQsIGNzcCwgdGV4dCk7XHJcbiAgICAgIHRva2VuLmZuID0gZXh0ZW5kKGZ1bmN0aW9uKHNlbGYsIGxvY2Fscykge1xyXG4gICAgICAgIHJldHVybiAoZ2V0dGVyKHNlbGYsIGxvY2FscykpO1xyXG4gICAgICB9LCB7XHJcbiAgICAgICAgYXNzaWduOiBmdW5jdGlvbihzZWxmLCB2YWx1ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHNldHRlcihzZWxmLCBpZGVudCwgdmFsdWUsIHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG5cclxuICAgIGlmIChtZXRob2ROYW1lKSB7XHJcbiAgICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgICBpbmRleDpsYXN0RG90LFxyXG4gICAgICAgIHRleHQ6ICcuJyxcclxuICAgICAgICBqc29uOiBmYWxzZVxyXG4gICAgICB9KTtcclxuICAgICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgIGluZGV4OiBsYXN0RG90ICsgMSxcclxuICAgICAgICB0ZXh0OiBtZXRob2ROYW1lLFxyXG4gICAgICAgIGpzb246IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZFN0cmluZyhxdW90ZSkge1xyXG4gICAgdmFyIHN0YXJ0ID0gaW5kZXg7XHJcbiAgICBpbmRleCsrO1xyXG4gICAgdmFyIHN0cmluZyA9IFwiXCI7XHJcbiAgICB2YXIgcmF3U3RyaW5nID0gcXVvdGU7XHJcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChpbmRleCk7XHJcbiAgICAgIHJhd1N0cmluZyArPSBjaDtcclxuICAgICAgaWYgKGVzY2FwZSkge1xyXG4gICAgICAgIGlmIChjaCA9PSAndScpIHtcclxuICAgICAgICAgIHZhciBoZXggPSB0ZXh0LnN1YnN0cmluZyhpbmRleCArIDEsIGluZGV4ICsgNSk7XHJcbiAgICAgICAgICBpZiAoIWhleC5tYXRjaCgvW1xcZGEtZl17NH0vaSkpXHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoIFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZSBbXFxcXHVcIiArIGhleCArIFwiXVwiKTtcclxuICAgICAgICAgIGluZGV4ICs9IDQ7XHJcbiAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciByZXAgPSBFU0NBUEVbY2hdO1xyXG4gICAgICAgICAgaWYgKHJlcCkge1xyXG4gICAgICAgICAgICBzdHJpbmcgKz0gcmVwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIGlmIChjaCA9PSAnXFxcXCcpIHtcclxuICAgICAgICBlc2NhcGUgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoID09IHF1b3RlKSB7XHJcbiAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB0b2tlbnMucHVzaCh7XHJcbiAgICAgICAgICBpbmRleDpzdGFydCxcclxuICAgICAgICAgIHRleHQ6cmF3U3RyaW5nLFxyXG4gICAgICAgICAgc3RyaW5nOnN0cmluZyxcclxuICAgICAgICAgIGpzb246dHJ1ZSxcclxuICAgICAgICAgIGZuOmZ1bmN0aW9uKCkgeyByZXR1cm4gc3RyaW5nOyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0cmluZyArPSBjaDtcclxuICAgICAgfVxyXG4gICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gICAgdGhyb3dFcnJvcihcIlVudGVybWluYXRlZCBxdW90ZVwiLCBzdGFydCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuZnVuY3Rpb24gcGFyc2VyKHRleHQsIGpzb24sICRmaWx0ZXIsIGNzcCl7XHJcbiAgdmFyIFpFUk8gPSB2YWx1ZUZuKDApLFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgdG9rZW5zID0gbGV4KHRleHQsIGNzcCksXHJcbiAgICAgIGFzc2lnbm1lbnQgPSBfYXNzaWdubWVudCxcclxuICAgICAgZnVuY3Rpb25DYWxsID0gX2Z1bmN0aW9uQ2FsbCxcclxuICAgICAgZmllbGRBY2Nlc3MgPSBfZmllbGRBY2Nlc3MsXHJcbiAgICAgIG9iamVjdEluZGV4ID0gX29iamVjdEluZGV4LFxyXG4gICAgICBmaWx0ZXJDaGFpbiA9IF9maWx0ZXJDaGFpbjtcclxuXHJcbiAgaWYoanNvbil7XHJcbiAgICAvLyBUaGUgZXh0cmEgbGV2ZWwgb2YgYWxpYXNpbmcgaXMgaGVyZSwganVzdCBpbiBjYXNlIHRoZSBsZXhlciBtaXNzZXMgc29tZXRoaW5nLCBzbyB0aGF0XHJcbiAgICAvLyB3ZSBwcmV2ZW50IGFueSBhY2NpZGVudGFsIGV4ZWN1dGlvbiBpbiBKU09OLlxyXG4gICAgYXNzaWdubWVudCA9IGxvZ2ljYWxPUjtcclxuICAgIGZ1bmN0aW9uQ2FsbCA9XHJcbiAgICAgIGZpZWxkQWNjZXNzID1cclxuICAgICAgb2JqZWN0SW5kZXggPVxyXG4gICAgICBmaWx0ZXJDaGFpbiA9XHJcbiAgICAgICAgZnVuY3Rpb24oKSB7IHRocm93RXJyb3IoXCJpcyBub3QgdmFsaWQganNvblwiLCB7dGV4dDp0ZXh0LCBpbmRleDowfSk7IH07XHJcbiAgICB2YWx1ZSA9IHByaW1hcnkoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFsdWUgPSBzdGF0ZW1lbnRzKCk7XHJcbiAgfVxyXG4gIGlmICh0b2tlbnMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICB0aHJvd0Vycm9yKFwiaXMgYW4gdW5leHBlY3RlZCB0b2tlblwiLCB0b2tlbnNbMF0pO1xyXG4gIH1cclxuICB2YWx1ZS5saXRlcmFsID0gISF2YWx1ZS5saXRlcmFsO1xyXG4gIHZhbHVlLmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcclxuICByZXR1cm4gdmFsdWU7XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgZnVuY3Rpb24gdGhyb3dFcnJvcihtc2csIHRva2VuKSB7XHJcbiAgICB0aHJvdyAkcGFyc2VNaW5FcnIoJ3N5bnRheCcsXHJcbiAgICAgICAgXCJTeW50YXggRXJyb3I6IFRva2VuICd7MH0nIHsxfSBhdCBjb2x1bW4gezJ9IG9mIHRoZSBleHByZXNzaW9uIFt7M31dIHN0YXJ0aW5nIGF0IFt7NH1dLlwiLFxyXG4gICAgICAgIHRva2VuLnRleHQsIG1zZywgKHRva2VuLmluZGV4ICsgMSksIHRleHQsIHRleHQuc3Vic3RyaW5nKHRva2VuLmluZGV4KSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWVrVG9rZW4oKSB7XHJcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMClcclxuICAgICAgdGhyb3cgJHBhcnNlTWluRXJyKCd1ZW9lJywgXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiB7MH1cIiwgdGV4dCk7XHJcbiAgICByZXR1cm4gdG9rZW5zWzBdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVlayhlMSwgZTIsIGUzLCBlNCkge1xyXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1swXTtcclxuICAgICAgdmFyIHQgPSB0b2tlbi50ZXh0O1xyXG4gICAgICBpZiAodD09ZTEgfHwgdD09ZTIgfHwgdD09ZTMgfHwgdD09ZTQgfHxcclxuICAgICAgICAgICghZTEgJiYgIWUyICYmICFlMyAmJiAhZTQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBleHBlY3QoZTEsIGUyLCBlMywgZTQpe1xyXG4gICAgdmFyIHRva2VuID0gcGVlayhlMSwgZTIsIGUzLCBlNCk7XHJcbiAgICBpZiAodG9rZW4pIHtcclxuICAgICAgaWYgKGpzb24gJiYgIXRva2VuLmpzb24pIHtcclxuICAgICAgICB0aHJvd0Vycm9yKFwiaXMgbm90IHZhbGlkIGpzb25cIiwgdG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHRva2Vucy5zaGlmdCgpO1xyXG4gICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb25zdW1lKGUxKXtcclxuICAgIGlmICghZXhwZWN0KGUxKSkge1xyXG4gICAgICB0aHJvd0Vycm9yKFwiaXMgdW5leHBlY3RlZCwgZXhwZWN0aW5nIFtcIiArIGUxICsgXCJdXCIsIHBlZWsoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1bmFyeUZuKGZuLCByaWdodCkge1xyXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbihzZWxmLCBsb2NhbHMpIHtcclxuICAgICAgcmV0dXJuIGZuKHNlbGYsIGxvY2FscywgcmlnaHQpO1xyXG4gICAgfSwge1xyXG4gICAgICBjb25zdGFudDpyaWdodC5jb25zdGFudFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0ZXJuYXJ5Rm4obGVmdCwgbWlkZGxlLCByaWdodCl7XHJcbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uKHNlbGYsIGxvY2Fscyl7XHJcbiAgICAgIHJldHVybiBsZWZ0KHNlbGYsIGxvY2FscykgPyBtaWRkbGUoc2VsZiwgbG9jYWxzKSA6IHJpZ2h0KHNlbGYsIGxvY2Fscyk7XHJcbiAgICB9LCB7XHJcbiAgICAgIGNvbnN0YW50OiBsZWZ0LmNvbnN0YW50ICYmIG1pZGRsZS5jb25zdGFudCAmJiByaWdodC5jb25zdGFudFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBiaW5hcnlGbihsZWZ0LCBmbiwgcmlnaHQpIHtcclxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKSB7XHJcbiAgICAgIHJldHVybiBmbihzZWxmLCBsb2NhbHMsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH0sIHtcclxuICAgICAgY29uc3RhbnQ6bGVmdC5jb25zdGFudCAmJiByaWdodC5jb25zdGFudFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzdGF0ZW1lbnRzKCkge1xyXG4gICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcclxuICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmICFwZWVrKCd9JywgJyknLCAnOycsICddJykpXHJcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGZpbHRlckNoYWluKCkpO1xyXG4gICAgICBpZiAoIWV4cGVjdCgnOycpKSB7XHJcbiAgICAgICAgLy8gb3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSB0aGVyZSBpcyBvbmx5IG9uZSBzdGF0ZW1lbnQuXHJcbiAgICAgICAgLy8gVE9ETyhzaXplKTogbWF5YmUgd2Ugc2hvdWxkIG5vdCBzdXBwb3J0IG11bHRpcGxlIHN0YXRlbWVudHM/XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHMubGVuZ3RoID09IDFcclxuICAgICAgICAgID8gc3RhdGVtZW50c1swXVxyXG4gICAgICAgICAgOiBmdW5jdGlvbihzZWxmLCBsb2NhbHMpe1xyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gc3RhdGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICBpZiAoc3RhdGVtZW50KVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZW1lbnQoc2VsZiwgbG9jYWxzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZmlsdGVyQ2hhaW4oKSB7XHJcbiAgICB2YXIgbGVmdCA9IGV4cHJlc3Npb24oKTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgaWYgKCh0b2tlbiA9IGV4cGVjdCgnfCcpKSkge1xyXG4gICAgICAgIGxlZnQgPSBiaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgZmlsdGVyKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaWx0ZXIoKSB7XHJcbiAgICB2YXIgdG9rZW4gPSBleHBlY3QoKTtcclxuICAgIHZhciBmbiA9ICRmaWx0ZXIodG9rZW4udGV4dCk7XHJcbiAgICB2YXIgYXJnc0ZuID0gW107XHJcbiAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgIGlmICgodG9rZW4gPSBleHBlY3QoJzonKSkpIHtcclxuICAgICAgICBhcmdzRm4ucHVzaChleHByZXNzaW9uKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBmbkludm9rZSA9IGZ1bmN0aW9uKHNlbGYsIGxvY2FscywgaW5wdXQpe1xyXG4gICAgICAgICAgdmFyIGFyZ3MgPSBbaW5wdXRdO1xyXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJnc0ZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmdzRm5baV0oc2VsZiwgbG9jYWxzKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gZm5JbnZva2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXhwcmVzc2lvbigpIHtcclxuICAgIHJldHVybiBhc3NpZ25tZW50KCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfYXNzaWdubWVudCgpIHtcclxuICAgIHZhciBsZWZ0ID0gdGVybmFyeSgpO1xyXG4gICAgdmFyIHJpZ2h0O1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKCh0b2tlbiA9IGV4cGVjdCgnPScpKSkge1xyXG4gICAgICBpZiAoIWxlZnQuYXNzaWduKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcihcImltcGxpZXMgYXNzaWdubWVudCBidXQgW1wiICtcclxuICAgICAgICAgIHRleHQuc3Vic3RyaW5nKDAsIHRva2VuLmluZGV4KSArIFwiXSBjYW4gbm90IGJlIGFzc2lnbmVkIHRvXCIsIHRva2VuKTtcclxuICAgICAgfVxyXG4gICAgICByaWdodCA9IHRlcm5hcnkoKTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBsb2NhbHMpe1xyXG4gICAgICAgIHJldHVybiBsZWZ0LmFzc2lnbihzY29wZSwgcmlnaHQoc2NvcGUsIGxvY2FscyksIGxvY2Fscyk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbGVmdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRlcm5hcnkoKSB7XHJcbiAgICB2YXIgbGVmdCA9IGxvZ2ljYWxPUigpO1xyXG4gICAgdmFyIG1pZGRsZTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIGlmKCh0b2tlbiA9IGV4cGVjdCgnPycpKSl7XHJcbiAgICAgIG1pZGRsZSA9IHRlcm5hcnkoKTtcclxuICAgICAgaWYoKHRva2VuID0gZXhwZWN0KCc6JykpKXtcclxuICAgICAgICByZXR1cm4gdGVybmFyeUZuKGxlZnQsIG1pZGRsZSwgdGVybmFyeSgpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aHJvd0Vycm9yKCdleHBlY3RlZCA6JywgdG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2dpY2FsT1IoKSB7XHJcbiAgICB2YXIgbGVmdCA9IGxvZ2ljYWxBTkQoKTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgaWYgKCh0b2tlbiA9IGV4cGVjdCgnfHwnKSkpIHtcclxuICAgICAgICBsZWZ0ID0gYmluYXJ5Rm4obGVmdCwgdG9rZW4uZm4sIGxvZ2ljYWxBTkQoKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvZ2ljYWxBTkQoKSB7XHJcbiAgICB2YXIgbGVmdCA9IGVxdWFsaXR5KCk7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICBpZiAoKHRva2VuID0gZXhwZWN0KCcmJicpKSkge1xyXG4gICAgICBsZWZ0ID0gYmluYXJ5Rm4obGVmdCwgdG9rZW4uZm4sIGxvZ2ljYWxBTkQoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVxdWFsaXR5KCkge1xyXG4gICAgdmFyIGxlZnQgPSByZWxhdGlvbmFsKCk7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICBpZiAoKHRva2VuID0gZXhwZWN0KCc9PScsJyE9JywnPT09JywnIT09JykpKSB7XHJcbiAgICAgIGxlZnQgPSBiaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgZXF1YWxpdHkoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbGF0aW9uYWwoKSB7XHJcbiAgICB2YXIgbGVmdCA9IGFkZGl0aXZlKCk7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICBpZiAoKHRva2VuID0gZXhwZWN0KCc8JywgJz4nLCAnPD0nLCAnPj0nKSkpIHtcclxuICAgICAgbGVmdCA9IGJpbmFyeUZuKGxlZnQsIHRva2VuLmZuLCByZWxhdGlvbmFsKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRpdGl2ZSgpIHtcclxuICAgIHZhciBsZWZ0ID0gbXVsdGlwbGljYXRpdmUoKTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIHdoaWxlICgodG9rZW4gPSBleHBlY3QoJysnLCctJykpKSB7XHJcbiAgICAgIGxlZnQgPSBiaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgbXVsdGlwbGljYXRpdmUoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG11bHRpcGxpY2F0aXZlKCkge1xyXG4gICAgdmFyIGxlZnQgPSB1bmFyeSgpO1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgd2hpbGUgKCh0b2tlbiA9IGV4cGVjdCgnKicsJy8nLCclJykpKSB7XHJcbiAgICAgIGxlZnQgPSBiaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgdW5hcnkoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVuYXJ5KCkge1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKGV4cGVjdCgnKycpKSB7XHJcbiAgICAgIHJldHVybiBwcmltYXJ5KCk7XHJcbiAgICB9IGVsc2UgaWYgKCh0b2tlbiA9IGV4cGVjdCgnLScpKSkge1xyXG4gICAgICByZXR1cm4gYmluYXJ5Rm4oWkVSTywgdG9rZW4uZm4sIHVuYXJ5KCkpO1xyXG4gICAgfSBlbHNlIGlmICgodG9rZW4gPSBleHBlY3QoJyEnKSkpIHtcclxuICAgICAgcmV0dXJuIHVuYXJ5Rm4odG9rZW4uZm4sIHVuYXJ5KCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHByaW1hcnkoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBwcmltYXJ5KCkge1xyXG4gICAgdmFyIHByaW1hcnk7XHJcbiAgICBpZiAoZXhwZWN0KCcoJykpIHtcclxuICAgICAgcHJpbWFyeSA9IGZpbHRlckNoYWluKCk7XHJcbiAgICAgIGNvbnN1bWUoJyknKTtcclxuICAgIH0gZWxzZSBpZiAoZXhwZWN0KCdbJykpIHtcclxuICAgICAgcHJpbWFyeSA9IGFycmF5RGVjbGFyYXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAoZXhwZWN0KCd7JykpIHtcclxuICAgICAgcHJpbWFyeSA9IG9iamVjdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHRva2VuID0gZXhwZWN0KCk7XHJcbiAgICAgIHByaW1hcnkgPSB0b2tlbi5mbjtcclxuICAgICAgaWYgKCFwcmltYXJ5KSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcihcIm5vdCBhIHByaW1hcnkgZXhwcmVzc2lvblwiLCB0b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRva2VuLmpzb24pIHtcclxuICAgICAgICBwcmltYXJ5LmNvbnN0YW50ID0gcHJpbWFyeS5saXRlcmFsID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXh0LCBjb250ZXh0O1xyXG4gICAgd2hpbGUgKChuZXh0ID0gZXhwZWN0KCcoJywgJ1snLCAnLicpKSkge1xyXG4gICAgICBpZiAobmV4dC50ZXh0ID09PSAnKCcpIHtcclxuICAgICAgICBwcmltYXJ5ID0gZnVuY3Rpb25DYWxsKHByaW1hcnksIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnRleHQgPSBudWxsO1xyXG4gICAgICB9IGVsc2UgaWYgKG5leHQudGV4dCA9PT0gJ1snKSB7XHJcbiAgICAgICAgY29udGV4dCA9IHByaW1hcnk7XHJcbiAgICAgICAgcHJpbWFyeSA9IG9iamVjdEluZGV4KHByaW1hcnkpO1xyXG4gICAgICB9IGVsc2UgaWYgKG5leHQudGV4dCA9PT0gJy4nKSB7XHJcbiAgICAgICAgY29udGV4dCA9IHByaW1hcnk7XHJcbiAgICAgICAgcHJpbWFyeSA9IGZpZWxkQWNjZXNzKHByaW1hcnkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93RXJyb3IoXCJJTVBPU1NJQkxFXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpbWFyeTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9maWVsZEFjY2VzcyhvYmplY3QpIHtcclxuICAgIHZhciBmaWVsZCA9IGV4cGVjdCgpLnRleHQ7XHJcbiAgICB2YXIgZ2V0dGVyID0gZ2V0dGVyRm4oZmllbGQsIGNzcCwgdGV4dCk7XHJcbiAgICByZXR1cm4gZXh0ZW5kKFxyXG4gICAgICAgIGZ1bmN0aW9uKHNjb3BlLCBsb2NhbHMsIHNlbGYpIHtcclxuICAgICAgICAgIHJldHVybiBnZXR0ZXIoc2VsZiB8fCBvYmplY3Qoc2NvcGUsIGxvY2FscyksIGxvY2Fscyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBhc3NpZ246ZnVuY3Rpb24oc2NvcGUsIHZhbHVlLCBsb2NhbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHRlcihvYmplY3Qoc2NvcGUsIGxvY2FscyksIGZpZWxkLCB2YWx1ZSwgdGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIF9vYmplY3RJbmRleChvYmopIHtcclxuICAgIHZhciBpbmRleEZuID0gZXhwcmVzc2lvbigpO1xyXG4gICAgY29uc3VtZSgnXScpO1xyXG4gICAgcmV0dXJuIGV4dGVuZChcclxuICAgICAgZnVuY3Rpb24oc2VsZiwgbG9jYWxzKXtcclxuICAgICAgICB2YXIgbyA9IG9iaihzZWxmLCBsb2NhbHMpLFxyXG4gICAgICAgICAgICBpID0gaW5kZXhGbihzZWxmLCBsb2NhbHMpLFxyXG4gICAgICAgICAgICB2LCBwO1xyXG5cclxuICAgICAgICBpZiAoIW8pIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgdiA9IGVuc3VyZVNhZmVPYmplY3Qob1tpXSwgdGV4dCk7XHJcbiAgICAgICAgaWYgKHYgJiYgdi50aGVuKSB7XHJcbiAgICAgICAgICBwID0gdjtcclxuICAgICAgICAgIGlmICghKCckJHYnIGluIHYpKSB7XHJcbiAgICAgICAgICAgIHAuJCR2ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24odmFsKSB7IHAuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHYgPSB2LiQkdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgIH0sIHtcclxuICAgICAgICBhc3NpZ246ZnVuY3Rpb24oc2VsZiwgdmFsdWUsIGxvY2Fscyl7XHJcbiAgICAgICAgICB2YXIga2V5ID0gaW5kZXhGbihzZWxmLCBsb2NhbHMpO1xyXG4gICAgICAgICAgLy8gcHJldmVudCBvdmVyd3JpdGluZyBvZiBGdW5jdGlvbi5jb25zdHJ1Y3RvciB3aGljaCB3b3VsZCBicmVhayBlbnN1cmVTYWZlT2JqZWN0IGNoZWNrXHJcbiAgICAgICAgICByZXR1cm4gZW5zdXJlU2FmZU9iamVjdChvYmooc2VsZiwgbG9jYWxzKSwgdGV4dClba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZnVuY3Rpb25DYWxsKGZuLCBjb250ZXh0R2V0dGVyKSB7XHJcbiAgICB2YXIgYXJnc0ZuID0gW107XHJcbiAgICBpZiAocGVla1Rva2VuKCkudGV4dCAhPSAnKScpIHtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIGFyZ3NGbi5wdXNoKGV4cHJlc3Npb24oKSk7XHJcbiAgICAgIH0gd2hpbGUgKGV4cGVjdCgnLCcpKTtcclxuICAgIH1cclxuICAgIGNvbnN1bWUoJyknKTtcclxuICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgbG9jYWxzKXtcclxuICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0R2V0dGVyID8gY29udGV4dEdldHRlcihzY29wZSwgbG9jYWxzKSA6IHNjb3BlO1xyXG5cclxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJnc0ZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXJncy5wdXNoKGFyZ3NGbltpXShzY29wZSwgbG9jYWxzKSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGZuUHRyID0gZm4oc2NvcGUsIGxvY2FscywgY29udGV4dCkgfHwgbm9vcDtcclxuICAgICAgLy8gSUUgc3R1cGlkaXR5IVxyXG4gICAgICB2YXIgdiA9IGZuUHRyLmFwcGx5XHJcbiAgICAgICAgICA/IGZuUHRyLmFwcGx5KGNvbnRleHQsIGFyZ3MpXHJcbiAgICAgICAgICA6IGZuUHRyKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHByb21pc2VcclxuICAgICAgaWYgKHYgJiYgdi50aGVuKSB7XHJcbiAgICAgICAgdmFyIHAgPSB2O1xyXG4gICAgICAgIGlmICghKCckJHYnIGluIHYpKSB7XHJcbiAgICAgICAgICBwLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIHAudGhlbihmdW5jdGlvbih2YWwpIHsgcC4kJHYgPSB2YWw7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ID0gdi4kJHY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB2O1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFRoaXMgaXMgdXNlZCB3aXRoIGpzb24gYXJyYXkgZGVjbGFyYXRpb25cclxuICBmdW5jdGlvbiBhcnJheURlY2xhcmF0aW9uICgpIHtcclxuICAgIHZhciBlbGVtZW50Rm5zID0gW107XHJcbiAgICB2YXIgYWxsQ29uc3RhbnQgPSB0cnVlO1xyXG4gICAgaWYgKHBlZWtUb2tlbigpLnRleHQgIT0gJ10nKSB7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICB2YXIgZWxlbWVudEZuID0gZXhwcmVzc2lvbigpO1xyXG4gICAgICAgIGVsZW1lbnRGbnMucHVzaChlbGVtZW50Rm4pO1xyXG4gICAgICAgIGlmICghZWxlbWVudEZuLmNvbnN0YW50KSB7XHJcbiAgICAgICAgICBhbGxDb25zdGFudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSB3aGlsZSAoZXhwZWN0KCcsJykpO1xyXG4gICAgfVxyXG4gICAgY29uc3VtZSgnXScpO1xyXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbihzZWxmLCBsb2NhbHMpe1xyXG4gICAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudEZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudEZuc1tpXShzZWxmLCBsb2NhbHMpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9LCB7XHJcbiAgICAgIGxpdGVyYWw6dHJ1ZSxcclxuICAgICAgY29uc3RhbnQ6YWxsQ29uc3RhbnRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2JqZWN0ICgpIHtcclxuICAgIHZhciBrZXlWYWx1ZXMgPSBbXTtcclxuICAgIHZhciBhbGxDb25zdGFudCA9IHRydWU7XHJcbiAgICBpZiAocGVla1Rva2VuKCkudGV4dCAhPSAnfScpIHtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIHZhciB0b2tlbiA9IGV4cGVjdCgpLFxyXG4gICAgICAgIGtleSA9IHRva2VuLnN0cmluZyB8fCB0b2tlbi50ZXh0O1xyXG4gICAgICAgIGNvbnN1bWUoXCI6XCIpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHJlc3Npb24oKTtcclxuICAgICAgICBrZXlWYWx1ZXMucHVzaCh7a2V5OmtleSwgdmFsdWU6dmFsdWV9KTtcclxuICAgICAgICBpZiAoIXZhbHVlLmNvbnN0YW50KSB7XHJcbiAgICAgICAgICBhbGxDb25zdGFudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSB3aGlsZSAoZXhwZWN0KCcsJykpO1xyXG4gICAgfVxyXG4gICAgY29uc3VtZSgnfScpO1xyXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbihzZWxmLCBsb2NhbHMpe1xyXG4gICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBrZXlWYWx1ZSA9IGtleVZhbHVlc1tpXTtcclxuICAgICAgICBvYmplY3Rba2V5VmFsdWUua2V5XSA9IGtleVZhbHVlLnZhbHVlKHNlbGYsIGxvY2Fscyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH0sIHtcclxuICAgICAgbGl0ZXJhbDp0cnVlLFxyXG4gICAgICBjb25zdGFudDphbGxDb25zdGFudFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBQYXJzZXIgaGVscGVyIGZ1bmN0aW9uc1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuZnVuY3Rpb24gc2V0dGVyKG9iaiwgcGF0aCwgc2V0VmFsdWUsIGZ1bGxFeHApIHtcclxuICB2YXIgZWxlbWVudCA9IHBhdGguc3BsaXQoJy4nKSwga2V5O1xyXG4gIGZvciAodmFyIGkgPSAwOyBlbGVtZW50Lmxlbmd0aCA+IDE7IGkrKykge1xyXG4gICAga2V5ID0gZW5zdXJlU2FmZU1lbWJlck5hbWUoZWxlbWVudC5zaGlmdCgpLCBmdWxsRXhwKTtcclxuICAgIHZhciBwcm9wZXJ0eU9iaiA9IG9ialtrZXldO1xyXG4gICAgaWYgKCFwcm9wZXJ0eU9iaikge1xyXG4gICAgICBwcm9wZXJ0eU9iaiA9IHt9O1xyXG4gICAgICBvYmpba2V5XSA9IHByb3BlcnR5T2JqO1xyXG4gICAgfVxyXG4gICAgb2JqID0gcHJvcGVydHlPYmo7XHJcbiAgICBpZiAob2JqLnRoZW4pIHtcclxuICAgICAgaWYgKCEoXCIkJHZcIiBpbiBvYmopKSB7XHJcbiAgICAgICAgKGZ1bmN0aW9uKHByb21pc2UpIHtcclxuICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWwpIHsgcHJvbWlzZS4kJHYgPSB2YWw7IH0pOyB9XHJcbiAgICAgICAgKShvYmopO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvYmouJCR2ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvYmouJCR2ID0ge307XHJcbiAgICAgIH1cclxuICAgICAgb2JqID0gb2JqLiQkdjtcclxuICAgIH1cclxuICB9XHJcbiAga2V5ID0gZW5zdXJlU2FmZU1lbWJlck5hbWUoZWxlbWVudC5zaGlmdCgpLCBmdWxsRXhwKTtcclxuICBvYmpba2V5XSA9IHNldFZhbHVlO1xyXG4gIHJldHVybiBzZXRWYWx1ZTtcclxufVxyXG5cclxudmFyIGdldHRlckZuQ2FjaGUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgXCJCbGFjayBIb2xlXCIgdmFyaWFudCBmcm9tOlxyXG4gKiAtIGh0dHA6Ly9qc3BlcmYuY29tL2FuZ3VsYXJqcy1wYXJzZS1nZXR0ZXIvNFxyXG4gKiAtIGh0dHA6Ly9qc3BlcmYuY29tL3BhdGgtZXZhbHVhdGlvbi1zaW1wbGlmaWVkLzdcclxuICovXHJcbmZ1bmN0aW9uIGNzcFNhZmVHZXR0ZXJGbihrZXkwLCBrZXkxLCBrZXkyLCBrZXkzLCBrZXk0LCBmdWxsRXhwKSB7XHJcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5MCwgZnVsbEV4cCk7XHJcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5MSwgZnVsbEV4cCk7XHJcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5MiwgZnVsbEV4cCk7XHJcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5MywgZnVsbEV4cCk7XHJcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5NCwgZnVsbEV4cCk7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBsb2NhbHMpIHtcclxuICAgIHZhciBwYXRoVmFsID0gKGxvY2FscyAmJiBsb2NhbHMuaGFzT3duUHJvcGVydHkoa2V5MCkpID8gbG9jYWxzIDogc2NvcGUsXHJcbiAgICAgICAgcHJvbWlzZTtcclxuXHJcbiAgICBpZiAocGF0aFZhbCA9PT0gbnVsbCB8fCBwYXRoVmFsID09PSB1bmRlZmluZWQpIHJldHVybiBwYXRoVmFsO1xyXG5cclxuICAgIHBhdGhWYWwgPSBwYXRoVmFsW2tleTBdO1xyXG4gICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XHJcbiAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcclxuICAgICAgICBwcm9taXNlID0gcGF0aFZhbDtcclxuICAgICAgICBwcm9taXNlLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoVmFsID0gcGF0aFZhbC4kJHY7XHJcbiAgICB9XHJcbiAgICBpZiAoIWtleTEgfHwgcGF0aFZhbCA9PT0gbnVsbCB8fCBwYXRoVmFsID09PSB1bmRlZmluZWQpIHJldHVybiBwYXRoVmFsO1xyXG5cclxuICAgIHBhdGhWYWwgPSBwYXRoVmFsW2tleTFdO1xyXG4gICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XHJcbiAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcclxuICAgICAgICBwcm9taXNlID0gcGF0aFZhbDtcclxuICAgICAgICBwcm9taXNlLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoVmFsID0gcGF0aFZhbC4kJHY7XHJcbiAgICB9XHJcbiAgICBpZiAoIWtleTIgfHwgcGF0aFZhbCA9PT0gbnVsbCB8fCBwYXRoVmFsID09PSB1bmRlZmluZWQpIHJldHVybiBwYXRoVmFsO1xyXG5cclxuICAgIHBhdGhWYWwgPSBwYXRoVmFsW2tleTJdO1xyXG4gICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XHJcbiAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcclxuICAgICAgICBwcm9taXNlID0gcGF0aFZhbDtcclxuICAgICAgICBwcm9taXNlLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoVmFsID0gcGF0aFZhbC4kJHY7XHJcbiAgICB9XHJcbiAgICBpZiAoIWtleTMgfHwgcGF0aFZhbCA9PT0gbnVsbCB8fCBwYXRoVmFsID09PSB1bmRlZmluZWQpIHJldHVybiBwYXRoVmFsO1xyXG5cclxuICAgIHBhdGhWYWwgPSBwYXRoVmFsW2tleTNdO1xyXG4gICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XHJcbiAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcclxuICAgICAgICBwcm9taXNlID0gcGF0aFZhbDtcclxuICAgICAgICBwcm9taXNlLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoVmFsID0gcGF0aFZhbC4kJHY7XHJcbiAgICB9XHJcbiAgICBpZiAoIWtleTQgfHwgcGF0aFZhbCA9PT0gbnVsbCB8fCBwYXRoVmFsID09PSB1bmRlZmluZWQpIHJldHVybiBwYXRoVmFsO1xyXG5cclxuICAgIHBhdGhWYWwgPSBwYXRoVmFsW2tleTRdO1xyXG4gICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XHJcbiAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcclxuICAgICAgICBwcm9taXNlID0gcGF0aFZhbDtcclxuICAgICAgICBwcm9taXNlLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgfVxyXG4gICAgICBwYXRoVmFsID0gcGF0aFZhbC4kJHY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFZhbDtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXR0ZXJGbihwYXRoLCBjc3AsIGZ1bGxFeHApIHtcclxuICBpZiAoZ2V0dGVyRm5DYWNoZS5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xyXG4gICAgcmV0dXJuIGdldHRlckZuQ2FjaGVbcGF0aF07XHJcbiAgfVxyXG5cclxuICB2YXIgcGF0aEtleXMgPSBwYXRoLnNwbGl0KCcuJyksXHJcbiAgICAgIHBhdGhLZXlzTGVuZ3RoID0gcGF0aEtleXMubGVuZ3RoLFxyXG4gICAgICBmbjtcclxuXHJcbiAgaWYgKGNzcCkge1xyXG4gICAgZm4gPSAocGF0aEtleXNMZW5ndGggPCA2KVxyXG4gICAgICAgID8gY3NwU2FmZUdldHRlckZuKHBhdGhLZXlzWzBdLCBwYXRoS2V5c1sxXSwgcGF0aEtleXNbMl0sIHBhdGhLZXlzWzNdLCBwYXRoS2V5c1s0XSwgZnVsbEV4cClcclxuICAgICAgICA6IGZ1bmN0aW9uKHNjb3BlLCBsb2NhbHMpIHtcclxuICAgICAgICAgIHZhciBpID0gMCwgdmFsO1xyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2YWwgPSBjc3BTYWZlR2V0dGVyRm4oXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aEtleXNbaSsrXSwgcGF0aEtleXNbaSsrXSwgcGF0aEtleXNbaSsrXSwgcGF0aEtleXNbaSsrXSwgcGF0aEtleXNbaSsrXSwgZnVsbEV4cFxyXG4gICAgICAgICAgICAgICAgICApKHNjb3BlLCBsb2NhbHMpO1xyXG5cclxuICAgICAgICAgICAgbG9jYWxzID0gdW5kZWZpbmVkOyAvLyBjbGVhciBhZnRlciBmaXJzdCBpdGVyYXRpb25cclxuICAgICAgICAgICAgc2NvcGUgPSB2YWw7XHJcbiAgICAgICAgICB9IHdoaWxlIChpIDwgcGF0aEtleXNMZW5ndGgpO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBjb2RlID0gJ3ZhciBsLCBmbiwgcDtcXG4nO1xyXG4gICAgZm9yRWFjaChwYXRoS2V5cywgZnVuY3Rpb24oa2V5LCBpbmRleCkge1xyXG4gICAgICBlbnN1cmVTYWZlTWVtYmVyTmFtZShrZXksIGZ1bGxFeHApO1xyXG4gICAgICBjb2RlICs9ICdpZihzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHM7XFxuJyArXHJcbiAgICAgICAgICAgICAgJ2w9cztcXG4nICtcclxuICAgICAgICAgICAgICAncz0nKyAoaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNpbXBseSBkZXJlZmVyZW5jZSAncycgb24gYW55IC5kb3Qgbm90YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgID8gJ3MnXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgaWYgd2UgYXJlIGZpcnN0IHRoZW4gd2UgY2hlY2sgbG9jYWxzIGZpcnN0LCBhbmQgaWYgc28gcmVhZCBpdCBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgOiAnKChrJiZrLmhhc093blByb3BlcnR5KFwiJyArIGtleSArICdcIikpP2s6cyknKSArICdbXCInICsga2V5ICsgJ1wiXScgKyAnO1xcbicgK1xyXG4gICAgICAgICAgICAgICdpZiAocyAmJiBzLnRoZW4pIHtcXG4nICtcclxuICAgICAgICAgICAgICAgICcgaWYgKCEoXCIkJHZcIiBpbiBzKSkge1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAnIHA9cztcXG4nICtcclxuICAgICAgICAgICAgICAgICAgJyBwLiQkdiA9IHVuZGVmaW5lZDtcXG4nICtcclxuICAgICAgICAgICAgICAgICAgJyBwLnRoZW4oZnVuY3Rpb24odikge3AuJCR2PXY7fSk7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICd9XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnIHM9cy4kJHZcXG4nICtcclxuICAgICAgICAgICAgICAnfVxcbic7XHJcbiAgICB9KTtcclxuICAgIGNvZGUgKz0gJ3JldHVybiBzOyc7XHJcbiAgICBmbiA9IEZ1bmN0aW9uKCdzJywgJ2snLCBjb2RlKTsgLy8gcz1zY29wZSwgaz1sb2NhbHNcclxuICAgIGZuLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb2RlOyB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldHRlckZuQ2FjaGVbcGF0aF0gPSBmbjtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuJHBhcnNlXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogQ29udmVydHMgQW5ndWxhciB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpbnRvIGEgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqICAgdmFyIGdldHRlciA9ICRwYXJzZSgndXNlci5uYW1lJyk7XHJcbiAqICAgdmFyIHNldHRlciA9IGdldHRlci5hc3NpZ247XHJcbiAqICAgdmFyIGNvbnRleHQgPSB7dXNlcjp7bmFtZTonYW5ndWxhcid9fTtcclxuICogICB2YXIgbG9jYWxzID0ge3VzZXI6e25hbWU6J2xvY2FsJ319O1xyXG4gKlxyXG4gKiAgIGV4cGVjdChnZXR0ZXIoY29udGV4dCkpLnRvRXF1YWwoJ2FuZ3VsYXInKTtcclxuICogICBzZXR0ZXIoY29udGV4dCwgJ25ld1ZhbHVlJyk7XHJcbiAqICAgZXhwZWN0KGNvbnRleHQudXNlci5uYW1lKS50b0VxdWFsKCduZXdWYWx1ZScpO1xyXG4gKiAgIGV4cGVjdChnZXR0ZXIoY29udGV4dCwgbG9jYWxzKSkudG9FcXVhbCgnbG9jYWwnKTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAqXHJcbiAqICAgICogYGNvbnRleHRgIMOi4oKs4oCcIGB7b2JqZWN0fWAgw6LigqzigJwgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXHJcbiAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gKiAgICAqIGBsb2NhbHNgIMOi4oKs4oCcIGB7b2JqZWN0PX1gIMOi4oKs4oCcIGxvY2FsIHZhcmlhYmxlcyBjb250ZXh0IG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpblxyXG4gKiAgICAgIGBjb250ZXh0YC5cclxuICpcclxuICogICAgVGhlIHJldHVybmVkIGZ1bmN0aW9uIGFsc28gaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICogICAgICAqIGBsaXRlcmFsYCDDouKCrOKAnCBge2Jvb2xlYW59YCDDouKCrOKAnCB3aGV0aGVyIHRoZSBleHByZXNzaW9uJ3MgdG9wLWxldmVsIG5vZGUgaXMgYSBKYXZhU2NyaXB0XHJcbiAqICAgICAgICBsaXRlcmFsLlxyXG4gKiAgICAgICogYGNvbnN0YW50YCDDouKCrOKAnCBge2Jvb2xlYW59YCDDouKCrOKAnCB3aGV0aGVyIHRoZSBleHByZXNzaW9uIGlzIG1hZGUgZW50aXJlbHkgb2YgSmF2YVNjcmlwdFxyXG4gKiAgICAgICAgY29uc3RhbnQgbGl0ZXJhbHMuXHJcbiAqICAgICAgKiBgYXNzaWduYCDDouKCrOKAnCBgez9mdW5jdGlvbihjb250ZXh0LCB2YWx1ZSl9YCDDouKCrOKAnCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhc3NpZ25hYmxlLCB0aGlzIHdpbGwgYmVcclxuICogICAgICAgIHNldCB0byBhIGZ1bmN0aW9uIHRvIGNoYW5nZSBpdHMgdmFsdWUgb24gdGhlIGdpdmVuIGNvbnRleHQuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiAkUGFyc2VQcm92aWRlcigpIHtcclxuICB2YXIgY2FjaGUgPSB7fTtcclxuICB0aGlzLiRnZXQgPSBbJyRmaWx0ZXInLCAnJHNuaWZmZXInLCBmdW5jdGlvbigkZmlsdGVyLCAkc25pZmZlcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV4cCkge1xyXG4gICAgICBzd2l0Y2godHlwZW9mIGV4cCkge1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzT3duUHJvcGVydHkoZXhwKVxyXG4gICAgICAgICAgICA/IGNhY2hlW2V4cF1cclxuICAgICAgICAgICAgOiBjYWNoZVtleHBdID0gIHBhcnNlcihleHAsIGZhbHNlLCAkZmlsdGVyLCAkc25pZmZlci5jc3ApO1xyXG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgICAgIHJldHVybiBleHA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIHNlcnZpY2VcclxuICogQG5hbWUgbmcuJHFcclxuICogQHJlcXVpcmVzICRyb290U2NvcGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgcHJvbWlzZS9kZWZlcnJlZCBpbXBsZW1lbnRhdGlvbiBpbnNwaXJlZCBieSBbS3JpcyBLb3dhbCdzIFFdKGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcSkuXHJcbiAqXHJcbiAqIFtUaGUgQ29tbW9uSlMgUHJvbWlzZSBwcm9wb3NhbF0oaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvUHJvbWlzZXMpIGRlc2NyaWJlcyBhIHByb21pc2UgYXMgYW5cclxuICogaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiBhbiBhY3Rpb24gdGhhdCBpc1xyXG4gKiBwZXJmb3JtZWQgYXN5bmNocm9ub3VzbHksIGFuZCBtYXkgb3IgbWF5IG5vdCBiZSBmaW5pc2hlZCBhdCBhbnkgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cclxuICpcclxuICogRnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgZGVhbGluZyB3aXRoIGVycm9yIGhhbmRsaW5nLCBkZWZlcnJlZCBhbmQgcHJvbWlzZSBBUElzIGFyZSB0b1xyXG4gKiBhc3luY2hyb25vdXMgcHJvZ3JhbW1pbmcgd2hhdCBgdHJ5YCwgYGNhdGNoYCBhbmQgYHRocm93YCBrZXl3b3JkcyBhcmUgdG8gc3luY2hyb25vdXMgcHJvZ3JhbW1pbmcuXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqICAgLy8gZm9yIHRoZSBwdXJwb3NlIG9mIHRoaXMgZXhhbXBsZSBsZXQncyBhc3N1bWUgdGhhdCB2YXJpYWJsZXMgYCRxYCBhbmQgYHNjb3BlYCBhcmVcclxuICogICAvLyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSAodGhleSBjb3VsZCBoYXZlIGJlZW4gaW5qZWN0ZWQgb3IgcGFzc2VkIGluKS5cclxuICpcclxuICogICBmdW5jdGlvbiBhc3luY0dyZWV0KG5hbWUpIHtcclxuICogICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAqXHJcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICAvLyBzaW5jZSB0aGlzIGZuIGV4ZWN1dGVzIGFzeW5jIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AsIHdlIG5lZWQgdG8gd3JhcFxyXG4gKiAgICAgICAvLyBvdXIgY29kZSBpbnRvIGFuICRhcHBseSBjYWxsIHNvIHRoYXQgdGhlIG1vZGVsIGNoYW5nZXMgYXJlIHByb3Blcmx5IG9ic2VydmVkLlxyXG4gKiAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgICAgZGVmZXJyZWQubm90aWZ5KCdBYm91dCB0byBncmVldCAnICsgbmFtZSArICcuJyk7XHJcbiAqXHJcbiAqICAgICAgICAgaWYgKG9rVG9HcmVldChuYW1lKSkge1xyXG4gKiAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgnSGVsbG8sICcgKyBuYW1lICsgJyEnKTtcclxuICogICAgICAgICB9IGVsc2Uge1xyXG4gKiAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCdHcmVldGluZyAnICsgbmFtZSArICcgaXMgbm90IGFsbG93ZWQuJyk7XHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgICB9KTtcclxuICogICAgIH0sIDEwMDApO1xyXG4gKlxyXG4gKiAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAqICAgfVxyXG4gKlxyXG4gKiAgIHZhciBwcm9taXNlID0gYXN5bmNHcmVldCgnUm9iaW4gSG9vZCcpO1xyXG4gKiAgIHByb21pc2UudGhlbihmdW5jdGlvbihncmVldGluZykge1xyXG4gKiAgICAgYWxlcnQoJ1N1Y2Nlc3M6ICcgKyBncmVldGluZyk7XHJcbiAqICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAqICAgICBhbGVydCgnRmFpbGVkOiAnICsgcmVhc29uKTtcclxuICogICB9LCBmdW5jdGlvbih1cGRhdGUpIHtcclxuICogICAgIGFsZXJ0KCdHb3Qgbm90aWZpY2F0aW9uOiAnICsgdXBkYXRlKTtcclxuICogICB9KTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEF0IGZpcnN0IGl0IG1pZ2h0IG5vdCBiZSBvYnZpb3VzIHdoeSB0aGlzIGV4dHJhIGNvbXBsZXhpdHkgaXMgd29ydGggdGhlIHRyb3VibGUuIFRoZSBwYXlvZmZcclxuICogY29tZXMgaW4gdGhlIHdheSBvZlxyXG4gKiBbZ3VhcmFudGVlcyB0aGF0IHByb21pc2UgYW5kIGRlZmVycmVkIEFQSXMgbWFrZV0oaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC91bmNvbW1vbmpzL2Jsb2IvbWFzdGVyL3Byb21pc2VzL3NwZWNpZmljYXRpb24ubWQpLlxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHkgdGhlIHByb21pc2UgYXBpIGFsbG93cyBmb3IgY29tcG9zaXRpb24gdGhhdCBpcyB2ZXJ5IGhhcmQgdG8gZG8gd2l0aCB0aGVcclxuICogdHJhZGl0aW9uYWwgY2FsbGJhY2sgKFtDUFNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludWF0aW9uLXBhc3Npbmdfc3R5bGUpKSBhcHByb2FjaC5cclxuICogRm9yIG1vcmUgb24gdGhpcyBwbGVhc2Ugc2VlIHRoZSBbUSBkb2N1bWVudGF0aW9uXShodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EpIGVzcGVjaWFsbHkgdGhlXHJcbiAqIHNlY3Rpb24gb24gc2VyaWFsIG9yIHBhcmFsbGVsIGpvaW5pbmcgb2YgcHJvbWlzZXMuXHJcbiAqXHJcbiAqXHJcbiAqICMgVGhlIERlZmVycmVkIEFQSVxyXG4gKlxyXG4gKiBBIG5ldyBpbnN0YW5jZSBvZiBkZWZlcnJlZCBpcyBjb25zdHJ1Y3RlZCBieSBjYWxsaW5nIGAkcS5kZWZlcigpYC5cclxuICpcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhlIGRlZmVycmVkIG9iamVjdCBpcyB0byBleHBvc2UgdGhlIGFzc29jaWF0ZWQgUHJvbWlzZSBpbnN0YW5jZSBhcyB3ZWxsIGFzIEFQSXNcclxuICogdGhhdCBjYW4gYmUgdXNlZCBmb3Igc2lnbmFsaW5nIHRoZSBzdWNjZXNzZnVsIG9yIHVuc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLCBhcyB3ZWxsIGFzIHRoZSBzdGF0dXNcclxuICogb2YgdGhlIHRhc2suXHJcbiAqXHJcbiAqICoqTWV0aG9kcyoqXHJcbiAqXHJcbiAqIC0gYHJlc29sdmUodmFsdWUpYCDDouKCrOKAnCByZXNvbHZlcyB0aGUgZGVyaXZlZCBwcm9taXNlIHdpdGggdGhlIGB2YWx1ZWAuIElmIHRoZSB2YWx1ZSBpcyBhIHJlamVjdGlvblxyXG4gKiAgIGNvbnN0cnVjdGVkIHZpYSBgJHEucmVqZWN0YCwgdGhlIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCBpbnN0ZWFkLlxyXG4gKiAtIGByZWplY3QocmVhc29uKWAgw6LigqzigJwgcmVqZWN0cyB0aGUgZGVyaXZlZCBwcm9taXNlIHdpdGggdGhlIGByZWFzb25gLiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cclxuICogICByZXNvbHZpbmcgaXQgd2l0aCBhIHJlamVjdGlvbiBjb25zdHJ1Y3RlZCB2aWEgYCRxLnJlamVjdGAuXHJcbiAqIC0gYG5vdGlmeSh2YWx1ZSlgIC0gcHJvdmlkZXMgdXBkYXRlcyBvbiB0aGUgc3RhdHVzIG9mIHRoZSBwcm9taXNlcyBleGVjdXRpb24uIFRoaXMgbWF5IGJlIGNhbGxlZFxyXG4gKiAgIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGUgcHJvbWlzZSBpcyBlaXRoZXIgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXHJcbiAqXHJcbiAqICoqUHJvcGVydGllcyoqXHJcbiAqXHJcbiAqIC0gcHJvbWlzZSDDouKCrOKAnCBge1Byb21pc2V9YCDDouKCrOKAnCBwcm9taXNlIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBkZWZlcnJlZC5cclxuICpcclxuICpcclxuICogIyBUaGUgUHJvbWlzZSBBUElcclxuICpcclxuICogQSBuZXcgcHJvbWlzZSBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoZW4gYSBkZWZlcnJlZCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBjYW4gYmUgcmV0cmlldmVkIGJ5XHJcbiAqIGNhbGxpbmcgYGRlZmVycmVkLnByb21pc2VgLlxyXG4gKlxyXG4gKiBUaGUgcHVycG9zZSBvZiB0aGUgcHJvbWlzZSBvYmplY3QgaXMgdG8gYWxsb3cgZm9yIGludGVyZXN0ZWQgcGFydGllcyB0byBnZXQgYWNjZXNzIHRvIHRoZSByZXN1bHRcclxuICogb2YgdGhlIGRlZmVycmVkIHRhc2sgd2hlbiBpdCBjb21wbGV0ZXMuXHJcbiAqXHJcbiAqICoqTWV0aG9kcyoqXHJcbiAqXHJcbiAqIC0gYHRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrLCBub3RpZnlDYWxsYmFjaylgIMOi4oKs4oCcIHJlZ2FyZGxlc3Mgb2Ygd2hlbiB0aGUgcHJvbWlzZSB3YXMgb3JcclxuICogICB3aWxsIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkLCBgdGhlbmAgY2FsbHMgb25lIG9mIHRoZSBzdWNjZXNzIG9yIGVycm9yIGNhbGxiYWNrcyBhc3luY2hyb25vdXNseVxyXG4gKiAgIGFzIHNvb24gYXMgdGhlIHJlc3VsdCBpcyBhdmFpbGFibGUuIFRoZSBjYWxsYmFja3MgYXJlIGNhbGxlZCB3aXRoIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgcmVzdWx0XHJcbiAqICAgb3IgcmVqZWN0aW9uIHJlYXNvbi4gQWRkaXRpb25hbGx5LCB0aGUgbm90aWZ5IGNhbGxiYWNrIG1heSBiZSBjYWxsZWQgemVybyBvciBtb3JlIHRpbWVzIHRvXHJcbiAqICAgcHJvdmlkZSBhIHByb2dyZXNzIGluZGljYXRpb24sIGJlZm9yZSB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCBvciByZWplY3RlZC5cclxuICpcclxuICogICBUaGlzIG1ldGhvZCAqcmV0dXJucyBhIG5ldyBwcm9taXNlKiB3aGljaCBpcyByZXNvbHZlZCBvciByZWplY3RlZCB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGVcclxuICogICBgc3VjY2Vzc0NhbGxiYWNrYCwgYGVycm9yQ2FsbGJhY2tgLiBJdCBhbHNvIG5vdGlmaWVzIHZpYSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgbm90aWZ5Q2FsbGJhY2tgXHJcbiAqICAgbWV0aG9kLiBUaGUgcHJvbWlzZSBjYW4gbm90IGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGZyb20gdGhlIG5vdGlmeUNhbGxiYWNrIG1ldGhvZC5cclxuICpcclxuICogLSBgY2F0Y2goZXJyb3JDYWxsYmFjaylgIMOi4oKs4oCcIHNob3J0aGFuZCBmb3IgYHByb21pc2UudGhlbihudWxsLCBlcnJvckNhbGxiYWNrKWBcclxuICpcclxuICogLSBgZmluYWxseShjYWxsYmFjaylgIMOi4oKs4oCcIGFsbG93cyB5b3UgdG8gb2JzZXJ2ZSBlaXRoZXIgdGhlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBvZiBhIHByb21pc2UsXHJcbiAqICAgYnV0IHRvIGRvIHNvIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBmaW5hbCB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgdG8gcmVsZWFzZSByZXNvdXJjZXMgb3IgZG8gc29tZVxyXG4gKiAgIGNsZWFuLXVwIHRoYXQgbmVlZHMgdG8gYmUgZG9uZSB3aGV0aGVyIHRoZSBwcm9taXNlIHdhcyByZWplY3RlZCBvciByZXNvbHZlZC4gU2VlIHRoZSBbZnVsbFxyXG4gKiAgIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS93aWtpL0FQSS1SZWZlcmVuY2UjcHJvbWlzZWZpbmFsbHljYWxsYmFjaykgZm9yXHJcbiAqICAgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogICBCZWNhdXNlIGBmaW5hbGx5YCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YVNjcmlwdCBhbmQgcmVzZXJ2ZWQga2V5d29yZHMgYXJlIG5vdCBzdXBwb3J0ZWQgYXNcclxuICogICBwcm9wZXJ0eSBuYW1lcyBieSBFUzMsIHlvdSdsbCBuZWVkIHRvIGludm9rZSB0aGUgbWV0aG9kIGxpa2UgYHByb21pc2VbJ2ZpbmFsbHknXShjYWxsYmFjaylgIHRvXHJcbiAqICAgbWFrZSB5b3VyIGNvZGUgSUU4IGNvbXBhdGlibGUuXHJcbiAqXHJcbiAqICMgQ2hhaW5pbmcgcHJvbWlzZXNcclxuICpcclxuICogQmVjYXVzZSBjYWxsaW5nIHRoZSBgdGhlbmAgbWV0aG9kIG9mIGEgcHJvbWlzZSByZXR1cm5zIGEgbmV3IGRlcml2ZWQgcHJvbWlzZSwgaXQgaXMgZWFzaWx5IHBvc3NpYmxlXHJcbiAqIHRvIGNyZWF0ZSBhIGNoYWluIG9mIHByb21pc2VzOlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIHByb21pc2VCID0gcHJvbWlzZUEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICogICAgIHJldHVybiByZXN1bHQgKyAxO1xyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKiAgIC8vIHByb21pc2VCIHdpbGwgYmUgcmVzb2x2ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgcHJvbWlzZUEgaXMgcmVzb2x2ZWQgYW5kIGl0cyB2YWx1ZVxyXG4gKiAgIC8vIHdpbGwgYmUgdGhlIHJlc3VsdCBvZiBwcm9taXNlQSBpbmNyZW1lbnRlZCBieSAxXHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBjcmVhdGUgY2hhaW5zIG9mIGFueSBsZW5ndGggYW5kIHNpbmNlIGEgcHJvbWlzZSBjYW4gYmUgcmVzb2x2ZWQgd2l0aCBhbm90aGVyXHJcbiAqIHByb21pc2UgKHdoaWNoIHdpbGwgZGVmZXIgaXRzIHJlc29sdXRpb24gZnVydGhlciksIGl0IGlzIHBvc3NpYmxlIHRvIHBhdXNlL2RlZmVyIHJlc29sdXRpb24gb2ZcclxuICogdGhlIHByb21pc2VzIGF0IGFueSBwb2ludCBpbiB0aGUgY2hhaW4uIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8gaW1wbGVtZW50IHBvd2VyZnVsIEFQSXMgbGlrZVxyXG4gKiAkaHR0cCdzIHJlc3BvbnNlIGludGVyY2VwdG9ycy5cclxuICpcclxuICpcclxuICogIyBEaWZmZXJlbmNlcyBiZXR3ZWVuIEtyaXMgS293YWwncyBRIGFuZCAkcVxyXG4gKlxyXG4gKiAgVGhlcmUgYXJlIHRocmVlIG1haW4gZGlmZmVyZW5jZXM6XHJcbiAqXHJcbiAqIC0gJHEgaXMgaW50ZWdyYXRlZCB3aXRoIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZX0gU2NvcGUgbW9kZWwgb2JzZXJ2YXRpb25cclxuICogICBtZWNoYW5pc20gaW4gYW5ndWxhciwgd2hpY2ggbWVhbnMgZmFzdGVyIHByb3BhZ2F0aW9uIG9mIHJlc29sdXRpb24gb3IgcmVqZWN0aW9uIGludG8geW91clxyXG4gKiAgIG1vZGVscyBhbmQgYXZvaWRpbmcgdW5uZWNlc3NhcnkgYnJvd3NlciByZXBhaW50cywgd2hpY2ggd291bGQgcmVzdWx0IGluIGZsaWNrZXJpbmcgVUkuXHJcbiAqIC0gJHEgcHJvbWlzZXMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIHRlbXBsYXRpbmcgZW5naW5lIGluIGFuZ3VsYXIsIHdoaWNoIG1lYW5zIHRoYXQgaW4gdGVtcGxhdGVzXHJcbiAqICAgeW91IGNhbiB0cmVhdCBwcm9taXNlcyBhdHRhY2hlZCB0byBhIHNjb3BlIGFzIGlmIHRoZXkgd2VyZSB0aGUgcmVzdWx0aW5nIHZhbHVlcy5cclxuICogLSBRIGhhcyBtYW55IG1vcmUgZmVhdHVyZXMgdGhhbiAkcSwgYnV0IHRoYXQgY29tZXMgYXQgYSBjb3N0IG9mIGJ5dGVzLiAkcSBpcyB0aW55LCBidXQgY29udGFpbnNcclxuICogICBhbGwgdGhlIGltcG9ydGFudCBmdW5jdGlvbmFsaXR5IG5lZWRlZCBmb3IgY29tbW9uIGFzeW5jIHRhc2tzLlxyXG4gKlxyXG4gKiAgIyBUZXN0aW5nXHJcbiAqXHJcbiAqICA8cHJlPlxyXG4gKiAgICBpdCgnc2hvdWxkIHNpbXVsYXRlIHByb21pc2UnLCBpbmplY3QoZnVuY3Rpb24oJHEsICRyb290U2NvcGUpIHtcclxuICogICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xyXG4gKiAgICAgIHZhciBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcclxuICogICAgICB2YXIgcmVzb2x2ZWRWYWx1ZTtcclxuICpcclxuICogICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHsgcmVzb2x2ZWRWYWx1ZSA9IHZhbHVlOyB9KTtcclxuICogICAgICBleHBlY3QocmVzb2x2ZWRWYWx1ZSkudG9CZVVuZGVmaW5lZCgpO1xyXG4gKlxyXG4gKiAgICAgIC8vIFNpbXVsYXRlIHJlc29sdmluZyBvZiBwcm9taXNlXHJcbiAqICAgICAgZGVmZXJyZWQucmVzb2x2ZSgxMjMpO1xyXG4gKiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgJ3RoZW4nIGZ1bmN0aW9uIGRvZXMgbm90IGdldCBjYWxsZWQgc3luY2hyb25vdXNseS5cclxuICogICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugd2FudCB0aGUgcHJvbWlzZSBBUEkgdG8gYWx3YXlzIGJlIGFzeW5jLCB3aGV0aGVyIG9yIG5vdFxyXG4gKiAgICAgIC8vIGl0IGdvdCBjYWxsZWQgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseS5cclxuICogICAgICBleHBlY3QocmVzb2x2ZWRWYWx1ZSkudG9CZVVuZGVmaW5lZCgpO1xyXG4gKlxyXG4gKiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9taXNlIHJlc29sdXRpb24gdG8gJ3RoZW4nIGZ1bmN0aW9ucyB1c2luZyAkYXBwbHkoKS5cclxuICogICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xyXG4gKiAgICAgIGV4cGVjdChyZXNvbHZlZFZhbHVlKS50b0VxdWFsKDEyMyk7XHJcbiAqICAgIH0pO1xyXG4gKiAgPC9wcmU+XHJcbiAqL1xyXG5mdW5jdGlvbiAkUVByb3ZpZGVyKCkge1xyXG5cclxuICB0aGlzLiRnZXQgPSBbJyRyb290U2NvcGUnLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCBmdW5jdGlvbigkcm9vdFNjb3BlLCAkZXhjZXB0aW9uSGFuZGxlcikge1xyXG4gICAgcmV0dXJuIHFGYWN0b3J5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyhjYWxsYmFjayk7XHJcbiAgICB9LCAkZXhjZXB0aW9uSGFuZGxlcik7XHJcbiAgfV07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIHByb21pc2UgbWFuYWdlci5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbil9IG5leHRUaWNrIEZ1bmN0aW9uIGZvciBleGVjdXRpbmcgZnVuY3Rpb25zIGluIHRoZSBuZXh0IHR1cm4uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKil9IGV4Y2VwdGlvbkhhbmRsZXIgRnVuY3Rpb24gaW50byB3aGljaCB1bmV4cGVjdGVkIGV4Y2VwdGlvbnMgYXJlIHBhc3NlZCBmb3JcclxuICogICAgIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICogQHJldHVybnMge29iamVjdH0gUHJvbWlzZSBtYW5hZ2VyLlxyXG4gKi9cclxuZnVuY3Rpb24gcUZhY3RvcnkobmV4dFRpY2ssIGV4Y2VwdGlvbkhhbmRsZXIpIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jXHJcbiAgICogQG5hbWUgbmcuJHEjZGVmZXJcclxuICAgKiBAbWV0aG9kT2YgbmcuJHFcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBDcmVhdGVzIGEgYERlZmVycmVkYCBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBhIHRhc2sgd2hpY2ggd2lsbCBmaW5pc2ggaW4gdGhlIGZ1dHVyZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBkZWZlcnJlZC5cclxuICAgKi9cclxuICB2YXIgZGVmZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBwZW5kaW5nID0gW10sXHJcbiAgICAgICAgdmFsdWUsIGRlZmVycmVkO1xyXG5cclxuICAgIGRlZmVycmVkID0ge1xyXG5cclxuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBwZW5kaW5nO1xyXG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIHZhbHVlID0gcmVmKHZhbCk7XHJcblxyXG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4oY2FsbGJhY2tbMF0sIGNhbGxiYWNrWzFdLCBjYWxsYmFja1syXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG5cclxuICAgICAgcmVqZWN0OiBmdW5jdGlvbihyZWFzb24pIHtcclxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlamVjdChyZWFzb24pKTtcclxuICAgICAgfSxcclxuXHJcblxyXG4gICAgICBub3RpZnk6IGZ1bmN0aW9uKHByb2dyZXNzKSB7XHJcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBwZW5kaW5nO1xyXG5cclxuICAgICAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICB2YXIgY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tbMl0ocHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuXHJcbiAgICAgIHByb21pc2U6IHtcclxuICAgICAgICB0aGVuOiBmdW5jdGlvbihjYWxsYmFjaywgZXJyYmFjaywgcHJvZ3Jlc3NiYWNrKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKTtcclxuXHJcbiAgICAgICAgICB2YXIgd3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZSgoaXNGdW5jdGlvbihjYWxsYmFjaykgPyBjYWxsYmFjayA6IGRlZmF1bHRDYWxsYmFjaykodmFsdWUpKTtcclxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChlKTtcclxuICAgICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciB3cmFwcGVkRXJyYmFjayA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKChpc0Z1bmN0aW9uKGVycmJhY2spID8gZXJyYmFjayA6IGRlZmF1bHRFcnJiYWNrKShyZWFzb24pKTtcclxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChlKTtcclxuICAgICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciB3cmFwcGVkUHJvZ3Jlc3NiYWNrID0gZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICByZXN1bHQubm90aWZ5KChpc0Z1bmN0aW9uKHByb2dyZXNzYmFjaykgPyBwcm9ncmVzc2JhY2sgOiBkZWZhdWx0Q2FsbGJhY2spKHByb2dyZXNzKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgcGVuZGluZy5wdXNoKFt3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRFcnJiYWNrLCB3cmFwcGVkUHJvZ3Jlc3NiYWNrXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZS50aGVuKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZEVycmJhY2ssIHdyYXBwZWRQcm9ncmVzc2JhY2spO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIGNhbGxiYWNrKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBcImZpbmFsbHlcIjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBtYWtlUHJvbWlzZSh2YWx1ZSwgcmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRlZmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnByb21pc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2sodmFsdWUsIGlzUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrT3V0cHV0ID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjYWxsYmFja091dHB1dCA9IChjYWxsYmFjayB8fGRlZmF1bHRDYWxsYmFjaykoKTtcclxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG1ha2VQcm9taXNlKGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tPdXRwdXQgJiYgaXNGdW5jdGlvbihjYWxsYmFja091dHB1dC50aGVuKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja091dHB1dC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VQcm9taXNlKHZhbHVlLCBpc1Jlc29sdmVkKTtcclxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VQcm9taXNlKGVycm9yLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG1ha2VQcm9taXNlKHZhbHVlLCBpc1Jlc29sdmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYWxsYmFjayhlcnJvciwgZmFsc2UpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBkZWZlcnJlZDtcclxuICB9O1xyXG5cclxuXHJcbiAgdmFyIHJlZiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS50aGVuKSkgcmV0dXJuIHZhbHVlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGhlbjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKTtcclxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGNhbGxiYWNrKHZhbHVlKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2NcclxuICAgKiBAbmFtZSBuZy4kcSNyZWplY3RcclxuICAgKiBAbWV0aG9kT2YgbmcuJHFcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIGFzIHJlamVjdGVkIHdpdGggdGhlIHNwZWNpZmllZCBgcmVhc29uYC4gVGhpcyBhcGkgc2hvdWxkIGJlXHJcbiAgICogdXNlZCB0byBmb3J3YXJkIHJlamVjdGlvbiBpbiBhIGNoYWluIG9mIHByb21pc2VzLiBJZiB5b3UgYXJlIGRlYWxpbmcgd2l0aCB0aGUgbGFzdCBwcm9taXNlIGluXHJcbiAgICogYSBwcm9taXNlIGNoYWluLCB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBpdC5cclxuICAgKlxyXG4gICAqIFdoZW4gY29tcGFyaW5nIGRlZmVycmVkcy9wcm9taXNlcyB0byB0aGUgZmFtaWxpYXIgYmVoYXZpb3Igb2YgdHJ5L2NhdGNoL3Rocm93LCB0aGluayBvZlxyXG4gICAqIGByZWplY3RgIGFzIHRoZSBgdGhyb3dgIGtleXdvcmQgaW4gSmF2YVNjcmlwdC4gVGhpcyBhbHNvIG1lYW5zIHRoYXQgaWYgeW91IFwiY2F0Y2hcIiBhbiBlcnJvciB2aWFcclxuICAgKiBhIHByb21pc2UgZXJyb3IgY2FsbGJhY2sgYW5kIHlvdSB3YW50IHRvIGZvcndhcmQgdGhlIGVycm9yIHRvIHRoZSBwcm9taXNlIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgKiBjdXJyZW50IHByb21pc2UsIHlvdSBoYXZlIHRvIFwicmV0aHJvd1wiIHRoZSBlcnJvciBieSByZXR1cm5pbmcgYSByZWplY3Rpb24gY29uc3RydWN0ZWQgdmlhXHJcbiAgICogYHJlamVjdGAuXHJcbiAgICpcclxuICAgKiA8cHJlPlxyXG4gICAqICAgcHJvbWlzZUIgPSBwcm9taXNlQS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAqICAgICAvLyBzdWNjZXNzOiBkbyBzb21ldGhpbmcgYW5kIHJlc29sdmUgcHJvbWlzZUJcclxuICAgKiAgICAgLy8gICAgICAgICAgd2l0aCB0aGUgb2xkIG9yIGEgbmV3IHJlc3VsdFxyXG4gICAqICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAqICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICogICAgIC8vIGVycm9yOiBoYW5kbGUgdGhlIGVycm9yIGlmIHBvc3NpYmxlIGFuZFxyXG4gICAqICAgICAvLyAgICAgICAgcmVzb2x2ZSBwcm9taXNlQiB3aXRoIG5ld1Byb21pc2VPclZhbHVlLFxyXG4gICAqICAgICAvLyAgICAgICAgb3RoZXJ3aXNlIGZvcndhcmQgdGhlIHJlamVjdGlvbiB0byBwcm9taXNlQlxyXG4gICAqICAgICBpZiAoY2FuSGFuZGxlKHJlYXNvbikpIHtcclxuICAgKiAgICAgIC8vIGhhbmRsZSB0aGUgZXJyb3IgYW5kIHJlY292ZXJcclxuICAgKiAgICAgIHJldHVybiBuZXdQcm9taXNlT3JWYWx1ZTtcclxuICAgKiAgICAgfVxyXG4gICAqICAgICByZXR1cm4gJHEucmVqZWN0KHJlYXNvbik7XHJcbiAgICogICB9KTtcclxuICAgKiA8L3ByZT5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gcmVhc29uIENvbnN0YW50LCBtZXNzYWdlLCBleGNlcHRpb24gb3IgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVqZWN0aW9uIHJlYXNvbi5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCB3YXMgYWxyZWFkeSByZXNvbHZlZCBhcyByZWplY3RlZCB3aXRoIHRoZSBgcmVhc29uYC5cclxuICAgKi9cclxuICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0aGVuOiBmdW5jdGlvbihjYWxsYmFjaywgZXJyYmFjaykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBkZWZlcigpO1xyXG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoKGlzRnVuY3Rpb24oZXJyYmFjaykgPyBlcnJiYWNrIDogZGVmYXVsdEVycmJhY2spKHJlYXNvbikpO1xyXG4gICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2NcclxuICAgKiBAbmFtZSBuZy4kcSN3aGVuXHJcbiAgICogQG1ldGhvZE9mIG5nLiRxXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogV3JhcHMgYW4gb2JqZWN0IHRoYXQgbWlnaHQgYmUgYSB2YWx1ZSBvciBhICgzcmQgcGFydHkpIHRoZW4tYWJsZSBwcm9taXNlIGludG8gYSAkcSBwcm9taXNlLlxyXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IGFyZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IHRoYXQgbWlnaHQgb3IgbWlnaHQgbm90IGJlIGEgcHJvbWlzZSwgb3IgaWZcclxuICAgKiB0aGUgcHJvbWlzZSBjb21lcyBmcm9tIGEgc291cmNlIHRoYXQgY2FuJ3QgYmUgdHJ1c3RlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb3IgYSBwcm9taXNlXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IFJldHVybnMgYSBwcm9taXNlIG9mIHRoZSBwYXNzZWQgdmFsdWUgb3IgcHJvbWlzZVxyXG4gICAqL1xyXG4gIHZhciB3aGVuID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrLCBwcm9ncmVzc2JhY2spIHtcclxuICAgIHZhciByZXN1bHQgPSBkZWZlcigpLFxyXG4gICAgICAgIGRvbmU7XHJcblxyXG4gICAgdmFyIHdyYXBwZWRDYWxsYmFjayA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogZGVmYXVsdENhbGxiYWNrKSh2YWx1ZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgIHJldHVybiByZWplY3QoZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHdyYXBwZWRFcnJiYWNrID0gZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKGVycmJhY2spID8gZXJyYmFjayA6IGRlZmF1bHRFcnJiYWNrKShyZWFzb24pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB3cmFwcGVkUHJvZ3Jlc3NiYWNrID0gZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24ocHJvZ3Jlc3NiYWNrKSA/IHByb2dyZXNzYmFjayA6IGRlZmF1bHRDYWxsYmFjaykocHJvZ3Jlc3MpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcclxuICAgICAgcmVmKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcclxuICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQucmVzb2x2ZShyZWYodmFsdWUpLnRoZW4od3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkRXJyYmFjaywgd3JhcHBlZFByb2dyZXNzYmFjaykpO1xyXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcclxuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xyXG4gICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHdyYXBwZWRFcnJiYWNrKHJlYXNvbikpO1xyXG4gICAgICB9LCBmdW5jdGlvbihwcm9ncmVzcykge1xyXG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XHJcbiAgICAgICAgcmVzdWx0Lm5vdGlmeSh3cmFwcGVkUHJvZ3Jlc3NiYWNrKHByb2dyZXNzKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xyXG4gIH07XHJcblxyXG5cclxuICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2sodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBkZWZhdWx0RXJyYmFjayhyZWFzb24pIHtcclxuICAgIHJldHVybiByZWplY3QocmVhc29uKTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2NcclxuICAgKiBAbmFtZSBuZy4kcSNhbGxcclxuICAgKiBAbWV0aG9kT2YgbmcuJHFcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBDb21iaW5lcyBtdWx0aXBsZSBwcm9taXNlcyBpbnRvIGEgc2luZ2xlIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCBvZiB0aGUgaW5wdXRcclxuICAgKiBwcm9taXNlcyBhcmUgcmVzb2x2ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxQcm9taXNlPnxPYmplY3QuPFByb21pc2U+fSBwcm9taXNlcyBBbiBhcnJheSBvciBoYXNoIG9mIHByb21pc2VzLlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgc2luZ2xlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYW4gYXJyYXkvaGFzaCBvZiB2YWx1ZXMsXHJcbiAgICogICBlYWNoIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb21pc2UgYXQgdGhlIHNhbWUgaW5kZXgva2V5IGluIHRoZSBgcHJvbWlzZXNgIGFycmF5L2hhc2guIElmIGFueSBvZlxyXG4gICAqICAgdGhlIHByb21pc2VzIGlzIHJlc29sdmVkIHdpdGggYSByZWplY3Rpb24sIHRoaXMgcmVzdWx0aW5nIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZVxyXG4gICAqICAgc2FtZSByZWplY3Rpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XHJcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpLFxyXG4gICAgICAgIGNvdW50ZXIgPSAwLFxyXG4gICAgICAgIHJlc3VsdHMgPSBpc0FycmF5KHByb21pc2VzKSA/IFtdIDoge307XHJcblxyXG4gICAgZm9yRWFjaChwcm9taXNlcywgZnVuY3Rpb24ocHJvbWlzZSwga2V5KSB7XHJcbiAgICAgIGNvdW50ZXIrKztcclxuICAgICAgcmVmKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAocmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XHJcbiAgICAgICAgcmVzdWx0c1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKCEoLS1jb3VudGVyKSkgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdHMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xyXG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChjb3VudGVyID09PSAwKSB7XHJcbiAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZGVmZXI6IGRlZmVyLFxyXG4gICAgcmVqZWN0OiByZWplY3QsXHJcbiAgICB3aGVuOiB3aGVuLFxyXG4gICAgYWxsOiBhbGxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogREVTSUdOIE5PVEVTXHJcbiAqXHJcbiAqIFRoZSBkZXNpZ24gZGVjaXNpb25zIGJlaGluZCB0aGUgc2NvcGUgYXJlIGhlYXZpbHkgZmF2b3JlZCBmb3Igc3BlZWQgYW5kIG1lbW9yeSBjb25zdW1wdGlvbi5cclxuICpcclxuICogVGhlIHR5cGljYWwgdXNlIG9mIHNjb3BlIGlzIHRvIHdhdGNoIHRoZSBleHByZXNzaW9ucywgd2hpY2ggbW9zdCBvZiB0aGUgdGltZSByZXR1cm4gdGhlIHNhbWVcclxuICogdmFsdWUgYXMgbGFzdCB0aW1lIHNvIHdlIG9wdGltaXplIHRoZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIENsb3N1cmVzIGNvbnN0cnVjdGlvbiBpcyBleHBlbnNpdmUgaW4gdGVybXMgb2Ygc3BlZWQgYXMgd2VsbCBhcyBtZW1vcnk6XHJcbiAqICAgLSBObyBjbG9zdXJlcywgaW5zdGVhZCB1c2UgcHJvdG90eXBpY2FsIGluaGVyaXRhbmNlIGZvciBBUElcclxuICogICAtIEludGVybmFsIHN0YXRlIG5lZWRzIHRvIGJlIHN0b3JlZCBvbiBzY29wZSBkaXJlY3RseSwgd2hpY2ggbWVhbnMgdGhhdCBwcml2YXRlIHN0YXRlIGlzXHJcbiAqICAgICBleHBvc2VkIGFzICQkX19fXyBwcm9wZXJ0aWVzXHJcbiAqXHJcbiAqIExvb3Agb3BlcmF0aW9ucyBhcmUgb3B0aW1pemVkIGJ5IHVzaW5nIHdoaWxlKGNvdW50LS0pIHsgLi4uIH1cclxuICogICAtIHRoaXMgbWVhbnMgdGhhdCBpbiBvcmRlciB0byBrZWVwIHRoZSBzYW1lIG9yZGVyIG9mIGV4ZWN1dGlvbiBhcyBhZGRpdGlvbiB3ZSBoYXZlIHRvIGFkZFxyXG4gKiAgICAgaXRlbXMgdG8gdGhlIGFycmF5IGF0IHRoZSBiZWdpbm5pbmcgKHNoaWZ0KSBpbnN0ZWFkIG9mIGF0IHRoZSBlbmQgKHB1c2gpXHJcbiAqXHJcbiAqIENoaWxkIHNjb3BlcyBhcmUgY3JlYXRlZCBhbmQgcmVtb3ZlZCBvZnRlblxyXG4gKiAgIC0gVXNpbmcgYW4gYXJyYXkgd291bGQgYmUgc2xvdyBzaW5jZSBpbnNlcnRzIGluIG1pZGRsZSBhcmUgZXhwZW5zaXZlIHNvIHdlIHVzZSBsaW5rZWQgbGlzdFxyXG4gKlxyXG4gKiBUaGVyZSBhcmUgZmV3IHdhdGNoZXMgdGhlbiBhIGxvdCBvZiBvYnNlcnZlcnMuIFRoaXMgaXMgd2h5IHlvdSBkb24ndCB3YW50IHRoZSBvYnNlcnZlciB0byBiZVxyXG4gKiBpbXBsZW1lbnRlZCBpbiB0aGUgc2FtZSB3YXkgYXMgd2F0Y2guIFdhdGNoIHJlcXVpcmVzIHJldHVybiBvZiBpbml0aWFsaXphdGlvbiBmdW5jdGlvbiB3aGljaFxyXG4gKiBhcmUgZXhwZW5zaXZlIHRvIGNvbnN0cnVjdC5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJHJvb3RTY29wZVByb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBQcm92aWRlciBmb3IgdGhlICRyb290U2NvcGUgc2VydmljZS5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIG5nLiRyb290U2NvcGVQcm92aWRlciNkaWdlc3RUdGxcclxuICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGVQcm92aWRlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogU2V0cyB0aGUgbnVtYmVyIG9mIGRpZ2VzdCBpdGVyYXRpb25zIHRoZSBzY29wZSBzaG91bGQgYXR0ZW1wdCB0byBleGVjdXRlIGJlZm9yZSBnaXZpbmcgdXAgYW5kXHJcbiAqIGFzc3VtaW5nIHRoYXQgdGhlIG1vZGVsIGlzIHVuc3RhYmxlLlxyXG4gKlxyXG4gKiBUaGUgY3VycmVudCBkZWZhdWx0IGlzIDEwIGl0ZXJhdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbnVtYmVyIG9mIGRpZ2VzdCBpdGVyYXRpb25zLlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kcm9vdFNjb3BlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBFdmVyeSBhcHBsaWNhdGlvbiBoYXMgYSBzaW5nbGUgcm9vdCB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSBzY29wZX0uXHJcbiAqIEFsbCBvdGhlciBzY29wZXMgYXJlIGNoaWxkIHNjb3BlcyBvZiB0aGUgcm9vdCBzY29wZS4gU2NvcGVzIHByb3ZpZGUgbWVjaGFuaXNtIGZvciB3YXRjaGluZyB0aGUgbW9kZWwgYW5kIHByb3ZpZGVcclxuICogZXZlbnQgcHJvY2Vzc2luZyBsaWZlLWN5Y2xlLiBTZWUge0BsaW5rIGd1aWRlL3Njb3BlIGRldmVsb3BlciBndWlkZSBvbiBzY29wZXN9LlxyXG4gKi9cclxuZnVuY3Rpb24gJFJvb3RTY29wZVByb3ZpZGVyKCl7XHJcbiAgdmFyIFRUTCA9IDEwO1xyXG4gIHZhciAkcm9vdFNjb3BlTWluRXJyID0gbWluRXJyKCckcm9vdFNjb3BlJyk7XHJcblxyXG4gIHRoaXMuZGlnZXN0VHRsID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIFRUTCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRUTDtcclxuICB9O1xyXG5cclxuICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsICckZXhjZXB0aW9uSGFuZGxlcicsICckcGFyc2UnLCAnJGJyb3dzZXInLFxyXG4gICAgICBmdW5jdGlvbiggJGluamVjdG9yLCAgICRleGNlcHRpb25IYW5kbGVyLCAgICRwYXJzZSwgICAkYnJvd3Nlcikge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBBIHJvb3Qgc2NvcGUgY2FuIGJlIHJldHJpZXZlZCB1c2luZyB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUgJHJvb3RTY29wZX0ga2V5IGZyb20gdGhlXHJcbiAgICAgKiB7QGxpbmsgQVVUTy4kaW5qZWN0b3IgJGluamVjdG9yfS4gQ2hpbGQgc2NvcGVzIGFyZSBjcmVhdGVkIHVzaW5nIHRoZVxyXG4gICAgICoge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG5ldyAkbmV3KCl9IG1ldGhvZC4gKE1vc3Qgc2NvcGVzIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlblxyXG4gICAgICogY29tcGlsZWQgSFRNTCB0ZW1wbGF0ZSBpcyBleGVjdXRlZC4pXHJcbiAgICAgKlxyXG4gICAgICogSGVyZSBpcyBhIHNpbXBsZSBzY29wZSBzbmlwcGV0IHRvIHNob3cgaG93IHlvdSBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgc2NvcGUuXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICogPGZpbGUgc3JjPVwiLi90ZXN0L25nL3Jvb3RTY29wZVNwZWMuanNcIiB0YWc9XCJkb2NzMVwiIC8+XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiAjIEluaGVyaXRhbmNlXHJcbiAgICAgKiBBIHNjb3BlIGNhbiBpbmhlcml0IGZyb20gYSBwYXJlbnQgc2NvcGUsIGFzIGluIHRoaXMgZXhhbXBsZTpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgICAgIHZhciBwYXJlbnQgPSAkcm9vdFNjb3BlO1xyXG4gICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuJG5ldygpO1xyXG5cclxuICAgICAgICAgcGFyZW50LnNhbHV0YXRpb24gPSBcIkhlbGxvXCI7XHJcbiAgICAgICAgIGNoaWxkLm5hbWUgPSBcIldvcmxkXCI7XHJcbiAgICAgICAgIGV4cGVjdChjaGlsZC5zYWx1dGF0aW9uKS50b0VxdWFsKCdIZWxsbycpO1xyXG5cclxuICAgICAgICAgY2hpbGQuc2FsdXRhdGlvbiA9IFwiV2VsY29tZVwiO1xyXG4gICAgICAgICBleHBlY3QoY2hpbGQuc2FsdXRhdGlvbikudG9FcXVhbCgnV2VsY29tZScpO1xyXG4gICAgICAgICBleHBlY3QocGFyZW50LnNhbHV0YXRpb24pLnRvRXF1YWwoJ0hlbGxvJyk7XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oKT49fSBwcm92aWRlcnMgTWFwIG9mIHNlcnZpY2UgZmFjdG9yeSB3aGljaCBuZWVkIHRvIGJlIHByb3ZpZGVkXHJcbiAgICAgKiAgICAgZm9yIHRoZSBjdXJyZW50IHNjb3BlLiBEZWZhdWx0cyB0byB7QGxpbmsgbmd9LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj49fSBpbnN0YW5jZUNhY2hlIFByb3ZpZGVzIHByZS1pbnN0YW50aWF0ZWQgc2VydmljZXMgd2hpY2ggc2hvdWxkXHJcbiAgICAgKiAgICAgYXBwZW5kL292ZXJyaWRlIHNlcnZpY2VzIHByb3ZpZGVkIGJ5IGBwcm92aWRlcnNgLiBUaGlzIGlzIGhhbmR5IHdoZW4gdW5pdC10ZXN0aW5nIGFuZCBoYXZpbmdcclxuICAgICAqICAgICB0aGUgbmVlZCB0byBvdmVycmlkZSBhIGRlZmF1bHQgc2VydmljZS5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgc2NvcGUuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTY29wZSgpIHtcclxuICAgICAgdGhpcy4kaWQgPSBuZXh0VWlkKCk7XHJcbiAgICAgIHRoaXMuJCRwaGFzZSA9IHRoaXMuJHBhcmVudCA9IHRoaXMuJCR3YXRjaGVycyA9XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuJCRuZXh0U2libGluZyA9IHRoaXMuJCRwcmV2U2libGluZyA9XHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuJCRjaGlsZEhlYWQgPSB0aGlzLiQkY2hpbGRUYWlsID0gbnVsbDtcclxuICAgICAgdGhpc1sndGhpcyddID0gdGhpcy4kcm9vdCA9ICB0aGlzO1xyXG4gICAgICB0aGlzLiQkZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuJCRhc3luY1F1ZXVlID0gW107XHJcbiAgICAgIHRoaXMuJCRwb3N0RGlnZXN0UXVldWUgPSBbXTtcclxuICAgICAgdGhpcy4kJGxpc3RlbmVycyA9IHt9O1xyXG4gICAgICB0aGlzLiQkaXNvbGF0ZUJpbmRpbmdzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgcHJvcGVydHlcclxuICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGlkXHJcbiAgICAgKiBAcHJvcGVydHlPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbmlxdWUgc2NvcGUgSUQgKG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBhbHBoYW51bWVyaWMgc2VxdWVuY2UpIHVzZWZ1bCBmb3JcclxuICAgICAqICAgZGVidWdnaW5nLlxyXG4gICAgICovXHJcblxyXG5cclxuICAgIFNjb3BlLnByb3RvdHlwZSA9IHtcclxuICAgICAgY29uc3RydWN0b3I6IFNjb3BlLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJG5ld1xyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIENyZWF0ZXMgYSBuZXcgY2hpbGQge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUgc2NvcGV9LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgcGFyZW50IHNjb3BlIHdpbGwgcHJvcGFnYXRlIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZGlnZXN0ICRkaWdlc3QoKX0gYW5kXHJcbiAgICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCgpfSBldmVudHMuIFRoZSBzY29wZSBjYW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBzY29wZVxyXG4gICAgICAgKiBoaWVyYXJjaHkgdXNpbmcge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRlc3Ryb3kgJGRlc3Ryb3koKX0uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkZXN0cm95ICRkZXN0cm95KCl9IG11c3QgYmUgY2FsbGVkIG9uIGEgc2NvcGUgd2hlbiBpdCBpcyBkZXNpcmVkIGZvclxyXG4gICAgICAgKiB0aGUgc2NvcGUgYW5kIGl0cyBjaGlsZCBzY29wZXMgdG8gYmUgcGVybWFuZW50bHkgZGV0YWNoZWQgZnJvbSB0aGUgcGFyZW50IGFuZCB0aHVzIHN0b3BcclxuICAgICAgICogcGFydGljaXBhdGluZyBpbiBtb2RlbCBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCBsaXN0ZW5lciBub3RpZmljYXRpb24gYnkgaW52b2tpbmcuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNvbGF0ZSBpZiB0cnVlIHRoZW4gdGhlIHNjb3BlIGRvZXMgbm90IHByb3RvdHlwaWNhbGx5IGluaGVyaXQgZnJvbSB0aGVcclxuICAgICAgICogICAgICAgICBwYXJlbnQgc2NvcGUuIFRoZSBzY29wZSBpcyBpc29sYXRlZCwgYXMgaXQgY2FuIG5vdCBzZWUgcGFyZW50IHNjb3BlIHByb3BlcnRpZXMuXHJcbiAgICAgICAqICAgICAgICAgV2hlbiBjcmVhdGluZyB3aWRnZXRzIGl0IGlzIHVzZWZ1bCBmb3IgdGhlIHdpZGdldCB0byBub3QgYWNjaWRlbnRhbGx5IHJlYWQgcGFyZW50XHJcbiAgICAgICAqICAgICAgICAgc3RhdGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXdseSBjcmVhdGVkIGNoaWxkIHNjb3BlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cclxuICAgICAgJG5ldzogZnVuY3Rpb24oaXNvbGF0ZSkge1xyXG4gICAgICAgIHZhciBDaGlsZCxcclxuICAgICAgICAgICAgY2hpbGQ7XHJcblxyXG4gICAgICAgIGlmIChpc29sYXRlKSB7XHJcbiAgICAgICAgICBjaGlsZCA9IG5ldyBTY29wZSgpO1xyXG4gICAgICAgICAgY2hpbGQuJHJvb3QgPSB0aGlzLiRyb290O1xyXG4gICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlcmUgaXMganVzdCBvbmUgYXN5bmMgcXVldWUgcGVyICRyb290U2NvcGUgYW5kIGl0J3MgY2hpbGRyZW5cclxuICAgICAgICAgIGNoaWxkLiQkYXN5bmNRdWV1ZSA9IHRoaXMuJCRhc3luY1F1ZXVlO1xyXG4gICAgICAgICAgY2hpbGQuJCRwb3N0RGlnZXN0UXVldWUgPSB0aGlzLiQkcG9zdERpZ2VzdFF1ZXVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBDaGlsZCA9IGZ1bmN0aW9uKCkge307IC8vIHNob3VsZCBiZSBhbm9ueW1vdXM7IFRoaXMgaXMgc28gdGhhdCB3aGVuIHRoZSBtaW5pZmllciBtdW5nZXNcclxuICAgICAgICAgICAgLy8gdGhlIG5hbWUgaXQgZG9lcyBub3QgYmVjb21lIHJhbmRvbSBzZXQgb2YgY2hhcnMuIFRoZXNlIHdpbGwgdGhlbiBzaG93IHVwIGFzIGNsYXNzXHJcbiAgICAgICAgICAgIC8vIG5hbWUgaW4gdGhlIGRlYnVnZ2VyLlxyXG4gICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gdGhpcztcclxuICAgICAgICAgIGNoaWxkID0gbmV3IENoaWxkKCk7XHJcbiAgICAgICAgICBjaGlsZC4kaWQgPSBuZXh0VWlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkWyd0aGlzJ10gPSBjaGlsZDtcclxuICAgICAgICBjaGlsZC4kJGxpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgIGNoaWxkLiRwYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIGNoaWxkLiQkd2F0Y2hlcnMgPSBjaGlsZC4kJG5leHRTaWJsaW5nID0gY2hpbGQuJCRjaGlsZEhlYWQgPSBjaGlsZC4kJGNoaWxkVGFpbCA9IG51bGw7XHJcbiAgICAgICAgY2hpbGQuJCRwcmV2U2libGluZyA9IHRoaXMuJCRjaGlsZFRhaWw7XHJcbiAgICAgICAgaWYgKHRoaXMuJCRjaGlsZEhlYWQpIHtcclxuICAgICAgICAgIHRoaXMuJCRjaGlsZFRhaWwuJCRuZXh0U2libGluZyA9IGNoaWxkO1xyXG4gICAgICAgICAgdGhpcy4kJGNoaWxkVGFpbCA9IGNoaWxkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLiQkY2hpbGRIZWFkID0gdGhpcy4kJGNoaWxkVGFpbCA9IGNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJHdhdGNoXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogUmVnaXN0ZXJzIGEgYGxpc3RlbmVyYCBjYWxsYmFjayB0byBiZSBleGVjdXRlZCB3aGVuZXZlciB0aGUgYHdhdGNoRXhwcmVzc2lvbmAgY2hhbmdlcy5cclxuICAgICAgICpcclxuICAgICAgICogLSBUaGUgYHdhdGNoRXhwcmVzc2lvbmAgaXMgY2FsbGVkIG9uIGV2ZXJ5IGNhbGwgdG8ge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0KCl9IGFuZFxyXG4gICAgICAgKiAgIHNob3VsZCByZXR1cm4gdGhlIHZhbHVlIHdoaWNoIHdpbGwgYmUgd2F0Y2hlZC4gKFNpbmNlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCgpfVxyXG4gICAgICAgKiAgIHJlcnVucyB3aGVuIGl0IGRldGVjdHMgY2hhbmdlcyB0aGUgYHdhdGNoRXhwcmVzc2lvbmAgY2FuIGV4ZWN1dGUgbXVsdGlwbGUgdGltZXMgcGVyXHJcbiAgICAgICAqICAge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0KCl9IGFuZCBzaG91bGQgYmUgaWRlbXBvdGVudC4pXHJcbiAgICAgICAqIC0gVGhlIGBsaXN0ZW5lcmAgaXMgY2FsbGVkIG9ubHkgd2hlbiB0aGUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCBgd2F0Y2hFeHByZXNzaW9uYCBhbmQgdGhlXHJcbiAgICAgICAqICAgcHJldmlvdXMgY2FsbCB0byBgd2F0Y2hFeHByZXNzaW9uYCBhcmUgbm90IGVxdWFsICh3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIGluaXRpYWwgcnVuLFxyXG4gICAgICAgKiAgIHNlZSBiZWxvdykuIFRoZSBpbmVxdWFsaXR5IGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXHJcbiAgICAgICAqICAge0BsaW5rIGFuZ3VsYXIuZXF1YWxzfSBmdW5jdGlvbi4gVG8gc2F2ZSB0aGUgdmFsdWUgb2YgdGhlIG9iamVjdCBmb3IgbGF0ZXIgY29tcGFyaXNvbiwgdGhlXHJcbiAgICAgICAqICAge0BsaW5rIGFuZ3VsYXIuY29weX0gZnVuY3Rpb24gaXMgdXNlZC4gSXQgYWxzbyBtZWFucyB0aGF0IHdhdGNoaW5nIGNvbXBsZXggb3B0aW9ucyB3aWxsXHJcbiAgICAgICAqICAgaGF2ZSBhZHZlcnNlIG1lbW9yeSBhbmQgcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zLlxyXG4gICAgICAgKiAtIFRoZSB3YXRjaCBgbGlzdGVuZXJgIG1heSBjaGFuZ2UgdGhlIG1vZGVsLCB3aGljaCBtYXkgdHJpZ2dlciBvdGhlciBgbGlzdGVuZXJgcyB0byBmaXJlLiBUaGlzXHJcbiAgICAgICAqICAgaXMgYWNoaWV2ZWQgYnkgcmVydW5uaW5nIHRoZSB3YXRjaGVycyB1bnRpbCBubyBjaGFuZ2VzIGFyZSBkZXRlY3RlZC4gVGhlIHJlcnVuIGl0ZXJhdGlvblxyXG4gICAgICAgKiAgIGxpbWl0IGlzIDEwIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBkZWFkbG9jay5cclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICogSWYgeW91IHdhbnQgdG8gYmUgbm90aWZpZWQgd2hlbmV2ZXIge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0fSBpcyBjYWxsZWQsXHJcbiAgICAgICAqIHlvdSBjYW4gcmVnaXN0ZXIgYSBgd2F0Y2hFeHByZXNzaW9uYCBmdW5jdGlvbiB3aXRoIG5vIGBsaXN0ZW5lcmAuIChTaW5jZSBgd2F0Y2hFeHByZXNzaW9uYFxyXG4gICAgICAgKiBjYW4gZXhlY3V0ZSBtdWx0aXBsZSB0aW1lcyBwZXIge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0fSBjeWNsZSB3aGVuIGEgY2hhbmdlIGlzXHJcbiAgICAgICAqIGRldGVjdGVkLCBiZSBwcmVwYXJlZCBmb3IgbXVsdGlwbGUgY2FsbHMgdG8geW91ciBsaXN0ZW5lci4pXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFmdGVyIGEgd2F0Y2hlciBpcyByZWdpc3RlcmVkIHdpdGggdGhlIHNjb3BlLCB0aGUgYGxpc3RlbmVyYCBmbiBpcyBjYWxsZWQgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICogKHZpYSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZXZhbEFzeW5jICRldmFsQXN5bmN9KSB0byBpbml0aWFsaXplIHRoZVxyXG4gICAgICAgKiB3YXRjaGVyLiBJbiByYXJlIGNhc2VzLCB0aGlzIGlzIHVuZGVzaXJhYmxlIGJlY2F1c2UgdGhlIGxpc3RlbmVyIGlzIGNhbGxlZCB3aGVuIHRoZSByZXN1bHRcclxuICAgICAgICogb2YgYHdhdGNoRXhwcmVzc2lvbmAgZGlkbid0IGNoYW5nZS4gVG8gZGV0ZWN0IHRoaXMgc2NlbmFyaW8gd2l0aGluIHRoZSBgbGlzdGVuZXJgIGZuLCB5b3VcclxuICAgICAgICogY2FuIGNvbXBhcmUgdGhlIGBuZXdWYWxgIGFuZCBgb2xkVmFsYC4gSWYgdGhlc2UgdHdvIHZhbHVlcyBhcmUgaWRlbnRpY2FsIChgPT09YCkgdGhlbiB0aGVcclxuICAgICAgICogbGlzdGVuZXIgd2FzIGNhbGxlZCBkdWUgdG8gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqXHJcbiAgICAgICAqICMgRXhhbXBsZVxyXG4gICAgICAgKiA8cHJlPlxyXG4gICAgICAgICAgIC8vIGxldCdzIGFzc3VtZSB0aGF0IHNjb3BlIHdhcyBkZXBlbmRlbmN5IGluamVjdGVkIGFzIHRoZSAkcm9vdFNjb3BlXHJcbiAgICAgICAgICAgdmFyIHNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICAgICBzY29wZS5uYW1lID0gJ21pc2tvJztcclxuICAgICAgICAgICBzY29wZS5jb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgc2NvcGUuJHdhdGNoKCduYW1lJywgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7IHNjb3BlLmNvdW50ZXIgPSBzY29wZS5jb3VudGVyICsgMTsgfSk7XHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XHJcblxyXG4gICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICAgICAvLyBubyB2YXJpYWJsZSBjaGFuZ2VcclxuICAgICAgICAgICBleHBlY3Qoc2NvcGUuY291bnRlcikudG9FcXVhbCgwKTtcclxuXHJcbiAgICAgICAgICAgc2NvcGUubmFtZSA9ICdhZGFtJztcclxuICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAqIDwvcHJlPlxyXG4gICAgICAgKlxyXG4gICAgICAgKlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0geyhmdW5jdGlvbigpfHN0cmluZyl9IHdhdGNoRXhwcmVzc2lvbiBFeHByZXNzaW9uIHRoYXQgaXMgZXZhbHVhdGVkIG9uIGVhY2hcclxuICAgICAgICogICAge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0fSBjeWNsZS4gQSBjaGFuZ2UgaW4gdGhlIHJldHVybiB2YWx1ZSB0cmlnZ2VycyBhXHJcbiAgICAgICAqICAgIGNhbGwgdG8gdGhlIGBsaXN0ZW5lcmAuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICAgIC0gYHN0cmluZ2A6IEV2YWx1YXRlZCBhcyB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufVxyXG4gICAgICAgKiAgICAtIGBmdW5jdGlvbihzY29wZSlgOiBjYWxsZWQgd2l0aCBjdXJyZW50IGBzY29wZWAgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKCl8c3RyaW5nKT19IGxpc3RlbmVyIENhbGxiYWNrIGNhbGxlZCB3aGVuZXZlciB0aGUgcmV0dXJuIHZhbHVlIG9mXHJcbiAgICAgICAqICAgdGhlIGB3YXRjaEV4cHJlc3Npb25gIGNoYW5nZXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICAgIC0gYHN0cmluZ2A6IEV2YWx1YXRlZCBhcyB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufVxyXG4gICAgICAgKiAgICAtIGBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUsIHNjb3BlKWA6IGNhbGxlZCB3aXRoIGN1cnJlbnQgYW5kIHByZXZpb3VzIHZhbHVlcyBhcyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvYmplY3RFcXVhbGl0eSBDb21wYXJlIG9iamVjdCBmb3IgZXF1YWxpdHkgcmF0aGVyIHRoYW4gZm9yIHJlZmVyZW5jZS5cclxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKCl9IFJldHVybnMgYSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBsaXN0ZW5lci5cclxuICAgICAgICovXHJcbiAgICAgICR3YXRjaDogZnVuY3Rpb24od2F0Y2hFeHAsIGxpc3RlbmVyLCBvYmplY3RFcXVhbGl0eSkge1xyXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMsXHJcbiAgICAgICAgICAgIGdldCA9IGNvbXBpbGVUb0ZuKHdhdGNoRXhwLCAnd2F0Y2gnKSxcclxuICAgICAgICAgICAgYXJyYXkgPSBzY29wZS4kJHdhdGNoZXJzLFxyXG4gICAgICAgICAgICB3YXRjaGVyID0ge1xyXG4gICAgICAgICAgICAgIGZuOiBsaXN0ZW5lcixcclxuICAgICAgICAgICAgICBsYXN0OiBpbml0V2F0Y2hWYWwsXHJcbiAgICAgICAgICAgICAgZ2V0OiBnZXQsXHJcbiAgICAgICAgICAgICAgZXhwOiB3YXRjaEV4cCxcclxuICAgICAgICAgICAgICBlcTogISFvYmplY3RFcXVhbGl0eVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSB1c2VyIHBhc3Mgc3RyaW5nLCB3ZSBuZWVkIHRvIGNvbXBpbGUgaXQsIGRvIHdlIHJlYWxseSBuZWVkIHRoaXMgP1xyXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpIHtcclxuICAgICAgICAgIHZhciBsaXN0ZW5GbiA9IGNvbXBpbGVUb0ZuKGxpc3RlbmVyIHx8IG5vb3AsICdsaXN0ZW5lcicpO1xyXG4gICAgICAgICAgd2F0Y2hlci5mbiA9IGZ1bmN0aW9uKG5ld1ZhbCwgb2xkVmFsLCBzY29wZSkge2xpc3RlbkZuKHNjb3BlKTt9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3YXRjaEV4cCA9PSAnc3RyaW5nJyAmJiBnZXQuY29uc3RhbnQpIHtcclxuICAgICAgICAgIHZhciBvcmlnaW5hbEZuID0gd2F0Y2hlci5mbjtcclxuICAgICAgICAgIHdhdGNoZXIuZm4gPSBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCwgc2NvcGUpIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxGbi5jYWxsKHRoaXMsIG5ld1ZhbCwgb2xkVmFsLCBzY29wZSk7XHJcbiAgICAgICAgICAgIGFycmF5UmVtb3ZlKGFycmF5LCB3YXRjaGVyKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFycmF5KSB7XHJcbiAgICAgICAgICBhcnJheSA9IHNjb3BlLiQkd2F0Y2hlcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgdXNlIHVuc2hpZnQgc2luY2Ugd2UgdXNlIGEgd2hpbGUgbG9vcCBpbiAkZGlnZXN0IGZvciBzcGVlZC5cclxuICAgICAgICAvLyB0aGUgd2hpbGUgbG9vcCByZWFkcyBpbiByZXZlcnNlIG9yZGVyLlxyXG4gICAgICAgIGFycmF5LnVuc2hpZnQod2F0Y2hlcik7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGFycmF5UmVtb3ZlKGFycmF5LCB3YXRjaGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkd2F0Y2hDb2xsZWN0aW9uXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogU2hhbGxvdyB3YXRjaGVzIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmQgZmlyZXMgd2hlbmV2ZXIgYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxyXG4gICAgICAgKiAoZm9yIGFycmF5cyB0aGlzIGltcGxpZXMgd2F0Y2hpbmcgdGhlIGFycmF5IGl0ZW1zLCBmb3Igb2JqZWN0IG1hcHMgdGhpcyBpbXBsaWVzIHdhdGNoaW5nIHRoZSBwcm9wZXJ0aWVzKS5cclxuICAgICAgICogSWYgYSBjaGFuZ2UgaXMgZGV0ZWN0ZWQgdGhlIGBsaXN0ZW5lcmAgY2FsbGJhY2sgaXMgZmlyZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC0gVGhlIGBvYmpgIGNvbGxlY3Rpb24gaXMgb2JzZXJ2ZWQgdmlhIHN0YW5kYXJkICR3YXRjaCBvcGVyYXRpb24gYW5kIGlzIGV4YW1pbmVkIG9uIGV2ZXJ5IGNhbGwgdG8gJGRpZ2VzdCgpIHRvXHJcbiAgICAgICAqICAgc2VlIGlmIGFueSBpdGVtcyBoYXZlIGJlZW4gYWRkZWQsIHJlbW92ZWQsIG9yIG1vdmVkLlxyXG4gICAgICAgKiAtIFRoZSBgbGlzdGVuZXJgIGlzIGNhbGxlZCB3aGVuZXZlciBhbnl0aGluZyB3aXRoaW4gdGhlIGBvYmpgIGhhcyBjaGFuZ2VkLiBFeGFtcGxlcyBpbmNsdWRlIGFkZGluZyBuZXcgaXRlbXNcclxuICAgICAgICogICBpbnRvIHRoZSBvYmplY3Qgb3IgYXJyYXksIHJlbW92aW5nIGFuZCBtb3ZpbmcgaXRlbXMgYXJvdW5kLlxyXG4gICAgICAgKlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIEV4YW1wbGVcclxuICAgICAgICogPHByZT5cclxuICAgICAgICAgICRzY29wZS5uYW1lcyA9IFsnaWdvcicsICdtYXRpYXMnLCAnbWlza28nLCAnamFtZXMnXTtcclxuICAgICAgICAgICRzY29wZS5kYXRhQ291bnQgPSA0O1xyXG5cclxuICAgICAgICAgICRzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKCduYW1lcycsIGZ1bmN0aW9uKG5ld05hbWVzLCBvbGROYW1lcykge1xyXG4gICAgICAgICAgICAkc2NvcGUuZGF0YUNvdW50ID0gbmV3TmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgZXhwZWN0KCRzY29wZS5kYXRhQ291bnQpLnRvRXF1YWwoNCk7XHJcbiAgICAgICAgICAkc2NvcGUuJGRpZ2VzdCgpO1xyXG5cclxuICAgICAgICAgIC8vc3RpbGwgYXQgNCAuLi4gbm8gY2hhbmdlc1xyXG4gICAgICAgICAgZXhwZWN0KCRzY29wZS5kYXRhQ291bnQpLnRvRXF1YWwoNCk7XHJcblxyXG4gICAgICAgICAgJHNjb3BlLm5hbWVzLnBvcCgpO1xyXG4gICAgICAgICAgJHNjb3BlLiRkaWdlc3QoKTtcclxuXHJcbiAgICAgICAgICAvL25vdyB0aGVyZSdzIGJlZW4gYSBjaGFuZ2VcclxuICAgICAgICAgIGV4cGVjdCgkc2NvcGUuZGF0YUNvdW50KS50b0VxdWFsKDMpO1xyXG4gICAgICAgKiA8L3ByZT5cclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb24oc2NvcGUpfSBvYmogRXZhbHVhdGVkIGFzIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259LiBUaGUgZXhwcmVzc2lvbiB2YWx1ZVxyXG4gICAgICAgKiAgICBzaG91bGQgZXZhbHVhdGUgdG8gYW4gb2JqZWN0IG9yIGFuIGFycmF5IHdoaWNoIGlzIG9ic2VydmVkIG9uIGVhY2hcclxuICAgICAgICogICAge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0fSBjeWNsZS4gQW55IHNoYWxsb3cgY2hhbmdlIHdpdGhpbiB0aGUgY29sbGVjdGlvbiB3aWxsIHRyaWdnZXJcclxuICAgICAgICogICAgYSBjYWxsIHRvIHRoZSBgbGlzdGVuZXJgLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ld0NvbGxlY3Rpb24sIG9sZENvbGxlY3Rpb24sIHNjb3BlKX0gbGlzdGVuZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGZpcmVkIHdpdGggYm90aFxyXG4gICAgICAgKiAgICB0aGUgYG5ld0NvbGxlY3Rpb25gIGFuZCBgb2xkQ29sbGVjdGlvbmAgYXMgcGFyYW1ldGVycy5cclxuICAgICAgICogICAgVGhlIGBuZXdDb2xsZWN0aW9uYCBvYmplY3QgaXMgdGhlIG5ld2x5IG1vZGlmaWVkIGRhdGEgb2J0YWluZWQgZnJvbSB0aGUgYG9iamAgZXhwcmVzc2lvbiBhbmQgdGhlXHJcbiAgICAgICAqICAgIGBvbGRDb2xsZWN0aW9uYCBvYmplY3QgaXMgYSBjb3B5IG9mIHRoZSBmb3JtZXIgY29sbGVjdGlvbiBkYXRhLlxyXG4gICAgICAgKiAgICBUaGUgYHNjb3BlYCByZWZlcnMgdG8gdGhlIGN1cnJlbnQgc2NvcGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSBSZXR1cm5zIGEgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIGZvciB0aGlzIGxpc3RlbmVyLiBXaGVuIHRoZSBkZS1yZWdpc3RyYXRpb24gZnVuY3Rpb24gaXMgZXhlY3V0ZWRcclxuICAgICAgICogdGhlbiB0aGUgaW50ZXJuYWwgd2F0Y2ggb3BlcmF0aW9uIGlzIHRlcm1pbmF0ZWQuXHJcbiAgICAgICAqL1xyXG4gICAgICAkd2F0Y2hDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmosIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZTtcclxuICAgICAgICB2YXIgbmV3VmFsdWU7XHJcbiAgICAgICAgdmFyIGNoYW5nZURldGVjdGVkID0gMDtcclxuICAgICAgICB2YXIgb2JqR2V0dGVyID0gJHBhcnNlKG9iaik7XHJcbiAgICAgICAgdmFyIGludGVybmFsQXJyYXkgPSBbXTtcclxuICAgICAgICB2YXIgaW50ZXJuYWxPYmplY3QgPSB7fTtcclxuICAgICAgICB2YXIgb2xkTGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gJHdhdGNoQ29sbGVjdGlvbldhdGNoKCkge1xyXG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpHZXR0ZXIoc2VsZik7XHJcbiAgICAgICAgICB2YXIgbmV3TGVuZ3RoLCBrZXk7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc09iamVjdChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBpbnRlcm5hbEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgLy8gd2UgYXJlIHRyYW5zaXRpb25pbmcgZnJvbSBzb21ldGhpbmcgd2hpY2ggd2FzIG5vdCBhbiBhcnJheSBpbnRvIGFycmF5LlxyXG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gaW50ZXJuYWxBcnJheTtcclxuICAgICAgICAgICAgICBvbGRMZW5ndGggPSBvbGRWYWx1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdGVkKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ld0xlbmd0aCA9IG5ld1ZhbHVlLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChvbGRMZW5ndGggIT09IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgIC8vIGlmIGxlbmd0aHMgZG8gbm90IG1hdGNoIHdlIG5lZWQgdG8gdHJpZ2dlciBjaGFuZ2Ugbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgICBvbGRWYWx1ZS5sZW5ndGggPSBvbGRMZW5ndGggPSBuZXdMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29weSB0aGUgaXRlbXMgdG8gb2xkVmFsdWUgYW5kIGxvb2sgZm9yIGNoYW5nZXMuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBpZiAob2xkVmFsdWVbaV0gIT09IG5ld1ZhbHVlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWVbaV0gPSBuZXdWYWx1ZVtpXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gaW50ZXJuYWxPYmplY3QpIHtcclxuICAgICAgICAgICAgICAvLyB3ZSBhcmUgdHJhbnNpdGlvbmluZyBmcm9tIHNvbWV0aGluZyB3aGljaCB3YXMgbm90IGFuIG9iamVjdCBpbnRvIG9iamVjdC5cclxuICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGludGVybmFsT2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgICAgb2xkTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIGl0ZW1zIHRvIG9sZFZhbHVlIGFuZCBsb29rIGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgICBuZXdMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdMZW5ndGgrKztcclxuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZVtrZXldICE9PSBuZXdWYWx1ZVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtrZXldID0gbmV3VmFsdWVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgb2xkTGVuZ3RoKys7XHJcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlW2tleV0gPSBuZXdWYWx1ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgLy8gd2UgdXNlZCB0byBoYXZlIG1vcmUga2V5cywgbmVlZCB0byBmaW5kIHRoZW0gYW5kIGRlc3Ryb3kgdGhlbS5cclxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xyXG4gICAgICAgICAgICAgIGZvcihrZXkgaW4gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFuZXdWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9sZExlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICBkZWxldGUgb2xkVmFsdWVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBjaGFuZ2VEZXRlY3RlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uICR3YXRjaENvbGxlY3Rpb25BY3Rpb24oKSB7XHJcbiAgICAgICAgICBsaXN0ZW5lcihuZXdWYWx1ZSwgb2xkVmFsdWUsIHNlbGYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJHdhdGNoKCR3YXRjaENvbGxlY3Rpb25XYXRjaCwgJHdhdGNoQ29sbGVjdGlvbkFjdGlvbik7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdFxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFByb2Nlc3NlcyBhbGwgb2YgdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyR3YXRjaCB3YXRjaGVyc30gb2YgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICogQmVjYXVzZSBhIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyR3YXRjaCB3YXRjaGVyfSdzIGxpc3RlbmVyIGNhbiBjaGFuZ2UgdGhlIG1vZGVsLCB0aGVcclxuICAgICAgICogYCRkaWdlc3QoKWAga2VlcHMgY2FsbGluZyB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJHdhdGNoIHdhdGNoZXJzfSB1bnRpbCBubyBtb3JlIGxpc3RlbmVycyBhcmVcclxuICAgICAgICogZmlyaW5nLiBUaGlzIG1lYW5zIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gZ2V0IGludG8gYW4gaW5maW5pdGUgbG9vcC4gVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93XHJcbiAgICAgICAqIGAnTWF4aW11bSBpdGVyYXRpb24gbGltaXQgZXhjZWVkZWQuJ2AgaWYgdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGV4Y2VlZHMgMTAuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFVzdWFsbHkgeW91IGRvbid0IGNhbGwgYCRkaWdlc3QoKWAgZGlyZWN0bHkgaW5cclxuICAgICAgICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NvbnRyb2xsZXIgY29udHJvbGxlcnN9IG9yIGluXHJcbiAgICAgICAqIHtAbGluayBuZy4kY29tcGlsZVByb3ZpZGVyI2RpcmVjdGl2ZSBkaXJlY3RpdmVzfS5cclxuICAgICAgICogSW5zdGVhZCBhIGNhbGwgdG8ge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGFwcGx5ICRhcHBseSgpfSAodHlwaWNhbGx5IGZyb20gd2l0aGluIGFcclxuICAgICAgICoge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXIjZGlyZWN0aXZlIGRpcmVjdGl2ZXN9KSB3aWxsIGZvcmNlIGEgYCRkaWdlc3QoKWAuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIElmIHlvdSB3YW50IHRvIGJlIG5vdGlmaWVkIHdoZW5ldmVyIGAkZGlnZXN0KClgIGlzIGNhbGxlZCxcclxuICAgICAgICogeW91IGNhbiByZWdpc3RlciBhIGB3YXRjaEV4cHJlc3Npb25gIGZ1bmN0aW9uICB3aXRoIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyR3YXRjaCAkd2F0Y2goKX1cclxuICAgICAgICogd2l0aCBubyBgbGlzdGVuZXJgLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBZb3UgbWF5IGhhdmUgYSBuZWVkIHRvIGNhbGwgYCRkaWdlc3QoKWAgZnJvbSB3aXRoaW4gdW5pdC10ZXN0cywgdG8gc2ltdWxhdGUgdGhlIHNjb3BlXHJcbiAgICAgICAqIGxpZmUtY3ljbGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICMgRXhhbXBsZVxyXG4gICAgICAgKiA8cHJlPlxyXG4gICAgICAgICAgIHZhciBzY29wZSA9IC4uLjtcclxuICAgICAgICAgICBzY29wZS5uYW1lID0gJ21pc2tvJztcclxuICAgICAgICAgICBzY29wZS5jb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgc2NvcGUuJHdhdGNoKCduYW1lJywgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICBzY29wZS5jb3VudGVyID0gc2NvcGUuY291bnRlciArIDE7XHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XHJcblxyXG4gICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICAgICAvLyBubyB2YXJpYWJsZSBjaGFuZ2VcclxuICAgICAgICAgICBleHBlY3Qoc2NvcGUuY291bnRlcikudG9FcXVhbCgwKTtcclxuXHJcbiAgICAgICAgICAgc2NvcGUubmFtZSA9ICdhZGFtJztcclxuICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAqIDwvcHJlPlxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cclxuICAgICAgJGRpZ2VzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoLCB2YWx1ZSwgbGFzdCxcclxuICAgICAgICAgICAgd2F0Y2hlcnMsXHJcbiAgICAgICAgICAgIGFzeW5jUXVldWUgPSB0aGlzLiQkYXN5bmNRdWV1ZSxcclxuICAgICAgICAgICAgcG9zdERpZ2VzdFF1ZXVlID0gdGhpcy4kJHBvc3REaWdlc3RRdWV1ZSxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBkaXJ0eSwgdHRsID0gVFRMLFxyXG4gICAgICAgICAgICBuZXh0LCBjdXJyZW50LCB0YXJnZXQgPSB0aGlzLFxyXG4gICAgICAgICAgICB3YXRjaExvZyA9IFtdLFxyXG4gICAgICAgICAgICBsb2dJZHgsIGxvZ01zZztcclxuXHJcbiAgICAgICAgYmVnaW5QaGFzZSgnJGRpZ2VzdCcpO1xyXG5cclxuICAgICAgICBkbyB7IC8vIFwid2hpbGUgZGlydHlcIiBsb29wXHJcbiAgICAgICAgICBkaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgY3VycmVudCA9IHRhcmdldDtcclxuXHJcbiAgICAgICAgICB3aGlsZShhc3luY1F1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnQuJGV2YWwoYXN5bmNRdWV1ZS5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZG8geyAvLyBcInRyYXZlcnNlIHRoZSBzY29wZXNcIiBsb29wXHJcbiAgICAgICAgICAgIGlmICgod2F0Y2hlcnMgPSBjdXJyZW50LiQkd2F0Y2hlcnMpKSB7XHJcbiAgICAgICAgICAgICAgLy8gcHJvY2VzcyBvdXIgd2F0Y2hlc1xyXG4gICAgICAgICAgICAgIGxlbmd0aCA9IHdhdGNoZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIHdhdGNoID0gd2F0Y2hlcnNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgLy8gTW9zdCBjb21tb24gd2F0Y2hlcyBhcmUgb24gcHJpbWl0aXZlcywgaW4gd2hpY2ggY2FzZSB3ZSBjYW4gc2hvcnRcclxuICAgICAgICAgICAgICAgICAgLy8gY2lyY3VpdCBpdCB3aXRoID09PSBvcGVyYXRvciwgb25seSB3aGVuID09PSBmYWlscyBkbyB3ZSB1c2UgLmVxdWFsc1xyXG4gICAgICAgICAgICAgICAgICBpZiAod2F0Y2ggJiYgKHZhbHVlID0gd2F0Y2guZ2V0KGN1cnJlbnQpKSAhPT0gKGxhc3QgPSB3YXRjaC5sYXN0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgISh3YXRjaC5lcVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gZXF1YWxzKHZhbHVlLCBsYXN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFzdCA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGlzTmFOKHZhbHVlKSAmJiBpc05hTihsYXN0KSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoLmxhc3QgPSB3YXRjaC5lcSA/IGNvcHkodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2guZm4odmFsdWUsICgobGFzdCA9PT0gaW5pdFdhdGNoVmFsKSA/IHZhbHVlIDogbGFzdCksIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0dGwgPCA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBsb2dJZHggPSA0IC0gdHRsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YXRjaExvZ1tsb2dJZHhdKSB3YXRjaExvZ1tsb2dJZHhdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICBsb2dNc2cgPSAoaXNGdW5jdGlvbih3YXRjaC5leHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2ZuOiAnICsgKHdhdGNoLmV4cC5uYW1lIHx8IHdhdGNoLmV4cC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogd2F0Y2guZXhwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgbG9nTXNnICs9ICc7IG5ld1ZhbDogJyArIHRvSnNvbih2YWx1ZSkgKyAnOyBvbGRWYWw6ICcgKyB0b0pzb24obGFzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaExvZ1tsb2dJZHhdLnB1c2gobG9nTXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbnNhbml0eSBXYXJuaW5nOiBzY29wZSBkZXB0aC1maXJzdCB0cmF2ZXJzYWxcclxuICAgICAgICAgICAgLy8geWVzLCB0aGlzIGNvZGUgaXMgYSBiaXQgY3JhenksIGJ1dCBpdCB3b3JrcyBhbmQgd2UgaGF2ZSB0ZXN0cyB0byBwcm92ZSBpdCFcclxuICAgICAgICAgICAgLy8gdGhpcyBwaWVjZSBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRyYXZlcnNhbCBpbiAkYnJvYWRjYXN0XHJcbiAgICAgICAgICAgIGlmICghKG5leHQgPSAoY3VycmVudC4kJGNoaWxkSGVhZCB8fCAoY3VycmVudCAhPT0gdGFyZ2V0ICYmIGN1cnJlbnQuJCRuZXh0U2libGluZykpKSkge1xyXG4gICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnQgIT09IHRhcmdldCAmJiAhKG5leHQgPSBjdXJyZW50LiQkbmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kcGFyZW50O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKGN1cnJlbnQgPSBuZXh0KSk7XHJcblxyXG4gICAgICAgICAgaWYoZGlydHkgJiYgISh0dGwtLSkpIHtcclxuICAgICAgICAgICAgY2xlYXJQaGFzZSgpO1xyXG4gICAgICAgICAgICB0aHJvdyAkcm9vdFNjb3BlTWluRXJyKCdpbmZkaWcnLFxyXG4gICAgICAgICAgICAgICAgJ3swfSAkZGlnZXN0KCkgaXRlcmF0aW9ucyByZWFjaGVkLiBBYm9ydGluZyFcXG5XYXRjaGVycyBmaXJlZCBpbiB0aGUgbGFzdCA1IGl0ZXJhdGlvbnM6IHsxfScsXHJcbiAgICAgICAgICAgICAgICBUVEwsIHRvSnNvbih3YXRjaExvZykpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGRpcnR5IHx8IGFzeW5jUXVldWUubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgY2xlYXJQaGFzZSgpO1xyXG5cclxuICAgICAgICB3aGlsZShwb3N0RGlnZXN0UXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBwb3N0RGlnZXN0UXVldWUuc2hpZnQoKSgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBldmVudFxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkZXN0cm95XHJcbiAgICAgICAqIEBldmVudE9mIG5nLiRyb290U2NvcGUuU2NvcGVcclxuICAgICAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gc2NvcGUgYmVpbmcgZGVzdHJveWVkXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBCcm9hZGNhc3RlZCB3aGVuIGEgc2NvcGUgYW5kIGl0cyBjaGlsZHJlbiBhcmUgYmVpbmcgZGVzdHJveWVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBOb3RlIHRoYXQsIGluIEFuZ3VsYXJKUywgdGhlcmUgaXMgYWxzbyBhIGAkZGVzdHJveWAgalF1ZXJ5IGV2ZW50LCB3aGljaCBjYW4gYmUgdXNlZCB0b1xyXG4gICAgICAgKiBjbGVhbiB1cCBET00gYmluZGluZ3MgYmVmb3JlIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXHJcbiAgICAgICAqL1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkZXN0cm95XHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogUmVtb3ZlcyB0aGUgY3VycmVudCBzY29wZSAoYW5kIGFsbCBvZiBpdHMgY2hpbGRyZW4pIGZyb20gdGhlIHBhcmVudCBzY29wZS4gUmVtb3ZhbCBpbXBsaWVzXHJcbiAgICAgICAqIHRoYXQgY2FsbHMgdG8ge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0KCl9IHdpbGwgbm8gbG9uZ2VyXHJcbiAgICAgICAqIHByb3BhZ2F0ZSB0byB0aGUgY3VycmVudCBzY29wZSBhbmQgaXRzIGNoaWxkcmVuLiBSZW1vdmFsIGFsc28gaW1wbGllcyB0aGF0IHRoZSBjdXJyZW50XHJcbiAgICAgICAqIHNjb3BlIGlzIGVsaWdpYmxlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRoZSBgJGRlc3Ryb3koKWAgaXMgdXN1YWxseSB1c2VkIGJ5IGRpcmVjdGl2ZXMgc3VjaCBhc1xyXG4gICAgICAgKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IG5nUmVwZWF0fSBmb3IgbWFuYWdpbmcgdGhlXHJcbiAgICAgICAqIHVucm9sbGluZyBvZiB0aGUgbG9vcC5cclxuICAgICAgICpcclxuICAgICAgICogSnVzdCBiZWZvcmUgYSBzY29wZSBpcyBkZXN0cm95ZWQgYSBgJGRlc3Ryb3lgIGV2ZW50IGlzIGJyb2FkY2FzdGVkIG9uIHRoaXMgc2NvcGUuXHJcbiAgICAgICAqIEFwcGxpY2F0aW9uIGNvZGUgY2FuIHJlZ2lzdGVyIGEgYCRkZXN0cm95YCBldmVudCBoYW5kbGVyIHRoYXQgd2lsbCBnaXZlIGl0IGNoYW5jZSB0b1xyXG4gICAgICAgKiBwZXJmb3JtIGFueSBuZWNlc3NhcnkgY2xlYW51cC5cclxuICAgICAgICpcclxuICAgICAgICogTm90ZSB0aGF0LCBpbiBBbmd1bGFySlMsIHRoZXJlIGlzIGFsc28gYSBgJGRlc3Ryb3lgIGpRdWVyeSBldmVudCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cclxuICAgICAgICogY2xlYW4gdXAgRE9NIGJpbmRpbmdzIGJlZm9yZSBhbiBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxyXG4gICAgICAgKi9cclxuICAgICAgJGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIHdlIGNhbid0IGRlc3Ryb3kgdGhlIHJvb3Qgc2NvcGUgb3IgYSBzY29wZSB0aGF0IGhhcyBiZWVuIGFscmVhZHkgZGVzdHJveWVkXHJcbiAgICAgICAgaWYgKCRyb290U2NvcGUgPT0gdGhpcyB8fCB0aGlzLiQkZGVzdHJveWVkKSByZXR1cm47XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcclxuXHJcbiAgICAgICAgdGhpcy4kYnJvYWRjYXN0KCckZGVzdHJveScpO1xyXG4gICAgICAgIHRoaXMuJCRkZXN0cm95ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAocGFyZW50LiQkY2hpbGRIZWFkID09IHRoaXMpIHBhcmVudC4kJGNoaWxkSGVhZCA9IHRoaXMuJCRuZXh0U2libGluZztcclxuICAgICAgICBpZiAocGFyZW50LiQkY2hpbGRUYWlsID09IHRoaXMpIHBhcmVudC4kJGNoaWxkVGFpbCA9IHRoaXMuJCRwcmV2U2libGluZztcclxuICAgICAgICBpZiAodGhpcy4kJHByZXZTaWJsaW5nKSB0aGlzLiQkcHJldlNpYmxpbmcuJCRuZXh0U2libGluZyA9IHRoaXMuJCRuZXh0U2libGluZztcclxuICAgICAgICBpZiAodGhpcy4kJG5leHRTaWJsaW5nKSB0aGlzLiQkbmV4dFNpYmxpbmcuJCRwcmV2U2libGluZyA9IHRoaXMuJCRwcmV2U2libGluZztcclxuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBib2d1cyBjb2RlIHRoYXQgd29ya3MgYXJvdW5kIENocm9tZSdzIEdDIGxlYWtcclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzEzMTMjaXNzdWVjb21tZW50LTEwMzc4NDUxXHJcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy4kJG5leHRTaWJsaW5nID0gdGhpcy4kJHByZXZTaWJsaW5nID0gdGhpcy4kJGNoaWxkSGVhZCA9XHJcbiAgICAgICAgICAgIHRoaXMuJCRjaGlsZFRhaWwgPSBudWxsO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRldmFsXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogRXhlY3V0ZXMgdGhlIGBleHByZXNzaW9uYCBvbiB0aGUgY3VycmVudCBzY29wZSByZXR1cm5pbmcgdGhlIHJlc3VsdC4gQW55IGV4Y2VwdGlvbnMgaW4gdGhlXHJcbiAgICAgICAqIGV4cHJlc3Npb24gYXJlIHByb3BhZ2F0ZWQgKHVuY2F1Z2h0KS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBldmFsdWF0aW5nIEFuZ3VsYXIgZXhwcmVzc2lvbnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICMgRXhhbXBsZVxyXG4gICAgICAgKiA8cHJlPlxyXG4gICAgICAgICAgIHZhciBzY29wZSA9IG5nLiRyb290U2NvcGUuU2NvcGUoKTtcclxuICAgICAgICAgICBzY29wZS5hID0gMTtcclxuICAgICAgICAgICBzY29wZS5iID0gMjtcclxuXHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLiRldmFsKCdhK2InKSkudG9FcXVhbCgzKTtcclxuICAgICAgICAgICBleHBlY3Qoc2NvcGUuJGV2YWwoZnVuY3Rpb24oc2NvcGUpeyByZXR1cm4gc2NvcGUuYSArIHNjb3BlLmI7IH0pKS50b0VxdWFsKDMpO1xyXG4gICAgICAgKiA8L3ByZT5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKCkpPX0gZXhwcmVzc2lvbiBBbiBhbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICAgIC0gYHN0cmluZ2A6IGV4ZWN1dGUgdXNpbmcgdGhlIHJ1bGVzIGFzIGRlZmluZWQgaW4gIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259LlxyXG4gICAgICAgKiAgICAtIGBmdW5jdGlvbihzY29wZSlgOiBleGVjdXRlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBjdXJyZW50IGBzY29wZWAgcGFyYW1ldGVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBleHByZXNzaW9uLlxyXG4gICAgICAgKi9cclxuICAgICAgJGV2YWw6IGZ1bmN0aW9uKGV4cHIsIGxvY2Fscykge1xyXG4gICAgICAgIHJldHVybiAkcGFyc2UoZXhwcikodGhpcywgbG9jYWxzKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkZXZhbEFzeW5jXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogRXhlY3V0ZXMgdGhlIGV4cHJlc3Npb24gb24gdGhlIGN1cnJlbnQgc2NvcGUgYXQgYSBsYXRlciBwb2ludCBpbiB0aW1lLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgYCRldmFsQXN5bmNgIG1ha2VzIG5vIGd1YXJhbnRlZXMgYXMgdG8gd2hlbiB0aGUgYGV4cHJlc3Npb25gIHdpbGwgYmUgZXhlY3V0ZWQsIG9ubHkgdGhhdDpcclxuICAgICAgICpcclxuICAgICAgICogICAtIGl0IHdpbGwgZXhlY3V0ZSBhZnRlciB0aGUgZnVuY3Rpb24gdGhhdCBzY2hlZHVsZSB0aGUgZXZhbHVhdGlvbiBpcyBkb25lIHJ1bm5pbmcgKHByZWZlcmFibHkgYmVmb3JlIERPTSByZW5kZXJpbmcpLlxyXG4gICAgICAgKiAgIC0gYXQgbGVhc3Qgb25lIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCBjeWNsZX0gd2lsbCBiZSBwZXJmb3JtZWQgYWZ0ZXIgYGV4cHJlc3Npb25gIGV4ZWN1dGlvbi5cclxuICAgICAgICpcclxuICAgICAgICogQW55IGV4Y2VwdGlvbnMgZnJvbSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBleHByZXNzaW9uIGFyZSBmb3J3YXJkZWQgdG8gdGhlXHJcbiAgICAgICAqIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cclxuICAgICAgICpcclxuICAgICAgICogX19Ob3RlOl9fIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG91dHNpZGUgb2YgYCRkaWdlc3RgIGN5Y2xlLCBhIG5ldyAkZGlnZXN0IGN5Y2xlIHdpbGwgYmUgc2NoZWR1bGVkLlxyXG4gICAgICAgKiBJdCBpcyBob3dldmVyIGVuY291cmFnZWQgdG8gYWx3YXlzIGNhbGwgY29kZSB0aGF0IGNoYW5nZXMgdGhlIG1vZGVsIGZyb20gd2l0aGluZyBhbiBgJGFwcGx5YCBjYWxsLlxyXG4gICAgICAgKiBUaGF0IGluY2x1ZGVzIGNvZGUgZXZhbHVhdGVkIHZpYSBgJGV2YWxBc3luY2AuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbigpKT19IGV4cHJlc3Npb24gQW4gYW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAgICAtIGBzdHJpbmdgOiBleGVjdXRlIHVzaW5nIHRoZSBydWxlcyBhcyBkZWZpbmVkIGluICB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufS5cclxuICAgICAgICogICAgLSBgZnVuY3Rpb24oc2NvcGUpYDogZXhlY3V0ZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgY3VycmVudCBgc2NvcGVgIHBhcmFtZXRlci5cclxuICAgICAgICpcclxuICAgICAgICovXHJcbiAgICAgICRldmFsQXN5bmM6IGZ1bmN0aW9uKGV4cHIpIHtcclxuICAgICAgICAvLyBpZiB3ZSBhcmUgb3V0c2lkZSBvZiBhbiAkZGlnZXN0IGxvb3AgYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UgYXJlIHNjaGVkdWxpbmcgYXN5bmMgdGFzayBhbHNvIHNjaGVkdWxlXHJcbiAgICAgICAgLy8gYXN5bmMgYXV0by1mbHVzaFxyXG4gICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlICYmICEkcm9vdFNjb3BlLiQkYXN5bmNRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICRicm93c2VyLmRlZmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kJGFzeW5jUXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy4kJGFzeW5jUXVldWUucHVzaChleHByKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgICQkcG9zdERpZ2VzdCA6IGZ1bmN0aW9uKGV4cHIpIHtcclxuICAgICAgICB0aGlzLiQkcG9zdERpZ2VzdFF1ZXVlLnB1c2goZXhwcik7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGFwcGx5XHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogYCRhcHBseSgpYCBpcyB1c2VkIHRvIGV4ZWN1dGUgYW4gZXhwcmVzc2lvbiBpbiBhbmd1bGFyIGZyb20gb3V0c2lkZSBvZiB0aGUgYW5ndWxhciBmcmFtZXdvcmsuXHJcbiAgICAgICAqIChGb3IgZXhhbXBsZSBmcm9tIGJyb3dzZXIgRE9NIGV2ZW50cywgc2V0VGltZW91dCwgWEhSIG9yIHRoaXJkIHBhcnR5IGxpYnJhcmllcykuXHJcbiAgICAgICAqIEJlY2F1c2Ugd2UgYXJlIGNhbGxpbmcgaW50byB0aGUgYW5ndWxhciBmcmFtZXdvcmsgd2UgbmVlZCB0byBwZXJmb3JtIHByb3BlciBzY29wZSBsaWZlLWN5Y2xlXHJcbiAgICAgICAqIG9mIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciBleGNlcHRpb24gaGFuZGxpbmd9LFxyXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZGlnZXN0IGV4ZWN1dGluZyB3YXRjaGVzfS5cclxuICAgICAgICpcclxuICAgICAgICogIyMgTGlmZSBjeWNsZVxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIFBzZXVkby1Db2RlIG9mIGAkYXBwbHkoKWBcclxuICAgICAgICogPHByZT5cclxuICAgICAgICAgICBmdW5jdGlvbiAkYXBwbHkoZXhwcikge1xyXG4gICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgcmV0dXJuICRldmFsKGV4cHIpO1xyXG4gICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICRyb290LiRkaWdlc3QoKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAqIDwvcHJlPlxyXG4gICAgICAgKlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBTY29wZSdzIGAkYXBwbHkoKWAgbWV0aG9kIHRyYW5zaXRpb25zIHRocm91Z2ggdGhlIGZvbGxvd2luZyBzdGFnZXM6XHJcbiAgICAgICAqXHJcbiAgICAgICAqIDEuIFRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyBleGVjdXRlZCB1c2luZyB0aGVcclxuICAgICAgICogICAge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGV2YWwgJGV2YWwoKX0gbWV0aG9kLlxyXG4gICAgICAgKiAyLiBBbnkgZXhjZXB0aW9ucyBmcm9tIHRoZSBleGVjdXRpb24gb2YgdGhlIGV4cHJlc3Npb24gYXJlIGZvcndhcmRlZCB0byB0aGVcclxuICAgICAgICogICAge0BsaW5rIG5nLiRleGNlcHRpb25IYW5kbGVyICRleGNlcHRpb25IYW5kbGVyfSBzZXJ2aWNlLlxyXG4gICAgICAgKiAzLiBUaGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJHdhdGNoIHdhdGNofSBsaXN0ZW5lcnMgYXJlIGZpcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBleHByZXNzaW9uXHJcbiAgICAgICAqICAgIHdhcyBleGVjdXRlZCB1c2luZyB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0KCl9IG1ldGhvZC5cclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKCkpPX0gZXhwIEFuIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZC5cclxuICAgICAgICpcclxuICAgICAgICogICAgLSBgc3RyaW5nYDogZXhlY3V0ZSB1c2luZyB0aGUgcnVsZXMgYXMgZGVmaW5lZCBpbiB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufS5cclxuICAgICAgICogICAgLSBgZnVuY3Rpb24oc2NvcGUpYDogZXhlY3V0ZSB0aGUgZnVuY3Rpb24gd2l0aCBjdXJyZW50IGBzY29wZWAgcGFyYW1ldGVyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBleHByZXNzaW9uLlxyXG4gICAgICAgKi9cclxuICAgICAgJGFwcGx5OiBmdW5jdGlvbihleHByKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGJlZ2luUGhhc2UoJyRhcHBseScpO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGV2YWwoZXhwcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGNsZWFyUGhhc2UoKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICRyb290U2NvcGUuJGRpZ2VzdCgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJG9uXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogTGlzdGVucyBvbiBldmVudHMgb2YgYSBnaXZlbiB0eXBlLiBTZWUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGVtaXQgJGVtaXR9IGZvciBkaXNjdXNzaW9uIG9mXHJcbiAgICAgICAqIGV2ZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRoZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvbiBmb3JtYXQgaXM6IGBmdW5jdGlvbihldmVudCwgYXJncy4uLilgLiBUaGUgYGV2ZW50YCBvYmplY3RcclxuICAgICAgICogcGFzc2VkIGludG8gdGhlIGxpc3RlbmVyIGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XHJcbiAgICAgICAqXHJcbiAgICAgICAqICAgLSBgdGFyZ2V0U2NvcGVgIC0gYHtTY29wZX1gOiB0aGUgc2NvcGUgb24gd2hpY2ggdGhlIGV2ZW50IHdhcyBgJGVtaXRgLWVkIG9yIGAkYnJvYWRjYXN0YC1lZC5cclxuICAgICAgICogICAtIGBjdXJyZW50U2NvcGVgIC0gYHtTY29wZX1gOiB0aGUgY3VycmVudCBzY29wZSB3aGljaCBpcyBoYW5kbGluZyB0aGUgZXZlbnQuXHJcbiAgICAgICAqICAgLSBgbmFtZWAgLSBge3N0cmluZ31gOiBOYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAgICogICAtIGBzdG9wUHJvcGFnYXRpb25gIC0gYHtmdW5jdGlvbj19YDogY2FsbGluZyBgc3RvcFByb3BhZ2F0aW9uYCBmdW5jdGlvbiB3aWxsIGNhbmNlbCBmdXJ0aGVyIGV2ZW50XHJcbiAgICAgICAqICAgICBwcm9wYWdhdGlvbiAoYXZhaWxhYmxlIG9ubHkgZm9yIGV2ZW50cyB0aGF0IHdlcmUgYCRlbWl0YC1lZCkuXHJcbiAgICAgICAqICAgLSBgcHJldmVudERlZmF1bHRgIC0gYHtmdW5jdGlvbn1gOiBjYWxsaW5nIGBwcmV2ZW50RGVmYXVsdGAgc2V0cyBgZGVmYXVsdFByZXZlbnRlZGAgZmxhZyB0byB0cnVlLlxyXG4gICAgICAgKiAgIC0gYGRlZmF1bHRQcmV2ZW50ZWRgIC0gYHtib29sZWFufWA6IHRydWUgaWYgYHByZXZlbnREZWZhdWx0YCB3YXMgY2FsbGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lIHRvIGxpc3RlbiBvbi5cclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihldmVudCwgYXJncy4uLil9IGxpc3RlbmVyIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC5cclxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKCl9IFJldHVybnMgYSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBsaXN0ZW5lci5cclxuICAgICAgICovXHJcbiAgICAgICRvbjogZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgbmFtZWRMaXN0ZW5lcnMgPSB0aGlzLiQkbGlzdGVuZXJzW25hbWVdO1xyXG4gICAgICAgIGlmICghbmFtZWRMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgIHRoaXMuJCRsaXN0ZW5lcnNbbmFtZV0gPSBuYW1lZExpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuYW1lZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgbmFtZWRMaXN0ZW5lcnNbaW5kZXhPZihuYW1lZExpc3RlbmVycywgbGlzdGVuZXIpXSA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGVtaXRcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGBuYW1lYCB1cHdhcmRzIHRocm91Z2ggdGhlIHNjb3BlIGhpZXJhcmNoeSBub3RpZnlpbmcgdGhlXHJcbiAgICAgICAqIHJlZ2lzdGVyZWQge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG9ufSBsaXN0ZW5lcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRoZSBldmVudCBsaWZlIGN5Y2xlIHN0YXJ0cyBhdCB0aGUgc2NvcGUgb24gd2hpY2ggYCRlbWl0YCB3YXMgY2FsbGVkLiBBbGxcclxuICAgICAgICoge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG9uIGxpc3RlbmVyc30gbGlzdGVuaW5nIGZvciBgbmFtZWAgZXZlbnQgb24gdGhpcyBzY29wZSBnZXQgbm90aWZpZWQuXHJcbiAgICAgICAqIEFmdGVyd2FyZHMsIHRoZSBldmVudCB0cmF2ZXJzZXMgdXB3YXJkcyB0b3dhcmQgdGhlIHJvb3Qgc2NvcGUgYW5kIGNhbGxzIGFsbCByZWdpc3RlcmVkXHJcbiAgICAgICAqIGxpc3RlbmVycyBhbG9uZyB0aGUgd2F5LiBUaGUgZXZlbnQgd2lsbCBzdG9wIHByb3BhZ2F0aW5nIGlmIG9uZSBvZiB0aGUgbGlzdGVuZXJzIGNhbmNlbHMgaXQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFueSBleGNlcHRpb24gZW1pdHRlZCBmcm9tIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkb24gbGlzdGVuZXJzfSB3aWxsIGJlIHBhc3NlZFxyXG4gICAgICAgKiBvbnRvIHRoZSB7QGxpbmsgbmcuJGV4Y2VwdGlvbkhhbmRsZXIgJGV4Y2VwdGlvbkhhbmRsZXJ9IHNlcnZpY2UuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUgdG8gZW1pdC5cclxuICAgICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIE9wdGlvbmFsIHNldCBvZiBhcmd1bWVudHMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgb250byB0aGUgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEV2ZW50IG9iamVjdCwgc2VlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRvbn1cclxuICAgICAgICovXHJcbiAgICAgICRlbWl0OiBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIGVtcHR5ID0gW10sXHJcbiAgICAgICAgICAgIG5hbWVkTGlzdGVuZXJzLFxyXG4gICAgICAgICAgICBzY29wZSA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlLFxyXG4gICAgICAgICAgICBldmVudCA9IHtcclxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgIHRhcmdldFNjb3BlOiBzY29wZSxcclxuICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge3N0b3BQcm9wYWdhdGlvbiA9IHRydWU7fSxcclxuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RlbmVyQXJncyA9IGNvbmNhdChbZXZlbnRdLCBhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgICAgICBpLCBsZW5ndGg7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIG5hbWVkTGlzdGVuZXJzID0gc2NvcGUuJCRsaXN0ZW5lcnNbbmFtZV0gfHwgZW1wdHk7XHJcbiAgICAgICAgICBldmVudC5jdXJyZW50U2NvcGUgPSBzY29wZTtcclxuICAgICAgICAgIGZvciAoaT0wLCBsZW5ndGg9bmFtZWRMaXN0ZW5lcnMubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBsaXN0ZW5lcnMgd2VyZSBkZXJlZ2lzdGVyZWQsIGRlZnJhZ21lbnQgdGhlIGFycmF5XHJcbiAgICAgICAgICAgIGlmICghbmFtZWRMaXN0ZW5lcnNbaV0pIHtcclxuICAgICAgICAgICAgICBuYW1lZExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgIGxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgbmFtZWRMaXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgbGlzdGVuZXJBcmdzKTtcclxuICAgICAgICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKSByZXR1cm4gZXZlbnQ7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy90cmF2ZXJzZSB1cHdhcmRzXHJcbiAgICAgICAgICBzY29wZSA9IHNjb3BlLiRwYXJlbnQ7XHJcbiAgICAgICAgfSB3aGlsZSAoc2NvcGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgIH0sXHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRicm9hZGNhc3RcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGBuYW1lYCBkb3dud2FyZHMgdG8gYWxsIGNoaWxkIHNjb3BlcyAoYW5kIHRoZWlyIGNoaWxkcmVuKSBub3RpZnlpbmcgdGhlXHJcbiAgICAgICAqIHJlZ2lzdGVyZWQge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG9ufSBsaXN0ZW5lcnMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRoZSBldmVudCBsaWZlIGN5Y2xlIHN0YXJ0cyBhdCB0aGUgc2NvcGUgb24gd2hpY2ggYCRicm9hZGNhc3RgIHdhcyBjYWxsZWQuIEFsbFxyXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkb24gbGlzdGVuZXJzfSBsaXN0ZW5pbmcgZm9yIGBuYW1lYCBldmVudCBvbiB0aGlzIHNjb3BlIGdldCBub3RpZmllZC5cclxuICAgICAgICogQWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHByb3BhZ2F0ZXMgdG8gYWxsIGRpcmVjdCBhbmQgaW5kaXJlY3Qgc2NvcGVzIG9mIHRoZSBjdXJyZW50IHNjb3BlIGFuZFxyXG4gICAgICAgKiBjYWxscyBhbGwgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMgYWxvbmcgdGhlIHdheS4gVGhlIGV2ZW50IGNhbm5vdCBiZSBjYW5jZWxlZC5cclxuICAgICAgICpcclxuICAgICAgICogQW55IGV4Y2VwdGlvbiBlbWl0dGVkIGZyb20gdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRvbiBsaXN0ZW5lcnN9IHdpbGwgYmUgcGFzc2VkXHJcbiAgICAgICAqIG9udG8gdGhlIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBicm9hZGNhc3QuXHJcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBPcHRpb25hbCBzZXQgb2YgYXJndW1lbnRzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIG9udG8gdGhlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBFdmVudCBvYmplY3QsIHNlZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkb259XHJcbiAgICAgICAqL1xyXG4gICAgICAkYnJvYWRjYXN0OiBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0YXJnZXQsXHJcbiAgICAgICAgICAgIG5leHQgPSB0YXJnZXQsXHJcbiAgICAgICAgICAgIGV2ZW50ID0ge1xyXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgdGFyZ2V0U2NvcGU6IHRhcmdldCxcclxuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RlbmVyQXJncyA9IGNvbmNhdChbZXZlbnRdLCBhcmd1bWVudHMsIDEpLFxyXG4gICAgICAgICAgICBsaXN0ZW5lcnMsIGksIGxlbmd0aDtcclxuXHJcbiAgICAgICAgLy9kb3duIHdoaWxlIHlvdSBjYW4sIHRoZW4gdXAgYW5kIG5leHQgc2libGluZyBvciB1cCBhbmQgbmV4dCBzaWJsaW5nIHVudGlsIGJhY2sgYXQgcm9vdFxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xyXG4gICAgICAgICAgZXZlbnQuY3VycmVudFNjb3BlID0gY3VycmVudDtcclxuICAgICAgICAgIGxpc3RlbmVycyA9IGN1cnJlbnQuJCRsaXN0ZW5lcnNbbmFtZV0gfHwgW107XHJcbiAgICAgICAgICBmb3IgKGk9MCwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaTxsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBpZiBsaXN0ZW5lcnMgd2VyZSBkZXJlZ2lzdGVyZWQsIGRlZnJhZ21lbnQgdGhlIGFycmF5XHJcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzW2ldKSB7XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgbGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KG51bGwsIGxpc3RlbmVyQXJncyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gSW5zYW5pdHkgV2FybmluZzogc2NvcGUgZGVwdGgtZmlyc3QgdHJhdmVyc2FsXHJcbiAgICAgICAgICAvLyB5ZXMsIHRoaXMgY29kZSBpcyBhIGJpdCBjcmF6eSwgYnV0IGl0IHdvcmtzIGFuZCB3ZSBoYXZlIHRlc3RzIHRvIHByb3ZlIGl0IVxyXG4gICAgICAgICAgLy8gdGhpcyBwaWVjZSBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRyYXZlcnNhbCBpbiAkZGlnZXN0XHJcbiAgICAgICAgICBpZiAoIShuZXh0ID0gKGN1cnJlbnQuJCRjaGlsZEhlYWQgfHwgKGN1cnJlbnQgIT09IHRhcmdldCAmJiBjdXJyZW50LiQkbmV4dFNpYmxpbmcpKSkpIHtcclxuICAgICAgICAgICAgd2hpbGUoY3VycmVudCAhPT0gdGFyZ2V0ICYmICEobmV4dCA9IGN1cnJlbnQuJCRuZXh0U2libGluZykpIHtcclxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoKGN1cnJlbnQgPSBuZXh0KSk7XHJcblxyXG4gICAgICAgIHJldHVybiBldmVudDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgJHJvb3RTY29wZSA9IG5ldyBTY29wZSgpO1xyXG5cclxuICAgIHJldHVybiAkcm9vdFNjb3BlO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBiZWdpblBoYXNlKHBoYXNlKSB7XHJcbiAgICAgIGlmICgkcm9vdFNjb3BlLiQkcGhhc2UpIHtcclxuICAgICAgICB0aHJvdyAkcm9vdFNjb3BlTWluRXJyKCdpbnByb2cnLCAnezB9IGFscmVhZHkgaW4gcHJvZ3Jlc3MnLCAkcm9vdFNjb3BlLiQkcGhhc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkcm9vdFNjb3BlLiQkcGhhc2UgPSBwaGFzZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbGVhclBoYXNlKCkge1xyXG4gICAgICAkcm9vdFNjb3BlLiQkcGhhc2UgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBpbGVUb0ZuKGV4cCwgbmFtZSkge1xyXG4gICAgICB2YXIgZm4gPSAkcGFyc2UoZXhwKTtcclxuICAgICAgYXNzZXJ0QXJnRm4oZm4sIG5hbWUpO1xyXG4gICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBmdW5jdGlvbiB1c2VkIGFzIGFuIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzLlxyXG4gICAgICogYmVjYXVzZSBpdCdzIHVuaXF1ZSB3ZSBjYW4gZWFzaWx5IHRlbGwgaXQgYXBhcnQgZnJvbSBvdGhlciB2YWx1ZXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5pdFdhdGNoVmFsKCkge31cclxuICB9XTtcclxufVxyXG5cclxudmFyICRzY2VNaW5FcnIgPSBtaW5FcnIoJyRzY2UnKTtcclxuXHJcbnZhciBTQ0VfQ09OVEVYVFMgPSB7XHJcbiAgSFRNTDogJ2h0bWwnLFxyXG4gIENTUzogJ2NzcycsXHJcbiAgVVJMOiAndXJsJyxcclxuICAvLyBSRVNPVVJDRV9VUkwgaXMgYSBzdWJ0eXBlIG9mIFVSTCB1c2VkIGluIGNvbnRleHRzIHdoZXJlIGEgcHJpdmlsZWdlZCByZXNvdXJjZSBpcyBzb3VyY2VkIGZyb20gYVxyXG4gIC8vIHVybC4gIChlLmcuIG5nLWluY2x1ZGUsIHNjcmlwdCBzcmMsIHRlbXBsYXRlVXJsKVxyXG4gIFJFU09VUkNFX1VSTDogJ3Jlc291cmNlVXJsJyxcclxuICBKUzogJ2pzJ1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgc2VydmljZVxyXG4gKiBAbmFtZSBuZy4kc2NlRGVsZWdhdGVcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBgJHNjZURlbGVnYXRlYCBpcyBhIHNlcnZpY2UgdGhhdCBpcyB1c2VkIGJ5IHRoZSBgJHNjZWAgc2VydmljZSB0byBwcm92aWRlIHtAbGluayBuZy4kc2NlIFN0cmljdFxyXG4gKiBDb250ZXh0dWFsIEVzY2FwaW5nIChTQ0UpfSBzZXJ2aWNlcyB0byBBbmd1bGFySlMuXHJcbiAqXHJcbiAqIFR5cGljYWxseSwgeW91IHdvdWxkIGNvbmZpZ3VyZSBvciBvdmVycmlkZSB0aGUge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSAkc2NlRGVsZWdhdGV9IGluc3RlYWQgb2ZcclxuICogdGhlIGAkc2NlYCBzZXJ2aWNlIHRvIGN1c3RvbWl6ZSB0aGUgd2F5IFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIHdvcmtzIGluIEFuZ3VsYXJKUy4gIFRoaXMgaXNcclxuICogYmVjYXVzZSwgd2hpbGUgdGhlIGAkc2NlYCBwcm92aWRlcyBudW1lcm91cyBzaG9ydGhhbmQgbWV0aG9kcywgZXRjLiwgeW91IHJlYWxseSBvbmx5IG5lZWQgdG9cclxuICogb3ZlcnJpZGUgMyBjb3JlIGZ1bmN0aW9ucyAoYHRydXN0QXNgLCBgZ2V0VHJ1c3RlZGAgYW5kIGB2YWx1ZU9mYCkgdG8gcmVwbGFjZSB0aGUgd2F5IHRoaW5nc1xyXG4gKiB3b3JrIGJlY2F1c2UgYCRzY2VgIGRlbGVnYXRlcyB0byBgJHNjZURlbGVnYXRlYCBmb3IgdGhlc2Ugb3BlcmF0aW9ucy5cclxuICpcclxuICogUmVmZXIge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyICRzY2VEZWxlZ2F0ZVByb3ZpZGVyfSB0byBjb25maWd1cmUgdGhpcyBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBUaGUgZGVmYXVsdCBpbnN0YW5jZSBvZiBgJHNjZURlbGVnYXRlYCBzaG91bGQgd29yayBvdXQgb2YgdGhlIGJveCB3aXRoIGxpdHRsZSBwYWluLiAgV2hpbGUgeW91XHJcbiAqIGNhbiBvdmVycmlkZSBpdCBjb21wbGV0ZWx5IHRvIGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgYCRzY2VgLCB0aGUgY29tbW9uIGNhc2Ugd291bGRcclxuICogaW52b2x2ZSBjb25maWd1cmluZyB0aGUge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyICRzY2VEZWxlZ2F0ZVByb3ZpZGVyfSBpbnN0ZWFkIGJ5IHNldHRpbmdcclxuICogeW91ciBvd24gd2hpdGVsaXN0cyBhbmQgYmxhY2tsaXN0cyBmb3IgdHJ1c3RpbmcgVVJMcyB1c2VkIGZvciBsb2FkaW5nIEFuZ3VsYXJKUyByZXNvdXJjZXMgc3VjaCBhc1xyXG4gKiB0ZW1wbGF0ZXMuICBSZWZlciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxXaGl0ZWxpc3RcclxuICogJHNjZURlbGVnYXRlUHJvdmlkZXIucmVzb3VyY2VVcmxXaGl0ZWxpc3R9IGFuZCB7QGxpbmtcclxuICogbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxCbGFja2xpc3QgJHNjZURlbGVnYXRlUHJvdmlkZXIucmVzb3VyY2VVcmxCbGFja2xpc3R9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRoZSAkc2NlRGVsZWdhdGVQcm92aWRlciBwcm92aWRlciBhbGxvd3MgZGV2ZWxvcGVycyB0byBjb25maWd1cmUgdGhlIHtAbGluayBuZy4kc2NlRGVsZWdhdGVcclxuICogJHNjZURlbGVnYXRlfSBzZXJ2aWNlLiAgVGhpcyBhbGxvd3Mgb25lIHRvIGdldC9zZXQgdGhlIHdoaXRlbGlzdHMgYW5kIGJsYWNrbGlzdHMgdXNlZCB0byBlbnN1cmVcclxuICogdGhhdCBVUkxzIHVzZWQgZm9yIHNvdXJjaW5nIEFuZ3VsYXIgdGVtcGxhdGVzIGFyZSBzYWZlLiAgUmVmZXIge0BsaW5rXHJcbiAqIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsV2hpdGVsaXN0ICRzY2VEZWxlZ2F0ZVByb3ZpZGVyLnJlc291cmNlVXJsV2hpdGVsaXN0fSBhbmRcclxuICoge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsQmxhY2tsaXN0ICRzY2VEZWxlZ2F0ZVByb3ZpZGVyLnJlc291cmNlVXJsQmxhY2tsaXN0fVxyXG4gKlxyXG4gKiBSZWFkIG1vcmUgYWJvdXQge0BsaW5rIG5nLiRzY2UgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSl9LlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uICRTY2VEZWxlZ2F0ZVByb3ZpZGVyKCkge1xyXG4gIHRoaXMuU0NFX0NPTlRFWFRTID0gU0NFX0NPTlRFWFRTO1xyXG5cclxuICAvLyBSZXNvdXJjZSBVUkxzIGNhbiBhbHNvIGJlIHRydXN0ZWQgYnkgcG9saWN5LlxyXG4gIHZhciByZXNvdXJjZVVybFdoaXRlbGlzdCA9IFsnc2VsZiddLFxyXG4gICAgICByZXNvdXJjZVVybEJsYWNrbGlzdCA9IFtdO1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5zY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsV2hpdGVsaXN0XHJcbiAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5PX0gd2hpdGVsaXN0IFdoZW4gcHJvdmlkZWQsIHJlcGxhY2VzIHRoZSByZXNvdXJjZVVybFdoaXRlbGlzdCB3aXRoIHRoZSB2YWx1ZVxyXG4gICAqICAgICBwcm92aWRlZC4gIFRoaXMgbXVzdCBiZSBhbiBhcnJheS5cclxuICAgKlxyXG4gICAqICAgICBFYWNoIGVsZW1lbnQgb2YgdGhpcyBhcnJheSBtdXN0IGVpdGhlciBiZSBhIHJlZ2V4IG9yIHRoZSBzcGVjaWFsIHN0cmluZyBgJ3NlbGYnYC5cclxuICAgKlxyXG4gICAqICAgICBXaGVuIGEgcmVnZXggaXMgdXNlZCwgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBub3JtYWxpemVkIC8gYWJzb2x1dGUgVVJMIG9mIHRoZSByZXNvdXJjZVxyXG4gICAqICAgICBiZWluZyB0ZXN0ZWQuXHJcbiAgICpcclxuICAgKiAgICAgVGhlICoqc3BlY2lhbCBzdHJpbmcqKiBgJ3NlbGYnYCBjYW4gYmUgdXNlZCB0byBtYXRjaCBhZ2FpbnN0IGFsbCBVUkxzIG9mIHRoZSBzYW1lIGRvbWFpbiBhcyB0aGVcclxuICAgKiAgICAgYXBwbGljYXRpb24gZG9jdW1lbnQgd2l0aCB0aGUgc2FtZSBwcm90b2NvbCAoYWxsb3dzIHNvdXJjaW5nIGh0dHBzIHJlc291cmNlcyBmcm9tIGh0dHAgZG9jdW1lbnRzLilcclxuICAgKlxyXG4gICAqICAgICBQbGVhc2Ugbm90ZSB0aGF0ICoqYW4gZW1wdHkgd2hpdGVsaXN0IGFycmF5IHdpbGwgYmxvY2sgYWxsIFVSTHMqKiFcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgY3VycmVudGx5IHNldCB3aGl0ZWxpc3QgYXJyYXkuXHJcbiAgICpcclxuICAgKiBUaGUgKipkZWZhdWx0IHZhbHVlKiogd2hlbiBubyB3aGl0ZWxpc3QgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQgaXMgYFsnc2VsZiddYC5cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFNldHMvR2V0cyB0aGUgd2hpdGVsaXN0IG9mIHRydXN0ZWQgcmVzb3VyY2UgVVJMcy5cclxuICAgKi9cclxuICB0aGlzLnJlc291cmNlVXJsV2hpdGVsaXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXNvdXJjZVVybFdoaXRlbGlzdCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc291cmNlVXJsV2hpdGVsaXN0O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLnNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxCbGFja2xpc3RcclxuICAgKiBAbWV0aG9kT2YgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXJcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXk9fSBibGFja2xpc3QgV2hlbiBwcm92aWRlZCwgcmVwbGFjZXMgdGhlIHJlc291cmNlVXJsQmxhY2tsaXN0IHdpdGggdGhlIHZhbHVlXHJcbiAgICogICAgIHByb3ZpZGVkLiAgVGhpcyBtdXN0IGJlIGFuIGFycmF5LlxyXG4gICAqXHJcbiAgICogICAgIEVhY2ggZWxlbWVudCBvZiB0aGlzIGFycmF5IG11c3QgZWl0aGVyIGJlIGEgcmVnZXggb3IgdGhlIHNwZWNpYWwgc3RyaW5nIGAnc2VsZidgIChzZWVcclxuICAgKiAgICAgYHJlc291cmNlVXJsV2hpdGVsaXN0YCBmb3IgbWVhbmluZyAtIGl0J3Mgb25seSByZWFsbHkgdXNlZnVsIHRoZXJlLilcclxuICAgKlxyXG4gICAqICAgICBXaGVuIGEgcmVnZXggaXMgdXNlZCwgaXQgaXMgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBub3JtYWxpemVkIC8gYWJzb2x1dGUgVVJMIG9mIHRoZSByZXNvdXJjZVxyXG4gICAqICAgICBiZWluZyB0ZXN0ZWQuXHJcbiAgICpcclxuICAgKiAgICAgVGhlIHR5cGljYWwgdXNhZ2UgZm9yIHRoZSBibGFja2xpc3QgaXMgdG8gKipibG9jayBbb3BlbiByZWRpcmVjdHNdKGh0dHA6Ly9jd2UubWl0cmUub3JnL2RhdGEvZGVmaW5pdGlvbnMvNjAxLmh0bWwpKipcclxuICAgKiAgICAgc2VydmVkIGJ5IHlvdXIgZG9tYWluIGFzIHRoZXNlIHdvdWxkIG90aGVyd2lzZSBiZSB0cnVzdGVkIGJ1dCBhY3R1YWxseSByZXR1cm4gY29udGVudCBmcm9tIHRoZSByZWRpcmVjdGVkXHJcbiAgICogICAgIGRvbWFpbi5cclxuICAgKlxyXG4gICAqICAgICBGaW5hbGx5LCAqKnRoZSBibGFja2xpc3Qgb3ZlcnJpZGVzIHRoZSB3aGl0ZWxpc3QqKiBhbmQgaGFzIHRoZSBmaW5hbCBzYXkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIGN1cnJlbnRseSBzZXQgYmxhY2tsaXN0IGFycmF5LlxyXG4gICAqXHJcbiAgICogVGhlICoqZGVmYXVsdCB2YWx1ZSoqIHdoZW4gbm8gd2hpdGVsaXN0IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0IGlzIHRoZSBlbXB0eSBhcnJheSAoaS5lLiB0aGVyZSBpc1xyXG4gICAqIG5vIGJsYWNrbGlzdC4pXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBTZXRzL0dldHMgdGhlIGJsYWNrbGlzdCBvZiB0cnVzdGVkIHJlc291cmNlIFVSTHMuXHJcbiAgICovXHJcblxyXG4gIHRoaXMucmVzb3VyY2VVcmxCbGFja2xpc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc291cmNlVXJsQmxhY2tsaXN0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzb3VyY2VVcmxCbGFja2xpc3Q7XHJcbiAgfTtcclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWF0Y2hpbmcgcmVzb3VyY2UgdXJscyBieSBwb2xpY3kuXHJcbiAgZnVuY3Rpb24gaXNDb21wYXRpYmxlUHJvdG9jb2woZG9jdW1lbnRQcm90b2NvbCwgcmVzb3VyY2VQcm90b2NvbCkge1xyXG4gICAgcmV0dXJuICgoZG9jdW1lbnRQcm90b2NvbCA9PT0gcmVzb3VyY2VQcm90b2NvbCkgfHxcclxuICAgICAgICAgICAgKGRvY3VtZW50UHJvdG9jb2wgPT09IFwiaHR0cDpcIiAmJiByZXNvdXJjZVByb3RvY29sID09PSBcImh0dHBzOlwiKSk7XHJcbiAgfVxyXG5cclxuICB0aGlzLiRnZXQgPSBbJyRsb2cnLCAnJGRvY3VtZW50JywgJyRpbmplY3RvcicsICckJHVybFV0aWxzJywgZnVuY3Rpb24oXHJcbiAgICAgICAgICAgICAgICAkbG9nLCAgICRkb2N1bWVudCwgICAkaW5qZWN0b3IsICAgJCR1cmxVdGlscykge1xyXG5cclxuICAgIHZhciBodG1sU2FuaXRpemVyID0gZnVuY3Rpb24gaHRtbFNhbml0aXplcihodG1sKSB7XHJcbiAgICAgIHRocm93ICRzY2VNaW5FcnIoJ3Vuc2FmZScsICdBdHRlbXB0aW5nIHRvIHVzZSBhbiB1bnNhZmUgdmFsdWUgaW4gYSBzYWZlIGNvbnRleHQuJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICgkaW5qZWN0b3IuaGFzKCckc2FuaXRpemUnKSkge1xyXG4gICAgICBodG1sU2FuaXRpemVyID0gJGluamVjdG9yLmdldCgnJHNhbml0aXplJyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIG1hdGNoVXJsKG1hdGNoZXIsIHBhcnNlZFVybCkge1xyXG4gICAgICBpZiAobWF0Y2hlciA9PT0gJ3NlbGYnKSB7XHJcbiAgICAgICAgcmV0dXJuICQkdXJsVXRpbHMuaXNTYW1lT3JpZ2luKHBhcnNlZFVybCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICEhcGFyc2VkVXJsLmhyZWYubWF0Y2gobWF0Y2hlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1Jlc291cmNlVXJsQWxsb3dlZEJ5UG9saWN5KHVybCkge1xyXG4gICAgICB2YXIgcGFyc2VkVXJsID0gJCR1cmxVdGlscy5yZXNvbHZlKHVybC50b1N0cmluZygpLCB0cnVlKTtcclxuICAgICAgdmFyIGksIG4sIGFsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgLy8gRW5zdXJlIHRoYXQgYXQgbGVhc3Qgb25lIGl0ZW0gZnJvbSB0aGUgd2hpdGVsaXN0IGFsbG93cyB0aGlzIHVybC5cclxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlc291cmNlVXJsV2hpdGVsaXN0Lmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIGlmIChtYXRjaFVybChyZXNvdXJjZVVybFdoaXRlbGlzdFtpXSwgcGFyc2VkVXJsKSkge1xyXG4gICAgICAgICAgYWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFsbG93ZWQpIHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBubyBpdGVtIGZyb20gdGhlIGJsYWNrbGlzdCBibG9ja2VkIHRoaXMgdXJsLlxyXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSByZXNvdXJjZVVybEJsYWNrbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChtYXRjaFVybChyZXNvdXJjZVVybEJsYWNrbGlzdFtpXSwgcGFyc2VkVXJsKSkge1xyXG4gICAgICAgICAgICBhbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYWxsb3dlZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUhvbGRlclR5cGUoYmFzZSkge1xyXG4gICAgICB2YXIgaG9sZGVyVHlwZSA9IGZ1bmN0aW9uIFRydXN0ZWRWYWx1ZUhvbGRlclR5cGUodHJ1c3RlZFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy4kJHVud3JhcFRydXN0ZWRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydXN0ZWRWYWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoYmFzZSkge1xyXG4gICAgICAgIGhvbGRlclR5cGUucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBob2xkZXJUeXBlLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gc2NlVmFsdWVPZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kJHVud3JhcFRydXN0ZWRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGhvbGRlclR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gc2NlVG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJCR1bndyYXBUcnVzdGVkVmFsdWUoKS50b1N0cmluZygpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBob2xkZXJUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cnVzdGVkVmFsdWVIb2xkZXJCYXNlID0gZ2VuZXJhdGVIb2xkZXJUeXBlKCksXHJcbiAgICAgICAgYnlUeXBlID0ge307XHJcblxyXG4gICAgYnlUeXBlW1NDRV9DT05URVhUUy5IVE1MXSA9IGdlbmVyYXRlSG9sZGVyVHlwZSh0cnVzdGVkVmFsdWVIb2xkZXJCYXNlKTtcclxuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuQ1NTXSA9IGdlbmVyYXRlSG9sZGVyVHlwZSh0cnVzdGVkVmFsdWVIb2xkZXJCYXNlKTtcclxuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuVVJMXSA9IGdlbmVyYXRlSG9sZGVyVHlwZSh0cnVzdGVkVmFsdWVIb2xkZXJCYXNlKTtcclxuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuSlNdID0gZ2VuZXJhdGVIb2xkZXJUeXBlKHRydXN0ZWRWYWx1ZUhvbGRlckJhc2UpO1xyXG4gICAgYnlUeXBlW1NDRV9DT05URVhUUy5SRVNPVVJDRV9VUkxdID0gZ2VuZXJhdGVIb2xkZXJUeXBlKGJ5VHlwZVtTQ0VfQ09OVEVYVFMuVVJMXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBc1xyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpcyB0cnVzdGVkIGJ5IGFuZ3VsYXIgZm9yIHVzZSBpbiBzcGVjaWZpZWQgc3RyaWN0XHJcbiAgICAgKiBjb250ZXh0dWFsIGVzY2FwaW5nIGNvbnRleHRzIChzdWNoIGFzIG5nLWh0bWwtYmluZC11bnNhZmUsIG5nLWluY2x1ZGUsIGFueSBzcmNcclxuICAgICAqIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uLCBhbnkgZG9tIGV2ZW50IGJpbmRpbmcgYXR0cmlidXRlIGludGVycG9sYXRpb25cclxuICAgICAqIHN1Y2ggYXMgZm9yIG9uY2xpY2ssICBldGMuKSB0aGF0IHVzZXMgdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICogU2VlIHtAbGluayBuZy4kc2NlICRzY2V9IGZvciBlbmFibGluZyBzdHJpY3QgY29udGV4dHVhbCBlc2NhcGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUga2luZCBvZiBjb250ZXh0IGluIHdoaWNoIHRoaXMgdmFsdWUgaXMgc2FmZSBmb3IgdXNlLiAgZS5nLiB1cmwsXHJcbiAgICAgKiAgIHJlc291cmNlVXJsLCBodG1sLCBqcyBhbmQgY3NzLlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHRydXN0ZWQvc2FmZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBBIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RhbmQgaW4gZm9yIHRoZSBwcm92aWRlZCBgdmFsdWVgIGluIHBsYWNlc1xyXG4gICAgICogd2hlcmUgQW5ndWxhciBleHBlY3RzIGEgJHNjZS50cnVzdEFzKCkgcmV0dXJuIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cnVzdEFzKHR5cGUsIHRydXN0ZWRWYWx1ZSkge1xyXG4gICAgICB2YXIgY29uc3RydWN0b3IgPSAoYnlUeXBlLmhhc093blByb3BlcnR5KHR5cGUpID8gYnlUeXBlW3R5cGVdIDogbnVsbCk7XHJcbiAgICAgIGlmICghY29uc3RydWN0b3IpIHtcclxuICAgICAgICB0aHJvdyAkc2NlTWluRXJyKCdpY29udGV4dCcsICdBdHRlbXB0ZWQgdG8gdHJ1c3QgYSB2YWx1ZSBpbiBpbnZhbGlkIGNvbnRleHQuIENvbnRleHQ6IHswfTsgVmFsdWU6IHsxfScsXHJcbiAgICAgICAgICAgIHR5cGUsIHRydXN0ZWRWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRydXN0ZWRWYWx1ZSA9PT0gbnVsbCB8fCB0cnVzdGVkVmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0cnVzdGVkVmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydXN0ZWRWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBBbGwgdGhlIGN1cnJlbnQgY29udGV4dHMgaW4gU0NFX0NPTlRFWFRTIGhhcHBlbiB0byBiZSBzdHJpbmdzLiAgSW4gb3JkZXIgdG8gYXZvaWQgdHJ1c3RpbmdcclxuICAgICAgLy8gbXV0YWJsZSBvYmplY3RzLCB3ZSBlbnN1cmUgaGVyZSB0aGF0IHRoZSB2YWx1ZSBwYXNzZWQgaW4gaXMgYWN0dWFsbHkgYSBzdHJpbmcuXHJcbiAgICAgIGlmICh0eXBlb2YgdHJ1c3RlZFZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93ICRzY2VNaW5FcnIoJ2l0eXBlJyxcclxuICAgICAgICAgICAgJ0F0dGVtcHRlZCB0byB0cnVzdCBhIG5vbi1zdHJpbmcgdmFsdWUgaW4gYSBjb250ZW50IHJlcXVpcmluZyBhIHN0cmluZzogQ29udGV4dDogezB9JyxcclxuICAgICAgICAgICAgdHlwZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3Rvcih0cnVzdGVkVmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZURlbGVnYXRlI3ZhbHVlT2ZcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlRGVsZWdhdGVcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIElmIHRoZSBwYXNzZWQgcGFyYW1ldGVyIGhhZCBiZWVuIHJldHVybmVkIGJ5IGEgcHJpb3IgY2FsbCB0byB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXNcclxuICAgICAqIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9LCByZXR1cm5zIHRoZSB2YWx1ZSB0aGF0IGhhZCBiZWVuIHBhc3NlZCB0byB7QGxpbmtcclxuICAgICAqIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9LlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBwYXNzZWQgcGFyYW1ldGVyIGlzIG5vdCBhIHZhbHVlIHRoYXQgaGFkIGJlZW4gcmV0dXJuZWQgYnkge0BsaW5rXHJcbiAgICAgKiBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXNgfSwgcmV0dXJucyBpdCBhcy1pcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSByZXN1bHQgb2YgYSBwcmlvciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH1cclxuICAgICAqICAgICAgY2FsbCBvciBhbnl0aGluZyBlbHNlLlxyXG4gICAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGUgd2FzIG9yaWdpbmFsbHkgcHJvdmlkZWQgdG8ge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzXHJcbiAgICAgKiAgICAgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0gaWYgYHZhbHVlYCBpcyB0aGUgcmVzdWx0IG9mIHN1Y2ggYSBjYWxsLiAgT3RoZXJ3aXNlLCByZXR1cm5zIGB2YWx1ZWBcclxuICAgICAqICAgICB1bmNoYW5nZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2YobWF5YmVUcnVzdGVkKSB7XHJcbiAgICAgIGlmIChtYXliZVRydXN0ZWQgaW5zdGFuY2VvZiB0cnVzdGVkVmFsdWVIb2xkZXJCYXNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1heWJlVHJ1c3RlZC4kJHVud3JhcFRydXN0ZWRWYWx1ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXliZVRydXN0ZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2VEZWxlZ2F0ZSNnZXRUcnVzdGVkXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZURlbGVnYXRlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBUYWtlcyB0aGUgcmVzdWx0IG9mIGEge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9IGNhbGwgYW5kIHJldHVybnMgdGhlXHJcbiAgICAgKiBvcmlnaW5hbGx5IHN1cHBsaWVkIHZhbHVlIGlmIHRoZSBxdWVyaWVkIGNvbnRleHQgdHlwZSBpcyBhIHN1cGVydHlwZSBvZiB0aGUgY3JlYXRlZCB0eXBlLiAgSWZcclxuICAgICAqIHRoaXMgY29uZGl0aW9uIGlzbid0IHNhdGlzZmllZCwgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUga2luZCBvZiBjb250ZXh0IGluIHdoaWNoIHRoaXMgdmFsdWUgaXMgdG8gYmUgdXNlZC5cclxuICAgICAqIEBwYXJhbSB7Kn0gbWF5YmVUcnVzdGVkIFRoZSByZXN1bHQgb2YgYSBwcmlvciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXNcclxuICAgICAqIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9IGNhbGwuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoZSB3YXMgb3JpZ2luYWxseSBwcm92aWRlZCB0byB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXNcclxuICAgICAqICAgICBgJHNjZURlbGVnYXRlLnRydXN0QXNgfSBpZiB2YWxpZCBpbiB0aGlzIGNvbnRleHQuICBPdGhlcndpc2UsIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFRydXN0ZWQodHlwZSwgbWF5YmVUcnVzdGVkKSB7XHJcbiAgICAgIGlmIChtYXliZVRydXN0ZWQgPT09IG51bGwgfHwgbWF5YmVUcnVzdGVkID09PSB1bmRlZmluZWQgfHwgbWF5YmVUcnVzdGVkID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiBtYXliZVRydXN0ZWQ7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gKGJ5VHlwZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IGJ5VHlwZVt0eXBlXSA6IG51bGwpO1xyXG4gICAgICBpZiAoY29uc3RydWN0b3IgJiYgbWF5YmVUcnVzdGVkIGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gbWF5YmVUcnVzdGVkLiQkdW53cmFwVHJ1c3RlZFZhbHVlKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRoZW4gd2UgbWF5IG9ubHkgdGFrZSBvbmUgb2YgdHdvIGFjdGlvbnMuXHJcbiAgICAgIC8vIDEuIHNhbml0aXplIHRoZSB2YWx1ZSBmb3IgdGhlIHJlcXVlc3RlZCB0eXBlLCBvclxyXG4gICAgICAvLyAyLiB0aHJvdyBhbiBleGNlcHRpb24uXHJcbiAgICAgIGlmICh0eXBlID09PSBTQ0VfQ09OVEVYVFMuUkVTT1VSQ0VfVVJMKSB7XHJcbiAgICAgICAgaWYgKGlzUmVzb3VyY2VVcmxBbGxvd2VkQnlQb2xpY3kobWF5YmVUcnVzdGVkKSkge1xyXG4gICAgICAgICAgcmV0dXJuIG1heWJlVHJ1c3RlZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgJHNjZU1pbkVycignaW5zZWN1cmwnLFxyXG4gICAgICAgICAgICAgICdCbG9ja2VkIGxvYWRpbmcgcmVzb3VyY2UgZnJvbSB1cmwgbm90IGFsbG93ZWQgYnkgJHNjZURlbGVnYXRlIHBvbGljeS4gIFVSTDogezB9JywgbWF5YmVUcnVzdGVkLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBTQ0VfQ09OVEVYVFMuSFRNTCkge1xyXG4gICAgICAgIHJldHVybiBodG1sU2FuaXRpemVyKG1heWJlVHJ1c3RlZCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgJHNjZU1pbkVycigndW5zYWZlJywgJ0F0dGVtcHRpbmcgdG8gdXNlIGFuIHVuc2FmZSB2YWx1ZSBpbiBhIHNhZmUgY29udGV4dC4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyB0cnVzdEFzOiB0cnVzdEFzLFxyXG4gICAgICAgICAgICAgZ2V0VHJ1c3RlZDogZ2V0VHJ1c3RlZCxcclxuICAgICAgICAgICAgIHZhbHVlT2Y6IHZhbHVlT2YgfTtcclxuICB9XTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRzY2VQcm92aWRlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogVGhlICRzY2VQcm92aWRlciBwcm92aWRlciBhbGxvd3MgZGV2ZWxvcGVycyB0byBjb25maWd1cmUgdGhlIHtAbGluayBuZy4kc2NlICRzY2V9IHNlcnZpY2UuXHJcbiAqIC0gICBlbmFibGUvZGlzYWJsZSBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyAoU0NFKSBpbiBhIG1vZHVsZVxyXG4gKiAtICAgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2l0aCBhIGN1c3RvbSBkZWxlZ2F0ZVxyXG4gKlxyXG4gKiBSZWFkIG1vcmUgYWJvdXQge0BsaW5rIG5nLiRzY2UgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSl9LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgc2VydmljZVxyXG4gKiBAbmFtZSBuZy4kc2NlXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogYCRzY2VgIGlzIGEgc2VydmljZSB0aGF0IHByb3ZpZGVzIFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIHNlcnZpY2VzIHRvIEFuZ3VsYXJKUy5cclxuICpcclxuICogIyBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZ1xyXG4gKlxyXG4gKiBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyAoU0NFKSBpcyBhIG1vZGUgaW4gd2hpY2ggQW5ndWxhckpTIHJlcXVpcmVzIGJpbmRpbmdzIGluIGNlcnRhaW5cclxuICogY29udGV4dHMgdG8gcmVzdWx0IGluIGEgdmFsdWUgdGhhdCBpcyBtYXJrZWQgYXMgc2FmZSB0byB1c2UgZm9yIHRoYXQgY29udGV4dCBPbmUgZXhhbXBsZSBvZiBzdWNoXHJcbiAqIGEgY29udGV4dCBpcyBiaW5kaW5nIGFyYml0cmFyeSBodG1sIGNvbnRyb2xsZWQgYnkgdGhlIHVzZXIgdmlhIGBuZy1iaW5kLWh0bWxgLiAgV2UgcmVmZXIgdG8gdGhlc2VcclxuICogY29udGV4dHMgYXMgcHJpdmlsZWdlZCBvciBTQ0UgY29udGV4dHMuXHJcbiAqXHJcbiAqIEFzIG9mIHZlcnNpb24gMS4yLCBBbmd1bGFyIHNoaXBzIHdpdGggU0NFIGVuYWJsZWQgYnkgZGVmYXVsdC5cclxuICpcclxuICogTm90ZTogIFdoZW4gZW5hYmxlZCAodGhlIGRlZmF1bHQpLCBJRTggaW4gcXVpcmtzIG1vZGUgaXMgbm90IHN1cHBvcnRlZC4gIEluIHRoaXMgbW9kZSwgSUU4IGFsbG93c1xyXG4gKiBvbmUgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgamF2YXNjcmlwdCBieSB0aGUgdXNlIG9mIHRoZSBleHByZXNzaW9uKCkgc3ludGF4LiAgUmVmZXJcclxuICogPGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAwOC8xMC8xNi9lbmRpbmctZXhwcmVzc2lvbnMuYXNweD4gdG8gbGVhcm4gbW9yZSBhYm91dCB0aGVtLlxyXG4gKiBZb3UgY2FuIGVuc3VyZSB5b3VyIGRvY3VtZW50IGlzIGluIHN0YW5kYXJkcyBtb2RlIGFuZCBub3QgcXVpcmtzIG1vZGUgYnkgYWRkaW5nIGA8IWRvY3R5cGUgaHRtbD5gXHJcbiAqIHRvIHRoZSB0b3Agb2YgeW91ciBIVE1MIGRvY3VtZW50LlxyXG4gKlxyXG4gKiBTQ0UgYXNzaXN0cyBpbiB3cml0aW5nIGNvZGUgaW4gd2F5IHRoYXQgKGEpIGlzIHNlY3VyZSBieSBkZWZhdWx0IGFuZCAoYikgbWFrZXMgYXVkaXRpbmcgZm9yXHJcbiAqIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcyBzdWNoIGFzIFhTUywgY2xpY2tqYWNraW5nLCBldGMuIGEgbG90IGVhc2llci5cclxuICpcclxuICogSGVyZSdzIGFuIGV4YW1wbGUgb2YgYSBiaW5kaW5nIGluIGEgcHJpdmlsZWdlZCBjb250ZXh0OlxyXG4gKlxyXG4gKiA8cHJlIGNsYXNzPVwicHJldHR5cHJpbnRcIj5cclxuICogICAgIDxpbnB1dCBuZy1tb2RlbD1cInVzZXJIdG1sXCI+XHJcbiAqICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInt7dXNlckh0bWx9fVwiPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogTm90aWNlIHRoYXQgYG5nLWJpbmQtaHRtbGAgaXMgYm91bmQgdG8gYHt7dXNlckh0bWx9fWAgY29udHJvbGxlZCBieSB0aGUgdXNlci4gIFdpdGggU0NFXHJcbiAqIGRpc2FibGVkLCB0aGlzIGFwcGxpY2F0aW9uIGFsbG93cyB0aGUgdXNlciB0byByZW5kZXIgYXJiaXRyYXJ5IEhUTUwgaW50byB0aGUgRElWLlxyXG4gKiBJbiBhIG1vcmUgcmVhbGlzdGljIGV4YW1wbGUsIG9uZSBtYXkgYmUgcmVuZGVyaW5nIHVzZXIgY29tbWVudHMsIGJsb2cgYXJ0aWNsZXMsIGV0Yy4gdmlhXHJcbiAqIGJpbmRpbmdzLiAgKEhUTUwgaXMganVzdCBvbmUgZXhhbXBsZSBvZiBhIGNvbnRleHQgd2hlcmUgcmVuZGVyaW5nIHVzZXIgY29udHJvbGxlZCBpbnB1dCBjcmVhdGVzXHJcbiAqIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdGllcy4pXHJcbiAqXHJcbiAqIEZvciB0aGUgY2FzZSBvZiBIVE1MLCB5b3UgbWlnaHQgdXNlIGEgbGlicmFyeSwgZWl0aGVyIG9uIHRoZSBjbGllbnQgc2lkZSwgb3Igb24gdGhlIHNlcnZlciBzaWRlLFxyXG4gKiB0byBzYW5pdGl6ZSB1bnNhZmUgSFRNTCBiZWZvcmUgYmluZGluZyB0byB0aGUgdmFsdWUgYW5kIHJlbmRlcmluZyBpdCBpbiB0aGUgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIEhvdyB3b3VsZCB5b3UgZW5zdXJlIHRoYXQgZXZlcnkgcGxhY2UgdGhhdCB1c2VkIHRoZXNlIHR5cGVzIG9mIGJpbmRpbmdzIHdhcyBib3VuZCB0byBhIHZhbHVlIHRoYXRcclxuICogd2FzIHNhbml0aXplZCBieSB5b3VyIGxpYnJhcnkgKG9yIHJldHVybmVkIGFzIHNhZmUgZm9yIHJlbmRlcmluZyBieSB5b3VyIHNlcnZlcj8pICBIb3cgY2FuIHlvdVxyXG4gKiBlbnN1cmUgdGhhdCB5b3UgZGlkbid0IGFjY2lkZW50YWxseSBkZWxldGUgdGhlIGxpbmUgdGhhdCBzYW5pdGl6ZWQgdGhlIHZhbHVlLCBvciByZW5hbWVkIHNvbWVcclxuICogcHJvcGVydGllcy9maWVsZHMgYW5kIGZvcmdvdCB0byB1cGRhdGUgdGhlIGJpbmRpbmcgdG8gdGhlIHNhbml0aXplZCB2YWx1ZT9cclxuICpcclxuICogVG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQsIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGFueSBzdWNoIGJpbmRpbmdzIGFyZSBkaXNhbGxvd2VkIHVubGVzcyB5b3UgY2FuXHJcbiAqIGRldGVybWluZSB0aGF0IHNvbWV0aGluZyBleHBsaWNpdGx5IHNheXMgaXQncyBzYWZlIHRvIHVzZSBhIHZhbHVlIGZvciBiaW5kaW5nIGluIHRoYXRcclxuICogY29udGV4dC4gIFlvdSBjYW4gdGhlbiBhdWRpdCB5b3VyIGNvZGUgKGEgc2ltcGxlIGdyZXAgd291bGQgZG8pIHRvIGVuc3VyZSB0aGF0IHRoaXMgaXMgb25seSBkb25lXHJcbiAqIGZvciB0aG9zZSB2YWx1ZXMgdGhhdCB5b3UgY2FuIGVhc2lseSB0ZWxsIGFyZSBzYWZlIC0gYmVjYXVzZSB0aGV5IHdlcmUgcmVjZWl2ZWQgZnJvbSB5b3VyIHNlcnZlcixcclxuICogc2FuaXRpemVkIGJ5IHlvdXIgbGlicmFyeSwgZXRjLiAgWW91IGNhbiBvcmdhbml6ZSB5b3VyIGNvZGViYXNlIHRvIGhlbHAgd2l0aCB0aGlzIC0gcGVyaGFwc1xyXG4gKiBhbGxvd2luZyBvbmx5IHRoZSBmaWxlcyBpbiBhIHNwZWNpZmljIGRpcmVjdG9yeSB0byBkbyB0aGlzLiAgRW5zdXJpbmcgdGhhdCB0aGUgaW50ZXJuYWwgQVBJXHJcbiAqIGV4cG9zZWQgYnkgdGhhdCBjb2RlIGRvZXNuJ3QgbWFya3VwIGFyYml0cmFyeSB2YWx1ZXMgYXMgc2FmZSB0aGVuIGJlY29tZXMgYSBtb3JlIG1hbmFnZWFibGUgdGFzay5cclxuICpcclxuICogSW4gdGhlIGNhc2Ugb2YgQW5ndWxhckpTJyBTQ0Ugc2VydmljZSwgb25lIHVzZXMge0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyAkc2NlLnRydXN0QXN9IChhbmQgc2hvcnRoYW5kXHJcbiAqIG1ldGhvZHMgc3VjaCBhcyB7QGxpbmsgbmcuJHNjZSN0cnVzdEFzSHRtbCAkc2NlLnRydXN0QXNIdG1sfSwgZXRjLikgdG8gb2J0YWluIHZhbHVlcyB0aGF0IHdpbGwgYmVcclxuICogYWNjZXB0ZWQgYnkgU0NFIC8gcHJpdmlsZWdlZCBjb250ZXh0cy5cclxuICpcclxuICpcclxuICogIyMgSG93IGRvZXMgaXQgd29yaz9cclxuICpcclxuICogSW4gcHJpdmlsZWdlZCBjb250ZXh0cywgZGlyZWN0aXZlcyBhbmQgY29kZSB3aWxsIGJpbmQgdG8gdGhlIHJlc3VsdCBvZiB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkXHJcbiAqICRzY2UuZ2V0VHJ1c3RlZChjb250ZXh0LCB2YWx1ZSl9IHJhdGhlciB0aGFuIHRvIHRoZSB2YWx1ZSBkaXJlY3RseS4gIERpcmVjdGl2ZXMgdXNlIHtAbGlua1xyXG4gKiBuZy4kc2NlI3BhcnNlICRzY2UucGFyc2VBc30gcmF0aGVyIHRoYW4gYCRwYXJzZWAgdG8gd2F0Y2ggYXR0cmlidXRlIGJpbmRpbmdzLCB3aGljaCBwZXJmb3JtcyB0aGVcclxuICoge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZCAkc2NlLmdldFRydXN0ZWR9IGJlaGluZCB0aGUgc2NlbmVzIG9uIG5vbi1jb25zdGFudCBsaXRlcmFscy5cclxuICpcclxuICogQXMgYW4gZXhhbXBsZSwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0JpbmRIdG1sIG5nQmluZEh0bWx9IHVzZXMge0BsaW5rXHJcbiAqIG5nLiRzY2UjcGFyc2VBc0h0bWwgJHNjZS5wYXJzZUFzSHRtbChiaW5kaW5nIGV4cHJlc3Npb24pfS4gIEhlcmUncyB0aGUgYWN0dWFsIGNvZGUgKHNsaWdodGx5XHJcbiAqIHNpbXBsaWZpZWQpOlxyXG4gKlxyXG4gKiA8cHJlIGNsYXNzPVwicHJldHR5cHJpbnRcIj5cclxuICogICB2YXIgbmdCaW5kSHRtbERpcmVjdGl2ZSA9IFsnJHNjZScsIGZ1bmN0aW9uKCRzY2UpIHtcclxuICogICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gKiAgICAgICBzY29wZS4kd2F0Y2goJHNjZS5wYXJzZUFzSHRtbChhdHRyLm5nQmluZEh0bWwpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gKiAgICAgICAgIGVsZW1lbnQuaHRtbCh2YWx1ZSB8fCAnJyk7XHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgfTtcclxuICogICB9XTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqICMjIEltcGFjdCBvbiBsb2FkaW5nIHRlbXBsYXRlc1xyXG4gKlxyXG4gKiBUaGlzIGFwcGxpZXMgYm90aCB0byB0aGUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGUgYG5nLWluY2x1ZGVgfSBkaXJlY3RpdmUgYXMgd2VsbCBhc1xyXG4gKiBgdGVtcGxhdGVVcmxgJ3Mgc3BlY2lmaWVkIGJ5IHtAbGluayBndWlkZS9kaXJlY3RpdmUgZGlyZWN0aXZlc30uXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIEFuZ3VsYXIgb25seSBsb2FkcyB0ZW1wbGF0ZXMgZnJvbSB0aGUgc2FtZSBkb21haW4gYW5kIHByb3RvY29sIGFzIHRoZSBhcHBsaWNhdGlvblxyXG4gKiBkb2N1bWVudC4gIFRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIHtAbGluayBuZy4kc2NlI2dldFRydXN0ZWRSZXNvdXJjZVVybFxyXG4gKiAkc2NlLmdldFRydXN0ZWRSZXNvdXJjZVVybH0gb24gdGhlIHRlbXBsYXRlIFVSTC4gIFRvIGxvYWQgdGVtcGxhdGVzIGZyb20gb3RoZXIgZG9tYWlucyBhbmQvb3JcclxuICogcHJvdG9jb2xzLCB5b3UgbWF5IGVpdGhlciBlaXRoZXIge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsV2hpdGVsaXN0IHdoaXRlbGlzdFxyXG4gKiB0aGVtfSBvciB7QGxpbmsgbmcuJHNjZSN0cnVzdEFzUmVzb3VyY2VVcmwgd3JhcCBpdH0gaW50byBhIHRydXN0ZWQgdmFsdWUuXHJcbiAqXHJcbiAqICpQbGVhc2Ugbm90ZSo6XHJcbiAqIFRoZSBicm93c2VyJ3NcclxuICoge0BsaW5rIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYnJvd3NlcnNlYy93aWtpL1BhcnQyI1NhbWUtb3JpZ2luX3BvbGljeV9mb3JfWE1MSHR0cFJlcXVlc3RcclxuICogU2FtZSBPcmlnaW4gUG9saWN5fSBhbmQge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL2NvcnMvIENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nIChDT1JTKX1cclxuICogcG9saWN5IGFwcGx5IGluIGFkZGl0aW9uIHRvIHRoaXMgYW5kIG1heSBmdXJ0aGVyIHJlc3RyaWN0IHdoZXRoZXIgdGhlIHRlbXBsYXRlIGlzIHN1Y2Nlc3NmdWxseVxyXG4gKiBsb2FkZWQuICBUaGlzIG1lYW5zIHRoYXQgd2l0aG91dCB0aGUgcmlnaHQgQ09SUyBwb2xpY3ksIGxvYWRpbmcgdGVtcGxhdGVzIGZyb20gYSBkaWZmZXJlbnQgZG9tYWluXHJcbiAqIHdvbid0IHdvcmsgb24gYWxsIGJyb3dzZXJzLiAgQWxzbywgbG9hZGluZyB0ZW1wbGF0ZXMgZnJvbSBgZmlsZTovL2AgVVJMIGRvZXMgbm90IHdvcmsgb24gc29tZVxyXG4gKiBicm93c2Vycy5cclxuICpcclxuICogIyMgVGhpcyBmZWVscyBsaWtlIHRvbyBtdWNoIG92ZXJoZWFkIGZvciB0aGUgZGV2ZWxvcGVyP1xyXG4gKlxyXG4gKiBJdCdzIGltcG9ydGFudCB0byByZW1lbWJlciB0aGF0IFNDRSBvbmx5IGFwcGxpZXMgdG8gaW50ZXJwb2xhdGlvbiBleHByZXNzaW9ucy5cclxuICpcclxuICogSWYgeW91ciBleHByZXNzaW9ucyBhcmUgY29uc3RhbnQgbGl0ZXJhbHMsIHRoZXkncmUgYXV0b21hdGljYWxseSB0cnVzdGVkIGFuZCB5b3UgZG9uJ3QgbmVlZCB0b1xyXG4gKiBjYWxsIGAkc2NlLnRydXN0QXNgIG9uIHRoZW0uICAoZS5nLlxyXG4gKiBgPGRpdiBuZy1odG1sLWJpbmQtdW5zYWZlPVwiJzxiPmltcGxpY2l0bHkgdHJ1c3RlZDwvYj4nXCI+PC9kaXY+YCkganVzdCB3b3Jrcy5cclxuICpcclxuICogQWRkaXRpb25hbGx5LCBgYVtocmVmXWAgYW5kIGBpbWdbc3JjXWAgYXV0b21hdGljYWxseSBzYW5pdGl6ZSB0aGVpciBVUkxzIGFuZCBkbyBub3QgcGFzcyB0aGVtXHJcbiAqIHRocm91Z2gge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZCAkc2NlLmdldFRydXN0ZWR9LiAgU0NFIGRvZXNuJ3QgcGxheSBhIHJvbGUgaGVyZS5cclxuICpcclxuICogVGhlIGluY2x1ZGVkIHtAbGluayBuZy4kc2NlRGVsZWdhdGUgJHNjZURlbGVnYXRlfSBjb21lcyB3aXRoIHNhbmUgZGVmYXVsdHMgdG8gYWxsb3cgeW91IHRvIGxvYWRcclxuICogdGVtcGxhdGVzIGluIGBuZy1pbmNsdWRlYCBmcm9tIHlvdXIgYXBwbGljYXRpb24ncyBkb21haW4gd2l0aG91dCBoYXZpbmcgdG8gZXZlbiBrbm93IGFib3V0IFNDRS5cclxuICogSXQgYmxvY2tzIGxvYWRpbmcgdGVtcGxhdGVzIGZyb20gb3RoZXIgZG9tYWlucyBvciBsb2FkaW5nIHRlbXBsYXRlcyBvdmVyIGh0dHAgZnJvbSBhbiBodHRwc1xyXG4gKiBzZXJ2ZWQgZG9jdW1lbnQuICBZb3UgY2FuIGNoYW5nZSB0aGVzZSBieSBzZXR0aW5nIHlvdXIgb3duIGN1c3RvbSB7QGxpbmtcclxuICogbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxXaGl0ZWxpc3Qgd2hpdGVsaXN0c30gYW5kIHtAbGlua1xyXG4gKiBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNyZXNvdXJjZVVybEJsYWNrbGlzdCBibGFja2xpc3RzfSBmb3IgbWF0Y2hpbmcgc3VjaCBVUkxzLlxyXG4gKlxyXG4gKiBUaGlzIHNpZ25pZmljYW50bHkgcmVkdWNlcyB0aGUgb3ZlcmhlYWQuICBJdCBpcyBmYXIgZWFzaWVyIHRvIHBheSB0aGUgc21hbGwgb3ZlcmhlYWQgYW5kIGhhdmUgYW5cclxuICogYXBwbGljYXRpb24gdGhhdCdzIHNlY3VyZSBhbmQgY2FuIGJlIGF1ZGl0ZWQgdG8gdmVyaWZ5IHRoYXQgd2l0aCBtdWNoIG1vcmUgZWFzZSB0aGFuIGJvbHRpbmdcclxuICogc2VjdXJpdHkgb250byBhbiBhcHBsaWNhdGlvbiBsYXRlci5cclxuICpcclxuICogIyMgV2hhdCB0cnVzdGVkIGNvbnRleHQgdHlwZXMgYXJlIHN1cHBvcnRlZD88YSBuYW1lPVwiY29udGV4dHNcIj48L2E+XHJcbiAqXHJcbiAqIHwgQ29udGV4dCAgICAgICAgICAgICB8IE5vdGVzICAgICAgICAgIHxcclxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tfFxyXG4gKiB8IGAkc2NlLkhUTUxgICAgICAgICAgfCBGb3IgSFRNTCB0aGF0J3Mgc2FmZSB0byBzb3VyY2UgaW50byB0aGUgYXBwbGljYXRpb24uICBUaGUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0JpbmRIdG1sIG5nQmluZEh0bWx9IGRpcmVjdGl2ZSB1c2VzIHRoaXMgY29udGV4dCBmb3IgYmluZGluZ3MuIHxcclxuICogfCBgJHNjZS5DU1NgICAgICAgICAgIHwgRm9yIENTUyB0aGF0J3Mgc2FmZSB0byBzb3VyY2UgaW50byB0aGUgYXBwbGljYXRpb24uICBDdXJyZW50bHkgdW51c2VkLiAgRmVlbCBmcmVlIHRvIHVzZSBpdCBpbiB5b3VyIG93biBkaXJlY3RpdmVzLiB8XHJcbiAqIHwgYCRzY2UuVVJMYCAgICAgICAgICB8IEZvciBVUkxzIHRoYXQgYXJlIHNhZmUgdG8gZm9sbG93IGFzIGxpbmtzLiAgQ3VycmVudGx5IHVudXNlZCAoYDxhIGhyZWY9YCBhbmQgYDxpbWcgc3JjPWAgc2FuaXRpemUgdGhlaXIgdXJscyBhbmQgZG9uJ3QgY29uc2l0aXR1dGUgYW4gU0NFIGNvbnRleHQuIHxcclxuICogfCBgJHNjZS5SRVNPVVJDRV9VUkxgIHwgRm9yIFVSTHMgdGhhdCBhcmUgbm90IG9ubHkgc2FmZSB0byBmb2xsb3cgYXMgbGlua3MsIGJ1dCB3aG9zZSBjb250ZW5zIGFyZSBhbHNvIHNhZmUgdG8gaW5jbHVkZSBpbiB5b3VyIGFwcGxpY2F0aW9uLiAgRXhhbXBsZXMgaW5jbHVkZSBgbmctaW5jbHVkZWAsIGBzcmNgIC8gYG5nU3JjYCBiaW5kaW5ncyBmb3IgdGFncyBvdGhlciB0aGFuIGBJTUdgIChlLmcuIGBJRlJBTUVgLCBgT0JKRUNUYCwgZXRjLikgIDxicj48YnI+Tm90ZSB0aGF0IGAkc2NlLlJFU09VUkNFX1VSTGAgbWFrZXMgYSBzdHJvbmdlciBzdGF0ZW1lbnQgYWJvdXQgdGhlIFVSTCB0aGFuIGAkc2NlLlVSTGAgZG9lcyBhbmQgdGhlcmVmb3JlIGNvbnRleHRzIHJlcXVpcmluZyB2YWx1ZXMgdHJ1c3RlZCBmb3IgYCRzY2UuUkVTT1VSQ0VfVVJMYCBjYW4gYmUgdXNlZCBhbnl3aGVyZSB0aGF0IHZhbHVlcyB0cnVzdGVkIGZvciBgJHNjZS5VUkxgIGFyZSByZXF1aXJlZC4gfFxyXG4gKiB8IGAkc2NlLkpTYCAgICAgICAgICAgfCBGb3IgSmF2YVNjcmlwdCB0aGF0IGlzIHNhZmUgdG8gZXhlY3V0ZSBpbiB5b3VyIGFwcGxpY2F0aW9uJ3MgY29udGV4dC4gIEN1cnJlbnRseSB1bnVzZWQuICBGZWVsIGZyZWUgdG8gdXNlIGl0IGluIHlvdXIgb3duIGRpcmVjdGl2ZXMuIHxcclxuICpcclxuICogIyMgU2hvdyBtZSBhbiBleGFtcGxlLlxyXG4gKlxyXG4gKlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gPGV4YW1wbGUgbW9kdWxlPVwibXlTY2VBcHBcIj5cclxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgPGRpdiBuZy1jb250cm9sbGVyPVwibXlBcHBDb250cm9sbGVyIGFzIG15Q3RybFwiPlxyXG4gICAgICA8aSBuZy1iaW5kLWh0bWw9XCJteUN0cmwuZXhwbGljaXRseVRydXN0ZWRIdG1sXCIgaWQ9XCJleHBsaWNpdGx5VHJ1c3RlZEh0bWxcIj48L2k+PGJyPjxicj5cclxuICAgICAgPGI+VXNlciBjb21tZW50czwvYj48YnI+XHJcbiAgICAgIEJ5IGRlZmF1bHQsIEhUTUwgdGhhdCBpc24ndCBleHBsaWNpdGx5IHRydXN0ZWQgKGUuZy4gQWxpY2UncyBjb21tZW50KSBpcyBzYW5pdGl6ZWQgd2hlbiAkc2FuaXRpemUgaXMgYXZhaWxhYmxlLiAgSWYgJHNhbml0aXplIGlzbid0IGF2YWlsYWJsZSwgdGhpcyByZXN1bHRzIGluIGFuIGVycm9yIGluc3RlYWQgb2YgYW4gZXhwbG9pdC5cclxuICAgICAgPGRpdiBjbGFzcz1cIndlbGxcIj5cclxuICAgICAgICA8ZGl2IG5nLXJlcGVhdD1cInVzZXJDb21tZW50IGluIG15Q3RybC51c2VyQ29tbWVudHNcIj5cclxuICAgICAgICAgIDxiPnt7dXNlckNvbW1lbnQubmFtZX19PC9iPjpcclxuICAgICAgICAgIDxzcGFuIG5nLWJpbmQtaHRtbD1cInVzZXJDb21tZW50Lmh0bWxDb21tZW50XCIgY2xhc3M9XCJodG1sQ29tbWVudFwiPjwvc3Bhbj5cclxuICAgICAgICAgIDxicj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2ZpbGU+XHJcblxyXG4gIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cclxuICAgIHZhciBteVNjZUFwcCA9IGFuZ3VsYXIubW9kdWxlKCdteVNjZUFwcCcsIFsnbmdTYW5pdGl6ZSddKTtcclxuXHJcbiAgICBteVNjZUFwcC5jb250cm9sbGVyKFwibXlBcHBDb250cm9sbGVyXCIsIGZ1bmN0aW9uIG15QXBwQ29udHJvbGxlcigkaHR0cCwgJHRlbXBsYXRlQ2FjaGUsICRzY2UpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAkaHR0cC5nZXQoXCJ0ZXN0X2RhdGEuanNvblwiLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkuc3VjY2VzcyhmdW5jdGlvbih1c2VyQ29tbWVudHMpIHtcclxuICAgICAgICBzZWxmLnVzZXJDb21tZW50cyA9IHVzZXJDb21tZW50cztcclxuICAgICAgfSk7XHJcbiAgICAgIHNlbGYuZXhwbGljaXRseVRydXN0ZWRIdG1sID0gJHNjZS50cnVzdEFzSHRtbChcclxuICAgICAgICAgICc8c3BhbiBvbm1vdXNlb3Zlcj1cInRoaXMudGV4dENvbnRlbnQ9JnF1b3Q7RXhwbGljaXRseSB0cnVzdGVkIEhUTUwgYnlwYXNzZXMgJyArXHJcbiAgICAgICAgICAnc2FuaXRpemF0aW9uLiZxdW90O1wiPkhvdmVyIG92ZXIgdGhpcyB0ZXh0Ljwvc3Bhbj4nKTtcclxuICAgIH0pO1xyXG4gIDwvZmlsZT5cclxuXHJcbiAgPGZpbGUgbmFtZT1cInRlc3RfZGF0YS5qc29uXCI+XHJcbiAgICBbXHJcbiAgICAgIHsgXCJuYW1lXCI6IFwiQWxpY2VcIixcclxuICAgICAgICBcImh0bWxDb21tZW50XCI6IFwiPHNwYW4gb25tb3VzZW92ZXI9J3RoaXMudGV4dENvbnRlbnQ9XFxcIlBXTjNEIVxcXCInPklzIDxpPmFueW9uZTwvaT4gcmVhZGluZyB0aGlzPzwvc3Bhbj5cIlxyXG4gICAgICB9LFxyXG4gICAgICB7IFwibmFtZVwiOiBcIkJvYlwiLFxyXG4gICAgICAgIFwiaHRtbENvbW1lbnRcIjogXCI8aT5ZZXMhPC9pPiAgQW0gSSB0aGUgb25seSBvdGhlciBvbmU/XCJcclxuICAgICAgfVxyXG4gICAgXVxyXG4gIDwvZmlsZT5cclxuXHJcbiAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICBkZXNjcmliZSgnU0NFIGRvYyBkZW1vJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGl0KCdzaG91bGQgc2FuaXRpemUgdW50cnVzdGVkIHZhbHVlcycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGV4cGVjdChlbGVtZW50KCcuaHRtbENvbW1lbnQnKS5odG1sKCkpLnRvQmUoJzxzcGFuPklzIDxpPmFueW9uZTwvaT4gcmVhZGluZyB0aGlzPzwvc3Bhbj4nKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGl0KCdzaG91bGQgTk9UIHNhbml0aXplIGV4cGxpY2l0bHkgdHJ1c3RlZCB2YWx1ZXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBleHBlY3QoZWxlbWVudCgnI2V4cGxpY2l0bHlUcnVzdGVkSHRtbCcpLmh0bWwoKSkudG9CZShcclxuICAgICAgICAgICAgJzxzcGFuIG9ubW91c2VvdmVyPVwidGhpcy50ZXh0Q29udGVudD0mcXVvdDtFeHBsaWNpdGx5IHRydXN0ZWQgSFRNTCBieXBhc3NlcyAnICtcclxuICAgICAgICAgICAgJ3Nhbml0aXphdGlvbi4mcXVvdDtcIj5Ib3ZlciBvdmVyIHRoaXMgdGV4dC48L3NwYW4+Jyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgPC9maWxlPlxyXG4gPC9leGFtcGxlPlxyXG4gKlxyXG4gKlxyXG4gKlxyXG4gKiAjIyBDYW4gSSBkaXNhYmxlIFNDRSBjb21wbGV0ZWx5P1xyXG4gKlxyXG4gKiBZZXMsIHlvdSBjYW4uICBIb3dldmVyLCB0aGlzIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiAgU0NFIGdpdmVzIHlvdSBhIGxvdCBvZiBzZWN1cml0eSBiZW5lZml0c1xyXG4gKiBmb3IgbGl0dGxlIGNvZGluZyBvdmVyaGVhZC4gIEl0IHdpbGwgYmUgbXVjaCBoYXJkZXIgdG8gdGFrZSBhbiBTQ0UgZGlzYWJsZWQgYXBwbGljYXRpb24gYW5kXHJcbiAqIGVpdGhlciBzZWN1cmUgaXQgb24geW91ciBvd24gb3IgZW5hYmxlIFNDRSBhdCBhIGxhdGVyIHN0YWdlLiAgSXQgbWlnaHQgbWFrZSBzZW5zZSB0byBkaXNhYmxlIFNDRVxyXG4gKiBmb3IgY2FzZXMgd2hlcmUgeW91IGhhdmUgYSBsb3Qgb2YgZXhpc3RpbmcgY29kZSB0aGF0IHdhcyB3cml0dGVuIGJlZm9yZSBTQ0Ugd2FzIGludHJvZHVjZWQgYW5kXHJcbiAqIHlvdSdyZSBtaWdyYXRpbmcgdGhlbSBhIG1vZHVsZSBhdCBhIHRpbWUuXHJcbiAqXHJcbiAqIFRoYXQgc2FpZCwgaGVyZSdzIGhvdyB5b3UgY2FuIGNvbXBsZXRlbHkgZGlzYWJsZSBTQ0U6XHJcbiAqXHJcbiAqIDxwcmUgY2xhc3M9XCJwcmV0dHlwcmludFwiPlxyXG4gKiAgIGFuZ3VsYXIubW9kdWxlKCdteUFwcFdpdGhTY2VEaXNhYmxlZG15QXBwJywgW10pLmNvbmZpZyhmdW5jdGlvbigkc2NlUHJvdmlkZXIpIHtcclxuICogICAgIC8vIENvbXBsZXRlbHkgZGlzYWJsZSBTQ0UuICBGb3IgZGVtb25zdHJhdGlvbiBwdXJwb3NlcyBvbmx5IVxyXG4gKiAgICAgLy8gRG8gbm90IHVzZSBpbiBuZXcgcHJvamVjdHMuXHJcbiAqICAgICAkc2NlUHJvdmlkZXIuZW5hYmxlZChmYWxzZSk7XHJcbiAqICAgfSk7XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uICRTY2VQcm92aWRlcigpIHtcclxuICB2YXIgZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLnNjZVByb3ZpZGVyI2VuYWJsZWRcclxuICAgKiBAbWV0aG9kT2YgbmcuJHNjZVByb3ZpZGVyXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB2YWx1ZSBJZiBwcm92aWRlZCwgdGhlbiBlbmFibGVzL2Rpc2FibGVzIFNDRS5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIFNDRSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBFbmFibGVzL2Rpc2FibGVzIFNDRSBhbmQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZS5cclxuICAgKi9cclxuICB0aGlzLmVuYWJsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIGVuYWJsZWQgPSAhIXZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuYWJsZWQ7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qIERlc2lnbiBub3RlcyBvbiB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3IgU0NFLlxyXG4gICAqXHJcbiAgICogVGhlIEFQSSBjb250cmFjdCBmb3IgdGhlIFNDRSBkZWxlZ2F0ZVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBUaGUgU0NFIGRlbGVnYXRlIG9iamVjdCBtdXN0IHByb3ZpZGUgdGhlIGZvbGxvd2luZyAzIG1ldGhvZHM6XHJcbiAgICpcclxuICAgKiAtIHRydXN0QXMoY29udGV4dEVudW0sIHZhbHVlKVxyXG4gICAqICAgICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHRlbGwgdGhlIFNDRSBzZXJ2aWNlIHRoYXQgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIE9LIHRvIHVzZSBpbiB0aGVcclxuICAgKiAgICAgY29udGV4dHMgc3BlY2lmaWVkIGJ5IGNvbnRleHRFbnVtLiAgSXQgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBhY2NlcHRlZCBieVxyXG4gICAqICAgICBnZXRUcnVzdGVkKCkgZm9yIGEgY29tcGF0aWJsZSBjb250ZXh0RW51bSBhbmQgcmV0dXJuIHRoaXMgdmFsdWUuXHJcbiAgICpcclxuICAgKiAtIHZhbHVlT2YodmFsdWUpXHJcbiAgICogICAgIEZvciB2YWx1ZXMgdGhhdCB3ZXJlIG5vdCBwcm9kdWNlZCBieSB0cnVzdEFzKCksIHJldHVybiB0aGVtIGFzIGlzLiAgRm9yIHZhbHVlcyB0aGF0IHdlcmVcclxuICAgKiAgICAgcHJvZHVjZWQgYnkgdHJ1c3RBcygpLCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQgdmFsdWUgdG8gdHJ1c3RBcy4gIEJhc2ljYWxseSwgaWZcclxuICAgKiAgICAgdHJ1c3RBcyBpcyB3cmFwcGluZyB0aGUgZ2l2ZW4gdmFsdWVzIGludG8gc29tZSB0eXBlLCB0aGlzIG9wZXJhdGlvbiB1bndyYXBzIGl0IHdoZW4gZ2l2ZW5cclxuICAgKiAgICAgc3VjaCBhIHZhbHVlLlxyXG4gICAqXHJcbiAgICogLSBnZXRUcnVzdGVkKGNvbnRleHRFbnVtLCB2YWx1ZSlcclxuICAgKiAgICAgVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBhIHZhbHVlIHRoYXQgaXMgc2FmZSB0byB1c2UgaW4gdGhlIGNvbnRleHQgc3BlY2lmaWVkIGJ5XHJcbiAgICogICAgIGNvbnRleHRFbnVtIG9yIHRocm93IGFuZCBleGNlcHRpb24gb3RoZXJ3aXNlLlxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyBjb250cmFjdCBkZWxpYmVyYXRlbHkgZG9lcyBOT1Qgc3RhdGUgdGhhdCB2YWx1ZXMgcmV0dXJuZWQgYnkgdHJ1c3RBcygpIG11c3QgYmUgb3BhcXVlXHJcbiAgICogb3Igd3JhcHBlZCBpbiBzb21lIGhvbGRlciBvYmplY3QuICBUaGF0IGhhcHBlbnMgdG8gYmUgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLiAgRm9yIGluc3RhbmNlLFxyXG4gICAqIGFuIGltcGxlbWVudGF0aW9uIGNvdWxkIG1haW50YWluIGEgcmVnaXN0cnkgb2YgYWxsIHRydXN0ZWQgb2JqZWN0cyBieSBjb250ZXh0LiAgSW4gc3VjaCBhIGNhc2UsXHJcbiAgICogdHJ1c3RBcygpIHdvdWxkIHJldHVybiB0aGUgc2FtZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGluLiAgZ2V0VHJ1c3RlZCgpIHdvdWxkIHJldHVybiB0aGUgc2FtZVxyXG4gICAqIG9iamVjdCBwYXNzZWQgaW4gaWYgaXQgd2FzIGZvdW5kIGluIHRoZSByZWdpc3RyeSB1bmRlciBhIGNvbXBhdGlibGUgY29udGV4dCBvciB0aHJvdyBhblxyXG4gICAqIGV4Y2VwdGlvbiBvdGhlcndpc2UuICBBbiBpbXBsZW1lbnRhdGlvbiBtaWdodCBvbmx5IHdyYXAgdmFsdWVzIHNvbWUgb2YgdGhlIHRpbWUgYmFzZWQgb25cclxuICAgKiBzb21lIGNyaXRlcmlhLiAgZ2V0VHJ1c3RlZCgpIG1pZ2h0IHJldHVybiBhIHZhbHVlIGFuZCBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIGZvciBzcGVjaWFsXHJcbiAgICogY29uc3RhbnRzIG9yIG9iamVjdHMgZXZlbiBpZiBub3Qgd3JhcHBlZC4gIEFsbCBzdWNoIGltcGxlbWVudGF0aW9ucyBmdWxmaWxsIHRoaXMgY29udHJhY3QuXHJcbiAgICpcclxuICAgKlxyXG4gICAqIEEgbm90ZSBvbiB0aGUgaW5oZXJpdGFuY2UgbW9kZWwgZm9yIFNDRSBjb250ZXh0c1xyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEkndmUgdXNlZCBpbmhlcml0YW5jZSBhbmQgbWFkZSBSRVNPVVJDRV9VUkwgd3JhcHBlZCB0eXBlcyBhIHN1YnR5cGUgb2YgVVJMIHdyYXBwZWQgdHlwZXMuICBUaGlzXHJcbiAgICogaXMgcHVyZWx5IGFuIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXHJcbiAgICpcclxuICAgKiBUaGUgY29udHJhY3QgaXMgc2ltcGx5IHRoaXM6XHJcbiAgICpcclxuICAgKiAgICAgZ2V0VHJ1c3RlZCgkc2NlLlJFU09VUkNFX1VSTCwgdmFsdWUpIHN1Y2NlZWRpbmcgaW1wbGllcyB0aGF0IGdldFRydXN0ZWQoJHNjZS5VUkwsIHZhbHVlKVxyXG4gICAqICAgICB3aWxsIGFsc28gc3VjY2VlZC5cclxuICAgKlxyXG4gICAqIEluaGVyaXRhbmNlIGhhcHBlbnMgdG8gY2FwdHVyZSB0aGlzIGluIGEgbmF0dXJhbCB3YXkuICBJbiBzb21lIGZ1dHVyZSwgd2VcclxuICAgKiBtYXkgbm90IHVzZSBpbmhlcml0YW5jZSBhbnltb3JlLiAgVGhhdCBpcyBPSyBiZWNhdXNlIG5vIGNvZGUgb3V0c2lkZSBvZlxyXG4gICAqIHNjZS5qcyBhbmQgc2NlU3BlY3MuanMgd291bGQgbmVlZCB0byBiZSBhd2FyZSBvZiB0aGlzIGRldGFpbC5cclxuICAgKi9cclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckcGFyc2UnLCAnJGRvY3VtZW50JywgJyRzY2VEZWxlZ2F0ZScsIGZ1bmN0aW9uKFxyXG4gICAgICAgICAgICAgICAgJHBhcnNlLCAgICRkb2N1bWVudCwgICAkc2NlRGVsZWdhdGUpIHtcclxuICAgIC8vIFByZXJlcTogRW5zdXJlIHRoYXQgd2UncmUgbm90IHJ1bm5pbmcgaW4gSUU4IHF1aXJrcyBtb2RlLiAgSW4gdGhhdCBtb2RlLCBJRSBhbGxvd3NcclxuICAgIC8vIHRoZSBcImV4cHJlc3Npb24oamF2YXNjcmlwdCBleHByZXNzaW9uKVwiIHN5bnRheCB3aGljaCBpcyBpbnNlY3VyZS5cclxuICAgIGlmIChlbmFibGVkICYmIG1zaWUpIHtcclxuICAgICAgdmFyIGRvY3VtZW50TW9kZSA9ICRkb2N1bWVudFswXS5kb2N1bWVudE1vZGU7XHJcbiAgICAgIGlmIChkb2N1bWVudE1vZGUgIT09IHVuZGVmaW5lZCAmJiBkb2N1bWVudE1vZGUgPCA4KSB7XHJcbiAgICAgICAgdGhyb3cgJHNjZU1pbkVycignaWVxdWlya3MnLFxyXG4gICAgICAgICAgJ1N0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIGRvZXMgbm90IHN1cHBvcnQgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbiA8IDkgaW4gcXVpcmtzICcgK1xyXG4gICAgICAgICAgJ21vZGUuICBZb3UgY2FuIGZpeCB0aGlzIGJ5IGFkZGluZyB0aGUgdGV4dCA8IWRvY3R5cGUgaHRtbD4gdG8gdGhlIHRvcCBvZiB5b3VyIEhUTUwgJyArXHJcbiAgICAgICAgICAnZG9jdW1lbnQuICBTZWUgaHR0cDovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcuJHNjZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY2UgPSBjb3B5KFNDRV9DT05URVhUUyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIG5nLnNjZSNpc0VuYWJsZWRcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIFNDRSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuICBJZiB5b3Ugd2FudCB0byBzZXQgdGhlIHZhbHVlLCB5b3VcclxuICAgICAqIGhhdmUgdG8gZG8gaXQgYXQgbW9kdWxlIGNvbmZpZyB0aW1lIG9uIHtAbGluayBuZy4kc2NlUHJvdmlkZXIgJHNjZVByb3ZpZGVyfS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgU0NFIGlzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHNjZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBlbmFibGVkO1xyXG4gICAgfTtcclxuICAgIHNjZS50cnVzdEFzID0gJHNjZURlbGVnYXRlLnRydXN0QXM7XHJcbiAgICBzY2UuZ2V0VHJ1c3RlZCA9ICRzY2VEZWxlZ2F0ZS5nZXRUcnVzdGVkO1xyXG4gICAgc2NlLnZhbHVlT2YgPSAkc2NlRGVsZWdhdGUudmFsdWVPZjtcclxuXHJcbiAgICBpZiAoIWVuYWJsZWQpIHtcclxuICAgICAgc2NlLnRydXN0QXMgPSBzY2UuZ2V0VHJ1c3RlZCA9IGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfSxcclxuICAgICAgc2NlLnZhbHVlT2YgPSBpZGVudGl0eVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZVxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIENvbnZlcnRzIEFuZ3VsYXIge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gaW50byBhIGZ1bmN0aW9uLiAgVGhpcyBpcyBsaWtlIHtAbGlua1xyXG4gICAgICogbmcuJHBhcnNlICRwYXJzZX0gYW5kIGlzIGlkZW50aWNhbCB3aGVuIHRoZSBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCBjb25zdGFudC4gIE90aGVyd2lzZSwgaXRcclxuICAgICAqIHdyYXBzIHRoZSBleHByZXNzaW9uIGluIGEgY2FsbCB0byB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkICRzY2UuZ2V0VHJ1c3RlZCgqdHlwZSosXHJcbiAgICAgKiAqcmVzdWx0Kil9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGtpbmQgb2YgU0NFIGNvbnRleHQgaW4gd2hpY2ggdGhpcyByZXN1bHQgd2lsbCBiZSB1c2VkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGAgw6LigqzigJwgYHtvYmplY3R9YCDDouKCrOKAnCBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcclxuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gICAgICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICAgICAqICAgICAgYGNvbnRleHRgLlxyXG4gICAgICovXHJcbiAgICBzY2UucGFyc2VBcyA9IGZ1bmN0aW9uIHNjZVBhcnNlQXModHlwZSwgZXhwcikge1xyXG4gICAgICB2YXIgcGFyc2VkID0gJHBhcnNlKGV4cHIpO1xyXG4gICAgICBpZiAocGFyc2VkLmxpdGVyYWwgJiYgcGFyc2VkLmNvbnN0YW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NlUGFyc2VBc1RydXN0ZWQoc2VsZiwgbG9jYWxzKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2NlLmdldFRydXN0ZWQodHlwZSwgcGFyc2VkKHNlbGYsIGxvY2FscykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjdHJ1c3RBc1xyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIERlbGVnYXRlcyB0byB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0uICBBcyBzdWNoLCByZXR1cm5zIGFuIG9iamVjdFxyXG4gICAgICogdGhhdCBpcyB0cnVzdGVkIGJ5IGFuZ3VsYXIgZm9yIHVzZSBpbiBzcGVjaWZpZWQgc3RyaWN0IGNvbnRleHR1YWwgZXNjYXBpbmcgY29udGV4dHMgKHN1Y2ggYXNcclxuICAgICAqIG5nLWh0bWwtYmluZC11bnNhZmUsIG5nLWluY2x1ZGUsIGFueSBzcmMgYXR0cmlidXRlIGludGVycG9sYXRpb24sIGFueSBkb20gZXZlbnQgYmluZGluZ1xyXG4gICAgICogYXR0cmlidXRlIGludGVycG9sYXRpb24gc3VjaCBhcyBmb3Igb25jbGljaywgIGV0Yy4pIHRoYXQgdXNlcyB0aGUgcHJvdmlkZWQgdmFsdWUuICBTZWUgKlxyXG4gICAgICoge0BsaW5rIG5nLiRzY2UgJHNjZX0gZm9yIGVuYWJsaW5nIHN0cmljdCBjb250ZXh0dWFsIGVzY2FwaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBraW5kIG9mIGNvbnRleHQgaW4gd2hpY2ggdGhpcyB2YWx1ZSBpcyBzYWZlIGZvciB1c2UuICBlLmcuIHVybCxcclxuICAgICAqICAgcmVzb3VyY2VfdXJsLCBodG1sLCBqcyBhbmQgY3NzLlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHRydXN0ZWQvc2FmZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBBIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RhbmQgaW4gZm9yIHRoZSBwcm92aWRlZCBgdmFsdWVgIGluIHBsYWNlc1xyXG4gICAgICogd2hlcmUgQW5ndWxhciBleHBlY3RzIGEgJHNjZS50cnVzdEFzKCkgcmV0dXJuIHZhbHVlLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3RydXN0QXNIdG1sXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnRydXN0QXNIdG1sKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBcygkc2NlLkhUTUwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdHJ1c3RBcy5cclxuICAgICAqIEByZXR1cm5zIHsqfSBBbiBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBuZy4kc2NlI2dldFRydXN0ZWRIdG1sXHJcbiAgICAgKiAgICAgJHNjZS5nZXRUcnVzdGVkSHRtbCh2YWx1ZSl9IHRvIG9idGFpbiB0aGUgb3JpZ2luYWwgdmFsdWUuICAocHJpdmlsZWdlZCBkaXJlY3RpdmVzXHJcbiAgICAgKiAgICAgb25seSBhY2NlcHQgZXhwcmVzc2lvbnMgdGhhdCBhcmUgZWl0aGVyIGxpdGVyYWwgY29uc3RhbnRzIG9yIGFyZSB0aGVcclxuICAgICAqICAgICByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyAkc2NlLnRydXN0QXN9LilcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSN0cnVzdEFzVXJsXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnRydXN0QXNVcmwodmFsdWUpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzKCRzY2UuVVJMLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRydXN0QXMuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkVXJsXHJcbiAgICAgKiAgICAgJHNjZS5nZXRUcnVzdGVkVXJsKHZhbHVlKX0gdG8gb2J0YWluIHRoZSBvcmlnaW5hbCB2YWx1ZS4gIChwcml2aWxlZ2VkIGRpcmVjdGl2ZXNcclxuICAgICAqICAgICBvbmx5IGFjY2VwdCBleHByZXNzaW9ucyB0aGF0IGFyZSBlaXRoZXIgbGl0ZXJhbCBjb25zdGFudHMgb3IgYXJlIHRoZVxyXG4gICAgICogICAgIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgbmcuJHNjZSN0cnVzdEFzICRzY2UudHJ1c3RBc30uKVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3RydXN0QXNSZXNvdXJjZVVybFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwodmFsdWUpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzKCRzY2UuUkVTT1VSQ0VfVVJMLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRydXN0QXMuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkUmVzb3VyY2VVcmxcclxuICAgICAqICAgICAkc2NlLmdldFRydXN0ZWRSZXNvdXJjZVVybCh2YWx1ZSl9IHRvIG9idGFpbiB0aGUgb3JpZ2luYWwgdmFsdWUuICAocHJpdmlsZWdlZCBkaXJlY3RpdmVzXHJcbiAgICAgKiAgICAgb25seSBhY2NlcHQgZXhwcmVzc2lvbnMgdGhhdCBhcmUgZWl0aGVyIGxpdGVyYWwgY29uc3RhbnRzIG9yIGFyZSB0aGUgcmV0dXJuXHJcbiAgICAgKiAgICAgdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyAkc2NlLnRydXN0QXN9LilcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSN0cnVzdEFzSnNcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UudHJ1c3RBc0pzKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBcygkc2NlLkpTLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRydXN0QXMuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkSnNcclxuICAgICAqICAgICAkc2NlLmdldFRydXN0ZWRKcyh2YWx1ZSl9IHRvIG9idGFpbiB0aGUgb3JpZ2luYWwgdmFsdWUuICAocHJpdmlsZWdlZCBkaXJlY3RpdmVzXHJcbiAgICAgKiAgICAgb25seSBhY2NlcHQgZXhwcmVzc2lvbnMgdGhhdCBhcmUgZWl0aGVyIGxpdGVyYWwgY29uc3RhbnRzIG9yIGFyZSB0aGVcclxuICAgICAqICAgICByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyAkc2NlLnRydXN0QXN9LilcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSNnZXRUcnVzdGVkXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogRGVsZWdhdGVzIHRvIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWRgfS4gIEFzIHN1Y2gsIHRha2VzXHJcbiAgICAgKiB0aGUgcmVzdWx0IG9mIGEge0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyBgJHNjZS50cnVzdEFzYH0oKSBjYWxsIGFuZCByZXR1cm5zIHRoZSBvcmlnaW5hbGx5IHN1cHBsaWVkXHJcbiAgICAgKiB2YWx1ZSBpZiB0aGUgcXVlcmllZCBjb250ZXh0IHR5cGUgaXMgYSBzdXBlcnR5cGUgb2YgdGhlIGNyZWF0ZWQgdHlwZS4gIElmIHRoaXMgY29uZGl0aW9uXHJcbiAgICAgKiBpc24ndCBzYXRpc2ZpZWQsIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGtpbmQgb2YgY29udGV4dCBpbiB3aGljaCB0aGlzIHZhbHVlIGlzIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0geyp9IG1heWJlVHJ1c3RlZCBUaGUgcmVzdWx0IG9mIGEgcHJpb3Ige0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyBgJHNjZS50cnVzdEFzYH0gY2FsbC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhlIHdhcyBvcmlnaW5hbGx5IHByb3ZpZGVkIHRvIHtAbGluayBuZy4kc2NlI3RydXN0QXMgYCRzY2UudHJ1c3RBc2B9IGlmXHJcbiAgICAgKiAgICAgdmFsaWQgaW4gdGhpcyBjb250ZXh0LiAgT3RoZXJ3aXNlLCB0aHJvd3MgYW4gZXhjZXB0aW9uLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI2dldFRydXN0ZWRIdG1sXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLmdldFRydXN0ZWRIdG1sKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNnZXRUcnVzdGVkIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZCgkc2NlLkhUTUwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFzcyB0byBgJHNjZS5nZXRUcnVzdGVkYC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkc2NlLmdldFRydXN0ZWQoJHNjZS5IVE1MLCB2YWx1ZSlgXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZENzc1xyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5nZXRUcnVzdGVkQ3NzKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNnZXRUcnVzdGVkIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZCgkc2NlLkNTUywgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXNzIHRvIGAkc2NlLmdldFRydXN0ZWRgLlxyXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgYCRzY2UuZ2V0VHJ1c3RlZCgkc2NlLkNTUywgdmFsdWUpYFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI2dldFRydXN0ZWRVcmxcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UuZ2V0VHJ1c3RlZFVybCh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5VUkwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFzcyB0byBgJHNjZS5nZXRUcnVzdGVkYC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkc2NlLmdldFRydXN0ZWQoJHNjZS5VUkwsIHZhbHVlKWBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSNnZXRUcnVzdGVkUmVzb3VyY2VVcmxcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UuZ2V0VHJ1c3RlZFJlc291cmNlVXJsKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNnZXRUcnVzdGVkIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZCgkc2NlLlJFU09VUkNFX1VSTCwgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXNzIHRvIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZGAuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBgJHNjZS5nZXRUcnVzdGVkKCRzY2UuUkVTT1VSQ0VfVVJMLCB2YWx1ZSlgXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZEpzXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLmdldFRydXN0ZWRKcyh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5KUywgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXNzIHRvIGAkc2NlLmdldFRydXN0ZWRgLlxyXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgYCRzY2UuZ2V0VHJ1c3RlZCgkc2NlLkpTLCB2YWx1ZSlgXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjcGFyc2VBc0h0bWxcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UucGFyc2VBc0h0bWwoZXhwcmVzc2lvbiBzdHJpbmcpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZSNwYXJzZSBgJHNjZS5wYXJzZUFzKCRzY2UuSFRNTCwgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcclxuICAgICAqXHJcbiAgICAgKiAgICAqIGBjb250ZXh0YCDDouKCrOKAnCBge29iamVjdH1gIMOi4oKs4oCcIGFuIG9iamVjdCBhZ2FpbnN0IHdoaWNoIGFueSBleHByZXNzaW9ucyBlbWJlZGRlZCBpbiB0aGUgc3RyaW5nc1xyXG4gICAgICogICAgICBhcmUgZXZhbHVhdGVkIGFnYWluc3QgKHR5cGljYWxseSBhIHNjb3BlIG9iamVjdCkuXHJcbiAgICAgKiAgICAqIGBsb2NhbHNgIMOi4oKs4oCcIGB7b2JqZWN0PX1gIMOi4oKs4oCcIGxvY2FsIHZhcmlhYmxlcyBjb250ZXh0IG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpblxyXG4gICAgICogICAgICBgY29udGV4dGAuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjcGFyc2VBc0Nzc1xyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzQ3NzKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2UjcGFyc2UgYCRzY2UucGFyc2VBcygkc2NlLkNTUywgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcclxuICAgICAqXHJcbiAgICAgKiAgICAqIGBjb250ZXh0YCDDouKCrOKAnCBge29iamVjdH1gIMOi4oKs4oCcIGFuIG9iamVjdCBhZ2FpbnN0IHdoaWNoIGFueSBleHByZXNzaW9ucyBlbWJlZGRlZCBpbiB0aGUgc3RyaW5nc1xyXG4gICAgICogICAgICBhcmUgZXZhbHVhdGVkIGFnYWluc3QgKHR5cGljYWxseSBhIHNjb3BlIG9iamVjdCkuXHJcbiAgICAgKiAgICAqIGBsb2NhbHNgIMOi4oKs4oCcIGB7b2JqZWN0PX1gIMOi4oKs4oCcIGxvY2FsIHZhcmlhYmxlcyBjb250ZXh0IG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpblxyXG4gICAgICogICAgICBgY29udGV4dGAuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjcGFyc2VBc1VybFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzVXJsKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2UjcGFyc2UgYCRzY2UucGFyc2VBcygkc2NlLlVSTCwgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcclxuICAgICAqXHJcbiAgICAgKiAgICAqIGBjb250ZXh0YCDDouKCrOKAnCBge29iamVjdH1gIMOi4oKs4oCcIGFuIG9iamVjdCBhZ2FpbnN0IHdoaWNoIGFueSBleHByZXNzaW9ucyBlbWJlZGRlZCBpbiB0aGUgc3RyaW5nc1xyXG4gICAgICogICAgICBhcmUgZXZhbHVhdGVkIGFnYWluc3QgKHR5cGljYWxseSBhIHNjb3BlIG9iamVjdCkuXHJcbiAgICAgKiAgICAqIGBsb2NhbHNgIMOi4oKs4oCcIGB7b2JqZWN0PX1gIMOi4oKs4oCcIGxvY2FsIHZhcmlhYmxlcyBjb250ZXh0IG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpblxyXG4gICAgICogICAgICBgY29udGV4dGAuXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjcGFyc2VBc1Jlc291cmNlVXJsXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnBhcnNlQXNSZXNvdXJjZVVybCh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlI3BhcnNlIGAkc2NlLnBhcnNlQXMoJHNjZS5SRVNPVVJDRV9VUkwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGAgw6LigqzigJwgYHtvYmplY3R9YCDDouKCrOKAnCBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcclxuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gICAgICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICAgICAqICAgICAgYGNvbnRleHRgLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3BhcnNlQXNKc1xyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzSnModmFsdWUpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZSNwYXJzZSBgJHNjZS5wYXJzZUFzKCRzY2UuSlMsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGAgw6LigqzigJwgYHtvYmplY3R9YCDDouKCrOKAnCBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcclxuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gICAgICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICAgICAqICAgICAgYGNvbnRleHRgLlxyXG4gICAgICovXHJcblxyXG4gICAgLy8gU2hvcnRoYW5kIGRlbGVnYXRpb25zLlxyXG4gICAgdmFyIHBhcnNlID0gc2NlLnBhcnNlQXMsXHJcbiAgICAgICAgZ2V0VHJ1c3RlZCA9IHNjZS5nZXRUcnVzdGVkLFxyXG4gICAgICAgIHRydXN0QXMgPSBzY2UudHJ1c3RBcztcclxuXHJcbiAgICBhbmd1bGFyLmZvckVhY2goU0NFX0NPTlRFWFRTLCBmdW5jdGlvbiAoZW51bVZhbHVlLCBuYW1lKSB7XHJcbiAgICAgIHZhciBsTmFtZSA9IGxvd2VyY2FzZShuYW1lKTtcclxuICAgICAgc2NlW2NhbWVsQ2FzZShcInBhcnNlX2FzX1wiICsgbE5hbWUpXSA9IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlKGVudW1WYWx1ZSwgZXhwcik7XHJcbiAgICAgIH1cclxuICAgICAgc2NlW2NhbWVsQ2FzZShcImdldF90cnVzdGVkX1wiICsgbE5hbWUpXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBnZXRUcnVzdGVkKGVudW1WYWx1ZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHNjZVtjYW1lbENhc2UoXCJ0cnVzdF9hc19cIiArIGxOYW1lKV0gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1c3RBcyhlbnVtVmFsdWUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHNjZTtcclxuICB9XTtcclxufVxyXG5cclxuLyoqXHJcbiAqICEhISBUaGlzIGlzIGFuIHVuZG9jdW1lbnRlZCBcInByaXZhdGVcIiBzZXJ2aWNlICEhIVxyXG4gKlxyXG4gKiBAbmFtZSBuZy4kc25pZmZlclxyXG4gKiBAcmVxdWlyZXMgJHdpbmRvd1xyXG4gKiBAcmVxdWlyZXMgJGRvY3VtZW50XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlzdG9yeSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgaHRtbDUgaGlzdG9yeSBhcGkgP1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc2hjaGFuZ2UgRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGhhc2hjaGFuZ2UgZXZlbnQgP1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHRyYW5zaXRpb25zIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBDU1MgdHJhbnNpdGlvbiBldmVudHMgP1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuaW1hdGlvbnMgRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IENTUyBhbmltYXRpb24gZXZlbnRzID9cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgaXMgdmVyeSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGVzdGluZyBicm93c2VyJ3MgZmVhdHVyZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiAkU25pZmZlclByb3ZpZGVyKCkge1xyXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckZG9jdW1lbnQnLCBmdW5jdGlvbigkd2luZG93LCAkZG9jdW1lbnQpIHtcclxuICAgIHZhciBldmVudFN1cHBvcnQgPSB7fSxcclxuICAgICAgICBhbmRyb2lkID0gaW50KCgvYW5kcm9pZCAoXFxkKykvLmV4ZWMobG93ZXJjYXNlKCgkd2luZG93Lm5hdmlnYXRvciB8fCB7fSkudXNlckFnZW50KSkgfHwgW10pWzFdKSxcclxuICAgICAgICBib3hlZSA9IC9Cb3hlZS9pLnRlc3QoKCR3aW5kb3cubmF2aWdhdG9yIHx8IHt9KS51c2VyQWdlbnQpLFxyXG4gICAgICAgIGRvY3VtZW50ID0gJGRvY3VtZW50WzBdIHx8IHt9LFxyXG4gICAgICAgIHZlbmRvclByZWZpeCxcclxuICAgICAgICB2ZW5kb3JSZWdleCA9IC9eKE1venx3ZWJraXR8T3xtcykoPz1bQS1aXSkvLFxyXG4gICAgICAgIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5zdHlsZSxcclxuICAgICAgICB0cmFuc2l0aW9ucyA9IGZhbHNlLFxyXG4gICAgICAgIGFuaW1hdGlvbnMgPSBmYWxzZSxcclxuICAgICAgICBtYXRjaDtcclxuXHJcbiAgICBpZiAoYm9keVN0eWxlKSB7XHJcbiAgICAgIGZvcih2YXIgcHJvcCBpbiBib2R5U3R5bGUpIHtcclxuICAgICAgICBpZihtYXRjaCA9IHZlbmRvclJlZ2V4LmV4ZWMocHJvcCkpIHtcclxuICAgICAgICAgIHZlbmRvclByZWZpeCA9IG1hdGNoWzBdO1xyXG4gICAgICAgICAgdmVuZG9yUHJlZml4ID0gdmVuZG9yUHJlZml4LnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgdmVuZG9yUHJlZml4LnN1YnN0cigxKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIXZlbmRvclByZWZpeCkge1xyXG4gICAgICAgIHZlbmRvclByZWZpeCA9ICgnV2Via2l0T3BhY2l0eScgaW4gYm9keVN0eWxlKSAmJiAnd2Via2l0JztcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJhbnNpdGlvbnMgPSAhISgoJ3RyYW5zaXRpb24nIGluIGJvZHlTdHlsZSkgfHwgKHZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uJyBpbiBib2R5U3R5bGUpKTtcclxuICAgICAgYW5pbWF0aW9ucyAgPSAhISgoJ2FuaW1hdGlvbicgaW4gYm9keVN0eWxlKSB8fCAodmVuZG9yUHJlZml4ICsgJ0FuaW1hdGlvbicgaW4gYm9keVN0eWxlKSk7XHJcblxyXG4gICAgICBpZiAoYW5kcm9pZCAmJiAoIXRyYW5zaXRpb25zfHwhYW5pbWF0aW9ucykpIHtcclxuICAgICAgICB0cmFuc2l0aW9ucyA9IGlzU3RyaW5nKGRvY3VtZW50LmJvZHkuc3R5bGUud2Via2l0VHJhbnNpdGlvbik7XHJcbiAgICAgICAgYW5pbWF0aW9ucyA9IGlzU3RyaW5nKGRvY3VtZW50LmJvZHkuc3R5bGUud2Via2l0QW5pbWF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBBbmRyb2lkIGhhcyBoaXN0b3J5LnB1c2hTdGF0ZSwgYnV0IGl0IGRvZXMgbm90IHVwZGF0ZSBsb2NhdGlvbiBjb3JyZWN0bHlcclxuICAgICAgLy8gc28gbGV0J3Mgbm90IHVzZSB0aGUgaGlzdG9yeSBBUEkgYXQgYWxsLlxyXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTE3NDcxXHJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzkwNFxyXG5cclxuICAgICAgLy8gb2xkZXIgd2ViaXQgYnJvd3NlciAoNTMzLjkpIG9uIEJveGVlIGJveCBoYXMgZXhhY3RseSB0aGUgc2FtZSBwcm9ibGVtIGFzIEFuZHJvaWQgaGFzXHJcbiAgICAgIC8vIHNvIGxldCdzIG5vdCB1c2UgdGhlIGhpc3RvcnkgQVBJIGFsc29cclxuICAgICAgaGlzdG9yeTogISEoJHdpbmRvdy5oaXN0b3J5ICYmICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgJiYgIShhbmRyb2lkIDwgNCkgJiYgIWJveGVlKSxcclxuICAgICAgaGFzaGNoYW5nZTogJ29uaGFzaGNoYW5nZScgaW4gJHdpbmRvdyAmJlxyXG4gICAgICAgICAgICAgICAgICAvLyBJRTggY29tcGF0aWJsZSBtb2RlIGxpZXNcclxuICAgICAgICAgICAgICAgICAgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gNyksXHJcbiAgICAgIGhhc0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIC8vIElFOSBpbXBsZW1lbnRzICdpbnB1dCcgZXZlbnQgaXQncyBzbyBmdWJhcmVkIHRoYXQgd2UgcmF0aGVyIHByZXRlbmQgdGhhdCBpdCBkb2Vzbid0IGhhdmVcclxuICAgICAgICAvLyBpdC4gSW4gcGFydGljdWxhciB0aGUgZXZlbnQgaXMgbm90IGZpcmVkIHdoZW4gYmFja3NwYWNlIG9yIGRlbGV0ZSBrZXkgYXJlIHByZXNzZWQgb3JcclxuICAgICAgICAvLyB3aGVuIGN1dCBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLlxyXG4gICAgICAgIGlmIChldmVudCA9PSAnaW5wdXQnICYmIG1zaWUgPT0gOSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZXZlbnRTdXBwb3J0W2V2ZW50XSkpIHtcclxuICAgICAgICAgIHZhciBkaXZFbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgIGV2ZW50U3VwcG9ydFtldmVudF0gPSAnb24nICsgZXZlbnQgaW4gZGl2RWxtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGV2ZW50U3VwcG9ydFtldmVudF07XHJcbiAgICAgIH0sXHJcbiAgICAgIGNzcDogZG9jdW1lbnQuc2VjdXJpdHlQb2xpY3kgPyBkb2N1bWVudC5zZWN1cml0eVBvbGljeS5pc0FjdGl2ZSA6IGZhbHNlLFxyXG4gICAgICB2ZW5kb3JQcmVmaXg6IHZlbmRvclByZWZpeCxcclxuICAgICAgdHJhbnNpdGlvbnMgOiB0cmFuc2l0aW9ucyxcclxuICAgICAgYW5pbWF0aW9ucyA6IGFuaW1hdGlvbnNcclxuICAgIH07XHJcbiAgfV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uICRUaW1lb3V0UHJvdmlkZXIoKSB7XHJcbiAgdGhpcy4kZ2V0ID0gWyckcm9vdFNjb3BlJywgJyRicm93c2VyJywgJyRxJywgJyRleGNlcHRpb25IYW5kbGVyJyxcclxuICAgICAgIGZ1bmN0aW9uKCRyb290U2NvcGUsICAgJGJyb3dzZXIsICAgJHEsICAgJGV4Y2VwdGlvbkhhbmRsZXIpIHtcclxuICAgIHZhciBkZWZlcnJlZHMgPSB7fTtcclxuXHJcblxyXG4gICAgIC8qKlxyXG4gICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAqIEBuYW1lIG5nLiR0aW1lb3V0XHJcbiAgICAgICogQHJlcXVpcmVzICRicm93c2VyXHJcbiAgICAgICpcclxuICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgKiBBbmd1bGFyJ3Mgd3JhcHBlciBmb3IgYHdpbmRvdy5zZXRUaW1lb3V0YC4gVGhlIGBmbmAgZnVuY3Rpb24gaXMgd3JhcHBlZCBpbnRvIGEgdHJ5L2NhdGNoXHJcbiAgICAgICogYmxvY2sgYW5kIGRlbGVnYXRlcyBhbnkgZXhjZXB0aW9ucyB0b1xyXG4gICAgICAqIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cclxuICAgICAgKlxyXG4gICAgICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgcmVnaXN0ZXJpbmcgYSB0aW1lb3V0IGZ1bmN0aW9uIGlzIGEgcHJvbWlzZSwgd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aGVuXHJcbiAgICAgICogdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBhbmQgdGhlIHRpbWVvdXQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXHJcbiAgICAgICpcclxuICAgICAgKiBUbyBjYW5jZWwgYSB0aW1lb3V0IHJlcXVlc3QsIGNhbGwgYCR0aW1lb3V0LmNhbmNlbChwcm9taXNlKWAuXHJcbiAgICAgICpcclxuICAgICAgKiBJbiB0ZXN0cyB5b3UgY2FuIHVzZSB7QGxpbmsgbmdNb2NrLiR0aW1lb3V0IGAkdGltZW91dC5mbHVzaCgpYH0gdG9cclxuICAgICAgKiBzeW5jaHJvbm91c2x5IGZsdXNoIHRoZSBxdWV1ZSBvZiBkZWZlcnJlZCBmdW5jdGlvbnMuXHJcbiAgICAgICpcclxuICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIEEgZnVuY3Rpb24sIHdob3NlIGV4ZWN1dGlvbiBzaG91bGQgYmUgZGVsYXllZC5cclxuICAgICAgKiBAcGFyYW0ge251bWJlcj19IFtkZWxheT0wXSBEZWxheSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2ludm9rZUFwcGx5PXRydWVdIElmIHNldCB0byBgZmFsc2VgIHNraXBzIG1vZGVsIGRpcnR5IGNoZWNraW5nLCBvdGhlcndpc2VcclxuICAgICAgKiAgIHdpbGwgaW52b2tlIGBmbmAgd2l0aGluIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkYXBwbHkgJGFwcGx5fSBibG9jay5cclxuICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgdGltZW91dCBpcyByZWFjaGVkLiBUaGUgdmFsdWUgdGhpc1xyXG4gICAgICAqICAgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGggaXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYGZuYCBmdW5jdGlvbi5cclxuICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXQoZm4sIGRlbGF5LCBpbnZva2VBcHBseSkge1xyXG4gICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxyXG4gICAgICAgICAgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICBza2lwQXBwbHkgPSAoaXNEZWZpbmVkKGludm9rZUFwcGx5KSAmJiAhaW52b2tlQXBwbHkpLFxyXG4gICAgICAgICAgdGltZW91dElkO1xyXG5cclxuICAgICAgdGltZW91dElkID0gJGJyb3dzZXIuZGVmZXIoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZm4oKSk7XHJcbiAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICBkZWxldGUgZGVmZXJyZWRzW3Byb21pc2UuJCR0aW1lb3V0SWRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFza2lwQXBwbHkpICRyb290U2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgIH0sIGRlbGF5KTtcclxuXHJcbiAgICAgIHByb21pc2UuJCR0aW1lb3V0SWQgPSB0aW1lb3V0SWQ7XHJcbiAgICAgIGRlZmVycmVkc1t0aW1lb3V0SWRdID0gZGVmZXJyZWQ7XHJcblxyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgIC8qKlxyXG4gICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAqIEBuYW1lIG5nLiR0aW1lb3V0I2NhbmNlbFxyXG4gICAgICAqIEBtZXRob2RPZiBuZy4kdGltZW91dFxyXG4gICAgICAqXHJcbiAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICogQ2FuY2VscyBhIHRhc2sgYXNzb2NpYXRlZCB3aXRoIHRoZSBgcHJvbWlzZWAuIEFzIGEgcmVzdWx0IG9mIHRoaXMsIHRoZSBwcm9taXNlIHdpbGwgYmVcclxuICAgICAgKiByZXNvbHZlZCB3aXRoIGEgcmVqZWN0aW9uLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIHtQcm9taXNlPX0gcHJvbWlzZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoZSBgJHRpbWVvdXRgIGZ1bmN0aW9uLlxyXG4gICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFzayBoYXNuJ3QgZXhlY3V0ZWQgeWV0IGFuZCB3YXMgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgICogICBjYW5jZWxlZC5cclxuICAgICAgKi9cclxuICAgIHRpbWVvdXQuY2FuY2VsID0gZnVuY3Rpb24ocHJvbWlzZSkge1xyXG4gICAgICBpZiAocHJvbWlzZSAmJiBwcm9taXNlLiQkdGltZW91dElkIGluIGRlZmVycmVkcykge1xyXG4gICAgICAgIGRlZmVycmVkc1twcm9taXNlLiQkdGltZW91dElkXS5yZWplY3QoJ2NhbmNlbGVkJyk7XHJcbiAgICAgICAgZGVsZXRlIGRlZmVycmVkc1twcm9taXNlLiQkdGltZW91dElkXTtcclxuICAgICAgICByZXR1cm4gJGJyb3dzZXIuZGVmZXIuY2FuY2VsKHByb21pc2UuJCR0aW1lb3V0SWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRpbWVvdXQ7XHJcbiAgfV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uICQkVXJsVXRpbHNQcm92aWRlcigpIHtcclxuICB0aGlzLiRnZXQgPSBbZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxcclxuICAgICAgICAvLyBOT1RFOiAgVGhlIHVzYWdlIG9mIHdpbmRvdyBhbmQgZG9jdW1lbnQgaW5zdGVhZCBvZiAkd2luZG93IGFuZCAkZG9jdW1lbnQgaGVyZSBpc1xyXG4gICAgICAgIC8vIGRlbGliZXJhdGUuICBUaGlzIHNlcnZpY2UgZGVwZW5kcyBvbiB0aGUgc3BlY2lmaWMgYmVoYXZpb3Igb2YgYW5jaG9yIG5vZGVzIGNyZWF0ZWQgYnkgdGhlXHJcbiAgICAgICAgLy8gYnJvd3NlciAocmVzb2x2aW5nIGFuZCBwYXJzaW5nIFVSTHMpIHRoYXQgaXMgdW5saWtlbHkgdG8gYmUgcHJvdmlkZWQgYnkgbW9jayBvYmplY3RzIGFuZFxyXG4gICAgICAgIC8vIGNhdXNlIHVzIHRvIGJyZWFrIHRlc3RzLiAgSW4gYWRkaXRpb24sIHdoZW4gdGhlIGJyb3dzZXIgcmVzb2x2ZXMgYSBVUkwgZm9yIFhIUiwgaXRcclxuICAgICAgICAvLyBkb2Vzbid0IGtub3cgYWJvdXQgbW9ja2VkIGxvY2F0aW9ucyBhbmQgcmVzb2x2ZXMgVVJMcyB0byB0aGUgcmVhbCBkb2N1bWVudCAtIHdoaWNoIGlzXHJcbiAgICAgICAgLy8gZXhhY3RseSB0aGUgYmVoYXZpb3IgbmVlZGVkIGhlcmUuICBUaGVyZSBpcyBsaXR0bGUgdmFsdWUgaXMgbW9ja2luZyB0aGVzZSBvdXIgZm9yIHRoaXNcclxuICAgICAgICAvLyBzZXJ2aWNlLlxyXG4gICAgICAgIG9yaWdpblVybCA9IHJlc29sdmUod2luZG93LmxvY2F0aW9uLmhyZWYsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBOb3JtYWxpemVzIGFuZCBvcHRpb25hbGx5IHBhcnNlcyBhIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiAgVGhpcyBpcyBhIHByaXZhdGUgc2VydmljZS4gIFRoZSBBUEkgaXMgc3ViamVjdCB0byBjaGFuZ2UgdW5wcmVkaWN0YWJseSBpbiBhbnkgY29tbWl0LlxyXG4gICAgICpcclxuICAgICAqIEltcGxlbWVudGF0aW9uIE5vdGVzIGZvciBub24tSUUgYnJvd3NlcnNcclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAqIEFzc2lnbmluZyBhIFVSTCB0byB0aGUgaHJlZiBwcm9wZXJ0eSBvZiBhbiBhbmNob3IgRE9NIG5vZGUsIGV2ZW4gb25lIGF0dGFjaGVkIHRvIHRoZSBET00sXHJcbiAgICAgKiByZXN1bHRzIGJvdGggaW4gdGhlIG5vcm1hbGl6aW5nIGFuZCBwYXJzaW5nIG9mIHRoZSBVUkwuICBOb3JtYWxpemluZyBtZWFucyB0aGF0IGEgcmVsYXRpdmVcclxuICAgICAqIFVSTCB3aWxsIGJlIHJlc29sdmVkIGludG8gYW4gYWJzb2x1dGUgVVJMIGluIHRoZSBjb250ZXh0IG9mIHRoZSBhcHBsaWNhdGlvbiBkb2N1bWVudC5cclxuICAgICAqIFBhcnNpbmcgbWVhbnMgdGhhdCB0aGUgYW5jaG9yIG5vZGUncyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQsIHBhdGhuYW1lIGFuZCByZWxhdGVkXHJcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBhbGwgcG9wdWxhdGVkIHRvIHJlZmxlY3QgdGhlIG5vcm1hbGl6ZWQgVVJMLiAgVGhpcyBhcHByb2FjaCBoYXMgd2lkZVxyXG4gICAgICogY29tcGF0aWJpbGl0eSAtIFNhZmFyaSAxKywgTW96aWxsYSAxKywgT3BlcmEgNyssZSBldGMuICBTZWVcclxuICAgICAqIGh0dHA6Ly93d3cuYXB0YW5hLmNvbS9yZWZlcmVuY2UvaHRtbC9hcGkvSFRNTEFuY2hvckVsZW1lbnQuaHRtbFxyXG4gICAgICpcclxuICAgICAqIEltcGxlbWVudGF0aW9uIE5vdGVzIGZvciBJRVxyXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgKiBJRSA+PSA4IGFuZCA8PSAxMCBub3JtYWxpemVzIHRoZSBVUkwgd2hlbiBhc3NpZ25lZCB0byB0aGUgYW5jaG9yIG5vZGUgc2ltaWxhciB0byB0aGUgb3RoZXJcclxuICAgICAqIGJyb3dzZXJzLiAgSG93ZXZlciwgdGhlIHBhcnNlZCBjb21wb25lbnRzIHdpbGwgbm90IGJlIHNldCBpZiB0aGUgVVJMIGFzc2lnbmVkIGRpZCBub3Qgc3BlY2lmeVxyXG4gICAgICogdGhlbS4gIChlLmcuIGlmIHlvdSBhc3NpZ24gYS5ocmVmID0gXCJmb29cIiwgdGhlbiBhLnByb3RvY29sLCBhLmhvc3QsIGV0Yy4gd2lsbCBiZSBlbXB0eS4pICBXZVxyXG4gICAgICogd29yayBhcm91bmQgdGhhdCBieSBwZXJmb3JtaW5nIHRoZSBwYXJzaW5nIGluIGEgMm5kIHN0ZXAgYnkgdGFraW5nIGEgcHJldmlvdXNseSBub3JtYWxpemVkXHJcbiAgICAgKiBVUkwgKGUuZy4gYnkgYXNzaW5pbmcgdG8gYS5ocmVmKSBhbmQgYXNzaWduaW5nIGl0IGEuaHJlZiBhZ2Fpbi4gIFRoaXMgY29ycmVjdGx5IHBvcHVsYXRlcyB0aGVcclxuICAgICAqIHByb3BlcnRpZXMgc3VjaCBhcyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQsIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBJRTcgZG9lcyBub3Qgbm9ybWFsaXplIHRoZSBVUkwgd2hlbiBhc3NpZ25lZCB0byBhbiBhbmNob3Igbm9kZS4gIChBcHBhcmVudGx5LCBpdCBkb2VzLCBpZiBvbmVcclxuICAgICAqIHVzZXMgdGhlIGlubmVyIEhUTUwgYXBwcm9hY2ggdG8gYXNzaWduIHRoZSBVUkwgYXMgcGFydCBvZiBhbiBIVE1MIHNuaXBwZXQgLVxyXG4gICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDcyNzI5KSAgSG93ZXZlciwgc2V0dGluZyBpbWdbc3JjXSBkb2VzIG5vcm1hbGl6ZSB0aGUgVVJMLlxyXG4gICAgICogVW5mb3J0dW5hdGVseSwgc2V0dGluZyBpbWdbc3JjXSB0byBzb21ldGhpbmcgbGlrZSBcImphdmFzY3JpcHQ6Zm9vXCIgb24gSUUgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cclxuICAgICAqIFNpbmNlIHRoZSBwcmltYXJ5IHVzYWdlIGZvciBub3JtYWxpemluZyBVUkxzIGlzIHRvIHNhbml0aXplIHN1Y2ggVVJMcywgd2UgY2FuJ3QgdXNlIHRoYXRcclxuICAgICAqIG1ldGhvZCBhbmQgSUUgPCA4IGlzIHVuc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIFJlZmVyZW5jZXM6XHJcbiAgICAgKiAgIGh0dHA6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxBbmNob3JFbGVtZW50XHJcbiAgICAgKiAgIGh0dHA6Ly93d3cuYXB0YW5hLmNvbS9yZWZlcmVuY2UvaHRtbC9hcGkvSFRNTEFuY2hvckVsZW1lbnQuaHRtbFxyXG4gICAgICogICBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcclxuICAgICAqICAgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9wdWxsLzI5MDJcclxuICAgICAqICAgaHR0cDovL2phbWVzLnBhZG9sc2V5LmNvbS9qYXZhc2NyaXB0L3BhcnNpbmctdXJscy13aXRoLXRoZS1kb20vXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhcnNlIFdoZW4gdHJ1ZSwgcmV0dXJucyBhbiBvYmplY3QgZm9yIHRoZSBwYXJzZWQgVVJMLiAgT3RoZXJ3aXNlLCByZXR1cm5zXHJcbiAgICAgKiAgIGEgc2luZ2xlIHN0cmluZyB0aGF0IGlzIHRoZSBub3JtYWxpemVkIFVSTC5cclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8c3RyaW5nfSBXaGVuIHBhcnNlIGlzIHRydWUsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgVVJMIGFzIGEgc3RyaW5nLlxyXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgbWVtYmVycy5cclxuICAgICAqXHJcbiAgICAgKiAgIHwgbWVtYmVyIG5hbWUgICB8IERlc2NyaXB0aW9uICAgIHxcclxuICAgICAqICAgfC0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgICogICB8IGhyZWYgICAgICAgICAgfCBBIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgcHJvdmlkZWQgVVJMIGlmIGl0IHdhcyBub3QgYW4gYWJzb2x1dGUgVVJMIHxcclxuICAgICAqICAgfCBwcm90b2NvbCAgICAgIHwgVGhlIHByb3RvY29sIGluY2x1ZGluZyB0aGUgdHJhaWxpbmcgY29sb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKiAgIHwgaG9zdCAgICAgICAgICB8IFRoZSBob3N0IGFuZCBwb3J0IChpZiB0aGUgcG9ydCBpcyBub24tZGVmYXVsdCkgb2YgdGhlIG5vcm1hbGl6ZWRVcmwgICAgfFxyXG4gICAgICpcclxuICAgICAqIFRoZXNlIGZpZWxkcyBmcm9tIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgYXJlIGN1cnJlbnRseSBub3QgbmVlZGVkIGFuZCBoZW5jZSBub3QgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogICB8IG1lbWJlciBuYW1lICAgfCBEZXNjcmlwdGlvbiAgICB8XHJcbiAgICAgKiAgIHwtLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLXxcclxuICAgICAqICAgfCBob3N0bmFtZSAgICAgIHwgVGhlIGhvc3Qgd2l0aG91dCB0aGUgcG9ydCBvZiB0aGUgbm9ybWFsaXplZFVybCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKiAgIHwgcGF0aG5hbWUgICAgICB8IFRoZSBwYXRoIGZvbGxvd2luZyB0aGUgaG9zdCBpbiB0aGUgbm9ybWFsaXplZFVybCAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICogICB8IGhhc2ggICAgICAgICAgfCBUaGUgVVJMIGhhc2ggaWYgcHJlc2VudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAqICAgfCBzZWFyY2ggICAgICAgIHwgVGhlIHF1ZXJ5IHN0cmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKHVybCwgcGFyc2UpIHtcclxuICAgICAgdmFyIGhyZWYgPSB1cmw7XHJcbiAgICAgIGlmIChtc2llIDw9IDExKSB7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIGJlZm9yZSBwYXJzZS4gIFJlZmVyIEltcGxlbWVudGF0aW9uIE5vdGVzIG9uIHdoeSB0aGlzIGlzXHJcbiAgICAgICAgLy8gZG9uZSBpbiB0d28gc3RlcHMgb24gSUUuXHJcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBocmVmKTtcclxuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcclxuICAgICAgfVxyXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcclxuXHJcbiAgICAgIGlmICghcGFyc2UpIHtcclxuICAgICAgICByZXR1cm4gdXJsUGFyc2luZ05vZGUuaHJlZjtcclxuICAgICAgfVxyXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcclxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wsXHJcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdFxyXG4gICAgICAgIC8vIEN1cnJlbnRseSB1bnVzZWQgYW5kIGhlbmNlIGNvbW1lbnRlZCBvdXQuXHJcbiAgICAgICAgLy8gaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxyXG4gICAgICAgIC8vIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXHJcbiAgICAgICAgLy8gcGF0aG5hbWU6IHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLFxyXG4gICAgICAgIC8vIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2gsXHJcbiAgICAgICAgLy8gc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2hcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxyXG4gICAgICAvKipcclxuICAgICAgICogUGFyc2UgYSByZXF1ZXN0IFVSTCBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHNhbWUtb3JpZ2luIHJlcXVlc3QgYXMgdGhlIGFwcGxpY2F0aW9uIGRvY3VtZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlcXVlc3RVcmwgVGhlIHVybCBvZiB0aGUgcmVxdWVzdCBhcyBhIHN0cmluZyB0aGF0IHdpbGwgYmUgcmVzb2x2ZWRcclxuICAgICAgICogb3IgYSBwYXJzZWQgVVJMIG9iamVjdC5cclxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgZm9yIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgYXBwbGljYXRpb24gZG9jdW1lbnQuXHJcbiAgICAgICAqL1xyXG4gICAgICBpc1NhbWVPcmlnaW46IGZ1bmN0aW9uIGlzU2FtZU9yaWdpbihyZXF1ZXN0VXJsKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh0eXBlb2YgcmVxdWVzdFVybCA9PT0gJ3N0cmluZycpID8gcmVzb2x2ZShyZXF1ZXN0VXJsLCB0cnVlKSA6IHJlcXVlc3RVcmw7XHJcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVybC5wcm90b2NvbCAmJlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVybC5ob3N0KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJHdpbmRvd1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSByZWZlcmVuY2UgdG8gdGhlIGJyb3dzZXIncyBgd2luZG93YCBvYmplY3QuIFdoaWxlIGB3aW5kb3dgXHJcbiAqIGlzIGdsb2JhbGx5IGF2YWlsYWJsZSBpbiBKYXZhU2NyaXB0LCBpdCBjYXVzZXMgdGVzdGFiaWxpdHkgcHJvYmxlbXMsIGJlY2F1c2VcclxuICogaXQgaXMgYSBnbG9iYWwgdmFyaWFibGUuIEluIGFuZ3VsYXIgd2UgYWx3YXlzIHJlZmVyIHRvIGl0IHRocm91Z2ggdGhlXHJcbiAqIGAkd2luZG93YCBzZXJ2aWNlLCBzbyBpdCBtYXkgYmUgb3ZlcnJpZGRlbiwgcmVtb3ZlZCBvciBtb2NrZWQgZm9yIHRlc3RpbmcuXHJcbiAqXHJcbiAqIEV4cHJlc3Npb25zLCBsaWtlIHRoZSBvbmUgZGVmaW5lZCBmb3IgdGhlIGBuZ0NsaWNrYCBkaXJlY3RpdmUgaW4gdGhlIGV4YW1wbGVcclxuICogYmVsb3csIGFyZSBldmFsdWF0ZWQgd2l0aCByZXNwZWN0IHRvIHRoZSBjdXJyZW50IHNjb3BlLiAgVGhlcmVmb3JlLCB0aGVyZSBpc1xyXG4gKiBubyByaXNrIG9mIGluYWR2ZXJ0ZW50bHkgY29kaW5nIGluIGEgZGVwZW5kZW5jeSBvbiBhIGdsb2JhbCB2YWx1ZSBpbiBzdWNoIGFuXHJcbiAqIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlLCAkd2luZG93KSB7XHJcbiAgICAgICAgICAgJHNjb3BlLiR3aW5kb3cgPSAkd2luZG93O1xyXG4gICAgICAgICAgICRzY29wZS5ncmVldGluZyA9ICdIZWxsbywgV29ybGQhJztcclxuICAgICAgICAgfVxyXG4gICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwiZ3JlZXRpbmdcIiAvPlxyXG4gICAgICAgICA8YnV0dG9uIG5nLWNsaWNrPVwiJHdpbmRvdy5hbGVydChncmVldGluZylcIj5BTEVSVDwvYnV0dG9uPlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgIGl0KCdzaG91bGQgZGlzcGxheSB0aGUgZ3JlZXRpbmcgaW4gdGhlIGlucHV0IGJveCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgaW5wdXQoJ2dyZWV0aW5nJykuZW50ZXIoJ0hlbGxvLCBFMkUgVGVzdHMnKTtcclxuICAgICAgIC8vIElmIHdlIGNsaWNrIHRoZSBidXR0b24gaXQgd2lsbCBibG9jayB0aGUgdGVzdCBydW5uZXJcclxuICAgICAgIC8vIGVsZW1lbnQoJzpidXR0b24nKS5jbGljaygpO1xyXG4gICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbmZ1bmN0aW9uICRXaW5kb3dQcm92aWRlcigpe1xyXG4gIHRoaXMuJGdldCA9IHZhbHVlRm4od2luZG93KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJGZpbHRlclByb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBGaWx0ZXJzIGFyZSBqdXN0IGZ1bmN0aW9ucyB3aGljaCB0cmFuc2Zvcm0gaW5wdXQgdG8gYW4gb3V0cHV0LiBIb3dldmVyIGZpbHRlcnMgbmVlZCB0byBiZSBEZXBlbmRlbmN5IEluamVjdGVkLiBUb1xyXG4gKiBhY2hpZXZlIHRoaXMgYSBmaWx0ZXIgZGVmaW5pdGlvbiBjb25zaXN0cyBvZiBhIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggaXMgYW5ub3RhdGVkIHdpdGggZGVwZW5kZW5jaWVzIGFuZCBpc1xyXG4gKiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYSBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqICAgLy8gRmlsdGVyIHJlZ2lzdHJhdGlvblxyXG4gKiAgIGZ1bmN0aW9uIE15TW9kdWxlKCRwcm92aWRlLCAkZmlsdGVyUHJvdmlkZXIpIHtcclxuICogICAgIC8vIGNyZWF0ZSBhIHNlcnZpY2UgdG8gZGVtb25zdHJhdGUgaW5qZWN0aW9uIChub3QgYWx3YXlzIG5lZWRlZClcclxuICogICAgICRwcm92aWRlLnZhbHVlKCdncmVldCcsIGZ1bmN0aW9uKG5hbWUpe1xyXG4gKiAgICAgICByZXR1cm4gJ0hlbGxvICcgKyBuYW1lICsgJyEnO1xyXG4gKiAgICAgfSk7XHJcbiAqXHJcbiAqICAgICAvLyByZWdpc3RlciBhIGZpbHRlciBmYWN0b3J5IHdoaWNoIHVzZXMgdGhlXHJcbiAqICAgICAvLyBncmVldCBzZXJ2aWNlIHRvIGRlbW9uc3RyYXRlIERJLlxyXG4gKiAgICAgJGZpbHRlclByb3ZpZGVyLnJlZ2lzdGVyKCdncmVldCcsIGZ1bmN0aW9uKGdyZWV0KXtcclxuICogICAgICAgLy8gcmV0dXJuIHRoZSBmaWx0ZXIgZnVuY3Rpb24gd2hpY2ggdXNlcyB0aGUgZ3JlZXQgc2VydmljZVxyXG4gKiAgICAgICAvLyB0byBnZW5lcmF0ZSBzYWx1dGF0aW9uXHJcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAqICAgICAgICAgLy8gZmlsdGVycyBuZWVkIHRvIGJlIGZvcmdpdmluZyBzbyBjaGVjayBpbnB1dCB2YWxpZGl0eVxyXG4gKiAgICAgICAgIHJldHVybiB0ZXh0ICYmIGdyZWV0KHRleHQpIHx8IHRleHQ7XHJcbiAqICAgICAgIH07XHJcbiAqICAgICB9KTtcclxuICogICB9XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBUaGUgZmlsdGVyIGZ1bmN0aW9uIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgYCRpbmplY3RvcmAgdW5kZXIgdGhlIGZpbHRlciBuYW1lIHN1ZmZpeCB3aXRoIGBGaWx0ZXJgLlxyXG4gKiA8cHJlPlxyXG4gKiAgIGl0KCdzaG91bGQgYmUgdGhlIHNhbWUgaW5zdGFuY2UnLCBpbmplY3QoXHJcbiAqICAgICBmdW5jdGlvbigkZmlsdGVyUHJvdmlkZXIpIHtcclxuICogICAgICAgJGZpbHRlclByb3ZpZGVyLnJlZ2lzdGVyKCdyZXZlcnNlJywgZnVuY3Rpb24oKXtcclxuICogICAgICAgICByZXR1cm4gLi4uO1xyXG4gKiAgICAgICB9KTtcclxuICogICAgIH0sXHJcbiAqICAgICBmdW5jdGlvbigkZmlsdGVyLCByZXZlcnNlRmlsdGVyKSB7XHJcbiAqICAgICAgIGV4cGVjdCgkZmlsdGVyKCdyZXZlcnNlJykpLnRvQmUocmV2ZXJzZUZpbHRlcik7XHJcbiAqICAgICB9KTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqXHJcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBhbmd1bGFyIGZpbHRlcnMgd29yaywgYW5kIGhvdyB0byBjcmVhdGUgeW91ciBvd24gZmlsdGVycywgc2VlXHJcbiAqIHtAbGluayBndWlkZS9kZXZfZ3VpZGUudGVtcGxhdGVzLmZpbHRlcnMgVW5kZXJzdGFuZGluZyBBbmd1bGFyIEZpbHRlcnN9IGluIHRoZSBhbmd1bGFyIERldmVsb3BlclxyXG4gKiBHdWlkZS5cclxuICovXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIG5nLiRmaWx0ZXJQcm92aWRlciNyZWdpc3RlclxyXG4gKiBAbWV0aG9kT2YgbmcuJGZpbHRlclByb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBSZWdpc3RlciBmaWx0ZXIgZmFjdG9yeSBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZmlsdGVyLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZmlsdGVyIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggaXMgaW5qZWN0YWJsZS5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy4kZmlsdGVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRmlsdGVycyBhcmUgdXNlZCBmb3IgZm9ybWF0dGluZyBkYXRhIGRpc3BsYXllZCB0byB0aGUgdXNlci5cclxuICpcclxuICogVGhlIGdlbmVyYWwgc3ludGF4IGluIHRlbXBsYXRlcyBpcyBhcyBmb2xsb3dzOlxyXG4gKlxyXG4gKiAgICAgICAgIHt7IGV4cHJlc3Npb24gW3wgZmlsdGVyX25hbWVbOnBhcmFtZXRlcl92YWx1ZV0gLi4uIF0gfX1cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZmlsdGVyIGZ1bmN0aW9uIHRvIHJldHJpZXZlXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgZmlsdGVyIGZ1bmN0aW9uXHJcbiAqL1xyXG4kRmlsdGVyUHJvdmlkZXIuJGluamVjdCA9IFsnJHByb3ZpZGUnXTtcclxuZnVuY3Rpb24gJEZpbHRlclByb3ZpZGVyKCRwcm92aWRlKSB7XHJcbiAgdmFyIHN1ZmZpeCA9ICdGaWx0ZXInO1xyXG5cclxuICBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gJHByb3ZpZGUuZmFjdG9yeShuYW1lICsgc3VmZml4LCBmYWN0b3J5KTtcclxuICB9XHJcbiAgdGhpcy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xyXG5cclxuICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsIGZ1bmN0aW9uKCRpbmplY3Rvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgcmV0dXJuICRpbmplY3Rvci5nZXQobmFtZSArIHN1ZmZpeCk7XHJcbiAgICB9XHJcbiAgfV07XHJcblxyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgcmVnaXN0ZXIoJ2N1cnJlbmN5JywgY3VycmVuY3lGaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCdkYXRlJywgZGF0ZUZpbHRlcik7XHJcbiAgcmVnaXN0ZXIoJ2ZpbHRlcicsIGZpbHRlckZpbHRlcik7XHJcbiAgcmVnaXN0ZXIoJ2pzb24nLCBqc29uRmlsdGVyKTtcclxuICByZWdpc3RlcignbGltaXRUbycsIGxpbWl0VG9GaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCdsb3dlcmNhc2UnLCBsb3dlcmNhc2VGaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCdudW1iZXInLCBudW1iZXJGaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCdvcmRlckJ5Jywgb3JkZXJCeUZpbHRlcik7XHJcbiAgcmVnaXN0ZXIoJ3VwcGVyY2FzZScsIHVwcGVyY2FzZUZpbHRlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZmlsdGVyXHJcbiAqIEBuYW1lIG5nLmZpbHRlcjpmaWx0ZXJcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTZWxlY3RzIGEgc3Vic2V0IG9mIGl0ZW1zIGZyb20gYGFycmF5YCBhbmQgcmV0dXJucyBpdCBhcyBhIG5ldyBhcnJheS5cclxuICpcclxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF1Z21lbnQgdGhlIGBBcnJheWAgdHlwZSBpbiBBbmd1bGFyIGV4cHJlc3Npb25zLiBTZWVcclxuICoge0BsaW5rIG5nLiRmaWx0ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IEFuZ3VsYXIgYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc291cmNlIGFycmF5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R8ZnVuY3Rpb24oKX0gZXhwcmVzc2lvbiBUaGUgcHJlZGljYXRlIHRvIGJlIHVzZWQgZm9yIHNlbGVjdGluZyBpdGVtcyBmcm9tXHJcbiAqICAgYGFycmF5YC5cclxuICpcclxuICogICBDYW4gYmUgb25lIG9mOlxyXG4gKlxyXG4gKiAgIC0gYHN0cmluZ2A6IFByZWRpY2F0ZSB0aGF0IHJlc3VsdHMgaW4gYSBzdWJzdHJpbmcgbWF0Y2ggdXNpbmcgdGhlIHZhbHVlIG9mIGBleHByZXNzaW9uYFxyXG4gKiAgICAgc3RyaW5nLiBBbGwgc3RyaW5ncyBvciBvYmplY3RzIHdpdGggc3RyaW5nIHByb3BlcnRpZXMgaW4gYGFycmF5YCB0aGF0IGNvbnRhaW4gdGhpcyBzdHJpbmdcclxuICogICAgIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBwcmVkaWNhdGUgY2FuIGJlIG5lZ2F0ZWQgYnkgcHJlZml4aW5nIHRoZSBzdHJpbmcgd2l0aCBgIWAuXHJcbiAqXHJcbiAqICAgLSBgT2JqZWN0YDogQSBwYXR0ZXJuIG9iamVjdCBjYW4gYmUgdXNlZCB0byBmaWx0ZXIgc3BlY2lmaWMgcHJvcGVydGllcyBvbiBvYmplY3RzIGNvbnRhaW5lZFxyXG4gKiAgICAgYnkgYGFycmF5YC4gRm9yIGV4YW1wbGUgYHtuYW1lOlwiTVwiLCBwaG9uZTpcIjFcIn1gIHByZWRpY2F0ZSB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBpdGVtc1xyXG4gKiAgICAgd2hpY2ggaGF2ZSBwcm9wZXJ0eSBgbmFtZWAgY29udGFpbmluZyBcIk1cIiBhbmQgcHJvcGVydHkgYHBob25lYCBjb250YWluaW5nIFwiMVwiLiBBIHNwZWNpYWxcclxuICogICAgIHByb3BlcnR5IG5hbWUgYCRgIGNhbiBiZSB1c2VkIChhcyBpbiBgeyQ6XCJ0ZXh0XCJ9YCkgdG8gYWNjZXB0IGEgbWF0Y2ggYWdhaW5zdCBhbnlcclxuICogICAgIHByb3BlcnR5IG9mIHRoZSBvYmplY3QuIFRoYXQncyBlcXVpdmFsZW50IHRvIHRoZSBzaW1wbGUgc3Vic3RyaW5nIG1hdGNoIHdpdGggYSBgc3RyaW5nYFxyXG4gKiAgICAgYXMgZGVzY3JpYmVkIGFib3ZlLlxyXG4gKlxyXG4gKiAgIC0gYGZ1bmN0aW9uYDogQSBwcmVkaWNhdGUgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gd3JpdGUgYXJiaXRyYXJ5IGZpbHRlcnMuIFRoZSBmdW5jdGlvbiBpc1xyXG4gKiAgICAgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YC4gVGhlIGZpbmFsIHJlc3VsdCBpcyBhbiBhcnJheSBvZiB0aG9zZSBlbGVtZW50cyB0aGF0XHJcbiAqICAgICB0aGUgcHJlZGljYXRlIHJldHVybmVkIHRydWUgZm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGV4cGVjdGVkLCBhY3R1YWwpfHRydWV8dW5kZWZpbmVkfSBjb21wYXJhdG9yIENvbXBhcmF0b3Igd2hpY2ggaXMgdXNlZCBpblxyXG4gKiAgICAgZGV0ZXJtaW5pbmcgaWYgdGhlIGV4cGVjdGVkIHZhbHVlIChmcm9tIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbikgYW5kIGFjdHVhbCB2YWx1ZSAoZnJvbVxyXG4gKiAgICAgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXkpIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbWF0Y2guXHJcbiAqXHJcbiAqICAgQ2FuIGJlIG9uZSBvZjpcclxuICpcclxuICogICAgIC0gYGZ1bmN0aW9uKGV4cGVjdGVkLCBhY3R1YWwpYDpcclxuICogICAgICAgVGhlIGZ1bmN0aW9uIHdpbGwgYmUgZ2l2ZW4gdGhlIG9iamVjdCB2YWx1ZSBhbmQgdGhlIHByZWRpY2F0ZSB2YWx1ZSB0byBjb21wYXJlIGFuZFxyXG4gKiAgICAgICBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGluY2x1ZGVkIGluIGZpbHRlcmVkIHJlc3VsdC5cclxuICpcclxuICogICAgIC0gYHRydWVgOiBBIHNob3J0aGFuZCBmb3IgYGZ1bmN0aW9uKGV4cGVjdGVkLCBhY3R1YWwpIHsgcmV0dXJuIGFuZ3VsYXIuZXF1YWxzKGV4cGVjdGVkLCBhY3R1YWwpfWAuXHJcbiAqICAgICAgIHRoaXMgaXMgZXNzZW50aWFsbHkgc3RyaWN0IGNvbXBhcmlzb24gb2YgZXhwZWN0ZWQgYW5kIGFjdHVhbC5cclxuICpcclxuICogICAgIC0gYGZhbHNlfHVuZGVmaW5lZGA6IEEgc2hvcnQgaGFuZCBmb3IgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGxvb2sgZm9yIGEgc3Vic3RyaW5nIG1hdGNoIGluIGNhc2VcclxuICogICAgICAgaW5zZW5zaXRpdmUgd2F5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8ZGl2IG5nLWluaXQ9XCJmcmllbmRzID0gW3tuYW1lOidKb2huJywgcGhvbmU6JzU1NS0xMjc2J30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6J01hcnknLCBwaG9uZTonODAwLUJJRy1NQVJZJ30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6J01pa2UnLCBwaG9uZTonNTU1LTQzMjEnfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTonQWRhbScsIHBob25lOic1NTUtNTY3OCd9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidKdWxpZScsIHBob25lOic1NTUtODc2NSd9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidKdWxpZXR0ZScsIHBob25lOic1NTUtNTY3OCd9XVwiPjwvZGl2PlxyXG5cclxuICAgICAgIFNlYXJjaDogPGlucHV0IG5nLW1vZGVsPVwic2VhcmNoVGV4dFwiPlxyXG4gICAgICAgPHRhYmxlIGlkPVwic2VhcmNoVGV4dFJlc3VsdHNcIj5cclxuICAgICAgICAgPHRyPjx0aD5OYW1lPC90aD48dGg+UGhvbmU8L3RoPjwvdHI+XHJcbiAgICAgICAgIDx0ciBuZy1yZXBlYXQ9XCJmcmllbmQgaW4gZnJpZW5kcyB8IGZpbHRlcjpzZWFyY2hUZXh0XCI+XHJcbiAgICAgICAgICAgPHRkPnt7ZnJpZW5kLm5hbWV9fTwvdGQ+XHJcbiAgICAgICAgICAgPHRkPnt7ZnJpZW5kLnBob25lfX08L3RkPlxyXG4gICAgICAgICA8L3RyPlxyXG4gICAgICAgPC90YWJsZT5cclxuICAgICAgIDxocj5cclxuICAgICAgIEFueTogPGlucHV0IG5nLW1vZGVsPVwic2VhcmNoLiRcIj4gPGJyPlxyXG4gICAgICAgTmFtZSBvbmx5IDxpbnB1dCBuZy1tb2RlbD1cInNlYXJjaC5uYW1lXCI+PGJyPlxyXG4gICAgICAgUGhvbmUgb25seSA8aW5wdXQgbmctbW9kZWw9XCJzZWFyY2gucGhvbmVcIj48YnI+XHJcbiAgICAgICBFcXVhbGl0eSA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJzdHJpY3RcIj48YnI+XHJcbiAgICAgICA8dGFibGUgaWQ9XCJzZWFyY2hPYmpSZXN1bHRzXCI+XHJcbiAgICAgICAgIDx0cj48dGg+TmFtZTwvdGg+PHRoPlBob25lPC90aD48L3RyPlxyXG4gICAgICAgICA8dHIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBmaWx0ZXI6c2VhcmNoOnN0cmljdFwiPlxyXG4gICAgICAgICAgIDx0ZD57e2ZyaWVuZC5uYW1lfX08L3RkPlxyXG4gICAgICAgICAgIDx0ZD57e2ZyaWVuZC5waG9uZX19PC90ZD5cclxuICAgICAgICAgPC90cj5cclxuICAgICAgIDwvdGFibGU+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIHNlYXJjaCBhY3Jvc3MgYWxsIGZpZWxkcyB3aGVuIGZpbHRlcmluZyB3aXRoIGEgc3RyaW5nJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGlucHV0KCdzZWFyY2hUZXh0JykuZW50ZXIoJ20nKTtcclxuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCcjc2VhcmNoVGV4dFJlc3VsdHMgdHInLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5uYW1lJykpLlxyXG4gICAgICAgICAgIHRvRXF1YWwoWydNYXJ5JywgJ01pa2UnLCAnQWRhbSddKTtcclxuXHJcbiAgICAgICAgIGlucHV0KCdzZWFyY2hUZXh0JykuZW50ZXIoJzc2Jyk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcignI3NlYXJjaFRleHRSZXN1bHRzIHRyJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnSm9obicsICdKdWxpZSddKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAgIGl0KCdzaG91bGQgc2VhcmNoIGluIHNwZWNpZmljIGZpZWxkcyB3aGVuIGZpbHRlcmluZyB3aXRoIGEgcHJlZGljYXRlIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgnc2VhcmNoLiQnKS5lbnRlcignaScpO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJyNzZWFyY2hPYmpSZXN1bHRzIHRyJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnTWFyeScsICdNaWtlJywgJ0p1bGllJywgJ0p1bGlldHRlJ10pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgICBpdCgnc2hvdWxkIHVzZSBhIGVxdWFsIGNvbXBhcmlzb24gd2hlbiBjb21wYXJhdG9yIGlzIHRydWUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgaW5wdXQoJ3NlYXJjaC5uYW1lJykuZW50ZXIoJ0p1bGllJyk7XHJcbiAgICAgICAgIGlucHV0KCdzdHJpY3QnKS5jaGVjaygpO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJyNzZWFyY2hPYmpSZXN1bHRzIHRyJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnSnVsaWUnXSk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbmZ1bmN0aW9uIGZpbHRlckZpbHRlcigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGV4cHJlc3Npb24sIGNvbXBlcmF0b3IpIHtcclxuICAgIGlmICghaXNBcnJheShhcnJheSkpIHJldHVybiBhcnJheTtcclxuICAgIHZhciBwcmVkaWNhdGVzID0gW107XHJcbiAgICBwcmVkaWNhdGVzLmNoZWNrID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmVkaWNhdGVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYoIXByZWRpY2F0ZXNbal0odmFsdWUpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHN3aXRjaCh0eXBlb2YgY29tcGVyYXRvcikge1xyXG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgICBpZihjb21wZXJhdG9yID09IHRydWUpIHtcclxuICAgICAgICAgIGNvbXBlcmF0b3IgPSBmdW5jdGlvbihvYmosIHRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZXF1YWxzKG9iaiwgdGV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgY29tcGVyYXRvciA9IGZ1bmN0aW9uKG9iaiwgdGV4dCkge1xyXG4gICAgICAgICAgdGV4dCA9ICgnJyt0ZXh0KS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgcmV0dXJuICgnJytvYmopLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0ZXh0KSA+IC0xXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbihvYmosIHRleHQpe1xyXG4gICAgICBpZiAodHlwZW9mIHRleHQgPT0gJ3N0cmluZycgJiYgdGV4dC5jaGFyQXQoMCkgPT09ICchJykge1xyXG4gICAgICAgIHJldHVybiAhc2VhcmNoKG9iaiwgdGV4dC5zdWJzdHIoMSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xyXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgIHJldHVybiBjb21wZXJhdG9yKG9iaiwgdGV4dCk7XHJcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgdGV4dCkge1xyXG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBlcmF0b3Iob2JqLCB0ZXh0KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBmb3IgKCB2YXIgb2JqS2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iaktleS5jaGFyQXQoMCkgIT09ICckJyAmJiBzZWFyY2gob2JqW29iaktleV0sIHRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcclxuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoc2VhcmNoKG9ialtpXSwgdGV4dCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiBleHByZXNzaW9uKSB7XHJcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgIGV4cHJlc3Npb24gPSB7JDpleHByZXNzaW9ufTtcclxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICBpZiAoa2V5ID09ICckJykge1xyXG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFleHByZXNzaW9uW2tleV0pIHJldHVybjtcclxuICAgICAgICAgICAgICB2YXIgcGF0aCA9IGtleVxyXG4gICAgICAgICAgICAgIHByZWRpY2F0ZXMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaCh2YWx1ZSwgZXhwcmVzc2lvbltwYXRoXSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZihleHByZXNzaW9uW2tleV0pID09ICd1bmRlZmluZWQnKSB7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgIHZhciBwYXRoID0ga2V5O1xyXG4gICAgICAgICAgICAgIHByZWRpY2F0ZXMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaChnZXR0ZXIodmFsdWUscGF0aCksIGV4cHJlc3Npb25bcGF0aF0pO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG4gICAgICAgIHByZWRpY2F0ZXMucHVzaChleHByZXNzaW9uKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICB2YXIgZmlsdGVyZWQgPSBbXTtcclxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2pdO1xyXG4gICAgICBpZiAocHJlZGljYXRlcy5jaGVjayh2YWx1ZSkpIHtcclxuICAgICAgICBmaWx0ZXJlZC5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbHRlcmVkO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmaWx0ZXJcclxuICogQG5hbWUgbmcuZmlsdGVyOmN1cnJlbmN5XHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRm9ybWF0cyBhIG51bWJlciBhcyBhIGN1cnJlbmN5IChpZSAkMSwyMzQuNTYpLiBXaGVuIG5vIGN1cnJlbmN5IHN5bWJvbCBpcyBwcm92aWRlZCwgZGVmYXVsdFxyXG4gKiBzeW1ib2wgZm9yIGN1cnJlbnQgbG9jYWxlIGlzIHVzZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgSW5wdXQgdG8gZmlsdGVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHN5bWJvbCBDdXJyZW5jeSBzeW1ib2wgb3IgaWRlbnRpZmllciB0byBiZSBkaXNwbGF5ZWQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBudW1iZXIuXHJcbiAqXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgJHNjb3BlLmFtb3VudCA9IDEyMzQuNTY7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5nLW1vZGVsPVwiYW1vdW50XCI+IDxicj5cclxuICAgICAgICAgZGVmYXVsdCBjdXJyZW5jeSBzeW1ib2wgKCQpOiB7e2Ftb3VudCB8IGN1cnJlbmN5fX08YnI+XHJcbiAgICAgICAgIGN1c3RvbSBjdXJyZW5jeSBpZGVudGlmaWVyIChVU0QkKToge3thbW91bnQgfCBjdXJyZW5jeTpcIlVTRCRcIn19XHJcbiAgICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgaW5pdCB3aXRoIDEyMzQuNTYnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2Ftb3VudCB8IGN1cnJlbmN5JykpLnRvQmUoJyQxLDIzNC41NicpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnYW1vdW50IHwgY3VycmVuY3k6XCJVU0QkXCInKSkudG9CZSgnVVNEJDEsMjM0LjU2Jyk7XHJcbiAgICAgICB9KTtcclxuICAgICAgIGl0KCdzaG91bGQgdXBkYXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGlucHV0KCdhbW91bnQnKS5lbnRlcignLTEyMzQnKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2Ftb3VudCB8IGN1cnJlbmN5JykpLnRvQmUoJygkMSwyMzQuMDApJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdhbW91bnQgfCBjdXJyZW5jeTpcIlVTRCRcIicpKS50b0JlKCcoVVNEJDEsMjM0LjAwKScpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5jdXJyZW5jeUZpbHRlci4kaW5qZWN0ID0gWyckbG9jYWxlJ107XHJcbmZ1bmN0aW9uIGN1cnJlbmN5RmlsdGVyKCRsb2NhbGUpIHtcclxuICB2YXIgZm9ybWF0cyA9ICRsb2NhbGUuTlVNQkVSX0ZPUk1BVFM7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGFtb3VudCwgY3VycmVuY3lTeW1ib2wpe1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKGN1cnJlbmN5U3ltYm9sKSkgY3VycmVuY3lTeW1ib2wgPSBmb3JtYXRzLkNVUlJFTkNZX1NZTTtcclxuICAgIHJldHVybiBmb3JtYXROdW1iZXIoYW1vdW50LCBmb3JtYXRzLlBBVFRFUk5TWzFdLCBmb3JtYXRzLkdST1VQX1NFUCwgZm9ybWF0cy5ERUNJTUFMX1NFUCwgMikuXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlKC9cXHUwMEE0L2csIGN1cnJlbmN5U3ltYm9sKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZpbHRlclxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6bnVtYmVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRm9ybWF0cyBhIG51bWJlciBhcyB0ZXh0LlxyXG4gKlxyXG4gKiBJZiB0aGUgaW5wdXQgaXMgbm90IGEgbnVtYmVyIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgTnVtYmVyIHRvIGZvcm1hdC5cclxuICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyk9fSBmcmFjdGlvblNpemUgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHJvdW5kIHRoZSBudW1iZXIgdG8uXHJcbiAqIElmIHRoaXMgaXMgbm90IHByb3ZpZGVkIHRoZW4gdGhlIGZyYWN0aW9uIHNpemUgaXMgY29tcHV0ZWQgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUncyBudW1iZXJcclxuICogZm9ybWF0dGluZyBwYXR0ZXJuLiBJbiB0aGUgY2FzZSBvZiB0aGUgZGVmYXVsdCBsb2NhbGUsIGl0IHdpbGwgYmUgMy5cclxuICogQHJldHVybnMge3N0cmluZ30gTnVtYmVyIHJvdW5kZWQgdG8gZGVjaW1hbFBsYWNlcyBhbmQgcGxhY2VzIGEgw6LigqzFkyzDouKCrMKdIGFmdGVyIGVhY2ggdGhpcmQgZGlnaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgJHNjb3BlLnZhbCA9IDEyMzQuNTY3ODk7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICBFbnRlciBudW1iZXI6IDxpbnB1dCBuZy1tb2RlbD0ndmFsJz48YnI+XHJcbiAgICAgICAgIERlZmF1bHQgZm9ybWF0dGluZzoge3t2YWwgfCBudW1iZXJ9fTxicj5cclxuICAgICAgICAgTm8gZnJhY3Rpb25zOiB7e3ZhbCB8IG51bWJlcjowfX08YnI+XHJcbiAgICAgICAgIE5lZ2F0aXZlIG51bWJlcjoge3stdmFsIHwgbnVtYmVyOjR9fVxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGZvcm1hdCBudW1iZXJzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWwgfCBudW1iZXInKSkudG9CZSgnMSwyMzQuNTY4Jyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWwgfCBudW1iZXI6MCcpKS50b0JlKCcxLDIzNScpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnLXZhbCB8IG51bWJlcjo0JykpLnRvQmUoJy0xLDIzNC41Njc5Jyk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgndmFsJykuZW50ZXIoJzMzNzQuMzMzJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWwgfCBudW1iZXInKSkudG9CZSgnMywzNzQuMzMzJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWwgfCBudW1iZXI6MCcpKS50b0JlKCczLDM3NCcpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnLXZhbCB8IG51bWJlcjo0JykpLnRvQmUoJy0zLDM3NC4zMzMwJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcblxyXG5cclxubnVtYmVyRmlsdGVyLiRpbmplY3QgPSBbJyRsb2NhbGUnXTtcclxuZnVuY3Rpb24gbnVtYmVyRmlsdGVyKCRsb2NhbGUpIHtcclxuICB2YXIgZm9ybWF0cyA9ICRsb2NhbGUuTlVNQkVSX0ZPUk1BVFM7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgZnJhY3Rpb25TaXplKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKG51bWJlciwgZm9ybWF0cy5QQVRURVJOU1swXSwgZm9ybWF0cy5HUk9VUF9TRVAsIGZvcm1hdHMuREVDSU1BTF9TRVAsXHJcbiAgICAgIGZyYWN0aW9uU2l6ZSk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIERFQ0lNQUxfU0VQID0gJy4nO1xyXG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBwYXR0ZXJuLCBncm91cFNlcCwgZGVjaW1hbFNlcCwgZnJhY3Rpb25TaXplKSB7XHJcbiAgaWYgKGlzTmFOKG51bWJlcikgfHwgIWlzRmluaXRlKG51bWJlcikpIHJldHVybiAnJztcclxuXHJcbiAgdmFyIGlzTmVnYXRpdmUgPSBudW1iZXIgPCAwO1xyXG4gIG51bWJlciA9IE1hdGguYWJzKG51bWJlcik7XHJcbiAgdmFyIG51bVN0ciA9IG51bWJlciArICcnLFxyXG4gICAgICBmb3JtYXRlZFRleHQgPSAnJyxcclxuICAgICAgcGFydHMgPSBbXTtcclxuXHJcbiAgdmFyIGhhc0V4cG9uZW50ID0gZmFsc2U7XHJcbiAgaWYgKG51bVN0ci5pbmRleE9mKCdlJykgIT09IC0xKSB7XHJcbiAgICB2YXIgbWF0Y2ggPSBudW1TdHIubWF0Y2goLyhbXFxkXFwuXSspZSgtPykoXFxkKykvKTtcclxuICAgIGlmIChtYXRjaCAmJiBtYXRjaFsyXSA9PSAnLScgJiYgbWF0Y2hbM10gPiBmcmFjdGlvblNpemUgKyAxKSB7XHJcbiAgICAgIG51bVN0ciA9ICcwJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvcm1hdGVkVGV4dCA9IG51bVN0cjtcclxuICAgICAgaGFzRXhwb25lbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFoYXNFeHBvbmVudCkge1xyXG4gICAgdmFyIGZyYWN0aW9uTGVuID0gKG51bVN0ci5zcGxpdChERUNJTUFMX1NFUClbMV0gfHwgJycpLmxlbmd0aDtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgZnJhY3Rpb25TaXplIGlmIGl0IGlzIG5vdCBzcGVjaWZpZWRcclxuICAgIGlmIChpc1VuZGVmaW5lZChmcmFjdGlvblNpemUpKSB7XHJcbiAgICAgIGZyYWN0aW9uU2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KHBhdHRlcm4ubWluRnJhYywgZnJhY3Rpb25MZW4pLCBwYXR0ZXJuLm1heEZyYWMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwb3cgPSBNYXRoLnBvdygxMCwgZnJhY3Rpb25TaXplKTtcclxuICAgIG51bWJlciA9IE1hdGgucm91bmQobnVtYmVyICogcG93KSAvIHBvdztcclxuICAgIHZhciBmcmFjdGlvbiA9ICgnJyArIG51bWJlcikuc3BsaXQoREVDSU1BTF9TRVApO1xyXG4gICAgdmFyIHdob2xlID0gZnJhY3Rpb25bMF07XHJcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uWzFdIHx8ICcnO1xyXG5cclxuICAgIHZhciBwb3MgPSAwLFxyXG4gICAgICAgIGxncm91cCA9IHBhdHRlcm4ubGdTaXplLFxyXG4gICAgICAgIGdyb3VwID0gcGF0dGVybi5nU2l6ZTtcclxuXHJcbiAgICBpZiAod2hvbGUubGVuZ3RoID49IChsZ3JvdXAgKyBncm91cCkpIHtcclxuICAgICAgcG9zID0gd2hvbGUubGVuZ3RoIC0gbGdyb3VwO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvczsgaSsrKSB7XHJcbiAgICAgICAgaWYgKChwb3MgLSBpKSVncm91cCA9PT0gMCAmJiBpICE9PSAwKSB7XHJcbiAgICAgICAgICBmb3JtYXRlZFRleHQgKz0gZ3JvdXBTZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdGVkVGV4dCArPSB3aG9sZS5jaGFyQXQoaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSBwb3M7IGkgPCB3aG9sZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoKHdob2xlLmxlbmd0aCAtIGkpJWxncm91cCA9PT0gMCAmJiBpICE9PSAwKSB7XHJcbiAgICAgICAgZm9ybWF0ZWRUZXh0ICs9IGdyb3VwU2VwO1xyXG4gICAgICB9XHJcbiAgICAgIGZvcm1hdGVkVGV4dCArPSB3aG9sZS5jaGFyQXQoaSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9ybWF0IGZyYWN0aW9uIHBhcnQuXHJcbiAgICB3aGlsZShmcmFjdGlvbi5sZW5ndGggPCBmcmFjdGlvblNpemUpIHtcclxuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmcmFjdGlvblNpemUgJiYgZnJhY3Rpb25TaXplICE9PSBcIjBcIikgZm9ybWF0ZWRUZXh0ICs9IGRlY2ltYWxTZXAgKyBmcmFjdGlvbi5zdWJzdHIoMCwgZnJhY3Rpb25TaXplKTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIGlmIChmcmFjdGlvblNpemUgPiAwICYmIG51bWJlciA+IC0xICYmIG51bWJlciA8IDEpIHtcclxuICAgICAgZm9ybWF0ZWRUZXh0ID0gbnVtYmVyLnRvRml4ZWQoZnJhY3Rpb25TaXplKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBhcnRzLnB1c2goaXNOZWdhdGl2ZSA/IHBhdHRlcm4ubmVnUHJlIDogcGF0dGVybi5wb3NQcmUpO1xyXG4gIHBhcnRzLnB1c2goZm9ybWF0ZWRUZXh0KTtcclxuICBwYXJ0cy5wdXNoKGlzTmVnYXRpdmUgPyBwYXR0ZXJuLm5lZ1N1ZiA6IHBhdHRlcm4ucG9zU3VmKTtcclxuICByZXR1cm4gcGFydHMuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhZE51bWJlcihudW0sIGRpZ2l0cywgdHJpbSkge1xyXG4gIHZhciBuZWcgPSAnJztcclxuICBpZiAobnVtIDwgMCkge1xyXG4gICAgbmVnID0gICctJztcclxuICAgIG51bSA9IC1udW07XHJcbiAgfVxyXG4gIG51bSA9ICcnICsgbnVtO1xyXG4gIHdoaWxlKG51bS5sZW5ndGggPCBkaWdpdHMpIG51bSA9ICcwJyArIG51bTtcclxuICBpZiAodHJpbSlcclxuICAgIG51bSA9IG51bS5zdWJzdHIobnVtLmxlbmd0aCAtIGRpZ2l0cyk7XHJcbiAgcmV0dXJuIG5lZyArIG51bTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGRhdGVHZXR0ZXIobmFtZSwgc2l6ZSwgb2Zmc2V0LCB0cmltKSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgIHZhciB2YWx1ZSA9IGRhdGVbJ2dldCcgKyBuYW1lXSgpO1xyXG4gICAgaWYgKG9mZnNldCA+IDAgfHwgdmFsdWUgPiAtb2Zmc2V0KVxyXG4gICAgICB2YWx1ZSArPSBvZmZzZXQ7XHJcbiAgICBpZiAodmFsdWUgPT09IDAgJiYgb2Zmc2V0ID09IC0xMiApIHZhbHVlID0gMTI7XHJcbiAgICByZXR1cm4gcGFkTnVtYmVyKHZhbHVlLCBzaXplLCB0cmltKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkYXRlU3RyR2V0dGVyKG5hbWUsIHNob3J0Rm9ybSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihkYXRlLCBmb3JtYXRzKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBkYXRlWydnZXQnICsgbmFtZV0oKTtcclxuICAgIHZhciBnZXQgPSB1cHBlcmNhc2Uoc2hvcnRGb3JtID8gKCdTSE9SVCcgKyBuYW1lKSA6IG5hbWUpO1xyXG5cclxuICAgIHJldHVybiBmb3JtYXRzW2dldF1bdmFsdWVdO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRpbWVab25lR2V0dGVyKGRhdGUpIHtcclxuICB2YXIgem9uZSA9IC0xICogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gIHZhciBwYWRkZWRab25lID0gKHpvbmUgPj0gMCkgPyBcIitcIiA6IFwiXCI7XHJcblxyXG4gIHBhZGRlZFpvbmUgKz0gcGFkTnVtYmVyKE1hdGhbem9uZSA+IDAgPyAnZmxvb3InIDogJ2NlaWwnXSh6b25lIC8gNjApLCAyKSArXHJcbiAgICAgICAgICAgICAgICBwYWROdW1iZXIoTWF0aC5hYnMoem9uZSAlIDYwKSwgMik7XHJcblxyXG4gIHJldHVybiBwYWRkZWRab25lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbXBtR2V0dGVyKGRhdGUsIGZvcm1hdHMpIHtcclxuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBmb3JtYXRzLkFNUE1TWzBdIDogZm9ybWF0cy5BTVBNU1sxXTtcclxufVxyXG5cclxudmFyIERBVEVfRk9STUFUUyA9IHtcclxuICB5eXl5OiBkYXRlR2V0dGVyKCdGdWxsWWVhcicsIDQpLFxyXG4gICAgeXk6IGRhdGVHZXR0ZXIoJ0Z1bGxZZWFyJywgMiwgMCwgdHJ1ZSksXHJcbiAgICAgeTogZGF0ZUdldHRlcignRnVsbFllYXInLCAxKSxcclxuICBNTU1NOiBkYXRlU3RyR2V0dGVyKCdNb250aCcpLFxyXG4gICBNTU06IGRhdGVTdHJHZXR0ZXIoJ01vbnRoJywgdHJ1ZSksXHJcbiAgICBNTTogZGF0ZUdldHRlcignTW9udGgnLCAyLCAxKSxcclxuICAgICBNOiBkYXRlR2V0dGVyKCdNb250aCcsIDEsIDEpLFxyXG4gICAgZGQ6IGRhdGVHZXR0ZXIoJ0RhdGUnLCAyKSxcclxuICAgICBkOiBkYXRlR2V0dGVyKCdEYXRlJywgMSksXHJcbiAgICBISDogZGF0ZUdldHRlcignSG91cnMnLCAyKSxcclxuICAgICBIOiBkYXRlR2V0dGVyKCdIb3VycycsIDEpLFxyXG4gICAgaGg6IGRhdGVHZXR0ZXIoJ0hvdXJzJywgMiwgLTEyKSxcclxuICAgICBoOiBkYXRlR2V0dGVyKCdIb3VycycsIDEsIC0xMiksXHJcbiAgICBtbTogZGF0ZUdldHRlcignTWludXRlcycsIDIpLFxyXG4gICAgIG06IGRhdGVHZXR0ZXIoJ01pbnV0ZXMnLCAxKSxcclxuICAgIHNzOiBkYXRlR2V0dGVyKCdTZWNvbmRzJywgMiksXHJcbiAgICAgczogZGF0ZUdldHRlcignU2Vjb25kcycsIDEpLFxyXG4gICAgIC8vIHdoaWxlIElTTyA4NjAxIHJlcXVpcmVzIGZyYWN0aW9ucyB0byBiZSBwcmVmaXhlZCB3aXRoIGAuYCBvciBgLGBcclxuICAgICAvLyB3ZSBjYW4gYmUganVzdCBzYWZlbHkgcmVseSBvbiB1c2luZyBgc3NzYCBzaW5jZSB3ZSBjdXJyZW50bHkgZG9uJ3Qgc3VwcG9ydCBzaW5nbGUgb3IgdHdvIGRpZ2l0IGZyYWN0aW9uc1xyXG4gICBzc3M6IGRhdGVHZXR0ZXIoJ01pbGxpc2Vjb25kcycsIDMpLFxyXG4gIEVFRUU6IGRhdGVTdHJHZXR0ZXIoJ0RheScpLFxyXG4gICBFRUU6IGRhdGVTdHJHZXR0ZXIoJ0RheScsIHRydWUpLFxyXG4gICAgIGE6IGFtcG1HZXR0ZXIsXHJcbiAgICAgWjogdGltZVpvbmVHZXR0ZXJcclxufTtcclxuXHJcbnZhciBEQVRFX0ZPUk1BVFNfU1BMSVQgPSAvKCg/OlteeU1kSGhtc2FaRSddKyl8KD86Jyg/OlteJ118JycpKicpfCg/OkUrfHkrfE0rfGQrfEgrfGgrfG0rfHMrfGF8WikpKC4qKS8sXHJcbiAgICBOVU1CRVJfU1RSSU5HID0gL15cXGQrJC87XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZpbHRlclxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6ZGF0ZVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgRm9ybWF0cyBgZGF0ZWAgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBgZm9ybWF0YC5cclxuICpcclxuICogICBgZm9ybWF0YCBzdHJpbmcgY2FuIGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZWxlbWVudHM6XHJcbiAqXHJcbiAqICAgKiBgJ3l5eXknYDogNCBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiB5ZWFyIChlLmcuIEFEIDEgPT4gMDAwMSwgQUQgMjAxMCA9PiAyMDEwKVxyXG4gKiAgICogYCd5eSdgOiAyIGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHllYXIsIHBhZGRlZCAoMDAtOTkpLiAoZS5nLiBBRCAyMDAxID0+IDAxLCBBRCAyMDEwID0+IDEwKVxyXG4gKiAgICogYCd5J2A6IDEgZGlnaXQgcmVwcmVzZW50YXRpb24gb2YgeWVhciwgZS5nLiAoQUQgMSA9PiAxLCBBRCAxOTkgPT4gMTk5KVxyXG4gKiAgICogYCdNTU1NJ2A6IE1vbnRoIGluIHllYXIgKEphbnVhcnktRGVjZW1iZXIpXHJcbiAqICAgKiBgJ01NTSdgOiBNb250aCBpbiB5ZWFyIChKYW4tRGVjKVxyXG4gKiAgICogYCdNTSdgOiBNb250aCBpbiB5ZWFyLCBwYWRkZWQgKDAxLTEyKVxyXG4gKiAgICogYCdNJ2A6IE1vbnRoIGluIHllYXIgKDEtMTIpXHJcbiAqICAgKiBgJ2RkJ2A6IERheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMSlcclxuICogICAqIGAnZCdgOiBEYXkgaW4gbW9udGggKDEtMzEpXHJcbiAqICAgKiBgJ0VFRUUnYDogRGF5IGluIFdlZWssKFN1bmRheS1TYXR1cmRheSlcclxuICogICAqIGAnRUVFJ2A6IERheSBpbiBXZWVrLCAoU3VuLVNhdClcclxuICogICAqIGAnSEgnYDogSG91ciBpbiBkYXksIHBhZGRlZCAoMDAtMjMpXHJcbiAqICAgKiBgJ0gnYDogSG91ciBpbiBkYXkgKDAtMjMpXHJcbiAqICAgKiBgJ2hoJ2A6IEhvdXIgaW4gYW0vcG0sIHBhZGRlZCAoMDEtMTIpXHJcbiAqICAgKiBgJ2gnYDogSG91ciBpbiBhbS9wbSwgKDEtMTIpXHJcbiAqICAgKiBgJ21tJ2A6IE1pbnV0ZSBpbiBob3VyLCBwYWRkZWQgKDAwLTU5KVxyXG4gKiAgICogYCdtJ2A6IE1pbnV0ZSBpbiBob3VyICgwLTU5KVxyXG4gKiAgICogYCdzcydgOiBTZWNvbmQgaW4gbWludXRlLCBwYWRkZWQgKDAwLTU5KVxyXG4gKiAgICogYCdzJ2A6IFNlY29uZCBpbiBtaW51dGUgKDAtNTkpXHJcbiAqICAgKiBgJy5zc3MnIG9yICcsc3NzJ2A6IE1pbGxpc2Vjb25kIGluIHNlY29uZCwgcGFkZGVkICgwMDAtOTk5KVxyXG4gKiAgICogYCdhJ2A6IGFtL3BtIG1hcmtlclxyXG4gKiAgICogYCdaJ2A6IDQgZGlnaXQgKCtzaWduKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGltZXpvbmUgb2Zmc2V0ICgtMTIwMC0rMTIwMClcclxuICpcclxuICogICBgZm9ybWF0YCBzdHJpbmcgY2FuIGFsc28gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgcHJlZGVmaW5lZFxyXG4gKiAgIHtAbGluayBndWlkZS9pMThuIGxvY2FsaXphYmxlIGZvcm1hdHN9OlxyXG4gKlxyXG4gKiAgICogYCdtZWRpdW0nYDogZXF1aXZhbGVudCB0byBgJ01NTSBkLCB5IGg6bW06c3MgYSdgIGZvciBlbl9VUyBsb2NhbGVcclxuICogICAgIChlLmcuIFNlcCAzLCAyMDEwIDEyOjA1OjA4IHBtKVxyXG4gKiAgICogYCdzaG9ydCdgOiBlcXVpdmFsZW50IHRvIGAnTS9kL3l5IGg6bW0gYSdgIGZvciBlbl9VUyAgbG9jYWxlIChlLmcuIDkvMy8xMCAxMjowNSBwbSlcclxuICogICAqIGAnZnVsbERhdGUnYDogZXF1aXZhbGVudCB0byBgJ0VFRUUsIE1NTU0gZCx5J2AgZm9yIGVuX1VTICBsb2NhbGVcclxuICogICAgIChlLmcuIEZyaWRheSwgU2VwdGVtYmVyIDMsIDIwMTApXHJcbiAqICAgKiBgJ2xvbmdEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCdNTU1NIGQsIHknYCBmb3IgZW5fVVMgIGxvY2FsZSAoZS5nLiBTZXB0ZW1iZXIgMywgMjAxMClcclxuICogICAqIGAnbWVkaXVtRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAnTU1NIGQsIHknYCBmb3IgZW5fVVMgIGxvY2FsZSAoZS5nLiBTZXAgMywgMjAxMClcclxuICogICAqIGAnc2hvcnREYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCdNL2QveXknYCBmb3IgZW5fVVMgbG9jYWxlIChlLmcuIDkvMy8xMClcclxuICogICAqIGAnbWVkaXVtVGltZSdgOiBlcXVpdmFsZW50IHRvIGAnaDptbTpzcyBhJ2AgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiAxMjowNTowOCBwbSlcclxuICogICAqIGAnc2hvcnRUaW1lJ2A6IGVxdWl2YWxlbnQgdG8gYCdoOm1tIGEnYCBmb3IgZW5fVVMgbG9jYWxlIChlLmcuIDEyOjA1IHBtKVxyXG4gKlxyXG4gKiAgIGBmb3JtYXRgIHN0cmluZyBjYW4gY29udGFpbiBsaXRlcmFsIHZhbHVlcy4gVGhlc2UgbmVlZCB0byBiZSBxdW90ZWQgd2l0aCBzaW5nbGUgcXVvdGVzIChlLmcuXHJcbiAqICAgYFwiaCAnaW4gdGhlIG1vcm5pbmcnXCJgKS4gSW4gb3JkZXIgdG8gb3V0cHV0IHNpbmdsZSBxdW90ZSwgdXNlIHR3byBzaW5nbGUgcXVvdGVzIGluIGEgc2VxdWVuY2VcclxuICogICAoZS5nLiBgXCJoICdvJydjbG9jaydcImApLlxyXG4gKlxyXG4gKiBAcGFyYW0geyhEYXRlfG51bWJlcnxzdHJpbmcpfSBkYXRlIERhdGUgdG8gZm9ybWF0IGVpdGhlciBhcyBEYXRlIG9iamVjdCwgbWlsbGlzZWNvbmRzIChzdHJpbmcgb3JcclxuICogICAgbnVtYmVyKSBvciB2YXJpb3VzIElTTyA4NjAxIGRhdGV0aW1lIHN0cmluZyBmb3JtYXRzIChlLmcuIHl5eXktTU0tZGRUSEg6bW06c3MuU1NTWiBhbmQgaXRzXHJcbiAqICAgIHNob3J0ZXIgdmVyc2lvbnMgbGlrZSB5eXl5LU1NLWRkVEhIOm1tWiwgeXl5eS1NTS1kZCBvciB5eXl5TU1kZFRISG1tc3NaKS4gSWYgbm8gdGltZXpvbmUgaXNcclxuICogICAgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaW5wdXQsIHRoZSB0aW1lIGlzIGNvbnNpZGVyZWQgdG8gYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IGZvcm1hdCBGb3JtYXR0aW5nIHJ1bGVzIChzZWUgRGVzY3JpcHRpb24pLiBJZiBub3Qgc3BlY2lmaWVkLFxyXG4gKiAgICBgbWVkaXVtRGF0ZWAgaXMgdXNlZC5cclxuICogQHJldHVybnMge3N0cmluZ30gRm9ybWF0dGVkIHN0cmluZyBvciB0aGUgaW5wdXQgaWYgaW5wdXQgaXMgbm90IHJlY29nbml6ZWQgYXMgZGF0ZS9taWxsaXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT57ezEyODgzMjM2MjMwMDYgfCBkYXRlOidtZWRpdW0nfX08L3NwYW4+OlxyXG4gICAgICAgICAgIHt7MTI4ODMyMzYyMzAwNiB8IGRhdGU6J21lZGl1bSd9fTxicj5cclxuICAgICAgIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT57ezEyODgzMjM2MjMwMDYgfCBkYXRlOid5eXl5LU1NLWRkIEhIOm1tOnNzIFonfX08L3NwYW4+OlxyXG4gICAgICAgICAge3sxMjg4MzIzNjIzMDA2IHwgZGF0ZToneXl5eS1NTS1kZCBISDptbTpzcyBaJ319PGJyPlxyXG4gICAgICAgPHNwYW4gbmctbm9uLWJpbmRhYmxlPnt7MTI4ODMyMzYyMzAwNiB8IGRhdGU6J01NL2RkL3l5eXkgQCBoOm1tYSd9fTwvc3Bhbj46XHJcbiAgICAgICAgICB7eycxMjg4MzIzNjIzMDA2JyB8IGRhdGU6J01NL2RkL3l5eXkgQCBoOm1tYSd9fTxicj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgZm9ybWF0IGRhdGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoXCIxMjg4MzIzNjIzMDA2IHwgZGF0ZTonbWVkaXVtJ1wiKSkuXHJcbiAgICAgICAgICAgIHRvTWF0Y2goL09jdCAyXFxkLCAyMDEwIFxcZHsxLDJ9OlxcZHsyfTpcXGR7Mn0gKEFNfFBNKS8pO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZyhcIjEyODgzMjM2MjMwMDYgfCBkYXRlOid5eXl5LU1NLWRkIEhIOm1tOnNzIFonXCIpKS5cclxuICAgICAgICAgICAgdG9NYXRjaCgvMjAxMFxcLTEwXFwtMlxcZCBcXGR7Mn06XFxkezJ9OlxcZHsyfSAoXFwtfFxcKyk/XFxkezR9Lyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKFwiJzEyODgzMjM2MjMwMDYnIHwgZGF0ZTonTU0vZGQveXl5eSBAIGg6bW1hJ1wiKSkuXHJcbiAgICAgICAgICAgIHRvTWF0Y2goLzEwXFwvMlxcZFxcLzIwMTAgQCBcXGR7MSwyfTpcXGR7Mn0oQU18UE0pLyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbmRhdGVGaWx0ZXIuJGluamVjdCA9IFsnJGxvY2FsZSddO1xyXG5mdW5jdGlvbiBkYXRlRmlsdGVyKCRsb2NhbGUpIHtcclxuXHJcblxyXG4gIHZhciBSX0lTTzg2MDFfU1RSID0gL14oXFxkezR9KS0/KFxcZFxcZCktPyhcXGRcXGQpKD86VChcXGRcXGQpKD86Oj8oXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzpcXC4oXFxkKykpPyk/KT8oWnwoWystXSkoXFxkXFxkKTo/KFxcZFxcZCkpPyk/JC87XHJcbiAgICAgICAgICAgICAgICAgICAgIC8vIDEgICAgICAgIDIgICAgICAgMyAgICAgICAgIDQgICAgICAgICAgNSAgICAgICAgICA2ICAgICAgICAgIDcgICAgICAgICAgOCAgOSAgICAgMTAgICAgICAxMVxyXG4gIGZ1bmN0aW9uIGpzb25TdHJpbmdUb0RhdGUoc3RyaW5nKSB7XHJcbiAgICB2YXIgbWF0Y2g7XHJcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goUl9JU084NjAxX1NUUikpIHtcclxuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKSxcclxuICAgICAgICAgIHR6SG91ciA9IDAsXHJcbiAgICAgICAgICB0ek1pbiAgPSAwLFxyXG4gICAgICAgICAgZGF0ZVNldHRlciA9IG1hdGNoWzhdID8gZGF0ZS5zZXRVVENGdWxsWWVhciA6IGRhdGUuc2V0RnVsbFllYXIsXHJcbiAgICAgICAgICB0aW1lU2V0dGVyID0gbWF0Y2hbOF0gPyBkYXRlLnNldFVUQ0hvdXJzIDogZGF0ZS5zZXRIb3VycztcclxuXHJcbiAgICAgIGlmIChtYXRjaFs5XSkge1xyXG4gICAgICAgIHR6SG91ciA9IGludChtYXRjaFs5XSArIG1hdGNoWzEwXSk7XHJcbiAgICAgICAgdHpNaW4gPSBpbnQobWF0Y2hbOV0gKyBtYXRjaFsxMV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGRhdGVTZXR0ZXIuY2FsbChkYXRlLCBpbnQobWF0Y2hbMV0pLCBpbnQobWF0Y2hbMl0pIC0gMSwgaW50KG1hdGNoWzNdKSk7XHJcbiAgICAgIHZhciBoID0gaW50KG1hdGNoWzRdfHwwKSAtIHR6SG91cjtcclxuICAgICAgdmFyIG0gPSBpbnQobWF0Y2hbNV18fDApIC0gdHpNaW5cclxuICAgICAgdmFyIHMgPSBpbnQobWF0Y2hbNl18fDApO1xyXG4gICAgICB2YXIgbXMgPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoJzAuJyArIChtYXRjaFs3XXx8MCkpICogMTAwMCk7XHJcbiAgICAgIHRpbWVTZXR0ZXIuY2FsbChkYXRlLCBoLCBtLCBzLCBtcyk7XHJcbiAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cmluZztcclxuICB9XHJcblxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KSB7XHJcbiAgICB2YXIgdGV4dCA9ICcnLFxyXG4gICAgICAgIHBhcnRzID0gW10sXHJcbiAgICAgICAgZm4sIG1hdGNoO1xyXG5cclxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnbWVkaXVtRGF0ZSc7XHJcbiAgICBmb3JtYXQgPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFNbZm9ybWF0XSB8fCBmb3JtYXQ7XHJcbiAgICBpZiAoaXNTdHJpbmcoZGF0ZSkpIHtcclxuICAgICAgaWYgKE5VTUJFUl9TVFJJTkcudGVzdChkYXRlKSkge1xyXG4gICAgICAgIGRhdGUgPSBpbnQoZGF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0ZSA9IGpzb25TdHJpbmdUb0RhdGUoZGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNOdW1iZXIoZGF0ZSkpIHtcclxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNEYXRlKGRhdGUpKSB7XHJcbiAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlKGZvcm1hdCkge1xyXG4gICAgICBtYXRjaCA9IERBVEVfRk9STUFUU19TUExJVC5leGVjKGZvcm1hdCk7XHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIHBhcnRzID0gY29uY2F0KHBhcnRzLCBtYXRjaCwgMSk7XHJcbiAgICAgICAgZm9ybWF0ID0gcGFydHMucG9wKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFydHMucHVzaChmb3JtYXQpO1xyXG4gICAgICAgIGZvcm1hdCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3JFYWNoKHBhcnRzLCBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIGZuID0gREFURV9GT1JNQVRTW3ZhbHVlXTtcclxuICAgICAgdGV4dCArPSBmbiA/IGZuKGRhdGUsICRsb2NhbGUuREFURVRJTUVfRk9STUFUUylcclxuICAgICAgICAgICAgICAgICA6IHZhbHVlLnJlcGxhY2UoLyheJ3wnJCkvZywgJycpLnJlcGxhY2UoLycnL2csIFwiJ1wiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZpbHRlclxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6anNvblxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqICAgQWxsb3dzIHlvdSB0byBjb252ZXJ0IGEgSmF2YVNjcmlwdCBvYmplY3QgaW50byBKU09OIHN0cmluZy5cclxuICpcclxuICogICBUaGlzIGZpbHRlciBpcyBtb3N0bHkgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuIFdoZW4gdXNpbmcgdGhlIGRvdWJsZSBjdXJseSB7e3ZhbHVlfX0gbm90YXRpb25cclxuICogICB0aGUgYmluZGluZyBpcyBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBKU09OLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdCBBbnkgSmF2YVNjcmlwdCBvYmplY3QgKGluY2x1ZGluZyBhcnJheXMgYW5kIHByaW1pdGl2ZSB0eXBlcykgdG8gZmlsdGVyLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBKU09OIHN0cmluZy5cclxuICpcclxuICpcclxuICogQGV4YW1wbGU6XHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxwcmU+e3sgeyduYW1lJzondmFsdWUnfSB8IGpzb24gfX08L3ByZT5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQganNvbmlmeSBmaWx0ZXJlZCBvYmplY3RzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKFwieyduYW1lJzondmFsdWUnfVwiKSkudG9NYXRjaCgvXFx7XFxuICBcIm5hbWVcIjogP1widmFsdWVcIlxcbn0vKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24ganNvbkZpbHRlcigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gdG9Kc29uKG9iamVjdCwgdHJ1ZSk7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZmlsdGVyXHJcbiAqIEBuYW1lIG5nLmZpbHRlcjpsb3dlcmNhc2VcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gbG93ZXJjYXNlLlxyXG4gKiBAc2VlIGFuZ3VsYXIubG93ZXJjYXNlXHJcbiAqL1xyXG52YXIgbG93ZXJjYXNlRmlsdGVyID0gdmFsdWVGbihsb3dlcmNhc2UpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZmlsdGVyXHJcbiAqIEBuYW1lIG5nLmZpbHRlcjp1cHBlcmNhc2VcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gdXBwZXJjYXNlLlxyXG4gKiBAc2VlIGFuZ3VsYXIudXBwZXJjYXNlXHJcbiAqL1xyXG52YXIgdXBwZXJjYXNlRmlsdGVyID0gdmFsdWVGbih1cHBlcmNhc2UpO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6bGltaXRUb1xyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgb3Igc3RyaW5nIGNvbnRhaW5pbmcgb25seSBhIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMuIFRoZSBlbGVtZW50c1xyXG4gKiBhcmUgdGFrZW4gZnJvbSBlaXRoZXIgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mIHRoZSBzb3VyY2UgYXJyYXkgb3Igc3RyaW5nLCBhcyBzcGVjaWZpZWQgYnlcclxuICogdGhlIHZhbHVlIGFuZCBzaWduIChwb3NpdGl2ZSBvciBuZWdhdGl2ZSkgb2YgYGxpbWl0YC5cclxuICpcclxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF1Z21lbnQgdGhlIGBBcnJheWAgdHlwZSBpbiBBbmd1bGFyIGV4cHJlc3Npb25zLiBTZWVcclxuICoge0BsaW5rIG5nLiRmaWx0ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IEFuZ3VsYXIgYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gaW5wdXQgU291cmNlIGFycmF5IG9yIHN0cmluZyB0byBiZSBsaW1pdGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGxpbWl0IFRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGFycmF5IG9yIHN0cmluZy4gSWYgdGhlIGBsaW1pdGAgbnVtYmVyIFxyXG4gKiAgICAgaXMgcG9zaXRpdmUsIGBsaW1pdGAgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGFycmF5L3N0cmluZyBhcmUgY29waWVkLlxyXG4gKiAgICAgSWYgdGhlIG51bWJlciBpcyBuZWdhdGl2ZSwgYGxpbWl0YCBudW1iZXIgIG9mIGl0ZW1zIGZyb20gdGhlIGVuZCBvZiB0aGUgc291cmNlIGFycmF5L3N0cmluZyBcclxuICogICAgIGFyZSBjb3BpZWQuIFRoZSBgbGltaXRgIHdpbGwgYmUgdHJpbW1lZCBpZiBpdCBleGNlZWRzIGBhcnJheS5sZW5ndGhgXHJcbiAqIEByZXR1cm5zIHtBcnJheXxzdHJpbmd9IEEgbmV3IHN1Yi1hcnJheSBvciBzdWJzdHJpbmcgb2YgbGVuZ3RoIGBsaW1pdGAgb3IgbGVzcyBpZiBpbnB1dCBhcnJheVxyXG4gKiAgICAgaGFkIGxlc3MgdGhhbiBgbGltaXRgIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS5udW1iZXJzID0gWzEsMiwzLDQsNSw2LDcsOCw5XTtcclxuICAgICAgICAgICAkc2NvcGUubGV0dGVycyA9IFwiYWJjZGVmZ2hpXCI7XHJcbiAgICAgICAgICAgJHNjb3BlLm51bUxpbWl0ID0gMztcclxuICAgICAgICAgICAkc2NvcGUubGV0dGVyTGltaXQgPSAzO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgTGltaXQge3tudW1iZXJzfX0gdG86IDxpbnB1dCB0eXBlPVwiaW50ZWdlclwiIG5nLW1vZGVsPVwibnVtTGltaXRcIj5cclxuICAgICAgICAgPHA+T3V0cHV0IG51bWJlcnM6IHt7IG51bWJlcnMgfCBsaW1pdFRvOm51bUxpbWl0IH19PC9wPlxyXG4gICAgICAgICBMaW1pdCB7e2xldHRlcnN9fSB0bzogPGlucHV0IHR5cGU9XCJpbnRlZ2VyXCIgbmctbW9kZWw9XCJsZXR0ZXJMaW1pdFwiPlxyXG4gICAgICAgICA8cD5PdXRwdXQgbGV0dGVyczoge3sgbGV0dGVycyB8IGxpbWl0VG86bGV0dGVyTGltaXQgfX08L3A+XHJcbiAgICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgbGltaXQgdGhlIG51bWJlciBhcnJheSB0byBmaXJzdCB0aHJlZSBpdGVtcycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgaW5wdXRbbmctbW9kZWw9bnVtTGltaXRdJykudmFsKCkpLnRvQmUoJzMnKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGlucHV0W25nLW1vZGVsPWxldHRlckxpbWl0XScpLnZhbCgpKS50b0JlKCczJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdudW1iZXJzIHwgbGltaXRUbzpudW1MaW1pdCcpKS50b0VxdWFsKCdbMSwyLDNdJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdsZXR0ZXJzIHwgbGltaXRUbzpsZXR0ZXJMaW1pdCcpKS50b0VxdWFsKCdhYmMnKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHRoZSBvdXRwdXQgd2hlbiAtMyBpcyBlbnRlcmVkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGlucHV0KCdudW1MaW1pdCcpLmVudGVyKC0zKTtcclxuICAgICAgICAgaW5wdXQoJ2xldHRlckxpbWl0JykuZW50ZXIoLTMpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbnVtYmVycyB8IGxpbWl0VG86bnVtTGltaXQnKSkudG9FcXVhbCgnWzcsOCw5XScpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGV0dGVycyB8IGxpbWl0VG86bGV0dGVyTGltaXQnKSkudG9FcXVhbCgnZ2hpJyk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnc2hvdWxkIG5vdCBleGNlZWQgdGhlIG1heGltdW0gc2l6ZSBvZiBpbnB1dCBhcnJheScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgnbnVtTGltaXQnKS5lbnRlcigxMDApO1xyXG4gICAgICAgICBpbnB1dCgnbGV0dGVyTGltaXQnKS5lbnRlcigxMDApO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbnVtYmVycyB8IGxpbWl0VG86bnVtTGltaXQnKSkudG9FcXVhbCgnWzEsMiwzLDQsNSw2LDcsOCw5XScpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGV0dGVycyB8IGxpbWl0VG86bGV0dGVyTGltaXQnKSkudG9FcXVhbCgnYWJjZGVmZ2hpJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9GaWx0ZXIoKXtcclxuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGxpbWl0KSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoaW5wdXQpICYmICFpc1N0cmluZyhpbnB1dCkpIHJldHVybiBpbnB1dDtcclxuICAgIFxyXG4gICAgbGltaXQgPSBpbnQobGltaXQpO1xyXG5cclxuICAgIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcclxuICAgICAgLy9OYU4gY2hlY2sgb24gbGltaXRcclxuICAgICAgaWYgKGxpbWl0KSB7XHJcbiAgICAgICAgcmV0dXJuIGxpbWl0ID49IDAgPyBpbnB1dC5zbGljZSgwLCBsaW1pdCkgOiBpbnB1dC5zbGljZShsaW1pdCwgaW5wdXQubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBvdXQgPSBbXSxcclxuICAgICAgaSwgbjtcclxuXHJcbiAgICAvLyBpZiBhYnMobGltaXQpIGV4Y2VlZHMgbWF4aW11bSBsZW5ndGgsIHRyaW0gaXRcclxuICAgIGlmIChsaW1pdCA+IGlucHV0Lmxlbmd0aClcclxuICAgICAgbGltaXQgPSBpbnB1dC5sZW5ndGg7XHJcbiAgICBlbHNlIGlmIChsaW1pdCA8IC1pbnB1dC5sZW5ndGgpXHJcbiAgICAgIGxpbWl0ID0gLWlucHV0Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAobGltaXQgPiAwKSB7XHJcbiAgICAgIGkgPSAwO1xyXG4gICAgICBuID0gbGltaXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpID0gaW5wdXQubGVuZ3RoICsgbGltaXQ7XHJcbiAgICAgIG4gPSBpbnB1dC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICg7IGk8bjsgaSsrKSB7XHJcbiAgICAgIG91dC5wdXNoKGlucHV0W2ldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6b3JkZXJCeVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIE9yZGVycyBhIHNwZWNpZmllZCBgYXJyYXlgIGJ5IHRoZSBgZXhwcmVzc2lvbmAgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXVnbWVudCB0aGUgYEFycmF5YCB0eXBlIGluIEFuZ3VsYXIgZXhwcmVzc2lvbnMuIFNlZVxyXG4gKiB7QGxpbmsgbmcuJGZpbHRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgQW5ndWxhciBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfHN0cmluZ3xBcnJheS48KGZ1bmN0aW9uKCopfHN0cmluZyk+fSBleHByZXNzaW9uIEEgcHJlZGljYXRlIHRvIGJlXHJcbiAqICAgIHVzZWQgYnkgdGhlIGNvbXBhcmF0b3IgdG8gZGV0ZXJtaW5lIHRoZSBvcmRlciBvZiBlbGVtZW50cy5cclxuICpcclxuICogICAgQ2FuIGJlIG9uZSBvZjpcclxuICpcclxuICogICAgLSBgZnVuY3Rpb25gOiBHZXR0ZXIgZnVuY3Rpb24uIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIHNvcnRlZCB1c2luZyB0aGVcclxuICogICAgICBgPGAsIGA9YCwgYD5gIG9wZXJhdG9yLlxyXG4gKiAgICAtIGBzdHJpbmdgOiBBbiBBbmd1bGFyIGV4cHJlc3Npb24gd2hpY2ggZXZhbHVhdGVzIHRvIGFuIG9iamVjdCB0byBvcmRlciBieSwgc3VjaCBhcyAnbmFtZSdcclxuICogICAgICB0byBzb3J0IGJ5IGEgcHJvcGVydHkgY2FsbGVkICduYW1lJy4gT3B0aW9uYWxseSBwcmVmaXhlZCB3aXRoIGArYCBvciBgLWAgdG8gY29udHJvbFxyXG4gKiAgICAgIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIHNvcnQgb3JkZXIgKGZvciBleGFtcGxlLCArbmFtZSBvciAtbmFtZSkuXHJcbiAqICAgIC0gYEFycmF5YDogQW4gYXJyYXkgb2YgZnVuY3Rpb24gb3Igc3RyaW5nIHByZWRpY2F0ZXMuIFRoZSBmaXJzdCBwcmVkaWNhdGUgaW4gdGhlIGFycmF5XHJcbiAqICAgICAgaXMgdXNlZCBmb3Igc29ydGluZywgYnV0IHdoZW4gdHdvIGl0ZW1zIGFyZSBlcXVpdmFsZW50LCB0aGUgbmV4dCBwcmVkaWNhdGUgaXMgdXNlZC5cclxuICpcclxuICogQHBhcmFtIHtib29sZWFuPX0gcmV2ZXJzZSBSZXZlcnNlIHRoZSBvcmRlciB0aGUgYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gU29ydGVkIGNvcHkgb2YgdGhlIHNvdXJjZSBhcnJheS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUuZnJpZW5kcyA9XHJcbiAgICAgICAgICAgICAgIFt7bmFtZTonSm9obicsIHBob25lOic1NTUtMTIxMicsIGFnZToxMH0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTonTWFyeScsIHBob25lOic1NTUtOTg3NicsIGFnZToxOX0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTonTWlrZScsIHBob25lOic1NTUtNDMyMScsIGFnZToyMX0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTonQWRhbScsIHBob25lOic1NTUtNTY3OCcsIGFnZTozNX0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTonSnVsaWUnLCBwaG9uZTonNTU1LTg3NjUnLCBhZ2U6Mjl9XVxyXG4gICAgICAgICAgICRzY29wZS5wcmVkaWNhdGUgPSAnLWFnZSc7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICA8cHJlPlNvcnRpbmcgcHJlZGljYXRlID0ge3twcmVkaWNhdGV9fTsgcmV2ZXJzZSA9IHt7cmV2ZXJzZX19PC9wcmU+XHJcbiAgICAgICAgIDxoci8+XHJcbiAgICAgICAgIFsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicHJlZGljYXRlPScnXCI+dW5zb3J0ZWQ8L2E+IF1cclxuICAgICAgICAgPHRhYmxlIGNsYXNzPVwiZnJpZW5kXCI+XHJcbiAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgPHRoPjxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInByZWRpY2F0ZSA9ICduYW1lJzsgcmV2ZXJzZT1mYWxzZVwiPk5hbWU8L2E+XHJcbiAgICAgICAgICAgICAgICAgKDxhIGhyZWYgbmctY2xpY2s9XCJwcmVkaWNhdGUgPSAnLW5hbWUnOyByZXZlcnNlPWZhbHNlXCI+XjwvYT4pPC90aD5cclxuICAgICAgICAgICAgIDx0aD48YSBocmVmPVwiXCIgbmctY2xpY2s9XCJwcmVkaWNhdGUgPSAncGhvbmUnOyByZXZlcnNlPSFyZXZlcnNlXCI+UGhvbmUgTnVtYmVyPC9hPjwvdGg+XHJcbiAgICAgICAgICAgICA8dGg+PGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicHJlZGljYXRlID0gJ2FnZSc7IHJldmVyc2U9IXJldmVyc2VcIj5BZ2U8L2E+PC90aD5cclxuICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgIDx0ciBuZy1yZXBlYXQ9XCJmcmllbmQgaW4gZnJpZW5kcyB8IG9yZGVyQnk6cHJlZGljYXRlOnJldmVyc2VcIj5cclxuICAgICAgICAgICAgIDx0ZD57e2ZyaWVuZC5uYW1lfX08L3RkPlxyXG4gICAgICAgICAgICAgPHRkPnt7ZnJpZW5kLnBob25lfX08L3RkPlxyXG4gICAgICAgICAgICAgPHRkPnt7ZnJpZW5kLmFnZX19PC90ZD5cclxuICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGJlIHJldmVyc2Ugb3JkZXJlZCBieSBhZ2VkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdwcmVkaWNhdGUnKSkudG9CZSgnLWFnZScpO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLmFnZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnMzUnLCAnMjknLCAnMjEnLCAnMTknLCAnMTAnXSk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcigndGFibGUuZnJpZW5kJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnQWRhbScsICdKdWxpZScsICdNaWtlJywgJ01hcnknLCAnSm9obiddKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAgIGl0KCdzaG91bGQgcmVvcmRlciB0aGUgdGFibGUgd2hlbiB1c2VyIHNlbGVjdHMgZGlmZmVyZW50IHByZWRpY2F0ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBhOmNvbnRhaW5zKFwiTmFtZVwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcigndGFibGUuZnJpZW5kJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnQWRhbScsICdKb2huJywgJ0p1bGllJywgJ01hcnknLCAnTWlrZSddKTtcclxuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCd0YWJsZS5mcmllbmQnLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5hZ2UnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJzM1JywgJzEwJywgJzI5JywgJzE5JywgJzIxJ10pO1xyXG5cclxuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgYTpjb250YWlucyhcIlBob25lXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCd0YWJsZS5mcmllbmQnLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5waG9uZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnNTU1LTk4NzYnLCAnNTU1LTg3NjUnLCAnNTU1LTU2NzgnLCAnNTU1LTQzMjEnLCAnNTU1LTEyMTInXSk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcigndGFibGUuZnJpZW5kJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnTWFyeScsICdKdWxpZScsICdBZGFtJywgJ01pa2UnLCAnSm9obiddKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxub3JkZXJCeUZpbHRlci4kaW5qZWN0ID0gWyckcGFyc2UnXTtcclxuZnVuY3Rpb24gb3JkZXJCeUZpbHRlcigkcGFyc2Upe1xyXG4gIHJldHVybiBmdW5jdGlvbihhcnJheSwgc29ydFByZWRpY2F0ZSwgcmV2ZXJzZU9yZGVyKSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSByZXR1cm4gYXJyYXk7XHJcbiAgICBpZiAoIXNvcnRQcmVkaWNhdGUpIHJldHVybiBhcnJheTtcclxuICAgIHNvcnRQcmVkaWNhdGUgPSBpc0FycmF5KHNvcnRQcmVkaWNhdGUpID8gc29ydFByZWRpY2F0ZTogW3NvcnRQcmVkaWNhdGVdO1xyXG4gICAgc29ydFByZWRpY2F0ZSA9IG1hcChzb3J0UHJlZGljYXRlLCBmdW5jdGlvbihwcmVkaWNhdGUpe1xyXG4gICAgICB2YXIgZGVzY2VuZGluZyA9IGZhbHNlLCBnZXQgPSBwcmVkaWNhdGUgfHwgaWRlbnRpdHk7XHJcbiAgICAgIGlmIChpc1N0cmluZyhwcmVkaWNhdGUpKSB7XHJcbiAgICAgICAgaWYgKChwcmVkaWNhdGUuY2hhckF0KDApID09ICcrJyB8fCBwcmVkaWNhdGUuY2hhckF0KDApID09ICctJykpIHtcclxuICAgICAgICAgIGRlc2NlbmRpbmcgPSBwcmVkaWNhdGUuY2hhckF0KDApID09ICctJztcclxuICAgICAgICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCA9ICRwYXJzZShwcmVkaWNhdGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXZlcnNlQ29tcGFyYXRvcihmdW5jdGlvbihhLGIpe1xyXG4gICAgICAgIHJldHVybiBjb21wYXJlKGdldChhKSxnZXQoYikpO1xyXG4gICAgICB9LCBkZXNjZW5kaW5nKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGFycmF5Q29weSA9IFtdO1xyXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgYXJyYXlDb3B5LnB1c2goYXJyYXlbaV0pOyB9XHJcbiAgICByZXR1cm4gYXJyYXlDb3B5LnNvcnQocmV2ZXJzZUNvbXBhcmF0b3IoY29tcGFyYXRvciwgcmV2ZXJzZU9yZGVyKSk7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihvMSwgbzIpe1xyXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3J0UHJlZGljYXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNvbXAgPSBzb3J0UHJlZGljYXRlW2ldKG8xLCBvMik7XHJcbiAgICAgICAgaWYgKGNvbXAgIT09IDApIHJldHVybiBjb21wO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmV2ZXJzZUNvbXBhcmF0b3IoY29tcCwgZGVzY2VuZGluZykge1xyXG4gICAgICByZXR1cm4gdG9Cb29sZWFuKGRlc2NlbmRpbmcpXHJcbiAgICAgICAgICA/IGZ1bmN0aW9uKGEsYil7cmV0dXJuIGNvbXAoYixhKTt9XHJcbiAgICAgICAgICA6IGNvbXA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKHYxLCB2Mil7XHJcbiAgICAgIHZhciB0MSA9IHR5cGVvZiB2MTtcclxuICAgICAgdmFyIHQyID0gdHlwZW9mIHYyO1xyXG4gICAgICBpZiAodDEgPT0gdDIpIHtcclxuICAgICAgICBpZiAodDEgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgIHYxID0gdjEudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICB2MiA9IHYyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2MSA9PT0gdjIpIHJldHVybiAwO1xyXG4gICAgICAgIHJldHVybiB2MSA8IHYyID8gLTEgOiAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0MSA8IHQyID8gLTEgOiAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBuZ0RpcmVjdGl2ZShkaXJlY3RpdmUpIHtcclxuICBpZiAoaXNGdW5jdGlvbihkaXJlY3RpdmUpKSB7XHJcbiAgICBkaXJlY3RpdmUgPSB7XHJcbiAgICAgIGxpbms6IGRpcmVjdGl2ZVxyXG4gICAgfVxyXG4gIH1cclxuICBkaXJlY3RpdmUucmVzdHJpY3QgPSBkaXJlY3RpdmUucmVzdHJpY3QgfHwgJ0FDJztcclxuICByZXR1cm4gdmFsdWVGbihkaXJlY3RpdmUpO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6YVxyXG4gKiBAcmVzdHJpY3QgRVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogTW9kaWZpZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgaHRtbCBBIHRhZywgc28gdGhhdCB0aGUgZGVmYXVsdCBhY3Rpb24gaXMgcHJldmVudGVkIHdoZW4gaHJlZlxyXG4gKiBhdHRyaWJ1dGUgaXMgZW1wdHkuXHJcbiAqXHJcbiAqIFRoZSByZWFzb25pbmcgZm9yIHRoaXMgY2hhbmdlIGlzIHRvIGFsbG93IGVhc3kgY3JlYXRpb24gb2YgYWN0aW9uIGxpbmtzIHdpdGggYG5nQ2xpY2tgIGRpcmVjdGl2ZVxyXG4gKiB3aXRob3V0IGNoYW5naW5nIHRoZSBsb2NhdGlvbiBvciBjYXVzaW5nIHBhZ2UgcmVsb2FkcywgZS5nLjpcclxuICogYDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cIm1vZGVsLiRzYXZlKClcIj5TYXZlPC9hPmBcclxuICovXHJcbnZhciBodG1sQW5jaG9yRGlyZWN0aXZlID0gdmFsdWVGbih7XHJcbiAgcmVzdHJpY3Q6ICdFJyxcclxuICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XHJcblxyXG4gICAgaWYgKG1zaWUgPD0gOCkge1xyXG5cclxuICAgICAgLy8gdHVybiA8YSBocmVmIG5nLWNsaWNrPVwiLi5cIj5saW5rPC9hPiBpbnRvIGEgc3R5bGFibGUgbGluayBpbiBJRVxyXG4gICAgICAvLyBidXQgb25seSBpZiBpdCBkb2Vzbid0IGhhdmUgbmFtZSBhdHRyaWJ1dGUsIGluIHdoaWNoIGNhc2UgaXQncyBhbiBhbmNob3JcclxuICAgICAgaWYgKCFhdHRyLmhyZWYgJiYgIWF0dHIubmFtZSkge1xyXG4gICAgICAgIGF0dHIuJHNldCgnaHJlZicsICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRkIGEgY29tbWVudCBub2RlIHRvIGFuY2hvcnMgdG8gd29ya2Fyb3VuZCBJRSBidWcgdGhhdCBjYXVzZXMgZWxlbWVudCBjb250ZW50IHRvIGJlIHJlc2V0XHJcbiAgICAgIC8vIHRvIG5ldyBhdHRyaWJ1dGUgY29udGVudCBpZiBhdHRyaWJ1dGUgaXMgdXBkYXRlZCB3aXRoIHZhbHVlIGNvbnRhaW5pbmcgQCBhbmQgZWxlbWVudCBhbHNvXHJcbiAgICAgIC8vIGNvbnRhaW5zIHZhbHVlIHdpdGggQFxyXG4gICAgICAvLyBzZWUgaXNzdWUgIzE5NDlcclxuICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnSUUgZml4JykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xyXG4gICAgICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vIGhyZWYgdXJsLCB0aGVuIGRvbid0IG5hdmlnYXRlIGFueXdoZXJlLlxyXG4gICAgICAgIGlmICghZWxlbWVudC5hdHRyKCdocmVmJykpIHtcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSHJlZlxyXG4gKiBAcmVzdHJpY3QgQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVXNpbmcgQW5ndWxhciBtYXJrdXAgbGlrZSB7e2hhc2h9fSBpbiBhbiBocmVmIGF0dHJpYnV0ZSBtYWtlc1xyXG4gKiB0aGUgcGFnZSBvcGVuIHRvIGEgd3JvbmcgVVJMLCBpZiB0aGUgdXNlciBjbGlja3MgdGhhdCBsaW5rIGJlZm9yZVxyXG4gKiBhbmd1bGFyIGhhcyBhIGNoYW5jZSB0byByZXBsYWNlIHRoZSB7e2hhc2h9fSB3aXRoIGFjdHVhbCBVUkwsIHRoZVxyXG4gKiBsaW5rIHdpbGwgYmUgYnJva2VuIGFuZCB3aWxsIG1vc3QgbGlrZWx5IHJldHVybiBhIDQwNCBlcnJvci5cclxuICogVGhlIGBuZ0hyZWZgIGRpcmVjdGl2ZSBzb2x2ZXMgdGhpcyBwcm9ibGVtLlxyXG4gKlxyXG4gKiBUaGUgYnVnZ3kgd2F5IHRvIHdyaXRlIGl0OlxyXG4gKiA8cHJlPlxyXG4gKiA8YSBocmVmPVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19XCIvPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIGNvcnJlY3Qgd2F5IHRvIHdyaXRlIGl0OlxyXG4gKiA8cHJlPlxyXG4gKiA8YSBuZy1ocmVmPVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19XCIvPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogQGVsZW1lbnQgQVxyXG4gKiBAcGFyYW0ge3RlbXBsYXRlfSBuZ0hyZWYgYW55IHN0cmluZyB3aGljaCBjYW4gY29udGFpbiBge3t9fWAgbWFya3VwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBUaGlzIGV4YW1wbGUgdXNlcyBgbGlua2AgdmFyaWFibGUgaW5zaWRlIGBocmVmYCBhdHRyaWJ1dGU6XHJcbiAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInZhbHVlXCIgLz48YnIgLz5cclxuICAgICAgICA8YSBpZD1cImxpbmstMVwiIGhyZWYgbmctY2xpY2s9XCJ2YWx1ZSA9IDFcIj5saW5rIDE8L2E+IChsaW5rLCBkb24ndCByZWxvYWQpPGJyIC8+XHJcbiAgICAgICAgPGEgaWQ9XCJsaW5rLTJcIiBocmVmPVwiXCIgbmctY2xpY2s9XCJ2YWx1ZSA9IDJcIj5saW5rIDI8L2E+IChsaW5rLCBkb24ndCByZWxvYWQpPGJyIC8+XHJcbiAgICAgICAgPGEgaWQ9XCJsaW5rLTNcIiBuZy1ocmVmPVwiL3t7JzEyMyd9fVwiPmxpbmsgMzwvYT4gKGxpbmssIHJlbG9hZCEpPGJyIC8+XHJcbiAgICAgICAgPGEgaWQ9XCJsaW5rLTRcIiBocmVmPVwiXCIgbmFtZT1cInh4XCIgbmctY2xpY2s9XCJ2YWx1ZSA9IDRcIj5hbmNob3I8L2E+IChsaW5rLCBkb24ndCByZWxvYWQpPGJyIC8+XHJcbiAgICAgICAgPGEgaWQ9XCJsaW5rLTVcIiBuYW1lPVwieHh4XCIgbmctY2xpY2s9XCJ2YWx1ZSA9IDVcIj5hbmNob3I8L2E+IChubyBsaW5rKTxiciAvPlxyXG4gICAgICAgIDxhIGlkPVwibGluay02XCIgbmctaHJlZj1cInt7dmFsdWV9fVwiPmxpbms8L2E+IChsaW5rLCBjaGFuZ2UgbG9jYXRpb24pXHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgbmctY2xpY2sgYnV0IG5vdCByZWxvYWQgd2hlbiBocmVmIHdpdGhvdXQgdmFsdWUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGVsZW1lbnQoJyNsaW5rLTEnKS5jbGljaygpO1xyXG4gICAgICAgICAgZXhwZWN0KGlucHV0KCd2YWx1ZScpLnZhbCgpKS50b0VxdWFsKCcxJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstMScpLmF0dHIoJ2hyZWYnKSkudG9CZShcIlwiKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIG5nLWNsaWNrIGJ1dCBub3QgcmVsb2FkIHdoZW4gaHJlZiBlbXB0eSBzdHJpbmcnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGVsZW1lbnQoJyNsaW5rLTInKS5jbGljaygpO1xyXG4gICAgICAgICAgZXhwZWN0KGlucHV0KCd2YWx1ZScpLnZhbCgpKS50b0VxdWFsKCcyJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstMicpLmF0dHIoJ2hyZWYnKSkudG9CZShcIlwiKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIG5nLWNsaWNrIGFuZCBjaGFuZ2UgdXJsIHdoZW4gbmctaHJlZiBzcGVjaWZpZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjbGluay0zJykuYXR0cignaHJlZicpKS50b0JlKFwiLzEyM1wiKTtcclxuXHJcbiAgICAgICAgICBlbGVtZW50KCcjbGluay0zJykuY2xpY2soKTtcclxuICAgICAgICAgIGV4cGVjdChicm93c2VyKCkud2luZG93KCkucGF0aCgpKS50b0VxdWFsKCcvMTIzJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBuZy1jbGljayBidXQgbm90IHJlbG9hZCB3aGVuIGhyZWYgZW1wdHkgc3RyaW5nIGFuZCBuYW1lIHNwZWNpZmllZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZWxlbWVudCgnI2xpbmstNCcpLmNsaWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoaW5wdXQoJ3ZhbHVlJykudmFsKCkpLnRvRXF1YWwoJzQnKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjbGluay00JykuYXR0cignaHJlZicpKS50b0JlKCcnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIG5nLWNsaWNrIGJ1dCBub3QgcmVsb2FkIHdoZW4gbm8gaHJlZiBidXQgbmFtZSBzcGVjaWZpZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGVsZW1lbnQoJyNsaW5rLTUnKS5jbGljaygpO1xyXG4gICAgICAgICAgZXhwZWN0KGlucHV0KCd2YWx1ZScpLnZhbCgpKS50b0VxdWFsKCc1Jyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstNScpLmF0dHIoJ2hyZWYnKSkudG9CZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIG9ubHkgY2hhbmdlIHVybCB3aGVuIG9ubHkgbmctaHJlZicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaW5wdXQoJ3ZhbHVlJykuZW50ZXIoJzYnKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjbGluay02JykuYXR0cignaHJlZicpKS50b0JlKCc2Jyk7XHJcblxyXG4gICAgICAgICAgZWxlbWVudCgnI2xpbmstNicpLmNsaWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoYnJvd3NlcigpLmxvY2F0aW9uKCkudXJsKCkpLnRvRXF1YWwoJy82Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTcmNcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFVzaW5nIEFuZ3VsYXIgbWFya3VwIGxpa2UgYHt7aGFzaH19YCBpbiBhIGBzcmNgIGF0dHJpYnV0ZSBkb2Vzbid0XHJcbiAqIHdvcmsgcmlnaHQ6IFRoZSBicm93c2VyIHdpbGwgZmV0Y2ggZnJvbSB0aGUgVVJMIHdpdGggdGhlIGxpdGVyYWxcclxuICogdGV4dCBge3toYXNofX1gIHVudGlsIEFuZ3VsYXIgcmVwbGFjZXMgdGhlIGV4cHJlc3Npb24gaW5zaWRlXHJcbiAqIGB7e2hhc2h9fWAuIFRoZSBgbmdTcmNgIGRpcmVjdGl2ZSBzb2x2ZXMgdGhpcyBwcm9ibGVtLlxyXG4gKlxyXG4gKiBUaGUgYnVnZ3kgd2F5IHRvIHdyaXRlIGl0OlxyXG4gKiA8cHJlPlxyXG4gKiA8aW1nIHNyYz1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fVwiLz5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFRoZSBjb3JyZWN0IHdheSB0byB3cml0ZSBpdDpcclxuICogPHByZT5cclxuICogPGltZyBuZy1zcmM9XCJodHRwOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIve3toYXNofX1cIi8+XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBJTUdcclxuICogQHBhcmFtIHt0ZW1wbGF0ZX0gbmdTcmMgYW55IHN0cmluZyB3aGljaCBjYW4gY29udGFpbiBge3t9fWAgbWFya3VwLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1NyY3NldFxyXG4gKiBAcmVzdHJpY3QgQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVXNpbmcgQW5ndWxhciBtYXJrdXAgbGlrZSBge3toYXNofX1gIGluIGEgYHNyY3NldGAgYXR0cmlidXRlIGRvZXNuJ3RcclxuICogd29yayByaWdodDogVGhlIGJyb3dzZXIgd2lsbCBmZXRjaCBmcm9tIHRoZSBVUkwgd2l0aCB0aGUgbGl0ZXJhbFxyXG4gKiB0ZXh0IGB7e2hhc2h9fWAgdW50aWwgQW5ndWxhciByZXBsYWNlcyB0aGUgZXhwcmVzc2lvbiBpbnNpZGVcclxuICogYHt7aGFzaH19YC4gVGhlIGBuZ1NyY3NldGAgZGlyZWN0aXZlIHNvbHZlcyB0aGlzIHByb2JsZW0uXHJcbiAqXHJcbiAqIFRoZSBidWdneSB3YXkgdG8gd3JpdGUgaXQ6XHJcbiAqIDxwcmU+XHJcbiAqIDxpbWcgc3Jjc2V0PVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19IDJ4XCIvPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIGNvcnJlY3Qgd2F5IHRvIHdyaXRlIGl0OlxyXG4gKiA8cHJlPlxyXG4gKiA8aW1nIG5nLXNyY3NldD1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fSAyeFwiLz5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEBlbGVtZW50IElNR1xyXG4gKiBAcGFyYW0ge3RlbXBsYXRlfSBuZ1NyY3NldCBhbnkgc3RyaW5nIHdoaWNoIGNhbiBjb250YWluIGB7e319YCBtYXJrdXAuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nRGlzYWJsZWRcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgbWFya3VwIHdpbGwgbWFrZSB0aGUgYnV0dG9uIGVuYWJsZWQgb24gQ2hyb21lL0ZpcmVmb3ggYnV0IG5vdCBvbiBJRTggYW5kIG9sZGVyIElFczpcclxuICogPHByZT5cclxuICogPGRpdiBuZy1pbml0PVwic2NvcGUgPSB7IGlzRGlzYWJsZWQ6IGZhbHNlIH1cIj5cclxuICogIDxidXR0b24gZGlzYWJsZWQ9XCJ7e3Njb3BlLmlzRGlzYWJsZWR9fVwiPkRpc2FibGVkPC9idXR0b24+XHJcbiAqIDwvZGl2PlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIEhUTUwgc3BlY3MgZG8gbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHNwZWNpYWwgYXR0cmlidXRlcyBzdWNoIGFzIGRpc2FibGVkLlxyXG4gKiAoVGhlIHByZXNlbmNlIG9mIHRoZW0gbWVhbnMgdHJ1ZSBhbmQgYWJzZW5jZSBtZWFucyBmYWxzZSlcclxuICogVGhpcyBwcmV2ZW50cyB0aGUgYW5ndWxhciBjb21waWxlciBmcm9tIGNvcnJlY3RseSByZXRyaWV2aW5nIHRoZSBiaW5kaW5nIGV4cHJlc3Npb24uXHJcbiAqIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgd2UgaW50cm9kdWNlIHRoZSBgbmdEaXNhYmxlZGAgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICBDbGljayBtZSB0byB0b2dnbGU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxyXG4gICAgICAgIDxidXR0b24gbmctbW9kZWw9XCJidXR0b25cIiBuZy1kaXNhYmxlZD1cImNoZWNrZWRcIj5CdXR0b248L2J1dHRvbj5cclxuICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgIGl0KCdzaG91bGQgdG9nZ2xlIGJ1dHRvbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b24nKS5wcm9wKCdkaXNhYmxlZCcpKS50b0JlRmFsc3koKTtcclxuICAgICAgICAgIGlucHV0KCdjaGVja2VkJykuY2hlY2soKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6YnV0dG9uJykucHJvcCgnZGlzYWJsZWQnKSkudG9CZVRydXRoeSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqIEBlbGVtZW50IElOUFVUXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdEaXNhYmxlZCBBbmd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZC5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ2hlY2tlZFxyXG4gKiBAcmVzdHJpY3QgQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIEhUTUwgc3BlY3MgZG8gbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHNwZWNpYWwgYXR0cmlidXRlcyBzdWNoIGFzIGNoZWNrZWQuXHJcbiAqIChUaGUgcHJlc2VuY2Ugb2YgdGhlbSBtZWFucyB0cnVlIGFuZCBhYnNlbmNlIG1lYW5zIGZhbHNlKVxyXG4gKiBUaGlzIHByZXZlbnRzIHRoZSBhbmd1bGFyIGNvbXBpbGVyIGZyb20gY29ycmVjdGx5IHJldHJpZXZpbmcgdGhlIGJpbmRpbmcgZXhwcmVzc2lvbi5cclxuICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCB3ZSBpbnRyb2R1Y2UgdGhlIGBuZ0NoZWNrZWRgIGRpcmVjdGl2ZS5cclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgQ2hlY2sgbWUgdG8gY2hlY2sgYm90aDogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwibWFzdGVyXCI+PGJyLz5cclxuICAgICAgICA8aW5wdXQgaWQ9XCJjaGVja1NsYXZlXCIgdHlwZT1cImNoZWNrYm94XCIgbmctY2hlY2tlZD1cIm1hc3RlclwiPlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBjaGVjayBib3RoIGNoZWNrQm94ZXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjY2hlY2tTbGF2ZScpLnByb3AoJ2NoZWNrZWQnKSkudG9CZUZhbHN5KCk7XHJcbiAgICAgICAgICBpbnB1dCgnbWFzdGVyJykuY2hlY2soKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjY2hlY2tTbGF2ZScpLnByb3AoJ2NoZWNrZWQnKSkudG9CZVRydXRoeSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqIEBlbGVtZW50IElOUFVUXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDaGVja2VkIEFuZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkLlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdSZWFkb25seVxyXG4gKiBAcmVzdHJpY3QgQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIEhUTUwgc3BlY3MgZG8gbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHNwZWNpYWwgYXR0cmlidXRlcyBzdWNoIGFzIHJlYWRvbmx5LlxyXG4gKiAoVGhlIHByZXNlbmNlIG9mIHRoZW0gbWVhbnMgdHJ1ZSBhbmQgYWJzZW5jZSBtZWFucyBmYWxzZSlcclxuICogVGhpcyBwcmV2ZW50cyB0aGUgYW5ndWxhciBjb21waWxlciBmcm9tIGNvcnJlY3RseSByZXRyaWV2aW5nIHRoZSBiaW5kaW5nIGV4cHJlc3Npb24uXHJcbiAqIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgd2UgaW50cm9kdWNlIHRoZSBgbmdSZWFkb25seWAgZGlyZWN0aXZlLlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICBDaGVjayBtZSB0byBtYWtlIHRleHQgcmVhZG9ubHk6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxyXG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLXJlYWRvbmx5PVwiY2hlY2tlZFwiIHZhbHVlPVwiSSdtIEFuZ3VsYXJcIi8+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIHRvZ2dsZSByZWFkb25seSBhdHRyJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgOnRleHQnKS5wcm9wKCdyZWFkb25seScpKS50b0JlRmFsc3koKTtcclxuICAgICAgICAgIGlucHV0KCdjaGVja2VkJykuY2hlY2soKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6dGV4dCcpLnByb3AoJ3JlYWRvbmx5JykpLnRvQmVUcnV0aHkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBJTlBVVFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBBbmd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZC5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU2VsZWN0ZWRcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBIVE1MIHNwZWNzIGRvIG5vdCByZXF1aXJlIGJyb3dzZXJzIHRvIHByZXNlcnZlIHRoZSBzcGVjaWFsIGF0dHJpYnV0ZXMgc3VjaCBhcyBzZWxlY3RlZC5cclxuICogKFRoZSBwcmVzZW5jZSBvZiB0aGVtIG1lYW5zIHRydWUgYW5kIGFic2VuY2UgbWVhbnMgZmFsc2UpXHJcbiAqIFRoaXMgcHJldmVudHMgdGhlIGFuZ3VsYXIgY29tcGlsZXIgZnJvbSBjb3JyZWN0bHkgcmV0cmlldmluZyB0aGUgYmluZGluZyBleHByZXNzaW9uLlxyXG4gKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIHdlIGludHJvZHVjZWQgdGhlIGBuZ1NlbGVjdGVkYCBkaXJlY3RpdmUuXHJcbiAqIEBleGFtcGxlXHJcbiAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgIENoZWNrIG1lIHRvIHNlbGVjdDogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwic2VsZWN0ZWRcIj48YnIvPlxyXG4gICAgICAgIDxzZWxlY3Q+XHJcbiAgICAgICAgICA8b3B0aW9uPkhlbGxvITwvb3B0aW9uPlxyXG4gICAgICAgICAgPG9wdGlvbiBpZD1cImdyZWV0XCIgbmctc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPkdyZWV0aW5ncyE8L29wdGlvbj5cclxuICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgIGl0KCdzaG91bGQgc2VsZWN0IEdyZWV0aW5ncyEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjZ3JlZXQnKS5wcm9wKCdzZWxlY3RlZCcpKS50b0JlRmFsc3koKTtcclxuICAgICAgICAgIGlucHV0KCdzZWxlY3RlZCcpLmNoZWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2dyZWV0JykucHJvcCgnc2VsZWN0ZWQnKSkudG9CZVRydXRoeSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqIEBlbGVtZW50IE9QVElPTlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBBbmd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZC5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdPcGVuXHJcbiAqIEByZXN0cmljdCBBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgSFRNTCBzcGVjcyBkbyBub3QgcmVxdWlyZSBicm93c2VycyB0byBwcmVzZXJ2ZSB0aGUgc3BlY2lhbCBhdHRyaWJ1dGVzIHN1Y2ggYXMgb3Blbi5cclxuICogKFRoZSBwcmVzZW5jZSBvZiB0aGVtIG1lYW5zIHRydWUgYW5kIGFic2VuY2UgbWVhbnMgZmFsc2UpXHJcbiAqIFRoaXMgcHJldmVudHMgdGhlIGFuZ3VsYXIgY29tcGlsZXIgZnJvbSBjb3JyZWN0bHkgcmV0cmlldmluZyB0aGUgYmluZGluZyBleHByZXNzaW9uLlxyXG4gKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIHdlIGludHJvZHVjZSB0aGUgYG5nT3BlbmAgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgICBDaGVjayBtZSBjaGVjayBtdWx0aXBsZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwib3BlblwiPjxici8+XHJcbiAgICAgICAgIDxkZXRhaWxzIGlkPVwiZGV0YWlsc1wiIG5nLW9wZW49XCJvcGVuXCI+XHJcbiAgICAgICAgICAgIDxzdW1tYXJ5PlNob3cvSGlkZSBtZTwvc3VtbWFyeT5cclxuICAgICAgICAgPC9kZXRhaWxzPlxyXG4gICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICAgaXQoJ3Nob3VsZCB0b2dnbGUgb3BlbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjZGV0YWlscycpLnByb3AoJ29wZW4nKSkudG9CZUZhbHN5KCk7XHJcbiAgICAgICAgICAgaW5wdXQoJ29wZW4nKS5jaGVjaygpO1xyXG4gICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjZGV0YWlscycpLnByb3AoJ29wZW4nKSkudG9CZVRydXRoeSgpO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqIEBlbGVtZW50IERFVEFJTFNcclxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gQW5ndWxhciBleHByZXNzaW9uIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQuXHJcbiAqL1xyXG5cclxudmFyIG5nQXR0cmlidXRlQWxpYXNEaXJlY3RpdmVzID0ge307XHJcblxyXG5cclxuLy8gYm9vbGVhbiBhdHRycyBhcmUgZXZhbHVhdGVkXHJcbmZvckVhY2goQk9PTEVBTl9BVFRSLCBmdW5jdGlvbihwcm9wTmFtZSwgYXR0ck5hbWUpIHtcclxuICAvLyBiaW5kaW5nIHRvIG11bHRpcGxlIGlzIG5vdCBzdXBwb3J0ZWRcclxuICBpZiAocHJvcE5hbWUgPT0gXCJtdWx0aXBsZVwiKSByZXR1cm47XHJcblxyXG4gIHZhciBub3JtYWxpemVkID0gZGlyZWN0aXZlTm9ybWFsaXplKCduZy0nICsgYXR0ck5hbWUpO1xyXG4gIG5nQXR0cmlidXRlQWxpYXNEaXJlY3RpdmVzW25vcm1hbGl6ZWRdID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcmlvcml0eTogMTAwLFxyXG4gICAgICBjb21waWxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRyW25vcm1hbGl6ZWRdLCBmdW5jdGlvbiBuZ0Jvb2xlYW5BdHRyV2F0Y2hBY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgYXR0ci4kc2V0KGF0dHJOYW1lLCAhIXZhbHVlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxufSk7XHJcblxyXG5cclxuLy8gbmctc3JjLCBuZy1zcmNzZXQsIG5nLWhyZWYgYXJlIGludGVycG9sYXRlZFxyXG5mb3JFYWNoKFsnc3JjJywgJ3NyY3NldCcsICdocmVmJ10sIGZ1bmN0aW9uKGF0dHJOYW1lKSB7XHJcbiAgdmFyIG5vcm1hbGl6ZWQgPSBkaXJlY3RpdmVOb3JtYWxpemUoJ25nLScgKyBhdHRyTmFtZSk7XHJcbiAgbmdBdHRyaWJ1dGVBbGlhc0RpcmVjdGl2ZXNbbm9ybWFsaXplZF0gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHByaW9yaXR5OiA5OSwgLy8gaXQgbmVlZHMgdG8gcnVuIGFmdGVyIHRoZSBhdHRyaWJ1dGVzIGFyZSBpbnRlcnBvbGF0ZWRcclxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgICBhdHRyLiRvYnNlcnZlKG5vcm1hbGl6ZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAoIXZhbHVlKVxyXG4gICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIGF0dHIuJHNldChhdHRyTmFtZSwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgIC8vIG9uIElFLCBpZiBcIm5nOnNyY1wiIGRpcmVjdGl2ZSBkZWNsYXJhdGlvbiBpcyB1c2VkIGFuZCBcInNyY1wiIGF0dHJpYnV0ZSBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAvLyB0aGVuIGNhbGxpbmcgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsICdmb28nKSBkb2Vzbid0IGRvIGFueXRoaW5nLCBzbyB3ZSBuZWVkXHJcbiAgICAgICAgICAvLyB0byBzZXQgdGhlIHByb3BlcnR5IGFzIHdlbGwgdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXHJcbiAgICAgICAgICAvLyB3ZSB1c2UgYXR0clthdHRyTmFtZV0gdmFsdWUgc2luY2UgJHNldCBjYW4gc2FuaXRpemUgdGhlIHVybC5cclxuICAgICAgICAgIGlmIChtc2llKSBlbGVtZW50LnByb3AoYXR0ck5hbWUsIGF0dHJbYXR0ck5hbWVdKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG59KTtcclxuXHJcbnZhciBudWxsRm9ybUN0cmwgPSB7XHJcbiAgJGFkZENvbnRyb2w6IG5vb3AsXHJcbiAgJHJlbW92ZUNvbnRyb2w6IG5vb3AsXHJcbiAgJHNldFZhbGlkaXR5OiBub29wLFxyXG4gICRzZXREaXJ0eTogbm9vcCxcclxuICAkc2V0UHJpc3RpbmU6IG5vb3BcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJHByaXN0aW5lIFRydWUgaWYgdXNlciBoYXMgbm90IGludGVyYWN0ZWQgd2l0aCB0aGUgZm9ybSB5ZXQuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJGRpcnR5IFRydWUgaWYgdXNlciBoYXMgYWxyZWFkeSBpbnRlcmFjdGVkIHdpdGggdGhlIGZvcm0uXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJHZhbGlkIFRydWUgaWYgYWxsIG9mIHRoZSBjb250YWluaW5nIGZvcm1zIGFuZCBjb250cm9scyBhcmUgdmFsaWQuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJGludmFsaWQgVHJ1ZSBpZiBhdCBsZWFzdCBvbmUgY29udGFpbmluZyBjb250cm9sIG9yIGZvcm0gaXMgaW52YWxpZC5cclxuICpcclxuICogQHByb3BlcnR5IHtPYmplY3R9ICRlcnJvciBJcyBhbiBvYmplY3QgaGFzaCwgY29udGFpbmluZyByZWZlcmVuY2VzIHRvIGFsbCBpbnZhbGlkIGNvbnRyb2xzIG9yXHJcbiAqICBmb3Jtcywgd2hlcmU6XHJcbiAqXHJcbiAqICAtIGtleXMgYXJlIHZhbGlkYXRpb24gdG9rZW5zIChlcnJvciBuYW1lcykgw6LigqzigJ0gc3VjaCBhcyBgcmVxdWlyZWRgLCBgdXJsYCBvciBgZW1haWxgKSxcclxuICogIC0gdmFsdWVzIGFyZSBhcnJheXMgb2YgY29udHJvbHMgb3IgZm9ybXMgdGhhdCBhcmUgaW52YWxpZCB3aXRoIGdpdmVuIGVycm9yLlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogYEZvcm1Db250cm9sbGVyYCBrZWVwcyB0cmFjayBvZiBhbGwgaXRzIGNvbnRyb2xzIGFuZCBuZXN0ZWQgZm9ybXMgYXMgd2VsbCBhcyBzdGF0ZSBvZiB0aGVtLFxyXG4gKiBzdWNoIGFzIGJlaW5nIHZhbGlkL2ludmFsaWQgb3IgZGlydHkvcHJpc3RpbmUuXHJcbiAqXHJcbiAqIEVhY2gge0BsaW5rIG5nLmRpcmVjdGl2ZTpmb3JtIGZvcm19IGRpcmVjdGl2ZSBjcmVhdGVzIGFuIGluc3RhbmNlXHJcbiAqIG9mIGBGb3JtQ29udHJvbGxlcmAuXHJcbiAqXHJcbiAqL1xyXG4vL2Fza3MgZm9yICRzY29wZSB0byBmb29sIHRoZSBCQyBjb250cm9sbGVyIG1vZHVsZVxyXG5Gb3JtQ29udHJvbGxlci4kaW5qZWN0ID0gWyckZWxlbWVudCcsICckYXR0cnMnLCAnJHNjb3BlJ107XHJcbmZ1bmN0aW9uIEZvcm1Db250cm9sbGVyKGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgdmFyIGZvcm0gPSB0aGlzLFxyXG4gICAgICBwYXJlbnRGb3JtID0gZWxlbWVudC5wYXJlbnQoKS5jb250cm9sbGVyKCdmb3JtJykgfHwgbnVsbEZvcm1DdHJsLFxyXG4gICAgICBpbnZhbGlkQ291bnQgPSAwLCAvLyB1c2VkIHRvIGVhc2lseSBkZXRlcm1pbmUgaWYgd2UgYXJlIHZhbGlkXHJcbiAgICAgIGVycm9ycyA9IGZvcm0uJGVycm9yID0ge30sXHJcbiAgICAgIGNvbnRyb2xzID0gW107XHJcblxyXG4gIC8vIGluaXQgc3RhdGVcclxuICBmb3JtLiRuYW1lID0gYXR0cnMubmFtZSB8fCBhdHRycy5uZ0Zvcm07XHJcbiAgZm9ybS4kZGlydHkgPSBmYWxzZTtcclxuICBmb3JtLiRwcmlzdGluZSA9IHRydWU7XHJcbiAgZm9ybS4kdmFsaWQgPSB0cnVlO1xyXG4gIGZvcm0uJGludmFsaWQgPSBmYWxzZTtcclxuXHJcbiAgcGFyZW50Rm9ybS4kYWRkQ29udHJvbChmb3JtKTtcclxuXHJcbiAgLy8gU2V0dXAgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgY29udHJvbFxyXG4gIGVsZW1lbnQuYWRkQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpO1xyXG4gIHRvZ2dsZVZhbGlkQ3NzKHRydWUpO1xyXG5cclxuICAvLyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGVhc3kgdG9nZ2xpbmcgb2YgY2xhc3Nlc1xyXG4gIGZ1bmN0aW9uIHRvZ2dsZVZhbGlkQ3NzKGlzVmFsaWQsIHZhbGlkYXRpb25FcnJvcktleSkge1xyXG4gICAgdmFsaWRhdGlvbkVycm9yS2V5ID0gdmFsaWRhdGlvbkVycm9yS2V5ID8gJy0nICsgc25ha2VfY2FzZSh2YWxpZGF0aW9uRXJyb3JLZXksICctJykgOiAnJztcclxuICAgIGVsZW1lbnQuXHJcbiAgICAgIHJlbW92ZUNsYXNzKChpc1ZhbGlkID8gSU5WQUxJRF9DTEFTUyA6IFZBTElEX0NMQVNTKSArIHZhbGlkYXRpb25FcnJvcktleSkuXHJcbiAgICAgIGFkZENsYXNzKChpc1ZhbGlkID8gVkFMSURfQ0xBU1MgOiBJTlZBTElEX0NMQVNTKSArIHZhbGlkYXRpb25FcnJvcktleSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkYWRkQ29udHJvbFxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmVnaXN0ZXIgYSBjb250cm9sIHdpdGggdGhlIGZvcm0uXHJcbiAgICpcclxuICAgKiBJbnB1dCBlbGVtZW50cyB1c2luZyBuZ01vZGVsQ29udHJvbGxlciBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGV5IGFyZSBsaW5rZWQuXHJcbiAgICovXHJcbiAgZm9ybS4kYWRkQ29udHJvbCA9IGZ1bmN0aW9uKGNvbnRyb2wpIHtcclxuICAgIGNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcblxyXG4gICAgaWYgKGNvbnRyb2wuJG5hbWUgJiYgIWZvcm0uaGFzT3duUHJvcGVydHkoY29udHJvbC4kbmFtZSkpIHtcclxuICAgICAgZm9ybVtjb250cm9sLiRuYW1lXSA9IGNvbnRyb2w7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXIjJHJlbW92ZUNvbnRyb2xcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIERlcmVnaXN0ZXIgYSBjb250cm9sIGZyb20gdGhlIGZvcm0uXHJcbiAgICpcclxuICAgKiBJbnB1dCBlbGVtZW50cyB1c2luZyBuZ01vZGVsQ29udHJvbGxlciBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGV5IGFyZSBkZXN0cm95ZWQuXHJcbiAgICovXHJcbiAgZm9ybS4kcmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uKGNvbnRyb2wpIHtcclxuICAgIGlmIChjb250cm9sLiRuYW1lICYmIGZvcm1bY29udHJvbC4kbmFtZV0gPT09IGNvbnRyb2wpIHtcclxuICAgICAgZGVsZXRlIGZvcm1bY29udHJvbC4kbmFtZV07XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGVycm9ycywgZnVuY3Rpb24ocXVldWUsIHZhbGlkYXRpb25Ub2tlbikge1xyXG4gICAgICBmb3JtLiRzZXRWYWxpZGl0eSh2YWxpZGF0aW9uVG9rZW4sIHRydWUsIGNvbnRyb2wpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXJyYXlSZW1vdmUoY29udHJvbHMsIGNvbnRyb2wpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyIyRzZXRWYWxpZGl0eVxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogU2V0cyB0aGUgdmFsaWRpdHkgb2YgYSBmb3JtIGNvbnRyb2wuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gcHJvcGFnYXRlIHRvIHBhcmVudCBmb3Jtcy5cclxuICAgKi9cclxuICBmb3JtLiRzZXRWYWxpZGl0eSA9IGZ1bmN0aW9uKHZhbGlkYXRpb25Ub2tlbiwgaXNWYWxpZCwgY29udHJvbCkge1xyXG4gICAgdmFyIHF1ZXVlID0gZXJyb3JzW3ZhbGlkYXRpb25Ub2tlbl07XHJcblxyXG4gICAgaWYgKGlzVmFsaWQpIHtcclxuICAgICAgaWYgKHF1ZXVlKSB7XHJcbiAgICAgICAgYXJyYXlSZW1vdmUocXVldWUsIGNvbnRyb2wpO1xyXG4gICAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICBpbnZhbGlkQ291bnQtLTtcclxuICAgICAgICAgIGlmICghaW52YWxpZENvdW50KSB7XHJcbiAgICAgICAgICAgIHRvZ2dsZVZhbGlkQ3NzKGlzVmFsaWQpO1xyXG4gICAgICAgICAgICBmb3JtLiR2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvcm0uJGludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVycm9yc1t2YWxpZGF0aW9uVG9rZW5dID0gZmFsc2U7XHJcbiAgICAgICAgICB0b2dnbGVWYWxpZENzcyh0cnVlLCB2YWxpZGF0aW9uVG9rZW4pO1xyXG4gICAgICAgICAgcGFyZW50Rm9ybS4kc2V0VmFsaWRpdHkodmFsaWRhdGlvblRva2VuLCB0cnVlLCBmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWludmFsaWRDb3VudCkge1xyXG4gICAgICAgIHRvZ2dsZVZhbGlkQ3NzKGlzVmFsaWQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIGlmIChpbmNsdWRlcyhxdWV1ZSwgY29udHJvbCkpIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlcnJvcnNbdmFsaWRhdGlvblRva2VuXSA9IHF1ZXVlID0gW107XHJcbiAgICAgICAgaW52YWxpZENvdW50Kys7XHJcbiAgICAgICAgdG9nZ2xlVmFsaWRDc3MoZmFsc2UsIHZhbGlkYXRpb25Ub2tlbik7XHJcbiAgICAgICAgcGFyZW50Rm9ybS4kc2V0VmFsaWRpdHkodmFsaWRhdGlvblRva2VuLCBmYWxzZSwgZm9ybSk7XHJcbiAgICAgIH1cclxuICAgICAgcXVldWUucHVzaChjb250cm9sKTtcclxuXHJcbiAgICAgIGZvcm0uJHZhbGlkID0gZmFsc2U7XHJcbiAgICAgIGZvcm0uJGludmFsaWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyIyRzZXREaXJ0eVxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogU2V0cyB0aGUgZm9ybSB0byBhIGRpcnR5IHN0YXRlLlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byBhZGQgdGhlICduZy1kaXJ0eScgY2xhc3MgYW5kIHNldCB0aGUgZm9ybSB0byBhIGRpcnR5XHJcbiAgICogc3RhdGUgKG5nLWRpcnR5IGNsYXNzKS4gVGhpcyBtZXRob2Qgd2lsbCBhbHNvIHByb3BhZ2F0ZSB0byBwYXJlbnQgZm9ybXMuXHJcbiAgICovXHJcbiAgZm9ybS4kc2V0RGlydHkgPSBmdW5jdGlvbigpIHtcclxuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpLmFkZENsYXNzKERJUlRZX0NMQVNTKTtcclxuICAgIGZvcm0uJGRpcnR5ID0gdHJ1ZTtcclxuICAgIGZvcm0uJHByaXN0aW5lID0gZmFsc2U7XHJcbiAgICBwYXJlbnRGb3JtLiRzZXREaXJ0eSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyIyRzZXRQcmlzdGluZVxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogU2V0cyB0aGUgZm9ybSB0byBpdHMgcHJpc3RpbmUgc3RhdGUuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJlbW92ZSB0aGUgJ25nLWRpcnR5JyBjbGFzcyBhbmQgc2V0IHRoZSBmb3JtIHRvIGl0cyBwcmlzdGluZVxyXG4gICAqIHN0YXRlIChuZy1wcmlzdGluZSBjbGFzcykuIFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBwcm9wYWdhdGUgdG8gYWxsIHRoZSBjb250cm9scyBjb250YWluZWRcclxuICAgKiBpbiB0aGlzIGZvcm0uXHJcbiAgICpcclxuICAgKiBTZXR0aW5nIGEgZm9ybSBiYWNrIHRvIGEgcHJpc3RpbmUgc3RhdGUgaXMgb2Z0ZW4gdXNlZnVsIHdoZW4gd2Ugd2FudCB0byAncmV1c2UnIGEgZm9ybSBhZnRlclxyXG4gICAqIHNhdmluZyBvciByZXNldHRpbmcgaXQuXHJcbiAgICovXHJcbiAgZm9ybS4kc2V0UHJpc3RpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKERJUlRZX0NMQVNTKS5hZGRDbGFzcyhQUklTVElORV9DTEFTUyk7XHJcbiAgICBmb3JtLiRkaXJ0eSA9IGZhbHNlO1xyXG4gICAgZm9ybS4kcHJpc3RpbmUgPSB0cnVlO1xyXG4gICAgZm9yRWFjaChjb250cm9scywgZnVuY3Rpb24oY29udHJvbCkge1xyXG4gICAgICBjb250cm9sLiRzZXRQcmlzdGluZSgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0Zvcm1cclxuICogQHJlc3RyaWN0IEVBQ1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogTmVzdGFibGUgYWxpYXMgb2Yge0BsaW5rIG5nLmRpcmVjdGl2ZTpmb3JtIGBmb3JtYH0gZGlyZWN0aXZlLiBIVE1MXHJcbiAqIGRvZXMgbm90IGFsbG93IG5lc3Rpbmcgb2YgZm9ybSBlbGVtZW50cy4gSXQgaXMgdXNlZnVsIHRvIG5lc3QgZm9ybXMsIGZvciBleGFtcGxlIGlmIHRoZSB2YWxpZGl0eSBvZiBhXHJcbiAqIHN1Yi1ncm91cCBvZiBjb250cm9scyBuZWVkcyB0byBiZSBkZXRlcm1pbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWV8bmdGb3JtIE5hbWUgb2YgdGhlIGZvcm0uIElmIHNwZWNpZmllZCwgdGhlIGZvcm0gY29udHJvbGxlciB3aWxsIGJlIHB1Ymxpc2hlZCBpbnRvXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkIHNjb3BlLCB1bmRlciB0aGlzIG5hbWUuXHJcbiAqXHJcbiAqL1xyXG5cclxuIC8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtXHJcbiAqIEByZXN0cmljdCBFXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEaXJlY3RpdmUgdGhhdCBpbnN0YW50aWF0ZXNcclxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyIEZvcm1Db250cm9sbGVyfS5cclxuICpcclxuICogSWYgYG5hbWVgIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWQsIHRoZSBmb3JtIGNvbnRyb2xsZXIgaXMgcHVibGlzaGVkIG9udG8gdGhlIGN1cnJlbnQgc2NvcGUgdW5kZXJcclxuICogdGhpcyBuYW1lLlxyXG4gKlxyXG4gKiAjIEFsaWFzOiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nRm9ybSBgbmdGb3JtYH1cclxuICpcclxuICogSW4gYW5ndWxhciBmb3JtcyBjYW4gYmUgbmVzdGVkLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG91dGVyIGZvcm0gaXMgdmFsaWQgd2hlbiBhbGwgb2YgdGhlIGNoaWxkXHJcbiAqIGZvcm1zIGFyZSB2YWxpZCBhcyB3ZWxsLiBIb3dldmVyIGJyb3dzZXJzIGRvIG5vdCBhbGxvdyBuZXN0aW5nIG9mIGA8Zm9ybT5gIGVsZW1lbnRzLCBmb3IgdGhpc1xyXG4gKiByZWFzb24gYW5ndWxhciBwcm92aWRlcyB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nRm9ybSBgbmdGb3JtYH0gYWxpYXNcclxuICogd2hpY2ggYmVoYXZlcyBpZGVudGljYWwgdG8gYDxmb3JtPmAgYnV0IGFsbG93cyBmb3JtIG5lc3RpbmcuXHJcbiAqXHJcbiAqXHJcbiAqICMgQ1NTIGNsYXNzZXNcclxuICogIC0gYG5nLXZhbGlkYCBJcyBzZXQgaWYgdGhlIGZvcm0gaXMgdmFsaWQuXHJcbiAqICAtIGBuZy1pbnZhbGlkYCBJcyBzZXQgaWYgdGhlIGZvcm0gaXMgaW52YWxpZC5cclxuICogIC0gYG5nLXByaXN0aW5lYCBJcyBzZXQgaWYgdGhlIGZvcm0gaXMgcHJpc3RpbmUuXHJcbiAqICAtIGBuZy1kaXJ0eWAgSXMgc2V0IGlmIHRoZSBmb3JtIGlzIGRpcnR5LlxyXG4gKlxyXG4gKlxyXG4gKiAjIFN1Ym1pdHRpbmcgYSBmb3JtIGFuZCBwcmV2ZW50aW5nIGRlZmF1bHQgYWN0aW9uXHJcbiAqXHJcbiAqIFNpbmNlIHRoZSByb2xlIG9mIGZvcm1zIGluIGNsaWVudC1zaWRlIEFuZ3VsYXIgYXBwbGljYXRpb25zIGlzIGRpZmZlcmVudCB0aGFuIGluIGNsYXNzaWNhbFxyXG4gKiByb3VuZHRyaXAgYXBwcywgaXQgaXMgZGVzaXJhYmxlIGZvciB0aGUgYnJvd3NlciBub3QgdG8gdHJhbnNsYXRlIHRoZSBmb3JtIHN1Ym1pc3Npb24gaW50byBhIGZ1bGxcclxuICogcGFnZSByZWxvYWQgdGhhdCBzZW5kcyB0aGUgZGF0YSB0byB0aGUgc2VydmVyLiBJbnN0ZWFkIHNvbWUgamF2YXNjcmlwdCBsb2dpYyBzaG91bGQgYmUgdHJpZ2dlcmVkXHJcbiAqIHRvIGhhbmRsZSB0aGUgZm9ybSBzdWJtaXNzaW9uIGluIGFwcGxpY2F0aW9uIHNwZWNpZmljIHdheS5cclxuICpcclxuICogRm9yIHRoaXMgcmVhc29uLCBBbmd1bGFyIHByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiAoZm9ybSBzdWJtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIpIHVubGVzcyB0aGVcclxuICogYDxmb3JtPmAgZWxlbWVudCBoYXMgYW4gYGFjdGlvbmAgYXR0cmlidXRlIHNwZWNpZmllZC5cclxuICpcclxuICogWW91IGNhbiB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgdHdvIHdheXMgdG8gc3BlY2lmeSB3aGF0IGphdmFzY3JpcHQgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgd2hlblxyXG4gKiBhIGZvcm0gaXMgc3VibWl0dGVkOlxyXG4gKlxyXG4gKiAtIHtAbGluayBuZy5kaXJlY3RpdmU6bmdTdWJtaXQgbmdTdWJtaXR9IGRpcmVjdGl2ZSBvbiB0aGUgZm9ybSBlbGVtZW50XHJcbiAqIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9IGRpcmVjdGl2ZSBvbiB0aGUgZmlyc3RcclxuICAqICBidXR0b24gb3IgaW5wdXQgZmllbGQgb2YgdHlwZSBzdWJtaXQgKGlucHV0W3R5cGU9c3VibWl0XSlcclxuICpcclxuICogVG8gcHJldmVudCBkb3VibGUgZXhlY3V0aW9uIG9mIHRoZSBoYW5kbGVyLCB1c2Ugb25seSBvbmUgb2YgbmdTdWJtaXQgb3IgbmdDbGljayBkaXJlY3RpdmVzLiBUaGlzXHJcbiAqIGlzIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBmb3JtIHN1Ym1pc3Npb24gcnVsZXMgY29taW5nIGZyb20gdGhlIGh0bWwgc3BlYzpcclxuICpcclxuICogLSBJZiBhIGZvcm0gaGFzIG9ubHkgb25lIGlucHV0IGZpZWxkIHRoZW4gaGl0dGluZyBlbnRlciBpbiB0aGlzIGZpZWxkIHRyaWdnZXJzIGZvcm0gc3VibWl0XHJcbiAqIChgbmdTdWJtaXRgKVxyXG4gKiAtIGlmIGEgZm9ybSBoYXMgaGFzIDIrIGlucHV0IGZpZWxkcyBhbmQgbm8gYnV0dG9ucyBvciBpbnB1dFt0eXBlPXN1Ym1pdF0gdGhlbiBoaXR0aW5nIGVudGVyXHJcbiAqIGRvZXNuJ3QgdHJpZ2dlciBzdWJtaXRcclxuICogLSBpZiBhIGZvcm0gaGFzIG9uZSBvciBtb3JlIGlucHV0IGZpZWxkcyBhbmQgb25lIG9yIG1vcmUgYnV0dG9ucyBvciBpbnB1dFt0eXBlPXN1Ym1pdF0gdGhlblxyXG4gKiBoaXR0aW5nIGVudGVyIGluIGFueSBvZiB0aGUgaW5wdXQgZmllbGRzIHdpbGwgdHJpZ2dlciB0aGUgY2xpY2sgaGFuZGxlciBvbiB0aGUgKmZpcnN0KiBidXR0b24gb3JcclxuICogaW5wdXRbdHlwZT1zdWJtaXRdIChgbmdDbGlja2ApICphbmQqIGEgc3VibWl0IGhhbmRsZXIgb24gdGhlIGVuY2xvc2luZyBmb3JtIChgbmdTdWJtaXRgKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgTmFtZSBvZiB0aGUgZm9ybS4gSWYgc3BlY2lmaWVkLCB0aGUgZm9ybSBjb250cm9sbGVyIHdpbGwgYmUgcHVibGlzaGVkIGludG9cclxuICogICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQgc2NvcGUsIHVuZGVyIHRoaXMgbmFtZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS51c2VyVHlwZSA9ICdndWVzdCc7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgIHVzZXJUeXBlOiA8aW5wdXQgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ1c2VyVHlwZVwiIHJlcXVpcmVkPlxyXG4gICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IucmVxdWlyZWRcIj5SZXF1aXJlZCE8L3NwYW4+PGJyPlxyXG4gICAgICAgICA8dHQ+dXNlclR5cGUgPSB7e3VzZXJUeXBlfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnI+XHJcbiAgICAgICAgPC9mb3JtPlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd1c2VyVHlwZScpKS50b0VxdWFsKCdndWVzdCcpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgndXNlclR5cGUnKS5lbnRlcignJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd1c2VyVHlwZScpKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxudmFyIGZvcm1EaXJlY3RpdmVGYWN0b3J5ID0gZnVuY3Rpb24oaXNOZ0Zvcm0pIHtcclxuICByZXR1cm4gWyckdGltZW91dCcsIGZ1bmN0aW9uKCR0aW1lb3V0KSB7XHJcbiAgICB2YXIgZm9ybURpcmVjdGl2ZSA9IHtcclxuICAgICAgbmFtZTogJ2Zvcm0nLFxyXG4gICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICBjb250cm9sbGVyOiBGb3JtQ29udHJvbGxlcixcclxuICAgICAgY29tcGlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHByZTogZnVuY3Rpb24oc2NvcGUsIGZvcm1FbGVtZW50LCBhdHRyLCBjb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghYXR0ci5hY3Rpb24pIHtcclxuICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1c2UganEgZXZlbnRzIGJlY2F1c2UgaWYgYSBmb3JtIGlzIGRlc3Ryb3llZCBkdXJpbmcgc3VibWlzc2lvbiB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgIC8vIGFjdGlvbiBpcyBub3QgcHJldmVudGVkLiBzZWUgIzEyMzhcclxuICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgIC8vIElFIDkgaXMgbm90IGFmZmVjdGVkIGJlY2F1c2UgaXQgZG9lc24ndCBmaXJlIGEgc3VibWl0IGV2ZW50IGFuZCB0cnkgdG8gZG8gYSBmdWxsXHJcbiAgICAgICAgICAgICAgLy8gcGFnZSByZWxvYWQgaWYgdGhlIGZvcm0gd2FzIGRlc3Ryb3llZCBieSBzdWJtaXNzaW9uIG9mIHRoZSBmb3JtIHZpYSBhIGNsaWNrIGhhbmRsZXJcclxuICAgICAgICAgICAgICAvLyBvbiBhIGJ1dHRvbiBpbiB0aGUgZm9ybS4gTG9va3MgbGlrZSBhbiBJRTkgc3BlY2lmaWMgYnVnLlxyXG4gICAgICAgICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgID8gZXZlbnQucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICAgICAgICAgICA6IGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vIElFXHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lckZuKGZvcm1FbGVtZW50WzBdLCAnc3VibWl0JywgcHJldmVudERlZmF1bHRMaXN0ZW5lcik7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHVucmVnaXN0ZXIgdGhlIHByZXZlbnREZWZhdWx0IGxpc3RlbmVyIHNvIHRoYXQgd2UgZG9uJ3Qgbm90IGxlYWsgbWVtb3J5IGJ1dCBpbiBhXHJcbiAgICAgICAgICAgICAgLy8gd2F5IHRoYXQgd2lsbCBhY2hpZXZlIHRoZSBwcmV2ZW50aW9uIG9mIHRoZSBkZWZhdWx0IGFjdGlvbi5cclxuICAgICAgICAgICAgICBmb3JtRWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyRm4oZm9ybUVsZW1lbnRbMF0sICdzdWJtaXQnLCBwcmV2ZW50RGVmYXVsdExpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHBhcmVudEZvcm1DdHJsID0gZm9ybUVsZW1lbnQucGFyZW50KCkuY29udHJvbGxlcignZm9ybScpLFxyXG4gICAgICAgICAgICAgICAgYWxpYXMgPSBhdHRyLm5hbWUgfHwgYXR0ci5uZ0Zvcm07XHJcblxyXG4gICAgICAgICAgICBpZiAoYWxpYXMpIHtcclxuICAgICAgICAgICAgICBzZXR0ZXIoc2NvcGUsIGFsaWFzLCBjb250cm9sbGVyLCBhbGlhcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudEZvcm1DdHJsKSB7XHJcbiAgICAgICAgICAgICAgZm9ybUVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRGb3JtQ3RybC4kcmVtb3ZlQ29udHJvbChjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbGlhcykge1xyXG4gICAgICAgICAgICAgICAgICBzZXR0ZXIoc2NvcGUsIGFsaWFzLCB1bmRlZmluZWQsIGFsaWFzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4dGVuZChjb250cm9sbGVyLCBudWxsRm9ybUN0cmwpOyAvL3N0b3AgcHJvcGFnYXRpbmcgY2hpbGQgZGVzdHJ1Y3Rpb24gaGFuZGxlcnMgdXB3YXJkc1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gaXNOZ0Zvcm0gPyBleHRlbmQoY29weShmb3JtRGlyZWN0aXZlKSwge3Jlc3RyaWN0OiAnRUFDJ30pIDogZm9ybURpcmVjdGl2ZTtcclxuICB9XTtcclxufTtcclxuXHJcbnZhciBmb3JtRGlyZWN0aXZlID0gZm9ybURpcmVjdGl2ZUZhY3RvcnkoKTtcclxudmFyIG5nRm9ybURpcmVjdGl2ZSA9IGZvcm1EaXJlY3RpdmVGYWN0b3J5KHRydWUpO1xyXG5cclxudmFyIFVSTF9SRUdFWFAgPSAvXihmdHB8aHR0cHxodHRwcyk6XFwvXFwvKFxcdys6ezAsMX1cXHcqQCk/KFxcUyspKDpbMC05XSspPyhcXC98XFwvKFtcXHcjITouPys9JiVAIVxcLVxcL10pKT8kLztcclxudmFyIEVNQUlMX1JFR0VYUCA9IC9eW0EtWmEtejAtOS5fJSstXStAW0EtWmEtejAtOS4tXStcXC5bQS1aYS16XXsyLDZ9JC87XHJcbnZhciBOVU1CRVJfUkVHRVhQID0gL15cXHMqKFxcLXxcXCspPyhcXGQrfChcXGQqKFxcLlxcZCopKSlcXHMqJC87XHJcblxyXG52YXIgaW5wdXRUeXBlID0ge1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgaW5wdXRUeXBlXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0LnRleHRcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFN0YW5kYXJkIEhUTUwgdGV4dCBpbnB1dCB3aXRoIGFuZ3VsYXIgZGF0YSBiaW5kaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHJlcXVpcmVkIEFkZHMgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbm90IGVudGVyZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1JlcXVpcmVkIEFkZHMgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgYW5kIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBjb25zdHJhaW50IHRvXHJcbiAgICogICAgdGhlIGVsZW1lbnQgd2hlbiB0aGUgbmdSZXF1aXJlZCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLiBVc2UgYG5nUmVxdWlyZWRgIGluc3RlYWQgb2ZcclxuICAgKiAgICBgcmVxdWlyZWRgIHdoZW4geW91IHdhbnQgdG8gZGF0YS1iaW5kIHRvIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWlubGVuZ3RoIFNldHMgYG1pbmxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIHNob3J0ZXIgdGhhblxyXG4gICAqICAgIG1pbmxlbmd0aC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWF4bGVuZ3RoIFNldHMgYG1heGxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuXHJcbiAgICogICAgbWF4bGVuZ3RoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdQYXR0ZXJuIFNldHMgYHBhdHRlcm5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGVcclxuICAgKiAgICBSZWdFeHAgcGF0dGVybiBleHByZXNzaW9uLiBFeHBlY3RlZCB2YWx1ZSBpcyBgL3JlZ2V4cC9gIGZvciBpbmxpbmUgcGF0dGVybnMgb3IgYHJlZ2V4cGAgZm9yXHJcbiAgICogICAgcGF0dGVybnMgZGVmaW5lZCBhcyBzY29wZSBleHByZXNzaW9ucy5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtuZ1RyaW09dHJ1ZV0gSWYgc2V0IHRvIGZhbHNlIEFuZ3VsYXIgd2lsbCBub3QgYXV0b21hdGljYWxseSB0cmltbWluZyB0aGVcclxuICAgKiAgICBpbnB1dC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICAgJHNjb3BlLnRleHQgPSAnZ3Vlc3QnO1xyXG4gICAgICAgICAgICAgJHNjb3BlLndvcmQgPSAvXlxccypcXHcqXFxzKiQvO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICAgIFNpbmdsZSB3b3JkOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiaW5wdXRcIiBuZy1tb2RlbD1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmctcGF0dGVybj1cIndvcmRcIiByZXF1aXJlZCBuZy10cmltPVwiZmFsc2VcIj5cclxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IucmVxdWlyZWRcIj5cclxuICAgICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj5cclxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IucGF0dGVyblwiPlxyXG4gICAgICAgICAgICAgU2luZ2xlIHdvcmQgb25seSE8L3NwYW4+XHJcblxyXG4gICAgICAgICAgIDx0dD50ZXh0ID0ge3t0ZXh0fX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0ZXh0JykpLnRvRXF1YWwoJ2d1ZXN0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbXVsdGkgd29yZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCdoZWxsbyB3b3JsZCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBub3QgYmUgdHJpbW1lZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCd1bnRyaW1tZWQgJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0ZXh0JykpLnRvRXF1YWwoJ3VudHJpbW1lZCAnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgJ3RleHQnOiB0ZXh0SW5wdXRUeXBlLFxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGlucHV0VHlwZVxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTppbnB1dC5udW1iZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRleHQgaW5wdXQgd2l0aCBudW1iZXIgdmFsaWRhdGlvbiBhbmQgdHJhbnNmb3JtYXRpb24uIFNldHMgdGhlIGBudW1iZXJgIHZhbGlkYXRpb25cclxuICAgKiBlcnJvciBpZiBub3QgYSB2YWxpZCBudW1iZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbWluIFNldHMgdGhlIGBtaW5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBlbnRlcmVkIGlzIGxlc3MgdGhhbiBgbWluYC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1heCBTZXRzIHRoZSBgbWF4YCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZW50ZXJlZCBpcyBncmVhdGVyIHRoYW4gYG1heGAuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIG5vdCBlbnRlcmVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xyXG4gICAqICAgIHRoZSBlbGVtZW50IHdoZW4gdGhlIG5nUmVxdWlyZWQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gVXNlIGBuZ1JlcXVpcmVkYCBpbnN0ZWFkIG9mXHJcbiAgICogICAgYHJlcXVpcmVkYCB3aGVuIHlvdSB3YW50IHRvIGRhdGEtYmluZCB0byB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cclxuICAgKiAgICBtaW5sZW5ndGguXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxyXG4gICAqICAgIG1heGxlbmd0aC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUGF0dGVybiBTZXRzIGBwYXR0ZXJuYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlXHJcbiAgICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxyXG4gICAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXHJcbiAgICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICAgJHNjb3BlLnZhbHVlID0gMTI7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICA8L3NjcmlwdD5cclxuICAgICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgICAgTnVtYmVyOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5hbWU9XCJpbnB1dFwiIG5nLW1vZGVsPVwidmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjBcIiBtYXg9XCI5OVwiIHJlcXVpcmVkPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5yZXF1aXJlZFwiPlxyXG4gICAgICAgICAgICAgUmVxdWlyZWQhPC9zcGFuPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5udW1iZXJcIj5cclxuICAgICAgICAgICAgIE5vdCB2YWxpZCBudW1iZXIhPC9zcGFuPlxyXG4gICAgICAgICAgIDx0dD52YWx1ZSA9IHt7dmFsdWV9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiR2YWxpZCA9IHt7bXlGb3JtLmlucHV0LiR2YWxpZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uaW5wdXQuJGVycm9yID0ge3tteUZvcm0uaW5wdXQuJGVycm9yfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLiRlcnJvci5yZXF1aXJlZCA9IHt7ISFteUZvcm0uJGVycm9yLnJlcXVpcmVkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdG8gbW9kZWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUnKSkudG9FcXVhbCgnMTInKTtcclxuICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgZW1wdHknLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICBpbnB1dCgndmFsdWUnKS5lbnRlcignJyk7XHJcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlJykpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgb3ZlciBtYXgnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICBpbnB1dCgndmFsdWUnKS5lbnRlcignMTIzJyk7XHJcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlJykpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgICAgPC9kb2M6ZXhhbXBsZT5cclxuICAgKi9cclxuICAnbnVtYmVyJzogbnVtYmVySW5wdXRUeXBlLFxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGlucHV0VHlwZVxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTppbnB1dC51cmxcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRleHQgaW5wdXQgd2l0aCBVUkwgdmFsaWRhdGlvbi4gU2V0cyB0aGUgYHVybGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFcclxuICAgKiB2YWxpZCBVUkwuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBub3QgZW50ZXJlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUmVxdWlyZWQgQWRkcyBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBhbmQgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGNvbnN0cmFpbnQgdG9cclxuICAgKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxyXG4gICAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNaW5sZW5ndGggU2V0cyBgbWlubGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgc2hvcnRlciB0aGFuXHJcbiAgICogICAgbWlubGVuZ3RoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNYXhsZW5ndGggU2V0cyBgbWF4bGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbG9uZ2VyIHRoYW5cclxuICAgKiAgICBtYXhsZW5ndGguXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxyXG4gICAqICAgIFJlZ0V4cCBwYXR0ZXJuIGV4cHJlc3Npb24uIEV4cGVjdGVkIHZhbHVlIGlzIGAvcmVnZXhwL2AgZm9yIGlubGluZSBwYXR0ZXJucyBvciBgcmVnZXhwYCBmb3JcclxuICAgKiAgICBwYXR0ZXJucyBkZWZpbmVkIGFzIHNjb3BlIGV4cHJlc3Npb25zLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxyXG4gICAqICAgIGludGVyYWN0aW9uIHdpdGggdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAgICRzY29wZS50ZXh0ID0gJ2h0dHA6Ly9nb29nbGUuY29tJztcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCIgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgICBVUkw6IDxpbnB1dCB0eXBlPVwidXJsXCIgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ0ZXh0XCIgcmVxdWlyZWQ+XHJcbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+XHJcbiAgICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+XHJcbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnVybFwiPlxyXG4gICAgICAgICAgICAgTm90IHZhbGlkIHVybCE8L3NwYW4+XHJcbiAgICAgICAgICAgPHR0PnRleHQgPSB7e3RleHR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiR2YWxpZCA9IHt7bXlGb3JtLmlucHV0LiR2YWxpZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uaW5wdXQuJGVycm9yID0ge3tteUZvcm0uaW5wdXQuJGVycm9yfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLiRlcnJvci5yZXF1aXJlZCA9IHt7ISFteUZvcm0uJGVycm9yLnJlcXVpcmVkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IudXJsID0ge3shIW15Rm9ybS4kZXJyb3IudXJsfX08L3R0Pjxici8+XHJcbiAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdG8gbW9kZWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnaHR0cDovL2dvb2dsZS5jb20nKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIGVtcHR5JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBub3QgdXJsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJ3h4eCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgJ3VybCc6IHVybElucHV0VHlwZSxcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQuZW1haWxcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRleHQgaW5wdXQgd2l0aCBlbWFpbCB2YWxpZGF0aW9uLiBTZXRzIHRoZSBgZW1haWxgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIG5vdCBhIHZhbGlkIGVtYWlsXHJcbiAgICogYWRkcmVzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIG5vdCBlbnRlcmVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xyXG4gICAqICAgIHRoZSBlbGVtZW50IHdoZW4gdGhlIG5nUmVxdWlyZWQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gVXNlIGBuZ1JlcXVpcmVkYCBpbnN0ZWFkIG9mXHJcbiAgICogICAgYHJlcXVpcmVkYCB3aGVuIHlvdSB3YW50IHRvIGRhdGEtYmluZCB0byB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cclxuICAgKiAgICBtaW5sZW5ndGguXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxyXG4gICAqICAgIG1heGxlbmd0aC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUGF0dGVybiBTZXRzIGBwYXR0ZXJuYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlXHJcbiAgICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxyXG4gICAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXHJcbiAgICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICAgJHNjb3BlLnRleHQgPSAnbWVAZXhhbXBsZS5jb20nO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgICAgICBFbWFpbDogPGlucHV0IHR5cGU9XCJlbWFpbFwiIG5hbWU9XCJpbnB1dFwiIG5nLW1vZGVsPVwidGV4dFwiIHJlcXVpcmVkPlxyXG4gICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+XHJcbiAgICAgICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj5cclxuICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5lbWFpbFwiPlxyXG4gICAgICAgICAgICAgICBOb3QgdmFsaWQgZW1haWwhPC9zcGFuPlxyXG4gICAgICAgICAgICAgPHR0PnRleHQgPSB7e3RleHR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICAgIDx0dD5teUZvcm0uaW5wdXQuJHZhbGlkID0ge3tteUZvcm0uaW5wdXQuJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnIvPlxyXG4gICAgICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnJlcXVpcmVkID0ge3shIW15Rm9ybS4kZXJyb3IucmVxdWlyZWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLmVtYWlsID0ge3shIW15Rm9ybS4kZXJyb3IuZW1haWx9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdG8gbW9kZWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnbWVAZXhhbXBsZS5jb20nKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIGVtcHR5JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBub3QgZW1haWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcigneHh4Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgICAgPC9kb2M6ZXhhbXBsZT5cclxuICAgKi9cclxuICAnZW1haWwnOiBlbWFpbElucHV0VHlwZSxcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQucmFkaW9cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEhUTUwgcmFkaW8gYnV0dG9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd2hpY2ggdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHNldCB3aGVuIHNlbGVjdGVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAkc2NvcGUuY29sb3IgPSAnYmx1ZSc7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICA8L3NjcmlwdD5cclxuICAgICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5nLW1vZGVsPVwiY29sb3JcIiB2YWx1ZT1cInJlZFwiPiAgUmVkIDxici8+XHJcbiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5nLW1vZGVsPVwiY29sb3JcIiB2YWx1ZT1cImdyZWVuXCI+IEdyZWVuIDxici8+XHJcbiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5nLW1vZGVsPVwiY29sb3JcIiB2YWx1ZT1cImJsdWVcIj4gQmx1ZSA8YnIvPlxyXG4gICAgICAgICAgIDx0dD5jb2xvciA9IHt7Y29sb3J9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICAgIGl0KCdzaG91bGQgY2hhbmdlIHN0YXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb2xvcicpKS50b0VxdWFsKCdibHVlJyk7XHJcblxyXG4gICAgICAgICAgICBpbnB1dCgnY29sb3InKS5zZWxlY3QoJ3JlZCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnY29sb3InKSkudG9FcXVhbCgncmVkJyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgICAgPC9kb2M6ZXhhbXBsZT5cclxuICAgKi9cclxuICAncmFkaW8nOiByYWRpb0lucHV0VHlwZSxcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQuY2hlY2tib3hcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEhUTUwgY2hlY2tib3guXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdUcnVlVmFsdWUgVGhlIHZhbHVlIHRvIHdoaWNoIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzZXQgd2hlbiBzZWxlY3RlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nRmFsc2VWYWx1ZSBUaGUgdmFsdWUgdG8gd2hpY2ggdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHNldCB3aGVuIG5vdCBzZWxlY3RlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAkc2NvcGUudmFsdWUxID0gdHJ1ZTtcclxuICAgICAgICAgICAgICRzY29wZS52YWx1ZTIgPSAnWUVTJ1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICAgIFZhbHVlMTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwidmFsdWUxXCI+IDxici8+XHJcbiAgICAgICAgICAgVmFsdWUyOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJ2YWx1ZTJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5nLXRydWUtdmFsdWU9XCJZRVNcIiBuZy1mYWxzZS12YWx1ZT1cIk5PXCI+IDxici8+XHJcbiAgICAgICAgICAgPHR0PnZhbHVlMSA9IHt7dmFsdWUxfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0PnZhbHVlMiA9IHt7dmFsdWUyfX08L3R0Pjxici8+XHJcbiAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGNoYW5nZSBzdGF0ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUxJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlMicpKS50b0VxdWFsKCdZRVMnKTtcclxuXHJcbiAgICAgICAgICAgIGlucHV0KCd2YWx1ZTEnKS5jaGVjaygpO1xyXG4gICAgICAgICAgICBpbnB1dCgndmFsdWUyJykuY2hlY2soKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlMScpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUyJykpLnRvRXF1YWwoJ05PJyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgICAgPC9kb2M6ZXhhbXBsZT5cclxuICAgKi9cclxuICAnY2hlY2tib3gnOiBjaGVja2JveElucHV0VHlwZSxcclxuXHJcbiAgJ2hpZGRlbic6IG5vb3AsXHJcbiAgJ2J1dHRvbic6IG5vb3AsXHJcbiAgJ3N1Ym1pdCc6IG5vb3AsXHJcbiAgJ3Jlc2V0Jzogbm9vcFxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcclxuICByZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWU7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0ZXh0SW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcclxuXHJcbiAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnZhbCgpO1xyXG5cclxuICAgIC8vIEJ5IGRlZmF1bHQgd2Ugd2lsbCB0cmltIHRoZSB2YWx1ZVxyXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBuZy10cmltIGV4aXN0cyB3ZSB3aWxsIGF2b2lkIHRyaW1taW5nXHJcbiAgICAvLyBlLmcuIDxpbnB1dCBuZy1tb2RlbD1cImZvb1wiIG5nLXRyaW09XCJmYWxzZVwiPlxyXG4gICAgaWYgKHRvQm9vbGVhbihhdHRyLm5nVHJpbSB8fCAnVCcpKSB7XHJcbiAgICAgIHZhbHVlID0gdHJpbSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN0cmwuJHZpZXdWYWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIGlmIHRoZSBicm93c2VyIGRvZXMgc3VwcG9ydCBcImlucHV0XCIgZXZlbnQsIHdlIGFyZSBmaW5lIC0gZXhjZXB0IG9uIElFOSB3aGljaCBkb2Vzbid0IGZpcmUgdGhlXHJcbiAgLy8gaW5wdXQgZXZlbnQgb24gYmFja3NwYWNlLCBkZWxldGUgb3IgY3V0XHJcbiAgaWYgKCRzbmlmZmVyLmhhc0V2ZW50KCdpbnB1dCcpKSB7XHJcbiAgICBlbGVtZW50Lm9uKCdpbnB1dCcsIGxpc3RlbmVyKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIHRpbWVvdXQ7XHJcblxyXG4gICAgdmFyIGRlZmVyTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aW1lb3V0KSB7XHJcbiAgICAgICAgdGltZW91dCA9ICRicm93c2VyLmRlZmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGVsZW1lbnQub24oJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZTtcclxuXHJcbiAgICAgIC8vIGlnbm9yZVxyXG4gICAgICAvLyAgICBjb21tYW5kICAgICAgICAgICAgbW9kaWZpZXJzICAgICAgICAgICAgICAgICAgIGFycm93c1xyXG4gICAgICBpZiAoa2V5ID09PSA5MSB8fCAoMTUgPCBrZXkgJiYga2V5IDwgMTkpIHx8ICgzNyA8PSBrZXkgJiYga2V5IDw9IDQwKSkgcmV0dXJuO1xyXG5cclxuICAgICAgZGVmZXJMaXN0ZW5lcigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaWYgdXNlciBwYXN0ZSBpbnRvIGlucHV0IHVzaW5nIG1vdXNlLCB3ZSBuZWVkIFwiY2hhbmdlXCIgZXZlbnQgdG8gY2F0Y2ggaXRcclxuICAgIGVsZW1lbnQub24oJ2NoYW5nZScsIGxpc3RlbmVyKTtcclxuXHJcbiAgICAvLyBpZiB1c2VyIG1vZGlmaWVzIGlucHV0IHZhbHVlIHVzaW5nIGNvbnRleHQgbWVudSBpbiBJRSwgd2UgbmVlZCBcInBhc3RlXCIgYW5kIFwiY3V0XCIgZXZlbnRzIHRvIGNhdGNoIGl0XHJcbiAgICBpZiAoJHNuaWZmZXIuaGFzRXZlbnQoJ3Bhc3RlJykpIHtcclxuICAgICAgZWxlbWVudC5vbigncGFzdGUgY3V0JywgZGVmZXJMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgY3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICBlbGVtZW50LnZhbChpc0VtcHR5KGN0cmwuJHZpZXdWYWx1ZSkgPyAnJyA6IGN0cmwuJHZpZXdWYWx1ZSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gcGF0dGVybiB2YWxpZGF0b3JcclxuICB2YXIgcGF0dGVybiA9IGF0dHIubmdQYXR0ZXJuLFxyXG4gICAgICBwYXR0ZXJuVmFsaWRhdG9yLFxyXG4gICAgICBtYXRjaDtcclxuXHJcbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24ocmVnZXhwLCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzRW1wdHkodmFsdWUpIHx8IHJlZ2V4cC50ZXN0KHZhbHVlKSkge1xyXG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgncGF0dGVybicsIHRydWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgncGF0dGVybicsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpZiAocGF0dGVybikge1xyXG4gICAgbWF0Y2ggPSBwYXR0ZXJuLm1hdGNoKC9eXFwvKC4qKVxcLyhbZ2ltXSopJC8pO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKG1hdGNoWzFdLCBtYXRjaFsyXSk7XHJcbiAgICAgIHBhdHRlcm5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwYXR0ZXJuLCB2YWx1ZSlcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdHRlcm5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBwYXR0ZXJuT2JqID0gc2NvcGUuJGV2YWwocGF0dGVybik7XHJcblxyXG4gICAgICAgIGlmICghcGF0dGVybk9iaiB8fCAhcGF0dGVybk9iai50ZXN0KSB7XHJcbiAgICAgICAgICB0aHJvdyBtaW5FcnIoJ25nUGF0dGVybicpKCdub3JlZ2V4cCcsXHJcbiAgICAgICAgICAgICdFeHBlY3RlZCB7MH0gdG8gYmUgYSBSZWdFeHAgYnV0IHdhcyB7MX0uIEVsZW1lbnQ6IHsyfScsIHBhdHRlcm4sXHJcbiAgICAgICAgICAgIHBhdHRlcm5PYmosIHN0YXJ0aW5nVGFnKGVsZW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHBhdHRlcm5PYmosIHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2gocGF0dGVyblZhbGlkYXRvcik7XHJcbiAgICBjdHJsLiRwYXJzZXJzLnB1c2gocGF0dGVyblZhbGlkYXRvcik7XHJcbiAgfVxyXG5cclxuICAvLyBtaW4gbGVuZ3RoIHZhbGlkYXRvclxyXG4gIGlmIChhdHRyLm5nTWlubGVuZ3RoKSB7XHJcbiAgICB2YXIgbWlubGVuZ3RoID0gaW50KGF0dHIubmdNaW5sZW5ndGgpO1xyXG4gICAgdmFyIG1pbkxlbmd0aFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICghaXNFbXB0eSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoIDwgbWlubGVuZ3RoKSB7XHJcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21pbmxlbmd0aCcsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtaW5sZW5ndGgnLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKG1pbkxlbmd0aFZhbGlkYXRvcik7XHJcbiAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2gobWluTGVuZ3RoVmFsaWRhdG9yKTtcclxuICB9XHJcblxyXG4gIC8vIG1heCBsZW5ndGggdmFsaWRhdG9yXHJcbiAgaWYgKGF0dHIubmdNYXhsZW5ndGgpIHtcclxuICAgIHZhciBtYXhsZW5ndGggPSBpbnQoYXR0ci5uZ01heGxlbmd0aCk7XHJcbiAgICB2YXIgbWF4TGVuZ3RoVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKCFpc0VtcHR5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiBtYXhsZW5ndGgpIHtcclxuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWF4bGVuZ3RoJywgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21heGxlbmd0aCcsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjdHJsLiRwYXJzZXJzLnB1c2gobWF4TGVuZ3RoVmFsaWRhdG9yKTtcclxuICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaChtYXhMZW5ndGhWYWxpZGF0b3IpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbnVtYmVySW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcclxuICB0ZXh0SW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpO1xyXG5cclxuICBjdHJsLiRwYXJzZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhciBlbXB0eSA9IGlzRW1wdHkodmFsdWUpO1xyXG4gICAgaWYgKGVtcHR5IHx8IE5VTUJFUl9SRUdFWFAudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ251bWJlcicsIHRydWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6IChlbXB0eSA/IHZhbHVlIDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ251bWJlcicsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZSkgPyAnJyA6ICcnICsgdmFsdWU7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChhdHRyLm1pbikge1xyXG4gICAgdmFyIG1pbiA9IHBhcnNlRmxvYXQoYXR0ci5taW4pO1xyXG4gICAgdmFyIG1pblZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICghaXNFbXB0eSh2YWx1ZSkgJiYgdmFsdWUgPCBtaW4pIHtcclxuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWluJywgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21pbicsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjdHJsLiRwYXJzZXJzLnB1c2gobWluVmFsaWRhdG9yKTtcclxuICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaChtaW5WYWxpZGF0b3IpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF0dHIubWF4KSB7XHJcbiAgICB2YXIgbWF4ID0gcGFyc2VGbG9hdChhdHRyLm1heCk7XHJcbiAgICB2YXIgbWF4VmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKCFpc0VtcHR5KHZhbHVlKSAmJiB2YWx1ZSA+IG1heCkge1xyXG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtYXgnLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWF4JywgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGN0cmwuJHBhcnNlcnMucHVzaChtYXhWYWxpZGF0b3IpO1xyXG4gICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKG1heFZhbGlkYXRvcik7XHJcbiAgfVxyXG5cclxuICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuXHJcbiAgICBpZiAoaXNFbXB0eSh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdudW1iZXInLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ251bWJlcicsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXJsSW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcclxuICB0ZXh0SW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpO1xyXG5cclxuICB2YXIgdXJsVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmIChpc0VtcHR5KHZhbHVlKSB8fCBVUkxfUkVHRVhQLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCd1cmwnLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3VybCcsIGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2godXJsVmFsaWRhdG9yKTtcclxuICBjdHJsLiRwYXJzZXJzLnB1c2godXJsVmFsaWRhdG9yKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW1haWxJbnB1dFR5cGUoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwsICRzbmlmZmVyLCAkYnJvd3Nlcikge1xyXG4gIHRleHRJbnB1dFR5cGUoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwsICRzbmlmZmVyLCAkYnJvd3Nlcik7XHJcblxyXG4gIHZhciBlbWFpbFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNFbXB0eSh2YWx1ZSkgfHwgRU1BSUxfUkVHRVhQLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdlbWFpbCcsIHRydWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnZW1haWwnLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGVtYWlsVmFsaWRhdG9yKTtcclxuICBjdHJsLiRwYXJzZXJzLnB1c2goZW1haWxWYWxpZGF0b3IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByYWRpb0lucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCkge1xyXG4gIC8vIG1ha2UgdGhlIG5hbWUgdW5pcXVlLCBpZiBub3QgZGVmaW5lZFxyXG4gIGlmIChpc1VuZGVmaW5lZChhdHRyLm5hbWUpKSB7XHJcbiAgICBlbGVtZW50LmF0dHIoJ25hbWUnLCBuZXh0VWlkKCkpO1xyXG4gIH1cclxuXHJcbiAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgIGlmIChlbGVtZW50WzBdLmNoZWNrZWQpIHtcclxuICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZShhdHRyLnZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcclxuICAgIGVsZW1lbnRbMF0uY2hlY2tlZCA9ICh2YWx1ZSA9PSBjdHJsLiR2aWV3VmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIGF0dHIuJG9ic2VydmUoJ3ZhbHVlJywgY3RybC4kcmVuZGVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tib3hJbnB1dFR5cGUoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICB2YXIgdHJ1ZVZhbHVlID0gYXR0ci5uZ1RydWVWYWx1ZSxcclxuICAgICAgZmFsc2VWYWx1ZSA9IGF0dHIubmdGYWxzZVZhbHVlO1xyXG5cclxuICBpZiAoIWlzU3RyaW5nKHRydWVWYWx1ZSkpIHRydWVWYWx1ZSA9IHRydWU7XHJcbiAgaWYgKCFpc1N0cmluZyhmYWxzZVZhbHVlKSkgZmFsc2VWYWx1ZSA9IGZhbHNlO1xyXG5cclxuICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICBjdHJsLiRzZXRWaWV3VmFsdWUoZWxlbWVudFswXS5jaGVja2VkKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBjdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIGVsZW1lbnRbMF0uY2hlY2tlZCA9IGN0cmwuJHZpZXdWYWx1ZTtcclxuICB9O1xyXG5cclxuICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZVZhbHVlO1xyXG4gIH0pO1xyXG5cclxuICBjdHJsLiRwYXJzZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHRydWVWYWx1ZSA6IGZhbHNlVmFsdWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6dGV4dGFyZWFcclxuICogQHJlc3RyaWN0IEVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEhUTUwgdGV4dGFyZWEgZWxlbWVudCBjb250cm9sIHdpdGggYW5ndWxhciBkYXRhLWJpbmRpbmcuIFRoZSBkYXRhLWJpbmRpbmcgYW5kIHZhbGlkYXRpb25cclxuICogcHJvcGVydGllcyBvZiB0aGlzIGVsZW1lbnQgYXJlIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgdGhlXHJcbiAqIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQgaW5wdXQgZWxlbWVudH0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHJlcXVpcmVkIFNldHMgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbm90IGVudGVyZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xyXG4gKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxyXG4gKiAgICBgcmVxdWlyZWRgIHdoZW4geW91IHdhbnQgdG8gZGF0YS1iaW5kIHRvIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZS5cclxuICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cclxuICogICAgbWlubGVuZ3RoLlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG5nTWF4bGVuZ3RoIFNldHMgYG1heGxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuXHJcbiAqICAgIG1heGxlbmd0aC5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxyXG4gKiAgICBSZWdFeHAgcGF0dGVybiBleHByZXNzaW9uLiBFeHBlY3RlZCB2YWx1ZSBpcyBgL3JlZ2V4cC9gIGZvciBpbmxpbmUgcGF0dGVybnMgb3IgYHJlZ2V4cGAgZm9yXHJcbiAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxyXG4gKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXRcclxuICogQHJlc3RyaWN0IEVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEhUTUwgaW5wdXQgZWxlbWVudCBjb250cm9sIHdpdGggYW5ndWxhciBkYXRhLWJpbmRpbmcuIElucHV0IGNvbnRyb2wgZm9sbG93cyBIVE1MNSBpbnB1dCB0eXBlc1xyXG4gKiBhbmQgcG9seWZpbGxzIHRoZSBIVE1MNSB2YWxpZGF0aW9uIGJlaGF2aW9yIGZvciBvbGRlciBicm93c2Vycy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBub3QgZW50ZXJlZC5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbmdSZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGlmIHNldCB0byB0cnVlXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNaW5sZW5ndGggU2V0cyBgbWlubGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgc2hvcnRlciB0aGFuXHJcbiAqICAgIG1pbmxlbmd0aC5cclxuICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxyXG4gKiAgICBtYXhsZW5ndGguXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdQYXR0ZXJuIFNldHMgYHBhdHRlcm5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGVcclxuICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxyXG4gKiAgICBwYXR0ZXJucyBkZWZpbmVkIGFzIHNjb3BlIGV4cHJlc3Npb25zLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcclxuICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS51c2VyID0ge25hbWU6ICdndWVzdCcsIGxhc3Q6ICd2aXNpdG9yJ307XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XHJcbiAgICAgICAgICAgVXNlciBuYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwidXNlck5hbWVcIiBuZy1tb2RlbD1cInVzZXIubmFtZVwiIHJlcXVpcmVkPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLnVzZXJOYW1lLiRlcnJvci5yZXF1aXJlZFwiPlxyXG4gICAgICAgICAgICAgUmVxdWlyZWQhPC9zcGFuPjxicj5cclxuICAgICAgICAgICBMYXN0IG5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIG5nLW1vZGVsPVwidXNlci5sYXN0XCJcclxuICAgICAgICAgICAgIG5nLW1pbmxlbmd0aD1cIjNcIiBuZy1tYXhsZW5ndGg9XCIxMFwiPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmxhc3ROYW1lLiRlcnJvci5taW5sZW5ndGhcIj5cclxuICAgICAgICAgICAgIFRvbyBzaG9ydCE8L3NwYW4+XHJcbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0ubGFzdE5hbWUuJGVycm9yLm1heGxlbmd0aFwiPlxyXG4gICAgICAgICAgICAgVG9vIGxvbmchPC9zcGFuPjxicj5cclxuICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICA8aHI+XHJcbiAgICAgICAgIDx0dD51c2VyID0ge3t1c2VyfX08L3R0Pjxici8+XHJcbiAgICAgICAgIDx0dD5teUZvcm0udXNlck5hbWUuJHZhbGlkID0ge3tteUZvcm0udXNlck5hbWUuJHZhbGlkfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS51c2VyTmFtZS4kZXJyb3IgPSB7e215Rm9ybS51c2VyTmFtZS4kZXJyb3J9fTwvdHQ+PGJyPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLmxhc3ROYW1lLiR2YWxpZCA9IHt7bXlGb3JtLmxhc3ROYW1lLiR2YWxpZH19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0ubGFzdE5hbWUuJGVycm9yID0ge3tteUZvcm0ubGFzdE5hbWUuJGVycm9yfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLiRlcnJvci5yZXF1aXJlZCA9IHt7ISFteUZvcm0uJGVycm9yLnJlcXVpcmVkfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IubWlubGVuZ3RoID0ge3shIW15Rm9ybS4kZXJyb3IubWlubGVuZ3RofX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IubWF4bGVuZ3RoID0ge3shIW15Rm9ybS4kZXJyb3IubWF4bGVuZ3RofX08L3R0Pjxicj5cclxuICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndXNlcicpKS50b0VxdWFsKCd7XCJuYW1lXCI6XCJndWVzdFwiLFwibGFzdFwiOlwidmlzaXRvclwifScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS51c2VyTmFtZS4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgZW1wdHkgd2hlbiByZXF1aXJlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaW5wdXQoJ3VzZXIubmFtZScpLmVudGVyKCcnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd1c2VyJykpLnRvRXF1YWwoJ3tcImxhc3RcIjpcInZpc2l0b3JcIn0nKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0udXNlck5hbWUuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGJlIHZhbGlkIGlmIGVtcHR5IHdoZW4gbWluIGxlbmd0aCBpcyBzZXQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlucHV0KCd1c2VyLmxhc3QnKS5lbnRlcignJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndXNlcicpKS50b0VxdWFsKCd7XCJuYW1lXCI6XCJndWVzdFwiLFwibGFzdFwiOlwiXCJ9Jyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBsZXNzIHRoYW4gcmVxdWlyZWQgbWluIGxlbmd0aCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaW5wdXQoJ3VzZXIubGFzdCcpLmVudGVyKCd4eCcpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXInKSkudG9FcXVhbCgne1wibmFtZVwiOlwiZ3Vlc3RcIn0nKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0ubGFzdE5hbWUuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiRlcnJvcicpKS50b01hdGNoKC9taW5sZW5ndGgvKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBsb25nZXIgdGhhbiBtYXggbGVuZ3RoJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpbnB1dCgndXNlci5sYXN0JykuZW50ZXIoJ3NvbWUgcmlkaWN1bG91c2x5IGxvbmcgbmFtZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXInKSlcclxuICAgICAgICAgICAgLnRvRXF1YWwoJ3tcIm5hbWVcIjpcImd1ZXN0XCJ9Jyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5sYXN0TmFtZS4kZXJyb3InKSkudG9NYXRjaCgvbWF4bGVuZ3RoLyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgaW5wdXREaXJlY3RpdmUgPSBbJyRicm93c2VyJywgJyRzbmlmZmVyJywgZnVuY3Rpb24oJGJyb3dzZXIsICRzbmlmZmVyKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXF1aXJlOiAnP25nTW9kZWwnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICAgICAgaWYgKGN0cmwpIHtcclxuICAgICAgICAoaW5wdXRUeXBlW2xvd2VyY2FzZShhdHRyLnR5cGUpXSB8fCBpbnB1dFR5cGUudGV4dCkoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwsICRzbmlmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYnJvd3Nlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XTtcclxuXHJcbnZhciBWQUxJRF9DTEFTUyA9ICduZy12YWxpZCcsXHJcbiAgICBJTlZBTElEX0NMQVNTID0gJ25nLWludmFsaWQnLFxyXG4gICAgUFJJU1RJTkVfQ0xBU1MgPSAnbmctcHJpc3RpbmUnLFxyXG4gICAgRElSVFlfQ0xBU1MgPSAnbmctZGlydHknO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXJcclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9ICR2aWV3VmFsdWUgQWN0dWFsIHN0cmluZyB2YWx1ZSBpbiB0aGUgdmlldy5cclxuICogQHByb3BlcnR5IHsqfSAkbW9kZWxWYWx1ZSBUaGUgdmFsdWUgaW4gdGhlIG1vZGVsLCB0aGF0IHRoZSBjb250cm9sIGlzIGJvdW5kIHRvLlxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxGdW5jdGlvbj59ICRwYXJzZXJzIEFycmF5IG9mIGZ1bmN0aW9ucyB0byBleGVjdXRlLCBhcyBhIHBpcGVsaW5lLCB3aGVuZXZlclxyXG4gICAgICAgdGhlIGNvbnRyb2wgcmVhZHMgdmFsdWUgZnJvbSB0aGUgRE9NLiAgRWFjaCBmdW5jdGlvbiBpcyBjYWxsZWQsIGluIHR1cm4sIHBhc3NpbmcgdGhlIHZhbHVlXHJcbiAgICAgICB0aHJvdWdoIHRvIHRoZSBuZXh0LiBVc2VkIHRvIHNhbml0aXplIC8gY29udmVydCB0aGUgdmFsdWUgYXMgd2VsbCBhcyB2YWxpZGF0aW9uLlxyXG4gICAgICAgRm9yIHZhbGlkYXRpb24sIHRoZSBwYXJzZXJzIHNob3VsZCB1cGRhdGUgdGhlIHZhbGlkaXR5IHN0YXRlIHVzaW5nXHJcbiAgICAgICB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXIjJHNldFZhbGlkaXR5ICRzZXRWYWxpZGl0eSgpfSxcclxuICAgICAgIGFuZCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIGludmFsaWQgdmFsdWVzLlxyXG5cclxuICpcclxuICogQHByb3BlcnR5IHtBcnJheS48RnVuY3Rpb24+fSAkZm9ybWF0dGVycyBBcnJheSBvZiBmdW5jdGlvbnMgdG8gZXhlY3V0ZSwgYXMgYSBwaXBlbGluZSwgd2hlbmV2ZXJcclxuICAgICAgIHRoZSBtb2RlbCB2YWx1ZSBjaGFuZ2VzLiBFYWNoIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaW4gdHVybiwgcGFzc2luZyB0aGUgdmFsdWUgdGhyb3VnaCB0byB0aGVcclxuICAgICAgIG5leHQuIFVzZWQgdG8gZm9ybWF0IC8gY29udmVydCB2YWx1ZXMgZm9yIGRpc3BsYXkgaW4gdGhlIGNvbnRyb2wgYW5kIHZhbGlkYXRpb24uXHJcbiAqICAgICAgPHByZT5cclxuICogICAgICBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsdWUpIHtcclxuICogICAgICAgIGlmICh2YWx1ZSkge1xyXG4gKiAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcclxuICogICAgICAgIH1cclxuICogICAgICB9XHJcbiAqICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAqICAgICAgPC9wcmU+XHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkZXJyb3IgQW4gb2JqZWN0IGhhc2ggd2l0aCBhbGwgZXJyb3JzIGFzIGtleXMuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJHByaXN0aW5lIFRydWUgaWYgdXNlciBoYXMgbm90IGludGVyYWN0ZWQgd2l0aCB0aGUgY29udHJvbCB5ZXQuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJGRpcnR5IFRydWUgaWYgdXNlciBoYXMgYWxyZWFkeSBpbnRlcmFjdGVkIHdpdGggdGhlIGNvbnRyb2wuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJHZhbGlkIFRydWUgaWYgdGhlcmUgaXMgbm8gZXJyb3IuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJGludmFsaWQgVHJ1ZSBpZiBhdCBsZWFzdCBvbmUgZXJyb3Igb24gdGhlIGNvbnRyb2wuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBgTmdNb2RlbENvbnRyb2xsZXJgIHByb3ZpZGVzIEFQSSBmb3IgdGhlIGBuZy1tb2RlbGAgZGlyZWN0aXZlLiBUaGUgY29udHJvbGxlciBjb250YWluc1xyXG4gKiBzZXJ2aWNlcyBmb3IgZGF0YS1iaW5kaW5nLCB2YWxpZGF0aW9uLCBDU1MgdXBkYXRlLCB2YWx1ZSBmb3JtYXR0aW5nIGFuZCBwYXJzaW5nLiBJdFxyXG4gKiBzcGVjaWZpY2FsbHkgZG9lcyBub3QgY29udGFpbiBhbnkgbG9naWMgd2hpY2ggZGVhbHMgd2l0aCBET00gcmVuZGVyaW5nIG9yIGxpc3RlbmluZyB0b1xyXG4gKiBET00gZXZlbnRzLiBUaGUgYE5nTW9kZWxDb250cm9sbGVyYCBpcyBtZWFudCB0byBiZSBleHRlbmRlZCBieSBvdGhlciBkaXJlY3RpdmVzIHdoZXJlLCB0aGVcclxuICogZGlyZWN0aXZlIHByb3ZpZGVzIERPTSBtYW5pcHVsYXRpb24gYW5kIHRoZSBgTmdNb2RlbENvbnRyb2xsZXJgIHByb3ZpZGVzIHRoZSBkYXRhLWJpbmRpbmcuXHJcbiAqIE5vdGUgdGhhdCB5b3UgY2Fubm90IHVzZSBgTmdNb2RlbENvbnRyb2xsZXJgIGluIGEgZGlyZWN0aXZlIHdpdGggYW4gaXNvbGF0ZWQgc2NvcGUsXHJcbiAqIGFzLCBpbiB0aGF0IGNhc2UsIHRoZSBgbmctbW9kZWxgIHZhbHVlIGdldHMgcHV0IGludG8gdGhlIGlzb2xhdGVkIHNjb3BlIGFuZCBkb2VzIG5vdCBnZXRcclxuICogcHJvcG9nYXRlZCB0byB0aGUgcGFyZW50IHNjb3BlLlxyXG4gKlxyXG4gKlxyXG4gKiBUaGlzIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBgTmdNb2RlbENvbnRyb2xsZXJgIHdpdGggYSBjdXN0b20gY29udHJvbCB0byBhY2hpZXZlXHJcbiAqIGRhdGEtYmluZGluZy4gTm90aWNlIGhvdyBkaWZmZXJlbnQgZGlyZWN0aXZlcyAoYGNvbnRlbnRlZGl0YWJsZWAsIGBuZy1tb2RlbGAsIGFuZCBgcmVxdWlyZWRgKVxyXG4gKiBjb2xsYWJvcmF0ZSB0b2dldGhlciB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIHJlc3VsdC5cclxuICpcclxuICogPGV4YW1wbGUgbW9kdWxlPVwiY3VzdG9tQ29udHJvbFwiPlxyXG4gICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxyXG4gICAgICBbY29udGVudGVkaXRhYmxlXSB7XHJcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XHJcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XHJcbiAgICAgICAgbWluLWhlaWdodDogMjBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLm5nLWludmFsaWQge1xyXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJlZDtcclxuICAgICAgfVxyXG5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cclxuICAgICAgYW5ndWxhci5tb2R1bGUoJ2N1c3RvbUNvbnRyb2wnLCBbXSkuXHJcbiAgICAgICAgZGlyZWN0aXZlKCdjb250ZW50ZWRpdGFibGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsIC8vIG9ubHkgYWN0aXZhdGUgb24gZWxlbWVudCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgcmVxdWlyZTogJz9uZ01vZGVsJywgLy8gZ2V0IGEgaG9sZCBvZiBOZ01vZGVsQ29udHJvbGxlclxyXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgICAgICAgICBpZighbmdNb2RlbCkgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXHJcblxyXG4gICAgICAgICAgICAgIC8vIFNwZWNpZnkgaG93IFVJIHNob3VsZCBiZSB1cGRhdGVkXHJcbiAgICAgICAgICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lmh0bWwobmdNb2RlbC4kdmlld1ZhbHVlIHx8ICcnKTtcclxuICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGNoYW5nZSBldmVudHMgdG8gZW5hYmxlIGJpbmRpbmdcclxuICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdibHVyIGtleXVwIGNoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KHJlYWQpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHJlYWQoKTsgLy8gaW5pdGlhbGl6ZVxyXG5cclxuICAgICAgICAgICAgICAvLyBXcml0ZSBkYXRhIHRvIHRoZSBtb2RlbFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IGVsZW1lbnQuaHRtbCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSBjbGVhciB0aGUgY29udGVudCBlZGl0YWJsZSB0aGUgYnJvd3NlciBsZWF2ZXMgYSA8YnI+IGJlaGluZFxyXG4gICAgICAgICAgICAgICAgLy8gSWYgc3RyaXAtYnIgYXR0cmlidXRlIGlzIHByb3ZpZGVkIHRoZW4gd2Ugc3RyaXAgdGhpcyBvdXRcclxuICAgICAgICAgICAgICAgIGlmKCBhdHRycy5zdHJpcEJyICYmIGh0bWwgPT0gJzxicj4nICkge1xyXG4gICAgICAgICAgICAgICAgICBodG1sID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoaHRtbCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxyXG4gICAgICAgPGRpdiBjb250ZW50ZWRpdGFibGVcclxuICAgICAgICAgICAgbmFtZT1cIm15V2lkZ2V0XCIgbmctbW9kZWw9XCJ1c2VyQ29udGVudFwiXHJcbiAgICAgICAgICAgIHN0cmlwLWJyPVwidHJ1ZVwiXHJcbiAgICAgICAgICAgIHJlcXVpcmVkPkNoYW5nZSBtZSE8L2Rpdj5cclxuICAgICAgICA8c3BhbiBuZy1zaG93PVwibXlGb3JtLm15V2lkZ2V0LiRlcnJvci5yZXF1aXJlZFwiPlJlcXVpcmVkITwvc3Bhbj5cclxuICAgICAgIDxocj5cclxuICAgICAgIDx0ZXh0YXJlYSBuZy1tb2RlbD1cInVzZXJDb250ZW50XCI+PC90ZXh0YXJlYT5cclxuICAgICAgPC9mb3JtPlxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgIGl0KCdzaG91bGQgZGF0YS1iaW5kIGFuZCBiZWNvbWUgaW52YWxpZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjb250ZW50RWRpdGFibGUgPSBlbGVtZW50KCdbY29udGVudGVkaXRhYmxlXScpO1xyXG5cclxuICAgICAgICBleHBlY3QoY29udGVudEVkaXRhYmxlLnRleHQoKSkudG9FcXVhbCgnQ2hhbmdlIG1lIScpO1xyXG4gICAgICAgIGlucHV0KCd1c2VyQ29udGVudCcpLmVudGVyKCcnKTtcclxuICAgICAgICBleHBlY3QoY29udGVudEVkaXRhYmxlLnRleHQoKSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgZXhwZWN0KGNvbnRlbnRFZGl0YWJsZS5wcm9wKCdjbGFzc05hbWUnKSkudG9NYXRjaCgvbmctaW52YWxpZC1yZXF1aXJlZC8pO1xyXG4gICAgICB9KTtcclxuICAgIDwvZmlsZT5cclxuICogPC9leGFtcGxlPlxyXG4gKlxyXG4gKi9cclxudmFyIE5nTW9kZWxDb250cm9sbGVyID0gWyckc2NvcGUnLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCAnJGF0dHJzJywgJyRlbGVtZW50JywgJyRwYXJzZScsXHJcbiAgICBmdW5jdGlvbigkc2NvcGUsICRleGNlcHRpb25IYW5kbGVyLCAkYXR0ciwgJGVsZW1lbnQsICRwYXJzZSkge1xyXG4gIHRoaXMuJHZpZXdWYWx1ZSA9IE51bWJlci5OYU47XHJcbiAgdGhpcy4kbW9kZWxWYWx1ZSA9IE51bWJlci5OYU47XHJcbiAgdGhpcy4kcGFyc2VycyA9IFtdO1xyXG4gIHRoaXMuJGZvcm1hdHRlcnMgPSBbXTtcclxuICB0aGlzLiR2aWV3Q2hhbmdlTGlzdGVuZXJzID0gW107XHJcbiAgdGhpcy4kcHJpc3RpbmUgPSB0cnVlO1xyXG4gIHRoaXMuJGRpcnR5ID0gZmFsc2U7XHJcbiAgdGhpcy4kdmFsaWQgPSB0cnVlO1xyXG4gIHRoaXMuJGludmFsaWQgPSBmYWxzZTtcclxuICB0aGlzLiRuYW1lID0gJGF0dHIubmFtZTtcclxuXHJcbiAgdmFyIG5nTW9kZWxHZXQgPSAkcGFyc2UoJGF0dHIubmdNb2RlbCksXHJcbiAgICAgIG5nTW9kZWxTZXQgPSBuZ01vZGVsR2V0LmFzc2lnbjtcclxuXHJcbiAgaWYgKCFuZ01vZGVsU2V0KSB7XHJcbiAgICB0aHJvdyBtaW5FcnIoJ25nTW9kZWwnKSgnbm9uYXNzaWduJywgXCJFeHByZXNzaW9uICd7MH0nIGlzIG5vbi1hc3NpZ25hYmxlLiBFbGVtZW50OiB7MX1cIixcclxuICAgICAgICAkYXR0ci5uZ01vZGVsLCBzdGFydGluZ1RhZygkZWxlbWVudCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXIjJHJlbmRlclxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHZpZXcgbmVlZHMgdG8gYmUgdXBkYXRlZC4gSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgdXNlciBvZiB0aGUgbmctbW9kZWxcclxuICAgKiBkaXJlY3RpdmUgd2lsbCBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXHJcbiAgICovXHJcbiAgdGhpcy4kcmVuZGVyID0gbm9vcDtcclxuXHJcbiAgdmFyIHBhcmVudEZvcm0gPSAkZWxlbWVudC5pbmhlcml0ZWREYXRhKCckZm9ybUNvbnRyb2xsZXInKSB8fCBudWxsRm9ybUN0cmwsXHJcbiAgICAgIGludmFsaWRDb3VudCA9IDAsIC8vIHVzZWQgdG8gZWFzaWx5IGRldGVybWluZSBpZiB3ZSBhcmUgdmFsaWRcclxuICAgICAgJGVycm9yID0gdGhpcy4kZXJyb3IgPSB7fTsgLy8ga2VlcCBpbnZhbGlkIGtleXMgaGVyZVxyXG5cclxuXHJcbiAgLy8gU2V0dXAgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgY29udHJvbFxyXG4gICRlbGVtZW50LmFkZENsYXNzKFBSSVNUSU5FX0NMQVNTKTtcclxuICB0b2dnbGVWYWxpZENzcyh0cnVlKTtcclxuXHJcbiAgLy8gY29udmVuaWVuY2UgbWV0aG9kIGZvciBlYXN5IHRvZ2dsaW5nIG9mIGNsYXNzZXNcclxuICBmdW5jdGlvbiB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3JLZXkpIHtcclxuICAgIHZhbGlkYXRpb25FcnJvcktleSA9IHZhbGlkYXRpb25FcnJvcktleSA/ICctJyArIHNuYWtlX2Nhc2UodmFsaWRhdGlvbkVycm9yS2V5LCAnLScpIDogJyc7XHJcbiAgICAkZWxlbWVudC5cclxuICAgICAgcmVtb3ZlQ2xhc3MoKGlzVmFsaWQgPyBJTlZBTElEX0NMQVNTIDogVkFMSURfQ0xBU1MpICsgdmFsaWRhdGlvbkVycm9yS2V5KS5cclxuICAgICAgYWRkQ2xhc3MoKGlzVmFsaWQgPyBWQUxJRF9DTEFTUyA6IElOVkFMSURfQ0xBU1MpICsgdmFsaWRhdGlvbkVycm9yS2V5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRzZXRWYWxpZGl0eVxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQ2hhbmdlIHRoZSB2YWxpZGl0eSBzdGF0ZSwgYW5kIG5vdGlmaWVzIHRoZSBmb3JtIHdoZW4gdGhlIGNvbnRyb2wgY2hhbmdlcyB2YWxpZGl0eS4gKGkuZS4gaXRcclxuICAgKiBkb2VzIG5vdCBub3RpZnkgZm9ybSBpZiBnaXZlbiB2YWxpZGF0b3IgaXMgYWxyZWFkeSBtYXJrZWQgYXMgaW52YWxpZCkuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGJ5IHZhbGlkYXRvcnMgLSBpLmUuIHRoZSBwYXJzZXIgb3IgZm9ybWF0dGVyIGZ1bmN0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0aW9uRXJyb3JLZXkgTmFtZSBvZiB0aGUgdmFsaWRhdG9yLiB0aGUgYHZhbGlkYXRpb25FcnJvcktleWAgd2lsbCBhc3NpZ25cclxuICAgKiAgICAgICAgdG8gYCRlcnJvclt2YWxpZGF0aW9uRXJyb3JLZXldPWlzVmFsaWRgIHNvIHRoYXQgaXQgaXMgYXZhaWxhYmxlIGZvciBkYXRhLWJpbmRpbmcuXHJcbiAgICogICAgICAgIFRoZSBgdmFsaWRhdGlvbkVycm9yS2V5YCBzaG91bGQgYmUgaW4gY2FtZWxDYXNlIGFuZCB3aWxsIGdldCBjb252ZXJ0ZWQgaW50byBkYXNoLWNhc2VcclxuICAgKiAgICAgICAgZm9yIGNsYXNzIG5hbWUuIEV4YW1wbGU6IGBteUVycm9yYCB3aWxsIHJlc3VsdCBpbiBgbmctdmFsaWQtbXktZXJyb3JgIGFuZCBgbmctaW52YWxpZC1teS1lcnJvcmBcclxuICAgKiAgICAgICAgY2xhc3MgYW5kIGNhbiBiZSBib3VuZCB0byBhcyAgYHt7c29tZUZvcm0uc29tZUNvbnRyb2wuJGVycm9yLm15RXJyb3J9fWAgLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZCBXaGV0aGVyIHRoZSBjdXJyZW50IHN0YXRlIGlzIHZhbGlkICh0cnVlKSBvciBpbnZhbGlkIChmYWxzZSkuXHJcbiAgICovXHJcbiAgdGhpcy4kc2V0VmFsaWRpdHkgPSBmdW5jdGlvbih2YWxpZGF0aW9uRXJyb3JLZXksIGlzVmFsaWQpIHtcclxuICAgIGlmICgkZXJyb3JbdmFsaWRhdGlvbkVycm9yS2V5XSA9PT0gIWlzVmFsaWQpIHJldHVybjtcclxuXHJcbiAgICBpZiAoaXNWYWxpZCkge1xyXG4gICAgICBpZiAoJGVycm9yW3ZhbGlkYXRpb25FcnJvcktleV0pIGludmFsaWRDb3VudC0tO1xyXG4gICAgICBpZiAoIWludmFsaWRDb3VudCkge1xyXG4gICAgICAgIHRvZ2dsZVZhbGlkQ3NzKHRydWUpO1xyXG4gICAgICAgIHRoaXMuJHZhbGlkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLiRpbnZhbGlkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRvZ2dsZVZhbGlkQ3NzKGZhbHNlKTtcclxuICAgICAgdGhpcy4kaW52YWxpZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuJHZhbGlkID0gZmFsc2U7XHJcbiAgICAgIGludmFsaWRDb3VudCsrO1xyXG4gICAgfVxyXG5cclxuICAgICRlcnJvclt2YWxpZGF0aW9uRXJyb3JLZXldID0gIWlzVmFsaWQ7XHJcbiAgICB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3JLZXkpO1xyXG5cclxuICAgIHBhcmVudEZvcm0uJHNldFZhbGlkaXR5KHZhbGlkYXRpb25FcnJvcktleSwgaXNWYWxpZCwgdGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXIjJHNldFByaXN0aW5lXHJcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBTZXRzIHRoZSBjb250cm9sIHRvIGl0cyBwcmlzdGluZSBzdGF0ZS5cclxuICAgKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmVtb3ZlIHRoZSAnbmctZGlydHknIGNsYXNzIGFuZCBzZXQgdGhlIGNvbnRyb2wgdG8gaXRzIHByaXN0aW5lXHJcbiAgICogc3RhdGUgKG5nLXByaXN0aW5lIGNsYXNzKS5cclxuICAgKi9cclxuICB0aGlzLiRzZXRQcmlzdGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuJGRpcnR5ID0gZmFsc2U7XHJcbiAgICB0aGlzLiRwcmlzdGluZSA9IHRydWU7XHJcbiAgICAkZWxlbWVudC5yZW1vdmVDbGFzcyhESVJUWV9DTEFTUykuYWRkQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRzZXRWaWV3VmFsdWVcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFJlYWQgYSB2YWx1ZSBmcm9tIHZpZXcuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgRE9NIGV2ZW50IGhhbmRsZXIuXHJcbiAgICogRm9yIGV4YW1wbGUge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dCBpbnB1dH0gb3JcclxuICAgKiB7QGxpbmsgbmcuZGlyZWN0aXZlOnNlbGVjdCBzZWxlY3R9IGRpcmVjdGl2ZXMgY2FsbCBpdC5cclxuICAgKlxyXG4gICAqIEl0IGludGVybmFsbHkgY2FsbHMgYWxsIGAkcGFyc2Vyc2AgKGluY2x1ZGluZyB2YWxpZGF0b3JzKSBhbmQgdXBkYXRlcyB0aGUgYCRtb2RlbFZhbHVlYCBhbmQgdGhlIGFjdHVhbCBtb2RlbCBwYXRoLlxyXG4gICAqIExhc3RseSBpdCBjYWxscyBhbGwgcmVnaXN0ZXJlZCBjaGFuZ2UgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIGZyb20gdGhlIHZpZXcuXHJcbiAgICovXHJcbiAgdGhpcy4kc2V0Vmlld1ZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHRoaXMuJHZpZXdWYWx1ZSA9IHZhbHVlO1xyXG5cclxuICAgIC8vIGNoYW5nZSB0byBkaXJ0eVxyXG4gICAgaWYgKHRoaXMuJHByaXN0aW5lKSB7XHJcbiAgICAgIHRoaXMuJGRpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy4kcHJpc3RpbmUgPSBmYWxzZTtcclxuICAgICAgJGVsZW1lbnQucmVtb3ZlQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpLmFkZENsYXNzKERJUlRZX0NMQVNTKTtcclxuICAgICAgcGFyZW50Rm9ybS4kc2V0RGlydHkoKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3JFYWNoKHRoaXMuJHBhcnNlcnMsIGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuJG1vZGVsVmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgIHRoaXMuJG1vZGVsVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgbmdNb2RlbFNldCgkc2NvcGUsIHZhbHVlKTtcclxuICAgICAgZm9yRWFjaCh0aGlzLiR2aWV3Q2hhbmdlTGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIG1vZGVsIC0+IHZhbHVlXHJcbiAgdmFyIGN0cmwgPSB0aGlzO1xyXG5cclxuICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uIG5nTW9kZWxXYXRjaCgpIHtcclxuICAgIHZhciB2YWx1ZSA9IG5nTW9kZWxHZXQoJHNjb3BlKTtcclxuXHJcbiAgICAvLyBpZiBzY29wZSBtb2RlbCB2YWx1ZSBhbmQgbmdNb2RlbCB2YWx1ZSBhcmUgb3V0IG9mIHN5bmNcclxuICAgIGlmIChjdHJsLiRtb2RlbFZhbHVlICE9PSB2YWx1ZSkge1xyXG5cclxuICAgICAgdmFyIGZvcm1hdHRlcnMgPSBjdHJsLiRmb3JtYXR0ZXJzLFxyXG4gICAgICAgICAgaWR4ID0gZm9ybWF0dGVycy5sZW5ndGg7XHJcblxyXG4gICAgICBjdHJsLiRtb2RlbFZhbHVlID0gdmFsdWU7XHJcbiAgICAgIHdoaWxlKGlkeC0tKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXJzW2lkeF0odmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY3RybC4kdmlld1ZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICAgIGN0cmwuJHZpZXdWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIGN0cmwuJHJlbmRlcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1dO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsXHJcbiAqXHJcbiAqIEBlbGVtZW50IGlucHV0XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBJcyBhIGRpcmVjdGl2ZSB0aGF0IHRlbGxzIEFuZ3VsYXIgdG8gZG8gdHdvLXdheSBkYXRhIGJpbmRpbmcuIEl0IHdvcmtzIHRvZ2V0aGVyIHdpdGggYGlucHV0YCxcclxuICogYHNlbGVjdGAsIGB0ZXh0YXJlYWAgYW5kIGV2ZW4gY3VzdG9tIGZvcm0gY29udHJvbHMgdGhhdCB1c2Uge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXHJcbiAqIE5nTW9kZWxDb250cm9sbGVyfSBleHBvc2VkIGJ5IHRoaXMgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiBgbmdNb2RlbGAgaXMgcmVzcG9uc2libGUgZm9yOlxyXG4gKlxyXG4gKiAtIGJpbmRpbmcgdGhlIHZpZXcgaW50byB0aGUgbW9kZWwsIHdoaWNoIG90aGVyIGRpcmVjdGl2ZXMgc3VjaCBhcyBgaW5wdXRgLCBgdGV4dGFyZWFgIG9yIGBzZWxlY3RgXHJcbiAqICAgcmVxdWlyZSxcclxuICogLSBwcm92aWRpbmcgdmFsaWRhdGlvbiBiZWhhdmlvciAoaS5lLiByZXF1aXJlZCwgbnVtYmVyLCBlbWFpbCwgdXJsKSxcclxuICogLSBrZWVwaW5nIHN0YXRlIG9mIHRoZSBjb250cm9sICh2YWxpZC9pbnZhbGlkLCBkaXJ0eS9wcmlzdGluZSwgdmFsaWRhdGlvbiBlcnJvcnMpLFxyXG4gKiAtIHNldHRpbmcgcmVsYXRlZCBjc3MgY2xhc3Mgb250byB0aGUgZWxlbWVudCAoYG5nLXZhbGlkYCwgYG5nLWludmFsaWRgLCBgbmctZGlydHlgLCBgbmctcHJpc3RpbmVgKSxcclxuICogLSByZWdpc3RlciB0aGUgY29udHJvbCB3aXRoIHBhcmVudCB7QGxpbmsgbmcuZGlyZWN0aXZlOmZvcm0gZm9ybX0uXHJcbiAqXHJcbiAqIE5vdGU6IGBuZ01vZGVsYCB3aWxsIHRyeSB0byBiaW5kIHRvIHRoZSBwcm9wZXJ0eSBnaXZlbiBieSBldmFsdWF0aW5nIHRoZSBleHByZXNzaW9uIG9uIHRoZVxyXG4gKiBjdXJyZW50IHNjb3BlLiBJZiB0aGUgcHJvcGVydHkgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9uIHRoaXMgc2NvcGUsIGl0IHdpbGwgYmUgY3JlYXRlZFxyXG4gKiBpbXBsaWNpdGx5IGFuZCBhZGRlZCB0byB0aGUgc2NvcGUuXHJcbiAqXHJcbiAqIEZvciBiYXNpYyBleGFtcGxlcywgaG93IHRvIHVzZSBgbmdNb2RlbGAsIHNlZTpcclxuICpcclxuICogIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dCBpbnB1dH1cclxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LnRleHQgdGV4dH1cclxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LmNoZWNrYm94IGNoZWNrYm94fVxyXG4gKiAgICAtIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQucmFkaW8gcmFkaW99XHJcbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC5udW1iZXIgbnVtYmVyfVxyXG4gKiAgICAtIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQuZW1haWwgZW1haWx9XHJcbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC51cmwgdXJsfVxyXG4gKiAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOnNlbGVjdCBzZWxlY3R9XHJcbiAqICAtIHtAbGluayBuZy5kaXJlY3RpdmU6dGV4dGFyZWEgdGV4dGFyZWF9XHJcbiAqXHJcbiAqL1xyXG52YXIgbmdNb2RlbERpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAnXj9mb3JtJ10sXHJcbiAgICBjb250cm9sbGVyOiBOZ01vZGVsQ29udHJvbGxlcixcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJscykge1xyXG4gICAgICAvLyBub3RpZnkgb3RoZXJzLCBlc3BlY2lhbGx5IHBhcmVudCBmb3Jtc1xyXG5cclxuICAgICAgdmFyIG1vZGVsQ3RybCA9IGN0cmxzWzBdLFxyXG4gICAgICAgICAgZm9ybUN0cmwgPSBjdHJsc1sxXSB8fCBudWxsRm9ybUN0cmw7XHJcblxyXG4gICAgICBmb3JtQ3RybC4kYWRkQ29udHJvbChtb2RlbEN0cmwpO1xyXG5cclxuICAgICAgZWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBmb3JtQ3RybC4kcmVtb3ZlQ29udHJvbChtb2RlbEN0cmwpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NoYW5nZVxyXG4gKiBAcmVzdHJpY3QgRVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRXZhbHVhdGUgZ2l2ZW4gZXhwcmVzc2lvbiB3aGVuIHVzZXIgY2hhbmdlcyB0aGUgaW5wdXQuXHJcbiAqIFRoZSBleHByZXNzaW9uIGlzIG5vdCBldmFsdWF0ZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlIGlzIGNvbWluZyBmcm9tIHRoZSBtb2RlbC5cclxuICpcclxuICogTm90ZSwgdGhpcyBkaXJlY3RpdmUgcmVxdWlyZXMgYG5nTW9kZWxgIHRvIGJlIHByZXNlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IGlucHV0XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIDxkb2M6ZXhhbXBsZT5cclxuICogICA8ZG9jOnNvdXJjZT5cclxuICogICAgIDxzY3JpcHQ+XHJcbiAqICAgICAgIGZ1bmN0aW9uIENvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAqICAgICAgICAgJHNjb3BlLmNvdW50ZXIgPSAwO1xyXG4gKiAgICAgICAgICRzY29wZS5jaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICogICAgICAgICAgICRzY29wZS5jb3VudGVyKys7XHJcbiAqICAgICAgICAgfTtcclxuICogICAgICAgfVxyXG4gKiAgICAgPC9zY3JpcHQ+XHJcbiAqICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDb250cm9sbGVyXCI+XHJcbiAqICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNvbmZpcm1lZFwiIG5nLWNoYW5nZT1cImNoYW5nZSgpXCIgaWQ9XCJuZy1jaGFuZ2UtZXhhbXBsZTFcIiAvPlxyXG4gKiAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjb25maXJtZWRcIiBpZD1cIm5nLWNoYW5nZS1leGFtcGxlMlwiIC8+XHJcbiAqICAgICAgIDxsYWJlbCBmb3I9XCJuZy1jaGFuZ2UtZXhhbXBsZTJcIj5Db25maXJtZWQ8L2xhYmVsPjxiciAvPlxyXG4gKiAgICAgICBkZWJ1ZyA9IHt7Y29uZmlybWVkfX08YnIgLz5cclxuICogICAgICAgY291bnRlciA9IHt7Y291bnRlcn19XHJcbiAqICAgICA8L2Rpdj5cclxuICogICA8L2RvYzpzb3VyY2U+XHJcbiAqICAgPGRvYzpzY2VuYXJpbz5cclxuICogICAgIGl0KCdzaG91bGQgZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gaWYgY2hhbmdpbmcgZnJvbSB2aWV3JywgZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudGVyJykpLnRvRXF1YWwoJzAnKTtcclxuICogICAgICAgZWxlbWVudCgnI25nLWNoYW5nZS1leGFtcGxlMScpLmNsaWNrKCk7XHJcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudGVyJykpLnRvRXF1YWwoJzEnKTtcclxuICogICAgICAgZXhwZWN0KGJpbmRpbmcoJ2NvbmZpcm1lZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAqICAgICB9KTtcclxuICpcclxuICogICAgIGl0KCdzaG91bGQgbm90IGV2YWx1YXRlIHRoZSBleHByZXNzaW9uIGlmIGNoYW5naW5nIGZyb20gbW9kZWwnLCBmdW5jdGlvbigpIHtcclxuICogICAgICAgZWxlbWVudCgnI25nLWNoYW5nZS1leGFtcGxlMicpLmNsaWNrKCk7XHJcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudGVyJykpLnRvRXF1YWwoJzAnKTtcclxuICogICAgICAgZXhwZWN0KGJpbmRpbmcoJ2NvbmZpcm1lZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAqICAgICB9KTtcclxuICogICA8L2RvYzpzY2VuYXJpbz5cclxuICogPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0NoYW5nZURpcmVjdGl2ZSA9IHZhbHVlRm4oe1xyXG4gIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCkge1xyXG4gICAgY3RybC4kdmlld0NoYW5nZUxpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBzY29wZS4kZXZhbChhdHRyLm5nQ2hhbmdlKTtcclxuICAgIH0pO1xyXG4gIH1cclxufSk7XHJcblxyXG5cclxudmFyIHJlcXVpcmVkRGlyZWN0aXZlID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRyLCBjdHJsKSB7XHJcbiAgICAgIGlmICghY3RybCkgcmV0dXJuO1xyXG4gICAgICBhdHRyLnJlcXVpcmVkID0gdHJ1ZTsgLy8gZm9yY2UgdHJ1dGh5IGluIGNhc2Ugd2UgYXJlIG9uIG5vbiBpbnB1dCBlbGVtZW50XHJcblxyXG4gICAgICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAoYXR0ci5yZXF1aXJlZCAmJiAoaXNFbXB0eSh2YWx1ZSkgfHwgdmFsdWUgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3JlcXVpcmVkJywgZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgncmVxdWlyZWQnLCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2godmFsaWRhdG9yKTtcclxuICAgICAgY3RybC4kcGFyc2Vycy51bnNoaWZ0KHZhbGlkYXRvcik7XHJcblxyXG4gICAgICBhdHRyLiRvYnNlcnZlKCdyZXF1aXJlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhbGlkYXRvcihjdHJsLiR2aWV3VmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0xpc3RcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRleHQgaW5wdXQgdGhhdCBjb252ZXJ0cyBiZXR3ZWVuIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBpbnB1dFxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5nTGlzdCBvcHRpb25hbCBkZWxpbWl0ZXIgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBzcGxpdCB0aGUgdmFsdWUuIElmXHJcbiAqICAgc3BlY2lmaWVkIGluIGZvcm0gYC9zb21ldGhpbmcvYCB0aGVuIHRoZSB2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgJHNjb3BlLm5hbWVzID0gWydpZ29yJywgJ21pc2tvJywgJ3ZvanRhJ107XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgIExpc3Q6IDxpbnB1dCBuYW1lPVwibmFtZXNJbnB1dFwiIG5nLW1vZGVsPVwibmFtZXNcIiBuZy1saXN0IHJlcXVpcmVkPlxyXG4gICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5uYW1lc0lucHV0LiRlcnJvci5yZXF1aXJlZFwiPlxyXG4gICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj5cclxuICAgICAgICAgPGJyPlxyXG4gICAgICAgICA8dHQ+bmFtZXMgPSB7e25hbWVzfX08L3R0Pjxici8+XHJcbiAgICAgICAgIDx0dD5teUZvcm0ubmFtZXNJbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5uYW1lc0lucHV0LiR2YWxpZH19PC90dD48YnIvPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLm5hbWVzSW5wdXQuJGVycm9yID0ge3tteUZvcm0ubmFtZXNJbnB1dC4kZXJyb3J9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxyXG4gICAgICAgIDwvZm9ybT5cclxuICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ25hbWVzJykpLnRvRXF1YWwoJ1tcImlnb3JcIixcIm1pc2tvXCIsXCJ2b2p0YVwiXScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5uYW1lc0lucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnc3Bhbi5lcnJvcicpLmNzcygnZGlzcGxheScpKS50b0JlKCdub25lJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaW5wdXQoJ25hbWVzJykuZW50ZXIoJycpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ25hbWVzJykpLnRvRXF1YWwoJ1tdJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLm5hbWVzSW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnc3Bhbi5lcnJvcicpLmNzcygnZGlzcGxheScpKS5ub3QoKS50b0JlKCdub25lJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0xpc3REaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICAgICAgdmFyIG1hdGNoID0gL1xcLyguKilcXC8vLmV4ZWMoYXR0ci5uZ0xpc3QpLFxyXG4gICAgICAgICAgc2VwYXJhdG9yID0gbWF0Y2ggJiYgbmV3IFJlZ0V4cChtYXRjaFsxXSkgfHwgYXR0ci5uZ0xpc3QgfHwgJywnO1xyXG5cclxuICAgICAgdmFyIHBhcnNlID0gZnVuY3Rpb24odmlld1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHZpZXdWYWx1ZSkge1xyXG4gICAgICAgICAgZm9yRWFjaCh2aWV3VmFsdWUuc3BsaXQoc2VwYXJhdG9yKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSBsaXN0LnB1c2godHJpbSh2YWx1ZSkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGN0cmwuJHBhcnNlcnMucHVzaChwYXJzZSk7XHJcbiAgICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmpvaW4oJywgJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuXHJcbnZhciBDT05TVEFOVF9WQUxVRV9SRUdFWFAgPSAvXih0cnVlfGZhbHNlfFxcZCspJC87XHJcblxyXG52YXIgbmdWYWx1ZURpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBwcmlvcml0eTogMTAwLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24odHBsLCB0cGxBdHRyKSB7XHJcbiAgICAgIGlmIChDT05TVEFOVF9WQUxVRV9SRUdFWFAudGVzdCh0cGxBdHRyLm5nVmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHIpIHtcclxuICAgICAgICAgIGF0dHIuJHNldCgndmFsdWUnLCBzY29wZS4kZXZhbChhdHRyLm5nVmFsdWUpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRyKSB7XHJcbiAgICAgICAgICBzY29wZS4kd2F0Y2goYXR0ci5uZ1ZhbHVlLCBmdW5jdGlvbiB2YWx1ZVdhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGF0dHIuJHNldCgndmFsdWUnLCB2YWx1ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0JpbmRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdCaW5kYCBhdHRyaWJ1dGUgdGVsbHMgQW5ndWxhciB0byByZXBsYWNlIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHNwZWNpZmllZCBIVE1MIGVsZW1lbnRcclxuICogd2l0aCB0aGUgdmFsdWUgb2YgYSBnaXZlbiBleHByZXNzaW9uLCBhbmQgdG8gdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhhdFxyXG4gKiBleHByZXNzaW9uIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFR5cGljYWxseSwgeW91IGRvbid0IHVzZSBgbmdCaW5kYCBkaXJlY3RseSwgYnV0IGluc3RlYWQgeW91IHVzZSB0aGUgZG91YmxlIGN1cmx5IG1hcmt1cCBsaWtlXHJcbiAqIGB7eyBleHByZXNzaW9uIH19YCB3aGljaCBpcyBzaW1pbGFyIGJ1dCBsZXNzIHZlcmJvc2UuXHJcbiAqXHJcbiAqIEl0IGlzIHByZWZlcnJhYmxlIHRvIHVzZSBgbmdCaW5kYCBpbnN0ZWFkIG9mIGB7eyBleHByZXNzaW9uIH19YCB3aGVuIGEgdGVtcGxhdGUgaXMgbW9tZW50YXJpbHkgXHJcbiAqIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciBpbiBpdHMgcmF3IHN0YXRlIGJlZm9yZSBBbmd1bGFyIGNvbXBpbGVzIGl0LiBTaW5jZSBgbmdCaW5kYCBpcyBhbiBcclxuICogZWxlbWVudCBhdHRyaWJ1dGUsIGl0IG1ha2VzIHRoZSBiaW5kaW5ncyBpbnZpc2libGUgdG8gdGhlIHVzZXIgd2hpbGUgdGhlIHBhZ2UgaXMgbG9hZGluZy5cclxuICpcclxuICogQW4gYWx0ZXJuYXRpdmUgc29sdXRpb24gdG8gdGhpcyBwcm9ibGVtIHdvdWxkIGJlIHVzaW5nIHRoZVxyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xvYWsgbmdDbG9ha30gZGlyZWN0aXZlLlxyXG4gKlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0JpbmQge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIEVudGVyIGEgbmFtZSBpbiB0aGUgTGl2ZSBQcmV2aWV3IHRleHQgYm94OyB0aGUgZ3JlZXRpbmcgYmVsb3cgdGhlIHRleHQgYm94IGNoYW5nZXMgaW5zdGFudGx5LlxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS5uYW1lID0gJ1doaXJsZWQnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgRW50ZXIgbmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJuYW1lXCI+PGJyPlxyXG4gICAgICAgICBIZWxsbyA8c3BhbiBuZy1iaW5kPVwibmFtZVwiPjwvc3Bhbj4hXHJcbiAgICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctYmluZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnbmFtZScpKS50b0JlKCdXaGlybGVkJyk7XHJcbiAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCduYW1lJykuZW50ZXIoJ3dvcmxkJyk7XHJcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5iaW5kaW5nKCduYW1lJykpLnRvQmUoJ3dvcmxkJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0JpbmREaXJlY3RpdmUgPSBuZ0RpcmVjdGl2ZShmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gIGVsZW1lbnQuYWRkQ2xhc3MoJ25nLWJpbmRpbmcnKS5kYXRhKCckYmluZGluZycsIGF0dHIubmdCaW5kKTtcclxuICBzY29wZS4kd2F0Y2goYXR0ci5uZ0JpbmQsIGZ1bmN0aW9uIG5nQmluZFdhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICBlbGVtZW50LnRleHQodmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZSk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0JpbmRUZW1wbGF0ZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0JpbmRUZW1wbGF0ZWAgZGlyZWN0aXZlIHNwZWNpZmllcyB0aGF0IHRoZSBlbGVtZW50XHJcbiAqIHRleHQgY29udGVudCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW50ZXJwb2xhdGlvbiBvZiB0aGUgdGVtcGxhdGVcclxuICogaW4gdGhlIGBuZ0JpbmRUZW1wbGF0ZWAgYXR0cmlidXRlLlxyXG4gKiBVbmxpa2UgYG5nQmluZGAsIHRoZSBgbmdCaW5kVGVtcGxhdGVgIGNhbiBjb250YWluIG11bHRpcGxlIGB7e2AgYH19YFxyXG4gKiBleHByZXNzaW9ucy4gVGhpcyBkaXJlY3RpdmUgaXMgbmVlZGVkIHNpbmNlIHNvbWUgSFRNTCBlbGVtZW50c1xyXG4gKiAoc3VjaCBhcyBUSVRMRSBhbmQgT1BUSU9OKSBjYW5ub3QgY29udGFpbiBTUEFOIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtzdHJpbmd9IG5nQmluZFRlbXBsYXRlIHRlbXBsYXRlIG9mIGZvcm1cclxuICogICA8dHQ+e3s8L3R0PiA8dHQ+ZXhwcmVzc2lvbjwvdHQ+IDx0dD59fTwvdHQ+IHRvIGV2YWwuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFRyeSBpdCBoZXJlOiBlbnRlciB0ZXh0IGluIHRleHQgYm94IGFuZCB3YXRjaCB0aGUgZ3JlZXRpbmcgY2hhbmdlLlxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS5zYWx1dGF0aW9uID0gJ0hlbGxvJztcclxuICAgICAgICAgICAkc2NvcGUubmFtZSA9ICdXb3JsZCc7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgIFNhbHV0YXRpb246IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwic2FsdXRhdGlvblwiPjxicj5cclxuICAgICAgICBOYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cIm5hbWVcIj48YnI+XHJcbiAgICAgICAgPHByZSBuZy1iaW5kLXRlbXBsYXRlPVwie3tzYWx1dGF0aW9ufX0ge3tuYW1lfX0hXCI+PC9wcmU+XHJcbiAgICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctYmluZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnc2FsdXRhdGlvbicpKS5cclxuICAgICAgICAgICB0b0JlKCdIZWxsbycpO1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnbmFtZScpKS5cclxuICAgICAgICAgICB0b0JlKCdXb3JsZCcpO1xyXG4gICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgnc2FsdXRhdGlvbicpLmVudGVyKCdHcmVldGluZ3MnKTtcclxuICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ25hbWUnKS5lbnRlcigndXNlcicpO1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnc2FsdXRhdGlvbicpKS5cclxuICAgICAgICAgICB0b0JlKCdHcmVldGluZ3MnKTtcclxuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ25hbWUnKSkuXHJcbiAgICAgICAgICAgdG9CZSgndXNlcicpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdCaW5kVGVtcGxhdGVEaXJlY3RpdmUgPSBbJyRpbnRlcnBvbGF0ZScsIGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIHNjZW5hcmlvIHJ1bm5lclxyXG4gICAgdmFyIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUoZWxlbWVudC5hdHRyKGF0dHIuJGF0dHIubmdCaW5kVGVtcGxhdGUpKTtcclxuICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ25nLWJpbmRpbmcnKS5kYXRhKCckYmluZGluZycsIGludGVycG9sYXRlRm4pO1xyXG4gICAgYXR0ci4kb2JzZXJ2ZSgnbmdCaW5kVGVtcGxhdGUnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdCaW5kSHRtbFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIGJpbmRpbmcgdGhhdCB3aWxsIGlubmVySFRNTCB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIGBleHByZXNzaW9uYCBpbnRvIHRoZSBjdXJyZW50XHJcbiAqIGVsZW1lbnQgaW4gYSBzZWN1cmUgd2F5LiAgQnkgZGVmYXVsdCwgdGhlIGlubmVySFRNTC1lZCBjb250ZW50IHdpbGwgYmUgc2FuaXRpemVkIHVzaW5nIHRoZSB7QGxpbmtcclxuICogbmdTYW5pdGl6ZS4kc2FuaXRpemUgJHNhbml0aXplfSBzZXJ2aWNlLiAgVG8gdXRpbGl6ZSB0aGlzIGZ1bmN0aW9uYWxpdHksIGVuc3VyZSB0aGF0IGAkc2FuaXRpemVgXHJcbiAqIGlzIGF2YWlsYWJsZSwgZm9yIGV4YW1wbGUsIGJ5IGluY2x1ZGluZyB7QGxpbmsgbmdTYW5pdGl6ZX0gaW4geW91ciBtb2R1bGUncyBkZXBlbmRlbmNpZXMgKG5vdCBpblxyXG4gKiBjb3JlIEFuZ3VsYXIuKSAgWW91IG1heSBhbHNvIGJ5cGFzcyBzYW5pdGl6YXRpb24gZm9yIHZhbHVlcyB5b3Uga25vdyBhcmUgc2FmZS4gVG8gZG8gc28sIGJpbmQgdG9cclxuICogYW4gZXhwbGljaXRseSB0cnVzdGVkIHZhbHVlIHZpYSB7QGxpbmsgbmcuJHNjZSN0cnVzdEFzSHRtbCAkc2NlLnRydXN0QXNIdG1sfS4gIFNlZSB0aGUgZXhhbXBsZVxyXG4gKiB1bmRlciB7QGxpbmsgbmcuJHNjZSNFeGFtcGxlIFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIChTQ0UpfS5cclxuICpcclxuICogTm90ZTogSWYgYSBgJHNhbml0aXplYCBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlIGFuZCB0aGUgYm91bmQgdmFsdWUgaXNuJ3QgZXhwbGljaXRseSB0cnVzdGVkLCB5b3VcclxuICogd2lsbCBoYXZlIGFuIGV4Y2VwdGlvbiAoaW5zdGVhZCBvZiBhbiBleHBsb2l0LilcclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdCaW5kSHRtbCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZS5cclxuICovXHJcbnZhciBuZ0JpbmRIdG1sRGlyZWN0aXZlID0gWyckc2NlJywgZnVuY3Rpb24oJHNjZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgZWxlbWVudC5hZGRDbGFzcygnbmctYmluZGluZycpLmRhdGEoJyRiaW5kaW5nJywgYXR0ci5uZ0JpbmRIdG1sKTtcclxuICAgIHNjb3BlLiR3YXRjaChhdHRyLm5nQmluZEh0bWwsIGZ1bmN0aW9uIG5nQmluZEh0bWxXYXRjaEFjdGlvbih2YWx1ZSkge1xyXG4gICAgICBlbGVtZW50Lmh0bWwoJHNjZS5nZXRUcnVzdGVkSHRtbCh2YWx1ZSkgfHwgJycpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufV07XHJcblxyXG5mdW5jdGlvbiBjbGFzc0RpcmVjdGl2ZShuYW1lLCBzZWxlY3Rvcikge1xyXG4gIG5hbWUgPSAnbmdDbGFzcycgKyBuYW1lO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnQUMnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgICAgIHZhciBvbGRWYWwgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHNjb3BlLiR3YXRjaChhdHRyW25hbWVdLCBuZ0NsYXNzV2F0Y2hBY3Rpb24sIHRydWUpO1xyXG5cclxuICAgICAgICBhdHRyLiRvYnNlcnZlKCdjbGFzcycsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBuZ0NsYXNzV2F0Y2hBY3Rpb24oc2NvcGUuJGV2YWwoYXR0cltuYW1lXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKG5hbWUgIT09ICduZ0NsYXNzJykge1xyXG4gICAgICAgICAgc2NvcGUuJHdhdGNoKCckaW5kZXgnLCBmdW5jdGlvbigkaW5kZXgsIG9sZCRpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgbW9kID0gJGluZGV4ICYgMTtcclxuICAgICAgICAgICAgaWYgKG1vZCAhPT0gb2xkJGluZGV4ICYgMSkge1xyXG4gICAgICAgICAgICAgIGlmIChtb2QgPT09IHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY29wZS4kZXZhbChhdHRyW25hbWVdKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlLiRldmFsKGF0dHJbbmFtZV0pKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5nQ2xhc3NXYXRjaEFjdGlvbihuZXdWYWwpIHtcclxuICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gdHJ1ZSB8fCBzY29wZS4kaW5kZXggJSAyID09PSBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAob2xkVmFsICYmICFlcXVhbHMobmV3VmFsLG9sZFZhbCkpIHtcclxuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhvbGRWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZENsYXNzKG5ld1ZhbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvbGRWYWwgPSBjb3B5KG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3NWYWwpIHtcclxuICAgICAgICAgIGF0dHIuJHJlbW92ZUNsYXNzKGZsYXR0ZW5DbGFzc2VzKGNsYXNzVmFsKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3NWYWwpIHtcclxuICAgICAgICAgIGF0dHIuJGFkZENsYXNzKGZsYXR0ZW5DbGFzc2VzKGNsYXNzVmFsKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmbGF0dGVuQ2xhc3NlcyhjbGFzc1ZhbCkge1xyXG4gICAgICAgICAgaWYoaXNBcnJheShjbGFzc1ZhbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzVmFsLmpvaW4oJyAnKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoY2xhc3NWYWwpKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW10sIGkgPSAwO1xyXG4gICAgICAgICAgICBmb3JFYWNoKGNsYXNzVmFsLCBmdW5jdGlvbih2LCBrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChrKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGNsYXNzVmFsO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ2xhc3NcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdDbGFzc2AgYWxsb3dzIHlvdSB0byBzZXQgQ1NTIGNsYXNzZXMgb24gSFRNTCBhbiBlbGVtZW50LCBkeW5hbWljYWxseSwgYnkgZGF0YWJpbmRpbmdcclxuICogYW4gZXhwcmVzc2lvbiB0aGF0IHJlcHJlc2VudHMgYWxsIGNsYXNzZXMgdG8gYmUgYWRkZWQuXHJcbiAqXHJcbiAqIFRoZSBkaXJlY3RpdmUgd29uJ3QgYWRkIGR1cGxpY2F0ZSBjbGFzc2VzIGlmIGEgcGFydGljdWxhciBjbGFzcyB3YXMgYWxyZWFkeSBzZXQuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIGV4cHJlc3Npb24gY2hhbmdlcywgdGhlIHByZXZpb3VzbHkgYWRkZWQgY2xhc3NlcyBhcmUgcmVtb3ZlZCBhbmQgb25seSB0aGVuIHRoZVxyXG4gKiBuZXcgY2xhc3NlcyBhcmUgYWRkZWQuXHJcbiAqXHJcbiAqIEBhbmltYXRpb25zXHJcbiAqIGFkZCAtIGhhcHBlbnMganVzdCBiZWZvcmUgdGhlIGNsYXNzIGlzIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcclxuICogcmVtb3ZlIC0gaGFwcGVucyBqdXN0IGJlZm9yZSB0aGUgY2xhc3MgaXMgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50XHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ2xhc3Mge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbC4gVGhlIHJlc3VsdFxyXG4gKiAgIG9mIHRoZSBldmFsdWF0aW9uIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgc3BhY2UgZGVsaW1pdGVkIGNsYXNzXHJcbiAqICAgbmFtZXMsIGFuIGFycmF5LCBvciBhIG1hcCBvZiBjbGFzcyBuYW1lcyB0byBib29sZWFuIHZhbHVlcy4gSW4gdGhlIGNhc2Ugb2YgYSBtYXAsIHRoZVxyXG4gKiAgIG5hbWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlcyBhcmUgdHJ1dGh5IHdpbGwgYmUgYWRkZWQgYXMgY3NzIGNsYXNzZXMgdG8gdGhlXHJcbiAqICAgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGUgRXhhbXBsZSB0aGF0IGRlbW9zdHJhdGVzIGJhc2ljIGJpbmRpbmdzIHZpYSBuZ0NsYXNzIGRpcmVjdGl2ZS5cclxuICAgPGV4YW1wbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgIDxwIG5nLWNsYXNzPVwie3N0cmlrZTogc3RyaWtlLCBib2xkOiBib2xkLCByZWQ6IHJlZH1cIj5NYXAgU3ludGF4IEV4YW1wbGU8L3A+XHJcbiAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJib2xkXCI+IGJvbGRcclxuICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cInN0cmlrZVwiPiBzdHJpa2VcclxuICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cInJlZFwiPiByZWRcclxuICAgICAgIDxocj5cclxuICAgICAgIDxwIG5nLWNsYXNzPVwic3R5bGVcIj5Vc2luZyBTdHJpbmcgU3ludGF4PC9wPlxyXG4gICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJzdHlsZVwiIHBsYWNlaG9sZGVyPVwiVHlwZTogYm9sZCBzdHJpa2UgcmVkXCI+XHJcbiAgICAgICA8aHI+XHJcbiAgICAgICA8cCBuZy1jbGFzcz1cIltzdHlsZTEsIHN0eWxlMiwgc3R5bGUzXVwiPlVzaW5nIEFycmF5IFN5bnRheDwvcD5cclxuICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInN0eWxlMVwiIHBsYWNlaG9sZGVyPVwiVHlwZTogYm9sZFwiPjxicj5cclxuICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInN0eWxlMlwiIHBsYWNlaG9sZGVyPVwiVHlwZTogc3RyaWtlXCI+PGJyPlxyXG4gICAgICAgPGlucHV0IG5nLW1vZGVsPVwic3R5bGUzXCIgcGxhY2Vob2xkZXI9XCJUeXBlOiByZWRcIj48YnI+XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzdHlsZS5jc3NcIj5cclxuICAgICAgIC5zdHJpa2Uge1xyXG4gICAgICAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcclxuICAgICAgIH1cclxuICAgICAgIC5ib2xkIHtcclxuICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgIH1cclxuICAgICAgIC5yZWQge1xyXG4gICAgICAgICAgIGNvbG9yOiByZWQ7XHJcbiAgICAgICB9XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBsZXQgeW91IHRvZ2dsZSB0aGUgY2xhc3MnLCBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOmZpcnN0JykucHJvcCgnY2xhc3NOYW1lJykpLm5vdCgpLnRvTWF0Y2goL2JvbGQvKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6Zmlyc3QnKS5wcm9wKCdjbGFzc05hbWUnKSkubm90KCkudG9NYXRjaCgvcmVkLyk7XHJcblxyXG4gICAgICAgICBpbnB1dCgnYm9sZCcpLmNoZWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOmZpcnN0JykucHJvcCgnY2xhc3NOYW1lJykpLnRvTWF0Y2goL2JvbGQvKTtcclxuXHJcbiAgICAgICAgIGlucHV0KCdyZWQnKS5jaGVjaygpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS50b01hdGNoKC9yZWQvKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAgIGl0KCdzaG91bGQgbGV0IHlvdSB0b2dnbGUgc3RyaW5nIGV4YW1wbGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6bnRoLW9mLXR5cGUoMiknKS5wcm9wKCdjbGFzc05hbWUnKSkudG9CZSgnJyk7XHJcbiAgICAgICAgIGlucHV0KCdzdHlsZScpLmVudGVyKCdyZWQnKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6bnRoLW9mLXR5cGUoMiknKS5wcm9wKCdjbGFzc05hbWUnKSkudG9CZSgncmVkJyk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnYXJyYXkgZXhhbXBsZSBzaG91bGQgaGF2ZSAzIGNsYXNzZXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6bGFzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS50b0JlKCcnKTtcclxuICAgICAgICAgaW5wdXQoJ3N0eWxlMScpLmVudGVyKCdib2xkJyk7XHJcbiAgICAgICAgIGlucHV0KCdzdHlsZTInKS5lbnRlcignc3RyaWtlJyk7XHJcbiAgICAgICAgIGlucHV0KCdzdHlsZTMnKS5lbnRlcigncmVkJyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOmxhc3QnKS5wcm9wKCdjbGFzc05hbWUnKSkudG9CZSgnYm9sZCBzdHJpa2UgcmVkJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2ZpbGU+XHJcbiAgIDwvZXhhbXBsZT5cclxuXHJcbiAgICMjIEFuaW1hdGlvbnNcclxuXHJcbiAgIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBob3cgdG8gcGVyZm9ybSBhbmltYXRpb25zIHVzaW5nIG5nQ2xhc3MuXHJcblxyXG4gICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJzZXRcIiBuZy1jbGljaz1cIm15VmFyPSdteS1jbGFzcydcIj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cImNsZWFyXCIgbmctY2xpY2s9XCJteVZhcj0nJ1wiPlxyXG4gICAgICA8YnI+XHJcbiAgICAgIDxzcGFuIG5nLWNsYXNzPVwibXlWYXJcIj5TYW1wbGUgVGV4dDwvc3Bhbj5cclxuICAgICA8L2ZpbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxyXG4gICAgICAgLm15LWNsYXNzLWFkZCwgLm15LWNsYXNzLXJlbW92ZSB7XHJcbiAgICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgICAtbW96LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAgLW8tdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgICB0cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLm15LWNsYXNzLFxyXG4gICAgICAgLm15LWNsYXNzLWFkZC5teS1jbGFzcy1hZGQtYWN0aXZlIHtcclxuICAgICAgICAgY29sb3I6IHJlZDtcclxuICAgICAgICAgZm9udC1zaXplOjNlbTtcclxuICAgICAgIH1cclxuXHJcbiAgICAgICAubXktY2xhc3MtcmVtb3ZlLm15LWNsYXNzLXJlbW92ZS1hY3RpdmUge1xyXG4gICAgICAgICBmb250LXNpemU6MS4wZW07XHJcbiAgICAgICAgIGNvbG9yOmJsYWNrO1xyXG4gICAgICAgfVxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctY2xhc3MnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkubm90KCkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvbXktY2xhc3MvKTtcclxuXHJcbiAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmVsZW1lbnQoJzpidXR0b246Zmlyc3QnKS5jbGljaygpO1xyXG5cclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvbXktY2xhc3MvKTtcclxuXHJcbiAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmVsZW1lbnQoJzpidXR0b246bGFzdCcpLmNsaWNrKCk7XHJcblxyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5ub3QoKS5cclxuICAgICAgICAgICB0b01hdGNoKC9teS1jbGFzcy8pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9maWxlPlxyXG4gICA8L2V4YW1wbGU+XHJcblxyXG5cclxuICAgIyMgbmdDbGFzcyBhbmQgcHJlLWV4aXN0aW5nIENTUzMgVHJhbnNpdGlvbnMvQW5pbWF0aW9uc1xyXG4gICBUaGUgbmdDbGFzcyBkaXJlY3RpdmUgc3RpbGwgc3VwcG9ydHMgQ1NTMyBUcmFuc2l0aW9ucy9BbmltYXRpb25zIGV2ZW4gaWYgdGhleSBkbyBub3QgZm9sbG93IHRoZSBuZ0FuaW1hdGUgQ1NTIG5hbWluZyBzdHJ1Y3R1cmUuXHJcbiAgIFRoZXJlZm9yZSwgaWYgYW55IENTUzMgVHJhbnNpdGlvbi9BbmltYXRpb24gc3R5bGVzIChvdXRzaWRlIG9mIG5nQW5pbWF0ZSkgYXJlIHNldCBvbiB0aGUgZWxlbWVudCwgdGhlbiwgaWYgYSBuZ0NsYXNzIGFuaW1hdGlvblxyXG4gICBpcyB0cmlnZ2VyZWQsIHRoZSBuZ0NsYXNzIGFuaW1hdGlvbiB3aWxsIGJlIHNraXBwZWQgc28gdGhhdCBuZ0FuaW1hdGUgY2FuIGFsbG93IGZvciB0aGUgcHJlLWV4aXN0aW5nIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uIHRvXHJcbiAgIHRha2Ugb3Zlci4gVGhpcyByZXN0cmljdGlvbiBhbGxvd3MgZm9yIG5nQ2xhc3MgdG8gc3RpbGwgd29yayB3aXRoIHN0YW5kYXJkIENTUzMgVHJhbnNpdGlvbnMvQW5pbWF0aW9ucyB0aGF0IGFyZSBkZWZpbmVkXHJcbiAgIG91dHNpZGUgb2YgbmdBbmltYXRlLlxyXG4gKi9cclxudmFyIG5nQ2xhc3NEaXJlY3RpdmUgPSBjbGFzc0RpcmVjdGl2ZSgnJywgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDbGFzc09kZFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0NsYXNzT2RkYCBhbmQgYG5nQ2xhc3NFdmVuYCBkaXJlY3RpdmVzIHdvcmsgZXhhY3RseSBhc1xyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xhc3MgbmdDbGFzc30sIGV4Y2VwdCBpdCB3b3JrcyBpblxyXG4gKiBjb25qdW5jdGlvbiB3aXRoIGBuZ1JlcGVhdGAgYW5kIHRha2VzIGFmZmVjdCBvbmx5IG9uIG9kZCAoZXZlbikgcm93cy5cclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIGFwcGxpZWQgb25seSB3aXRoaW4gYSBzY29wZSBvZiBhblxyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IG5nUmVwZWF0fS5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDbGFzc09kZCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLiBUaGUgcmVzdWx0XHJcbiAqICAgb2YgdGhlIGV2YWx1YXRpb24gY2FuIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBzcGFjZSBkZWxpbWl0ZWQgY2xhc3MgbmFtZXMgb3IgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxleGFtcGxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgICAgPG9sIG5nLWluaXQ9XCJuYW1lcz1bJ0pvaG4nLCAnTWFyeScsICdDYXRlJywgJ1N1eiddXCI+XHJcbiAgICAgICAgICA8bGkgbmctcmVwZWF0PVwibmFtZSBpbiBuYW1lc1wiPlxyXG4gICAgICAgICAgIDxzcGFuIG5nLWNsYXNzLW9kZD1cIidvZGQnXCIgbmctY2xhc3MtZXZlbj1cIidldmVuJ1wiPlxyXG4gICAgICAgICAgICAge3tuYW1lfX1cclxuICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIDwvb2w+XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzdHlsZS5jc3NcIj5cclxuICAgICAgIC5vZGQge1xyXG4gICAgICAgICBjb2xvcjogcmVkO1xyXG4gICAgICAgfVxyXG4gICAgICAgLmV2ZW4ge1xyXG4gICAgICAgICBjb2xvcjogYmx1ZTtcclxuICAgICAgIH1cclxuICAgICA8L2ZpbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWNsYXNzLW9kZCBhbmQgbmctY2xhc3MtZXZlbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbGk6Zmlyc3Qgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5cclxuICAgICAgICAgICB0b01hdGNoKC9vZGQvKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGxpOmxhc3Qgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5cclxuICAgICAgICAgICB0b01hdGNoKC9ldmVuLyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2ZpbGU+XHJcbiAgIDwvZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0NsYXNzT2RkRGlyZWN0aXZlID0gY2xhc3NEaXJlY3RpdmUoJ09kZCcsIDApO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ2xhc3NFdmVuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nQ2xhc3NPZGRgIGFuZCBgbmdDbGFzc0V2ZW5gIGRpcmVjdGl2ZXMgd29yayBleGFjdGx5IGFzXHJcbiAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGFzcyBuZ0NsYXNzfSwgZXhjZXB0IGl0IHdvcmtzIGluXHJcbiAqIGNvbmp1bmN0aW9uIHdpdGggYG5nUmVwZWF0YCBhbmQgdGFrZXMgYWZmZWN0IG9ubHkgb24gb2RkIChldmVuKSByb3dzLlxyXG4gKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgYXBwbGllZCBvbmx5IHdpdGhpbiBhIHNjb3BlIG9mIGFuXHJcbiAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdSZXBlYXQgbmdSZXBlYXR9LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0NsYXNzRXZlbiB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLiBUaGVcclxuICogICByZXN1bHQgb2YgdGhlIGV2YWx1YXRpb24gY2FuIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBzcGFjZSBkZWxpbWl0ZWQgY2xhc3MgbmFtZXMgb3IgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxleGFtcGxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgICAgPG9sIG5nLWluaXQ9XCJuYW1lcz1bJ0pvaG4nLCAnTWFyeScsICdDYXRlJywgJ1N1eiddXCI+XHJcbiAgICAgICAgICA8bGkgbmctcmVwZWF0PVwibmFtZSBpbiBuYW1lc1wiPlxyXG4gICAgICAgICAgIDxzcGFuIG5nLWNsYXNzLW9kZD1cIidvZGQnXCIgbmctY2xhc3MtZXZlbj1cIidldmVuJ1wiPlxyXG4gICAgICAgICAgICAge3tuYW1lfX0gJm5ic3A7ICZuYnNwOyAmbmJzcDtcclxuICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIDwvb2w+XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzdHlsZS5jc3NcIj5cclxuICAgICAgIC5vZGQge1xyXG4gICAgICAgICBjb2xvcjogcmVkO1xyXG4gICAgICAgfVxyXG4gICAgICAgLmV2ZW4ge1xyXG4gICAgICAgICBjb2xvcjogYmx1ZTtcclxuICAgICAgIH1cclxuICAgICA8L2ZpbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWNsYXNzLW9kZCBhbmQgbmctY2xhc3MtZXZlbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbGk6Zmlyc3Qgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5cclxuICAgICAgICAgICB0b01hdGNoKC9vZGQvKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGxpOmxhc3Qgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5cclxuICAgICAgICAgICB0b01hdGNoKC9ldmVuLyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2ZpbGU+XHJcbiAgIDwvZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0NsYXNzRXZlbkRpcmVjdGl2ZSA9IGNsYXNzRGlyZWN0aXZlKCdFdmVuJywgMSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDbG9ha1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0Nsb2FrYCBkaXJlY3RpdmUgaXMgdXNlZCB0byBwcmV2ZW50IHRoZSBBbmd1bGFyIGh0bWwgdGVtcGxhdGUgZnJvbSBiZWluZyBicmllZmx5XHJcbiAqIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciBpbiBpdHMgcmF3ICh1bmNvbXBpbGVkKSBmb3JtIHdoaWxlIHlvdXIgYXBwbGljYXRpb24gaXMgbG9hZGluZy4gVXNlIHRoaXNcclxuICogZGlyZWN0aXZlIHRvIGF2b2lkIHRoZSB1bmRlc2lyYWJsZSBmbGlja2VyIGVmZmVjdCBjYXVzZWQgYnkgdGhlIGh0bWwgdGVtcGxhdGUgZGlzcGxheS5cclxuICpcclxuICogVGhlIGRpcmVjdGl2ZSBjYW4gYmUgYXBwbGllZCB0byB0aGUgYDxib2R5PmAgZWxlbWVudCwgYnV0IHR5cGljYWxseSBhIGZpbmUtZ3JhaW5lZCBhcHBsaWNhdGlvbiBpc1xyXG4gKiBwcmVmZXJyZWQgaW4gb3JkZXIgdG8gYmVuZWZpdCBmcm9tIHByb2dyZXNzaXZlIHJlbmRlcmluZyBvZiB0aGUgYnJvd3NlciB2aWV3LlxyXG4gKlxyXG4gKiBgbmdDbG9ha2Agd29ya3MgaW4gY29vcGVyYXRpb24gd2l0aCBhIGNzcyBydWxlIHRoYXQgaXMgZW1iZWRkZWQgd2l0aGluIGBhbmd1bGFyLmpzYCBhbmRcclxuICogIGBhbmd1bGFyLm1pbi5qc2AgZmlsZXMuIEZvbGxvd2luZyBpcyB0aGUgY3NzIHJ1bGU6XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIFtuZ1xcOmNsb2FrXSwgW25nLWNsb2FrXSwgW2RhdGEtbmctY2xvYWtdLCBbeC1uZy1jbG9ha10sIC5uZy1jbG9haywgLngtbmctY2xvYWsge1xyXG4gKiAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcclxuICogfVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogV2hlbiB0aGlzIGNzcyBydWxlIGlzIGxvYWRlZCBieSB0aGUgYnJvd3NlciwgYWxsIGh0bWwgZWxlbWVudHMgKGluY2x1ZGluZyB0aGVpciBjaGlsZHJlbikgdGhhdFxyXG4gKiBhcmUgdGFnZ2VkIHdpdGggdGhlIGBuZy1jbG9ha2AgZGlyZWN0aXZlIGFyZSBoaWRkZW4uIFdoZW4gQW5ndWxhciBjb21lcyBhY3Jvc3MgdGhpcyBkaXJlY3RpdmVcclxuICogZHVyaW5nIHRoZSBjb21waWxhdGlvbiBvZiB0aGUgdGVtcGxhdGUgaXQgZGVsZXRlcyB0aGUgYG5nQ2xvYWtgIGVsZW1lbnQgYXR0cmlidXRlLCB3aGljaFxyXG4gKiBtYWtlcyB0aGUgY29tcGlsZWQgZWxlbWVudCB2aXNpYmxlLlxyXG4gKlxyXG4gKiBGb3IgdGhlIGJlc3QgcmVzdWx0LCBgYW5ndWxhci5qc2Agc2NyaXB0IG11c3QgYmUgbG9hZGVkIGluIHRoZSBoZWFkIHNlY3Rpb24gb2YgdGhlIGh0bWwgZmlsZTtcclxuICogYWx0ZXJuYXRpdmVseSwgdGhlIGNzcyBydWxlIChhYm92ZSkgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgZXh0ZXJuYWwgc3R5bGVzaGVldCBvZiB0aGVcclxuICogYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIExlZ2FjeSBicm93c2VycywgbGlrZSBJRTcsIGRvIG5vdCBwcm92aWRlIGF0dHJpYnV0ZSBzZWxlY3RvciBzdXBwb3J0IChhZGRlZCBpbiBDU1MgMi4xKSBzbyB0aGV5XHJcbiAqIGNhbm5vdCBtYXRjaCB0aGUgYFtuZ1xcOmNsb2FrXWAgc2VsZWN0b3IuIFRvIHdvcmsgYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgeW91IG11c3QgYWRkIHRoZSBjc3NcclxuICogY2xhc3MgYG5nQ2xvYWtgIGluIGFkZGl0aW9uIHRvIGBuZ0Nsb2FrYCBkaXJlY3RpdmUgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUgYmVsb3cuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgPGRpdiBpZD1cInRlbXBsYXRlMVwiIG5nLWNsb2FrPnt7ICdoZWxsbycgfX08L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPVwidGVtcGxhdGUyXCIgbmctY2xvYWsgY2xhc3M9XCJuZy1jbG9ha1wiPnt7ICdoZWxsbyBJRTcnIH19PC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIHJlbW92ZSB0aGUgdGVtcGxhdGUgZGlyZWN0aXZlIGFuZCBjc3MgY2xhc3MnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlICN0ZW1wbGF0ZTEnKS5hdHRyKCduZy1jbG9haycpKS5cclxuICAgICAgICAgICBub3QoKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI3RlbXBsYXRlMicpLmF0dHIoJ25nLWNsb2FrJykpLlxyXG4gICAgICAgICAgIG5vdCgpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICpcclxuICovXHJcbnZhciBuZ0Nsb2FrRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xyXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcclxuICAgIGF0dHIuJHNldCgnbmdDbG9haycsIHVuZGVmaW5lZCk7XHJcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCduZy1jbG9haycpO1xyXG4gIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDb250cm9sbGVyXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nQ29udHJvbGxlcmAgZGlyZWN0aXZlIGFzc2lnbnMgYmVoYXZpb3IgdG8gYSBzY29wZS4gVGhpcyBpcyBhIGtleSBhc3BlY3Qgb2YgaG93IGFuZ3VsYXJcclxuICogc3VwcG9ydHMgdGhlIHByaW5jaXBsZXMgYmVoaW5kIHRoZSBNb2RlbC1WaWV3LUNvbnRyb2xsZXIgZGVzaWduIHBhdHRlcm4uXHJcbiAqXHJcbiAqIE1WQyBjb21wb25lbnRzIGluIGFuZ3VsYXI6XHJcbiAqXHJcbiAqICogTW9kZWwgw6LigqzigJ0gVGhlIE1vZGVsIGlzIGRhdGEgaW4gc2NvcGUgcHJvcGVydGllczsgc2NvcGVzIGFyZSBhdHRhY2hlZCB0byB0aGUgRE9NLlxyXG4gKiAqIFZpZXcgw6LigqzigJ0gVGhlIHRlbXBsYXRlIChIVE1MIHdpdGggZGF0YSBiaW5kaW5ncykgaXMgcmVuZGVyZWQgaW50byB0aGUgVmlldy5cclxuICogKiBDb250cm9sbGVyIMOi4oKs4oCdIFRoZSBgbmdDb250cm9sbGVyYCBkaXJlY3RpdmUgc3BlY2lmaWVzIGEgQ29udHJvbGxlciBjbGFzczsgdGhlIGNsYXNzIGhhc1xyXG4gKiAgIG1ldGhvZHMgdGhhdCB0eXBpY2FsbHkgZXhwcmVzcyB0aGUgYnVzaW5lc3MgbG9naWMgYmVoaW5kIHRoZSBhcHBsaWNhdGlvbi5cclxuICpcclxuICogTm90ZSB0aGF0IGFuIGFsdGVybmF0aXZlIHdheSB0byBkZWZpbmUgY29udHJvbGxlcnMgaXMgdmlhIHRoZSB7QGxpbmsgbmdSb3V0ZS4kcm91dGUgJHJvdXRlfSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHNjb3BlXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDb250cm9sbGVyIE5hbWUgb2YgYSBnbG9iYWxseSBhY2Nlc3NpYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9yIGFuXHJcbiAqICAgICB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSB0aGF0IG9uIHRoZSBjdXJyZW50IHNjb3BlIGV2YWx1YXRlcyB0byBhXHJcbiAqICAgICBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gVGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UgY2FuIGZ1cnRoZXIgYmUgcHVibGlzaGVkIGludG8gdGhlIHNjb3BlXHJcbiAqICAgICBieSBhZGRpbmcgYGFzIGxvY2FsTmFtZWAgdGhlIGNvbnRyb2xsZXIgbmFtZSBhdHRyaWJ1dGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIEhlcmUgaXMgYSBzaW1wbGUgZm9ybSBmb3IgZWRpdGluZyB1c2VyIGNvbnRhY3QgaW5mb3JtYXRpb24uIEFkZGluZywgcmVtb3ZpbmcsIGNsZWFyaW5nLCBhbmRcclxuICogZ3JlZXRpbmcgYXJlIG1ldGhvZHMgZGVjbGFyZWQgb24gdGhlIGNvbnRyb2xsZXIgKHNlZSBzb3VyY2UgdGFiKS4gVGhlc2UgbWV0aG9kcyBjYW5cclxuICogZWFzaWx5IGJlIGNhbGxlZCBmcm9tIHRoZSBhbmd1bGFyIG1hcmt1cC4gTm90aWNlIHRoYXQgdGhlIHNjb3BlIGJlY29tZXMgdGhlIGB0aGlzYCBmb3IgdGhlXHJcbiAqIGNvbnRyb2xsZXIncyBpbnN0YW5jZS4gVGhpcyBhbGxvd3MgZm9yIGVhc3kgYWNjZXNzIHRvIHRoZSB2aWV3IGRhdGEgZnJvbSB0aGUgY29udHJvbGxlci4gQWxzb1xyXG4gKiBub3RpY2UgdGhhdCBhbnkgY2hhbmdlcyB0byB0aGUgZGF0YSBhcmUgYXV0b21hdGljYWxseSByZWZsZWN0ZWQgaW4gdGhlIFZpZXcgd2l0aG91dCB0aGUgbmVlZFxyXG4gKiBmb3IgYSBtYW51YWwgdXBkYXRlLiBUaGUgZXhhbXBsZSBpcyBpbmNsdWRlZCBpbiB0d28gZGlmZmVyZW50IGRlY2xhcmF0aW9uIHN0eWxlcyBiYXNlZCBvblxyXG4gKiB5b3VyIHN0eWxlIHByZWZlcmVuY2VzLlxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgZnVuY3Rpb24gU2V0dGluZ3NDb250cm9sbGVyMSgpIHtcclxuICAgICAgICAgIHRoaXMubmFtZSA9IFwiSm9obiBTbWl0aFwiO1xyXG4gICAgICAgICAgdGhpcy5jb250YWN0cyA9IFtcclxuICAgICAgICAgICAge3R5cGU6ICdwaG9uZScsIHZhbHVlOiAnNDA4IDU1NSAxMjEyJ30sXHJcbiAgICAgICAgICAgIHt0eXBlOiAnZW1haWwnLCB2YWx1ZTogJ2pvaG4uc21pdGhAZXhhbXBsZS5vcmcnfSBdO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2V0dGluZ3NDb250cm9sbGVyMS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGFsZXJ0KHRoaXMubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2V0dGluZ3NDb250cm9sbGVyMS5wcm90b3R5cGUuYWRkQ29udGFjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGhpcy5jb250YWN0cy5wdXNoKHt0eXBlOiAnZW1haWwnLCB2YWx1ZTogJ3lvdXJuYW1lQGV4YW1wbGUub3JnJ30pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFNldHRpbmdzQ29udHJvbGxlcjEucHJvdG90eXBlLnJlbW92ZUNvbnRhY3QgPSBmdW5jdGlvbihjb250YWN0VG9SZW1vdmUpIHtcclxuICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250YWN0cy5pbmRleE9mKGNvbnRhY3RUb1JlbW92ZSk7XHJcbiAgICAgICAgICB0aGlzLmNvbnRhY3RzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgU2V0dGluZ3NDb250cm9sbGVyMS5wcm90b3R5cGUuY2xlYXJDb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCkge1xyXG4gICAgICAgICAgY29udGFjdC50eXBlID0gJ3Bob25lJztcclxuICAgICAgICAgIGNvbnRhY3QudmFsdWUgPSAnJztcclxuICAgICAgICB9O1xyXG4gICAgICA8L3NjcmlwdD5cclxuICAgICAgPGRpdiBpZD1cImN0cmwtYXMtZXhtcGxcIiBuZy1jb250cm9sbGVyPVwiU2V0dGluZ3NDb250cm9sbGVyMSBhcyBzZXR0aW5nc1wiPlxyXG4gICAgICAgIE5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwic2V0dGluZ3MubmFtZVwiLz5cclxuICAgICAgICBbIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInNldHRpbmdzLmdyZWV0KClcIj5ncmVldDwvYT4gXTxici8+XHJcbiAgICAgICAgQ29udGFjdDpcclxuICAgICAgICA8dWw+XHJcbiAgICAgICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBzZXR0aW5ncy5jb250YWN0c1wiPlxyXG4gICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwiY29udGFjdC50eXBlXCI+XHJcbiAgICAgICAgICAgICAgIDxvcHRpb24+cGhvbmU8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgPG9wdGlvbj5lbWFpbDwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJjb250YWN0LnZhbHVlXCIvPlxyXG4gICAgICAgICAgICBbIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInNldHRpbmdzLmNsZWFyQ29udGFjdChjb250YWN0KVwiPmNsZWFyPC9hPlxyXG4gICAgICAgICAgICB8IDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInNldHRpbmdzLnJlbW92ZUNvbnRhY3QoY29udGFjdClcIj5YPC9hPiBdXHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpPlsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwic2V0dGluZ3MuYWRkQ29udGFjdCgpXCI+YWRkPC9hPiBdPC9saT5cclxuICAgICAgIDwvdWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBjb250cm9sbGVyIGFzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1hcy1leG1wbD46aW5wdXQnKS52YWwoKSkudG9CZSgnSm9obiBTbWl0aCcpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6bnRoLWNoaWxkKDEpIGlucHV0JykudmFsKCkpXHJcbiAgICAgICAgICAgLnRvQmUoJzQwOCA1NTUgMTIxMicpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6bnRoLWNoaWxkKDIpIGlucHV0JykudmFsKCkpXHJcbiAgICAgICAgICAgLnRvQmUoJ2pvaG4uc21pdGhAZXhhbXBsZS5vcmcnKTtcclxuXHJcbiAgICAgICAgIGVsZW1lbnQoJyNjdHJsLWFzLWV4bXBsIGxpOmZpcnN0IGE6Y29udGFpbnMoXCJjbGVhclwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpmaXJzdCBpbnB1dCcpLnZhbCgpKS50b0JlKCcnKTtcclxuXHJcbiAgICAgICAgIGVsZW1lbnQoJyNjdHJsLWFzLWV4bXBsIGxpOmxhc3QgYTpjb250YWlucyhcImFkZFwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpudGgtY2hpbGQoMykgaW5wdXQnKS52YWwoKSlcclxuICAgICAgICAgICAudG9CZSgneW91cm5hbWVAZXhhbXBsZS5vcmcnKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICA8c2NyaXB0PlxyXG4gICAgICAgIGZ1bmN0aW9uIFNldHRpbmdzQ29udHJvbGxlcjIoJHNjb3BlKSB7XHJcbiAgICAgICAgICAkc2NvcGUubmFtZSA9IFwiSm9obiBTbWl0aFwiO1xyXG4gICAgICAgICAgJHNjb3BlLmNvbnRhY3RzID0gW1xyXG4gICAgICAgICAgICB7dHlwZToncGhvbmUnLCB2YWx1ZTonNDA4IDU1NSAxMjEyJ30sXHJcbiAgICAgICAgICAgIHt0eXBlOidlbWFpbCcsIHZhbHVlOidqb2huLnNtaXRoQGV4YW1wbGUub3JnJ30gXTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICBhbGVydCh0aGlzLm5hbWUpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuYWRkQ29udGFjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIHRoaXMuY29udGFjdHMucHVzaCh7dHlwZTonZW1haWwnLCB2YWx1ZToneW91cm5hbWVAZXhhbXBsZS5vcmcnfSk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICRzY29wZS5yZW1vdmVDb250YWN0ID0gZnVuY3Rpb24oY29udGFjdFRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250YWN0cy5pbmRleE9mKGNvbnRhY3RUb1JlbW92ZSk7XHJcbiAgICAgICAgICAgdGhpcy5jb250YWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuY2xlYXJDb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCkge1xyXG4gICAgICAgICAgIGNvbnRhY3QudHlwZSA9ICdwaG9uZSc7XHJcbiAgICAgICAgICAgY29udGFjdC52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIDwvc2NyaXB0PlxyXG4gICAgICA8ZGl2IGlkPVwiY3RybC1leG1wbFwiIG5nLWNvbnRyb2xsZXI9XCJTZXR0aW5nc0NvbnRyb2xsZXIyXCI+XHJcbiAgICAgICAgTmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJuYW1lXCIvPlxyXG4gICAgICAgIFsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwiZ3JlZXQoKVwiPmdyZWV0PC9hPiBdPGJyLz5cclxuICAgICAgICBDb250YWN0OlxyXG4gICAgICAgIDx1bD5cclxuICAgICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIGNvbnRhY3RzXCI+XHJcbiAgICAgICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJjb250YWN0LnR5cGVcIj5cclxuICAgICAgICAgICAgICAgPG9wdGlvbj5waG9uZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICA8b3B0aW9uPmVtYWlsPC9vcHRpb24+XHJcbiAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cImNvbnRhY3QudmFsdWVcIi8+XHJcbiAgICAgICAgICAgIFsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwiY2xlYXJDb250YWN0KGNvbnRhY3QpXCI+Y2xlYXI8L2E+XHJcbiAgICAgICAgICAgIHwgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicmVtb3ZlQ29udGFjdChjb250YWN0KVwiPlg8L2E+IF1cclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICA8bGk+WyA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJhZGRDb250YWN0KClcIj5hZGQ8L2E+IF08L2xpPlxyXG4gICAgICAgPC91bD5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIGNvbnRyb2xsZXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWV4bXBsPjppbnB1dCcpLnZhbCgpKS50b0JlKCdKb2huIFNtaXRoJyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1leG1wbCBsaTpudGgtY2hpbGQoMSkgaW5wdXQnKS52YWwoKSlcclxuICAgICAgICAgICAudG9CZSgnNDA4IDU1NSAxMjEyJyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1leG1wbCBsaTpudGgtY2hpbGQoMikgaW5wdXQnKS52YWwoKSlcclxuICAgICAgICAgICAudG9CZSgnam9obi5zbWl0aEBleGFtcGxlLm9yZycpO1xyXG5cclxuICAgICAgICAgZWxlbWVudCgnI2N0cmwtZXhtcGwgbGk6Zmlyc3QgYTpjb250YWlucyhcImNsZWFyXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOmZpcnN0IGlucHV0JykudmFsKCkpLnRvQmUoJycpO1xyXG5cclxuICAgICAgICAgZWxlbWVudCgnI2N0cmwtZXhtcGwgbGk6bGFzdCBhOmNvbnRhaW5zKFwiYWRkXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOm50aC1jaGlsZCgzKSBpbnB1dCcpLnZhbCgpKVxyXG4gICAgICAgICAgIC50b0JlKCd5b3VybmFtZUBleGFtcGxlLm9yZycpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcblxyXG4gKi9cclxudmFyIG5nQ29udHJvbGxlckRpcmVjdGl2ZSA9IFtmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgc2NvcGU6IHRydWUsXHJcbiAgICBjb250cm9sbGVyOiAnQCdcclxuICB9O1xyXG59XTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NzcFxyXG4gKiBAcHJpb3JpdHkgMTAwMFxyXG4gKlxyXG4gKiBAZWxlbWVudCBodG1sXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBFbmFibGVzIFtDU1AgKENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vU2VjdXJpdHkvQ1NQKSBzdXBwb3J0LlxyXG4gKiBcclxuICogVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBkZXZlbG9waW5nIHRoaW5ncyBsaWtlIEdvb2dsZSBDaHJvbWUgRXh0ZW5zaW9ucy5cclxuICogXHJcbiAqIENTUCBmb3JiaWRzIGFwcHMgdG8gdXNlIGBldmFsYCBvciBgRnVuY3Rpb24oc3RyaW5nKWAgZ2VuZXJhdGVkIGZ1bmN0aW9ucyAoYW1vbmcgb3RoZXIgdGhpbmdzKS5cclxuICogRm9yIHVzIHRvIGJlIGNvbXBhdGlibGUsIHdlIGp1c3QgbmVlZCB0byBpbXBsZW1lbnQgdGhlIFwiZ2V0dGVyRm5cIiBpbiAkcGFyc2Ugd2l0aG91dCB2aW9sYXRpbmdcclxuICogYW55IG9mIHRoZXNlIHJlc3RyaWN0aW9ucy5cclxuICogXHJcbiAqIEFuZ3VsYXJKUyB1c2VzIGBGdW5jdGlvbihzdHJpbmcpYCBnZW5lcmF0ZWQgZnVuY3Rpb25zIGFzIGEgc3BlZWQgb3B0aW1pemF0aW9uLiBCeSBhcHBseWluZyBgbmdDc3BgXHJcbiAqIGl0IGlzIGJlIHBvc3NpYmxlIHRvIG9wdCBpbnRvIHRoZSBDU1AgY29tcGF0aWJsZSBtb2RlLiBXaGVuIHRoaXMgbW9kZSBpcyBvbiBBbmd1bGFySlMgd2lsbFxyXG4gKiBldmFsdWF0ZSBhbGwgZXhwcmVzc2lvbnMgdXAgdG8gMzAlIHNsb3dlciB0aGFuIGluIG5vbi1DU1AgbW9kZSwgYnV0IG5vIHNlY3VyaXR5IHZpb2xhdGlvbnMgd2lsbFxyXG4gKiBiZSByYWlzZWQuXHJcbiAqIFxyXG4gKiBJbiBvcmRlciB0byB1c2UgdGhpcyBmZWF0dXJlIHB1dCBgbmdDc3BgIGRpcmVjdGl2ZSBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBhcHBsaWNhdGlvbi5cclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIFRoaXMgZXhhbXBsZSBzaG93cyBob3cgdG8gYXBwbHkgdGhlIGBuZ0NzcGAgZGlyZWN0aXZlIHRvIHRoZSBgaHRtbGAgdGFnLlxyXG4gICA8cHJlPlxyXG4gICAgIDwhZG9jdHlwZSBodG1sPlxyXG4gICAgIDxodG1sIG5nLWFwcCBuZy1jc3A+XHJcbiAgICAgLi4uXHJcbiAgICAgLi4uXHJcbiAgICAgPC9odG1sPlxyXG4gICA8L3ByZT5cclxuICovXHJcblxyXG52YXIgbmdDc3BEaXJlY3RpdmUgPSBbJyRzbmlmZmVyJywgZnVuY3Rpb24oJHNuaWZmZXIpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcHJpb3JpdHk6IDEwMDAsXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgJHNuaWZmZXIuY3NwID0gdHJ1ZTtcclxuICAgIH1cclxuICB9O1xyXG59XTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgbmdDbGljayBhbGxvd3MgeW91IHRvIHNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIHdoZW5cclxuICogZWxlbWVudCBpcyBjbGlja2VkLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0NsaWNrIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogY2xpY2suIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgIDxidXR0b24gbmctY2xpY2s9XCJjb3VudCA9IGNvdW50ICsgMVwiIG5nLWluaXQ9XCJjb3VudD0wXCI+XHJcbiAgICAgICAgSW5jcmVtZW50XHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgICBjb3VudDoge3tjb3VudH19XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWNsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudCcpKS50b0JlKCcwJyk7XHJcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b24nKS5jbGljaygpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnY291bnQnKSkudG9CZSgnMScpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG4vKlxyXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGFsbG93cyBjcmVhdGlvbiBvZiBjdXN0b20gb25jbGljayBoYW5kbGVycyB0aGF0IGFyZSBkZWZpbmVkIGFzIGFuZ3VsYXJcclxuICogZXhwcmVzc2lvbnMgYW5kIGFyZSBjb21waWxlZCBhbmQgZXhlY3V0ZWQgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxyXG4gKlxyXG4gKiBFdmVudHMgdGhhdCBhcmUgaGFuZGxlZCB2aWEgdGhlc2UgaGFuZGxlciBhcmUgYWx3YXlzIGNvbmZpZ3VyZWQgbm90IHRvIHByb3BhZ2F0ZSBmdXJ0aGVyLlxyXG4gKi9cclxudmFyIG5nRXZlbnREaXJlY3RpdmVzID0ge307XHJcbmZvckVhY2goXHJcbiAgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgbW91c2VlbnRlciBtb3VzZWxlYXZlIGtleWRvd24ga2V5dXAga2V5cHJlc3Mgc3VibWl0IGZvY3VzIGJsdXInLnNwbGl0KCcgJyksXHJcbiAgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOb3JtYWxpemUoJ25nLScgKyBuYW1lKTtcclxuICAgIG5nRXZlbnREaXJlY3RpdmVzW2RpcmVjdGl2ZU5hbWVdID0gWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgdmFyIGZuID0gJHBhcnNlKGF0dHJbZGlyZWN0aXZlTmFtZV0pO1xyXG4gICAgICAgIGVsZW1lbnQub24obG93ZXJjYXNlKG5hbWUpLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmbihzY29wZSwgeyRldmVudDpldmVudH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XTtcclxuICB9XHJcbik7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdEYmxjbGlja1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0RibGNsaWNrYCBkaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBkYmxjbGljayBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdEYmxjbGljayB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIGRibGNsaWNrLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb3VzZWRvd25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBuZ01vdXNlZG93biBkaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBtb3VzZWRvd24gZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2Vkb3duIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogbW91c2Vkb3duLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb3VzZXVwXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBtb3VzZXVwIGV2ZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ01vdXNldXAge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBtb3VzZXVwLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vdXNlb3ZlclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2VvdmVyIGV2ZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ01vdXNlb3ZlciB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIG1vdXNlb3Zlci4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2VlbnRlclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2VlbnRlciBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNb3VzZWVudGVyIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogbW91c2VlbnRlci4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2VsZWF2ZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2VsZWF2ZSBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNb3VzZWxlYXZlIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogbW91c2VsZWF2ZS4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2Vtb3ZlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBtb3VzZW1vdmUgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2Vtb3ZlIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogbW91c2Vtb3ZlLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdLZXlkb3duXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBrZXlkb3duIGV2ZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0tleWRvd24ge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBrZXlkb3duLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YCBhbmQgY2FuIGJlIGludGVycm9nYXRlZCBmb3Iga2V5Q29kZSwgYWx0S2V5LCBldGMuKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0tleXVwXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBrZXl1cCBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdLZXl1cCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIGtleXVwLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YCBhbmQgY2FuIGJlIGludGVycm9nYXRlZCBmb3Iga2V5Q29kZSwgYWx0S2V5LCBldGMuKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0tleXByZXNzXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBrZXlwcmVzcyBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdLZXlwcmVzcyB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIGtleXByZXNzLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YCBhbmQgY2FuIGJlIGludGVycm9nYXRlZCBmb3Iga2V5Q29kZSwgYWx0S2V5LCBldGMuKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1N1Ym1pdFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRW5hYmxlcyBiaW5kaW5nIGFuZ3VsYXIgZXhwcmVzc2lvbnMgdG8gb25zdWJtaXQgZXZlbnRzLlxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHkgaXQgcHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uICh3aGljaCBmb3IgZm9ybSBtZWFucyBzZW5kaW5nIHRoZSByZXF1ZXN0IHRvIHRoZVxyXG4gKiBzZXJ2ZXIgYW5kIHJlbG9hZGluZyB0aGUgY3VycmVudCBwYWdlKSAqKmJ1dCBvbmx5IGlmIHRoZSBmb3JtIGRvZXMgbm90IGNvbnRhaW4gYW4gYGFjdGlvbmBcclxuICogYXR0cmlidXRlKiouXHJcbiAqXHJcbiAqIEBlbGVtZW50IGZvcm1cclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ1N1Ym1pdCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICA8c2NyaXB0PlxyXG4gICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAkc2NvcGUubGlzdCA9IFtdO1xyXG4gICAgICAgICAgJHNjb3BlLnRleHQgPSAnaGVsbG8nO1xyXG4gICAgICAgICAgJHNjb3BlLnN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy50ZXh0KTtcclxuICAgICAgICAgICAgICB0aGlzLnRleHQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIDwvc2NyaXB0PlxyXG4gICAgICA8Zm9ybSBuZy1zdWJtaXQ9XCJzdWJtaXQoKVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgRW50ZXIgdGV4dCBhbmQgaGl0IGVudGVyOlxyXG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwidGV4dFwiIG5hbWU9XCJ0ZXh0XCIgLz5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIGlkPVwic3VibWl0XCIgdmFsdWU9XCJTdWJtaXRcIiAvPlxyXG4gICAgICAgIDxwcmU+bGlzdD17e2xpc3R9fTwvcHJlPlxyXG4gICAgICA8L2Zvcm0+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLXN1Ym1pdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGlzdCcpKS50b0JlKCdbXScpO1xyXG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjc3VibWl0JykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xpc3QnKSkudG9CZSgnW1wiaGVsbG9cIl0nKTtcclxuICAgICAgICAgZXhwZWN0KGlucHV0KCd0ZXh0JykudmFsKCkpLnRvQmUoJycpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgICBpdCgnc2hvdWxkIGlnbm9yZSBlbXB0eSBzdHJpbmdzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdsaXN0JykpLnRvQmUoJ1tdJyk7XHJcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlICNzdWJtaXQnKS5jbGljaygpO1xyXG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjc3VibWl0JykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xpc3QnKSkudG9CZSgnW1wiaGVsbG9cIl0nKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0ZvY3VzXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBmb2N1cyBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgd2luZG93LCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nRm9jdXMge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBmb2N1cy4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdCbHVyXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBibHVyIGV2ZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCB3aW5kb3csIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBhXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdCbHVyIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogYmx1ci4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJZlxyXG4gKiBAcmVzdHJpY3QgQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0lmYCBkaXJlY3RpdmUgcmVtb3ZlcyBhbmQgcmVjcmVhdGVzIGEgcG9ydGlvbiBvZiB0aGUgRE9NIHRyZWUgKEhUTUwpXHJcbiAqIGNvbmRpdGlvbmFsbHkgYmFzZWQgb24gKipcImZhbHN5XCIqKiBhbmQgKipcInRydXRoeVwiKiogdmFsdWVzLCByZXNwZWN0aXZlbHksIGV2YWx1YXRlZCB3aXRoaW5cclxuICogYW4ge2V4cHJlc3Npb259LiBJbiBvdGhlciB3b3JkcywgaWYgdGhlIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gKipuZ0lmIGV2YWx1YXRlcyB0byBhIGZhbHNlXHJcbiAqIHZhbHVlKiogdGhlbiAqKnRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NKiogYW5kICoqaWYgdHJ1ZSoqIHRoZW4gKiphIGNsb25lIG9mIHRoZVxyXG4gKiBlbGVtZW50IGlzIHJlaW5zZXJ0ZWQgaW50byB0aGUgRE9NKiouXHJcbiAqXHJcbiAqIGBuZ0lmYCBkaWZmZXJzIGZyb20gYG5nU2hvd2AgYW5kIGBuZ0hpZGVgIGluIHRoYXQgYG5nSWZgIGNvbXBsZXRlbHkgcmVtb3ZlcyBhbmQgcmVjcmVhdGVzIHRoZVxyXG4gKiBlbGVtZW50IGluIHRoZSBET00gcmF0aGVyIHRoYW4gY2hhbmdpbmcgaXRzIHZpc2liaWxpdHkgdmlhIHRoZSBgZGlzcGxheWAgY3NzIHByb3BlcnR5LiAgQSBjb21tb25cclxuICogY2FzZSB3aGVuIHRoaXMgZGlmZmVyZW5jZSBpcyBzaWduaWZpY2FudCBpcyB3aGVuIHVzaW5nIGNzcyBzZWxlY3RvcnMgdGhhdCByZWx5IG9uIGFuIGVsZW1lbnQnc1xyXG4gKiBwb3NpdGlvbiB3aXRoaW4gdGhlIERPTSAoSFRNTCksIHN1Y2ggYXMgdGhlIGA6Zmlyc3QtY2hpbGRgIG9yIGA6bGFzdC1jaGlsZGAgcHNldWRvLWNsYXNzZXMuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCAqKndoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIHVzaW5nIG5nSWYgaXRzIHNjb3BlIGlzIGRlc3Ryb3llZCoqIGFuZCAqKmEgbmV3IHNjb3BlXHJcbiAqIGlzIGNyZWF0ZWQgd2hlbiB0aGUgZWxlbWVudCBpcyByZXN0b3JlZCoqLiAgVGhlIHNjb3BlIGNyZWF0ZWQgd2l0aGluIGBuZ0lmYCBpbmhlcml0cyBmcm9tIFxyXG4gKiBpdHMgcGFyZW50IHNjb3BlIHVzaW5nXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3dpa2kvVGhlLU51YW5jZXMtb2YtU2NvcGUtUHJvdG90eXBhbC1Jbmhlcml0YW5jZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlfS5cclxuICogQW4gaW1wb3J0YW50IGltcGxpY2F0aW9uIG9mIHRoaXMgaXMgaWYgYG5nTW9kZWxgIGlzIHVzZWQgd2l0aGluIGBuZ0lmYCB0byBiaW5kIHRvXHJcbiAqIGEgamF2YXNjcmlwdCBwcmltaXRpdmUgZGVmaW5lZCBpbiB0aGUgcGFyZW50IHNjb3BlLiBJbiB0aGlzIGNhc2UgYW55IG1vZGlmaWNhdGlvbnMgbWFkZSB0byB0aGVcclxuICogdmFyaWFibGUgd2l0aGluIHRoZSBjaGlsZCBzY29wZSB3aWxsIG92ZXJyaWRlIChoaWRlKSB0aGUgdmFsdWUgaW4gdGhlIHBhcmVudCBzY29wZS5cclxuICpcclxuICogQWxzbywgYG5nSWZgIHJlY3JlYXRlcyBlbGVtZW50cyB1c2luZyB0aGVpciBjb21waWxlZCBzdGF0ZS4gQW4gZXhhbXBsZSBzY2VuYXJpbyBvZiB0aGlzIGJlaGF2aW9yXHJcbiAqIGlzIGlmIGFuIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgaXMgZGlyZWN0bHkgbW9kaWZpZWQgYWZ0ZXIgaXQncyBjb21waWxlZCwgdXNpbmcgc29tZXRoaW5nIGxpa2UgXHJcbiAqIGpRdWVyeSdzIGAuYWRkQ2xhc3MoKWAgbWV0aG9kLCBhbmQgdGhlIGVsZW1lbnQgaXMgbGF0ZXIgcmVtb3ZlZC4gV2hlbiBgbmdJZmAgcmVjcmVhdGVzIHRoZSBlbGVtZW50XHJcbiAqIHRoZSBhZGRlZCBjbGFzcyB3aWxsIGJlIGxvc3QgYmVjYXVzZSB0aGUgb3JpZ2luYWwgY29tcGlsZWQgc3RhdGUgaXMgdXNlZCB0byByZWdlbmVyYXRlIHRoZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcHJvdmlkZSBhbmltYXRpb25zIHZpYSB0aGUgbmdBbmltYXRlIG1vZHVsZSB0byBhbmltYXRlIHRoZSAqKmVudGVyKipcclxuICogYW5kICoqbGVhdmUqKiBlZmZlY3RzLlxyXG4gKlxyXG4gKiBAYW5pbWF0aW9uc1xyXG4gKiBlbnRlciAtIGhhcHBlbnMganVzdCBhZnRlciB0aGUgbmdJZiBjb250ZW50cyBjaGFuZ2UgYW5kIGEgbmV3IERPTSBlbGVtZW50IGlzIGNyZWF0ZWQgYW5kIGluamVjdGVkIGludG8gdGhlIG5nSWYgY29udGFpbmVyXHJcbiAqIGxlYXZlIC0gaGFwcGVucyBqdXN0IGJlZm9yZSB0aGUgbmdJZiBjb250ZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBzY29wZVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nSWYgSWYgdGhlIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGlzIGZhbHN5IHRoZW5cclxuICogICAgIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NIHRyZWUgKEhUTUwpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XHJcbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICBDbGljayBtZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiY2hlY2tlZFwiIG5nLWluaXQ9XCJjaGVja2VkPXRydWVcIiAvPjxici8+XHJcbiAgICAgIFNob3cgd2hlbiBjaGVja2VkOlxyXG4gICAgICA8c3BhbiBuZy1pZj1cImNoZWNrZWRcIiBjbGFzcz1cImFuaW1hdGUtaWZcIj5cclxuICAgICAgICBJJ20gcmVtb3ZlZCB3aGVuIHRoZSBjaGVja2JveCBpcyB1bmNoZWNrZWQuXHJcbiAgICAgIDwvc3Bhbj5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxyXG4gICAgICAuYW5pbWF0ZS1pZiB7XHJcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtaWYubmctZW50ZXIsIC5hbmltYXRlLWlmLm5nLWxlYXZlIHtcclxuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAtbW96LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAtby10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1pZi5uZy1lbnRlcixcclxuICAgICAgLmFuaW1hdGUtaWYubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHtcclxuICAgICAgICBvcGFjaXR5OjA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLWlmLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSxcclxuICAgICAgLmFuaW1hdGUtaWYubmctbGVhdmUge1xyXG4gICAgICAgIG9wYWNpdHk6MTtcclxuICAgICAgfVxyXG4gICAgPC9maWxlPlxyXG4gIDwvZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0lmRGlyZWN0aXZlID0gWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcclxuICAgIHByaW9yaXR5OiAxMDAwLFxyXG4gICAgdGVybWluYWw6IHRydWUsXHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHIsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cikge1xyXG4gICAgICAgIHZhciBjaGlsZEVsZW1lbnQsIGNoaWxkU2NvcGU7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaCgkYXR0ci5uZ0lmLCBmdW5jdGlvbiBuZ0lmV2F0Y2hBY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoY2hpbGRFbGVtZW50KTtcclxuICAgICAgICAgICAgY2hpbGRFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGNoaWxkU2NvcGUpIHtcclxuICAgICAgICAgICAgY2hpbGRTY29wZS4kZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBjaGlsZFNjb3BlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRvQm9vbGVhbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgY2hpbGRTY29wZSA9ICRzY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgIHRyYW5zY2x1ZGUoY2hpbGRTY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgY2hpbGRFbGVtZW50ID0gY2xvbmU7XHJcbiAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoY2xvbmUsICRlbGVtZW50LnBhcmVudCgpLCAkZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGVcclxuICogQHJlc3RyaWN0IEVDQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRmV0Y2hlcywgY29tcGlsZXMgYW5kIGluY2x1ZGVzIGFuIGV4dGVybmFsIEhUTUwgZnJhZ21lbnQuXHJcbiAqXHJcbiAqIEtlZXAgaW4gbWluZCB0aGF0OlxyXG4gKlxyXG4gKiAtICAgIGJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBVUkwgaXMgcmVzdHJpY3RlZCB0byB0aGUgc2FtZSBkb21haW4gYW5kIHByb3RvY29sIGFzIHRoZVxyXG4gKiAgICAgIGFwcGxpY2F0aW9uIGRvY3VtZW50LiAgVGhpcyBpcyBkb25lIGJ5IGNhbGxpbmcge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZFJlc291cmNlVXJsXHJcbiAqICAgICAgJHNjZS5nZXRUcnVzdGVkUmVzb3VyY2VVcmx9IG9uIGl0LiAgVG8gbG9hZCB0ZW1wbGF0ZXMgZnJvbSBvdGhlciBkb21haW5zIGFuZC9vciBwcm90b2NvbHMsXHJcbiAqICAgICAgeW91IG1heSBlaXRoZXIgZWl0aGVyIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNyZXNvdXJjZVVybFdoaXRlbGlzdCB3aGl0ZWxpc3QgdGhlbX0gb3JcclxuICogICAgICB7QGxpbmsgbmcuJHNjZSN0cnVzdEFzUmVzb3VyY2VVcmwgd3JhcCBpdH0gaW50byBhIHRydXN0ZWQgdmFsdWUuICBSZWZlciBBbmd1bGFyJ3Mge0BsaW5rXHJcbiAqICAgICAgbmcuJHNjZSBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZ30uXHJcbiAqIC0gICAgaW4gYWRkaXRpb24sIHRoZSBicm93c2VyJ3NcclxuICogICAgICB7QGxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9icm93c2Vyc2VjL3dpa2kvUGFydDIjU2FtZS1vcmlnaW5fcG9saWN5X2Zvcl9YTUxIdHRwUmVxdWVzdFxyXG4gKiAgICAgIFNhbWUgT3JpZ2luIFBvbGljeX0gYW5kIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9jb3JzLyBDcm9zcy1PcmlnaW4gUmVzb3VyY2UgU2hhcmluZ1xyXG4gKiAgICAgIChDT1JTKX0gcG9saWN5IGFwcGx5IHRoYXQgbWF5IGZ1cnRoZXIgcmVzdHJpY3Qgd2hldGhlciB0aGUgdGVtcGxhdGUgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cclxuICogICAgICAoZS5nLiAgbmdJbmNsdWRlIHdvbid0IHdvcmsgZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cyBvbiBhbGwgYnJvd3NlcnMgYW5kIGZvciBgZmlsZTovL2BcclxuICogICAgICBhY2Nlc3Mgb24gc29tZSBicm93c2VycylcclxuICpcclxuICogQGFuaW1hdGlvbnNcclxuICogZW50ZXIgLSBhbmltYXRpb24gaXMgdXNlZCB0byBicmluZyBuZXcgY29udGVudCBpbnRvIHRoZSBicm93c2VyLlxyXG4gKiBsZWF2ZSAtIGFuaW1hdGlvbiBpcyB1c2VkIHRvIGFuaW1hdGUgZXhpc3RpbmcgY29udGVudCBhd2F5LlxyXG4gKlxyXG4gKiBUaGUgZW50ZXIgYW5kIGxlYXZlIGFuaW1hdGlvbiBvY2N1ciBjb25jdXJyZW50bHkuXHJcbiAqXHJcbiAqIEBzY29wZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmdJbmNsdWRlfHNyYyBhbmd1bGFyIGV4cHJlc3Npb24gZXZhbHVhdGluZyB0byBVUkwuIElmIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmcgY29uc3RhbnQsXHJcbiAqICAgICAgICAgICAgICAgICBtYWtlIHN1cmUgeW91IHdyYXAgaXQgaW4gcXVvdGVzLCBlLmcuIGBzcmM9XCInbXlQYXJ0aWFsVGVtcGxhdGUuaHRtbCdcImAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb25sb2FkIEV4cHJlc3Npb24gdG8gZXZhbHVhdGUgd2hlbiBhIG5ldyBwYXJ0aWFsIGlzIGxvYWRlZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmc9fSBhdXRvc2Nyb2xsIFdoZXRoZXIgYG5nSW5jbHVkZWAgc2hvdWxkIGNhbGwge0BsaW5rIG5nLiRhbmNob3JTY3JvbGxcclxuICogICAgICAgICAgICAgICAgICAkYW5jaG9yU2Nyb2xsfSB0byBzY3JvbGwgdGhlIHZpZXdwb3J0IGFmdGVyIHRoZSBjb250ZW50IGlzIGxvYWRlZC5cclxuICpcclxuICogICAgICAgICAgICAgICAgICAtIElmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHNldCwgZGlzYWJsZSBzY3JvbGxpbmcuXHJcbiAqICAgICAgICAgICAgICAgICAgLSBJZiB0aGUgYXR0cmlidXRlIGlzIHNldCB3aXRob3V0IHZhbHVlLCBlbmFibGUgc2Nyb2xsaW5nLlxyXG4gKiAgICAgICAgICAgICAgICAgIC0gT3RoZXJ3aXNlIGVuYWJsZSBzY3JvbGxpbmcgb25seSBpZiB0aGUgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1dGh5IHZhbHVlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XHJcbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJ0ZW1wbGF0ZVwiIG5nLW9wdGlvbnM9XCJ0Lm5hbWUgZm9yIHQgaW4gdGVtcGxhdGVzXCI+XHJcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPihibGFuayk8L29wdGlvbj5cclxuICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgdXJsIG9mIHRoZSB0ZW1wbGF0ZTogPHR0Pnt7dGVtcGxhdGUudXJsfX08L3R0PlxyXG4gICAgICAgPGhyLz5cclxuICAgICAgIDxkaXYgY2xhc3M9XCJleGFtcGxlLWFuaW1hdGUtY29udGFpbmVyXCI+XHJcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJpbmNsdWRlLWV4YW1wbGVcIiBuZy1pbmNsdWRlPVwidGVtcGxhdGUudXJsXCI+PC9kaXY+XHJcbiAgICAgICA8L2Rpdj5cclxuICAgICA8L2Rpdj5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cclxuICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAkc2NvcGUudGVtcGxhdGVzID1cclxuICAgICAgICAgIFsgeyBuYW1lOiAndGVtcGxhdGUxLmh0bWwnLCB1cmw6ICd0ZW1wbGF0ZTEuaHRtbCd9XHJcbiAgICAgICAgICAsIHsgbmFtZTogJ3RlbXBsYXRlMi5odG1sJywgdXJsOiAndGVtcGxhdGUyLmh0bWwnfSBdO1xyXG4gICAgICAgICRzY29wZS50ZW1wbGF0ZSA9ICRzY29wZS50ZW1wbGF0ZXNbMF07XHJcbiAgICAgIH1cclxuICAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwidGVtcGxhdGUxLmh0bWxcIj5cclxuICAgICAgQ29udGVudCBvZiB0ZW1wbGF0ZTEuaHRtbFxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInRlbXBsYXRlMi5odG1sXCI+XHJcbiAgICAgIENvbnRlbnQgb2YgdGVtcGxhdGUyLmh0bWxcclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxyXG4gICAgICAuZXhhbXBsZS1hbmltYXRlLWNvbnRhaW5lciB7XHJcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XHJcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGhlaWdodDo0MHB4O1xyXG4gICAgICAgIG92ZXJmbG93OmhpZGRlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmV4YW1wbGUtYW5pbWF0ZS1jb250YWluZXIgPiBkaXYge1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmluY2x1ZGUtZXhhbXBsZS5uZy1lbnRlciwgLmluY2x1ZGUtZXhhbXBsZS5uZy1sZWF2ZSB7XHJcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgLW1vei10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgLW8tdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgIHRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuXHJcbiAgICAgICAgcG9zaXRpb246YWJzb2x1dGU7XHJcbiAgICAgICAgdG9wOjA7XHJcbiAgICAgICAgbGVmdDowO1xyXG4gICAgICAgIHJpZ2h0OjA7XHJcbiAgICAgICAgYm90dG9tOjA7XHJcbiAgICAgICAgZGlzcGxheTpibG9jaztcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5pbmNsdWRlLWV4YW1wbGUubmctZW50ZXIge1xyXG4gICAgICAgIHRvcDotNTBweDtcclxuICAgICAgfVxyXG4gICAgICAuaW5jbHVkZS1leGFtcGxlLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XHJcbiAgICAgICAgdG9wOjA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5pbmNsdWRlLWV4YW1wbGUubmctbGVhdmUge1xyXG4gICAgICAgIHRvcDowO1xyXG4gICAgICB9XHJcbiAgICAgIC5pbmNsdWRlLWV4YW1wbGUubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHtcclxuICAgICAgICB0b3A6NTBweDtcclxuICAgICAgfVxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgIGl0KCdzaG91bGQgbG9hZCB0ZW1wbGF0ZTEuaHRtbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIFtuZy1pbmNsdWRlXScpLnRleHQoKSkuXHJcbiAgICAgICAgIHRvTWF0Y2goL0NvbnRlbnQgb2YgdGVtcGxhdGUxLmh0bWwvKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGl0KCdzaG91bGQgbG9hZCB0ZW1wbGF0ZTIuaHRtbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgc2VsZWN0KCd0ZW1wbGF0ZScpLm9wdGlvbignMScpO1xyXG4gICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIFtuZy1pbmNsdWRlXScpLnRleHQoKSkuXHJcbiAgICAgICAgIHRvTWF0Y2goL0NvbnRlbnQgb2YgdGVtcGxhdGUyLmh0bWwvKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGl0KCdzaG91bGQgY2hhbmdlIHRvIGJsYW5rJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICBzZWxlY3QoJ3RlbXBsYXRlJykub3B0aW9uKCcnKTtcclxuICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctaW5jbHVkZV0nKSkudG9CZSh1bmRlZmluZWQpO1xyXG4gICAgICB9KTtcclxuICAgIDwvZmlsZT5cclxuICA8L2V4YW1wbGU+XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZXZlbnRcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSW5jbHVkZSMkaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWRcclxuICogQGV2ZW50T2YgbmcuZGlyZWN0aXZlOm5nSW5jbHVkZVxyXG4gKiBAZXZlbnRUeXBlIGVtaXQgb24gdGhlIHNjb3BlIG5nSW5jbHVkZSB3YXMgZGVjbGFyZWQgaW5cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEVtaXR0ZWQgZXZlcnkgdGltZSB0aGUgbmdJbmNsdWRlIGNvbnRlbnQgaXMgcmVxdWVzdGVkLlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGV2ZW50XHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGUjJGluY2x1ZGVDb250ZW50TG9hZGVkXHJcbiAqIEBldmVudE9mIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGVcclxuICogQGV2ZW50VHlwZSBlbWl0IG9uIHRoZSBjdXJyZW50IG5nSW5jbHVkZSBzY29wZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRW1pdHRlZCBldmVyeSB0aW1lIHRoZSBuZ0luY2x1ZGUgY29udGVudCBpcyByZWxvYWRlZC5cclxuICovXHJcbnZhciBuZ0luY2x1ZGVEaXJlY3RpdmUgPSBbJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJywgJyRhbmNob3JTY3JvbGwnLCAnJGNvbXBpbGUnLCAnJGFuaW1hdGUnLCAnJHNjZScsXHJcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRodHRwLCAgICR0ZW1wbGF0ZUNhY2hlLCAgICRhbmNob3JTY3JvbGwsICAgJGNvbXBpbGUsICAgJGFuaW1hdGUsICAgJHNjZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VDQScsXHJcbiAgICB0ZXJtaW5hbDogdHJ1ZSxcclxuICAgIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIsIHRyYW5zY2x1c2lvbikge1xyXG4gICAgICB2YXIgc3JjRXhwID0gYXR0ci5uZ0luY2x1ZGUgfHwgYXR0ci5zcmMsXHJcbiAgICAgICAgICBvbmxvYWRFeHAgPSBhdHRyLm9ubG9hZCB8fCAnJyxcclxuICAgICAgICAgIGF1dG9TY3JvbGxFeHAgPSBhdHRyLmF1dG9zY3JvbGw7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZUNvdW50ZXIgPSAwLFxyXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUsXHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50O1xyXG5cclxuICAgICAgICB2YXIgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGN1cnJlbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLiR3YXRjaCgkc2NlLnBhcnNlQXNSZXNvdXJjZVVybChzcmNFeHApLCBmdW5jdGlvbiBuZ0luY2x1ZGVXYXRjaEFjdGlvbihzcmMpIHtcclxuICAgICAgICAgIHZhciB0aGlzQ2hhbmdlSWQgPSArK2NoYW5nZUNvdW50ZXI7XHJcblxyXG4gICAgICAgICAgaWYgKHNyYykge1xyXG4gICAgICAgICAgICAkaHR0cC5nZXQoc3JjLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkuc3VjY2VzcyhmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgIT09IGNoYW5nZUNvdW50ZXIpIHJldHVybjtcclxuICAgICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSBzY29wZS4kbmV3KCk7XHJcblxyXG4gICAgICAgICAgICAgIHRyYW5zY2x1c2lvbihuZXdTY29wZSwgZnVuY3Rpb24oY2xvbmUpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2xvbmU7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudEVsZW1lbnQuaHRtbChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjdXJyZW50RWxlbWVudCwgbnVsbCwgJGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgJGNvbXBpbGUoY3VycmVudEVsZW1lbnQuY29udGVudHMoKSkoY3VycmVudFNjb3BlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICghYXV0b1Njcm9sbEV4cCB8fCBzY29wZS4kZXZhbChhdXRvU2Nyb2xsRXhwKSkpIHtcclxuICAgICAgICAgICAgICAgICAgJGFuY2hvclNjcm9sbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50TG9hZGVkJyk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS4kZXZhbChvbmxvYWRFeHApO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkID09PSBjaGFuZ2VDb3VudGVyKSBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50UmVxdWVzdGVkJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJbml0XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nSW5pdGAgZGlyZWN0aXZlIHNwZWNpZmllcyBpbml0aWFsaXphdGlvbiB0YXNrcyB0byBiZSBleGVjdXRlZFxyXG4gKiAgYmVmb3JlIHRoZSB0ZW1wbGF0ZSBlbnRlcnMgZXhlY3V0aW9uIG1vZGUgZHVyaW5nIGJvb3RzdHJhcC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdJbml0IHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWwuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgIDxkaXYgbmctaW5pdD1cImdyZWV0aW5nPSdIZWxsbyc7IHBlcnNvbj0nV29ybGQnXCI+XHJcbiAgICAgIHt7Z3JlZXRpbmd9fSB7e3BlcnNvbn19IVxyXG4gICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIGdyZWV0aW5nJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdncmVldGluZycpKS50b0JlKCdIZWxsbycpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygncGVyc29uJykpLnRvQmUoJ1dvcmxkJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ0luaXREaXJlY3RpdmUgPSBuZ0RpcmVjdGl2ZSh7XHJcbiAgY29tcGlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcmU6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgIHNjb3BlLiRldmFsKGF0dHJzLm5nSW5pdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTm9uQmluZGFibGVcclxuICogQHByaW9yaXR5IDEwMDBcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNvbWV0aW1lcyBpdCBpcyBuZWNlc3NhcnkgdG8gd3JpdGUgY29kZSB3aGljaCBsb29rcyBsaWtlIGJpbmRpbmdzIGJ1dCB3aGljaCBzaG91bGQgYmUgbGVmdCBhbG9uZVxyXG4gKiBieSBhbmd1bGFyLiBVc2UgYG5nTm9uQmluZGFibGVgIHRvIG1ha2UgYW5ndWxhciBpZ25vcmUgYSBjaHVuayBvZiBIVE1MLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICpcclxuICogQGV4YW1wbGVcclxuICogSW4gdGhpcyBleGFtcGxlIHRoZXJlIGFyZSB0d28gbG9jYXRpb24gd2hlcmUgYSBzaW1wbGUgYmluZGluZyAoYHt7fX1gKSBpcyBwcmVzZW50LCBidXQgdGhlIG9uZVxyXG4gKiB3cmFwcGVkIGluIGBuZ05vbkJpbmRhYmxlYCBpcyBsZWZ0IGFsb25lLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICA8ZGl2Pk5vcm1hbDoge3sxICsgMn19PC9kaXY+XHJcbiAgICAgICAgPGRpdiBuZy1ub24tYmluZGFibGU+SWdub3JlZDoge3sxICsgMn19PC9kaXY+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctbm9uLWJpbmRhYmxlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5iaW5kaW5nKCcxICsgMicpKS50b0JlKCczJyk7XHJcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5lbGVtZW50KCdkaXY6bGFzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvMSBcXCsgMi8pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ05vbkJpbmRhYmxlRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoeyB0ZXJtaW5hbDogdHJ1ZSwgcHJpb3JpdHk6IDEwMDAgfSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdQbHVyYWxpemVcclxuICogQHJlc3RyaWN0IEVBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAjIE92ZXJ2aWV3XHJcbiAqIGBuZ1BsdXJhbGl6ZWAgaXMgYSBkaXJlY3RpdmUgdGhhdCBkaXNwbGF5cyBtZXNzYWdlcyBhY2NvcmRpbmcgdG8gZW4tVVMgbG9jYWxpemF0aW9uIHJ1bGVzLlxyXG4gKiBUaGVzZSBydWxlcyBhcmUgYnVuZGxlZCB3aXRoIGFuZ3VsYXIuanMsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlblxyXG4gKiAoc2VlIHtAbGluayBndWlkZS9pMThuIEFuZ3VsYXIgaTE4bn0gZGV2IGd1aWRlKS4gWW91IGNvbmZpZ3VyZSBuZ1BsdXJhbGl6ZSBkaXJlY3RpdmVcclxuICogYnkgc3BlY2lmeWluZyB0aGUgbWFwcGluZ3MgYmV0d2VlblxyXG4gKiB7QGxpbmsgaHR0cDovL3VuaWNvZGUub3JnL3JlcG9zL2NsZHItdG1wL3RydW5rL2RpZmYvc3VwcGxlbWVudGFsL2xhbmd1YWdlX3BsdXJhbF9ydWxlcy5odG1sXHJcbiAqIHBsdXJhbCBjYXRlZ29yaWVzfSBhbmQgdGhlIHN0cmluZ3MgdG8gYmUgZGlzcGxheWVkLlxyXG4gKlxyXG4gKiAjIFBsdXJhbCBjYXRlZ29yaWVzIGFuZCBleHBsaWNpdCBudW1iZXIgcnVsZXNcclxuICogVGhlcmUgYXJlIHR3b1xyXG4gKiB7QGxpbmsgaHR0cDovL3VuaWNvZGUub3JnL3JlcG9zL2NsZHItdG1wL3RydW5rL2RpZmYvc3VwcGxlbWVudGFsL2xhbmd1YWdlX3BsdXJhbF9ydWxlcy5odG1sXHJcbiAqIHBsdXJhbCBjYXRlZ29yaWVzfSBpbiBBbmd1bGFyJ3MgZGVmYXVsdCBlbi1VUyBsb2NhbGU6IFwib25lXCIgYW5kIFwib3RoZXJcIi5cclxuICpcclxuICogV2hpbGUgYSBwbHVyYWwgY2F0ZWdvcnkgbWF5IG1hdGNoIG1hbnkgbnVtYmVycyAoZm9yIGV4YW1wbGUsIGluIGVuLVVTIGxvY2FsZSwgXCJvdGhlclwiIGNhbiBtYXRjaFxyXG4gKiBhbnkgbnVtYmVyIHRoYXQgaXMgbm90IDEpLCBhbiBleHBsaWNpdCBudW1iZXIgcnVsZSBjYW4gb25seSBtYXRjaCBvbmUgbnVtYmVyLiBGb3IgZXhhbXBsZSwgdGhlXHJcbiAqIGV4cGxpY2l0IG51bWJlciBydWxlIGZvciBcIjNcIiBtYXRjaGVzIHRoZSBudW1iZXIgMy4gVGhlcmUgYXJlIGV4YW1wbGVzIG9mIHBsdXJhbCBjYXRlZ29yaWVzXHJcbiAqIGFuZCBleHBsaWNpdCBudW1iZXIgcnVsZXMgdGhyb3VnaG91dCB0aGUgcmVzdCBvZiB0aGlzIGRvY3VtZW50YXRpb24uXHJcbiAqXHJcbiAqICMgQ29uZmlndXJpbmcgbmdQbHVyYWxpemVcclxuICogWW91IGNvbmZpZ3VyZSBuZ1BsdXJhbGl6ZSBieSBwcm92aWRpbmcgMiBhdHRyaWJ1dGVzOiBgY291bnRgIGFuZCBgd2hlbmAuXHJcbiAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIG9wdGlvbmFsIGF0dHJpYnV0ZSwgYG9mZnNldGAuXHJcbiAqXHJcbiAqIFRoZSB2YWx1ZSBvZiB0aGUgYGNvdW50YCBhdHRyaWJ1dGUgY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvblxyXG4gKiBBbmd1bGFyIGV4cHJlc3Npb259OyB0aGVzZSBhcmUgZXZhbHVhdGVkIG9uIHRoZSBjdXJyZW50IHNjb3BlIGZvciBpdHMgYm91bmQgdmFsdWUuXHJcbiAqXHJcbiAqIFRoZSBgd2hlbmAgYXR0cmlidXRlIHNwZWNpZmllcyB0aGUgbWFwcGluZ3MgYmV0d2VlbiBwbHVyYWwgY2F0ZWdvcmllcyBhbmQgdGhlIGFjdHVhbFxyXG4gKiBzdHJpbmcgdG8gYmUgZGlzcGxheWVkLiBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgYSBKU09OIG9iamVjdC5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBjb25maWd1cmUgbmdQbHVyYWxpemU6XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIDxuZy1wbHVyYWxpemUgY291bnQ9XCJwZXJzb25Db3VudFwiXHJcbiAgICAgICAgICAgICAgICAgd2hlbj1cInsnMCc6ICdOb2JvZHkgaXMgdmlld2luZy4nLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAnb25lJzogJzEgcGVyc29uIGlzIHZpZXdpbmcuJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgJ290aGVyJzogJ3t9IHBlb3BsZSBhcmUgdmlld2luZy4nfVwiPlxyXG4gKiA8L25nLXBsdXJhbGl6ZT5cclxuICo8L3ByZT5cclxuICpcclxuICogSW4gdGhlIGV4YW1wbGUsIGBcIjA6IE5vYm9keSBpcyB2aWV3aW5nLlwiYCBpcyBhbiBleHBsaWNpdCBudW1iZXIgcnVsZS4gSWYgeW91IGRpZCBub3RcclxuICogc3BlY2lmeSB0aGlzIHJ1bGUsIDAgd291bGQgYmUgbWF0Y2hlZCB0byB0aGUgXCJvdGhlclwiIGNhdGVnb3J5IGFuZCBcIjAgcGVvcGxlIGFyZSB2aWV3aW5nXCJcclxuICogd291bGQgYmUgc2hvd24gaW5zdGVhZCBvZiBcIk5vYm9keSBpcyB2aWV3aW5nXCIuIFlvdSBjYW4gc3BlY2lmeSBhbiBleHBsaWNpdCBudW1iZXIgcnVsZSBmb3JcclxuICogb3RoZXIgbnVtYmVycywgZm9yIGV4YW1wbGUgMTIsIHNvIHRoYXQgaW5zdGVhZCBvZiBzaG93aW5nIFwiMTIgcGVvcGxlIGFyZSB2aWV3aW5nXCIsIHlvdSBjYW5cclxuICogc2hvdyBcImEgZG96ZW4gcGVvcGxlIGFyZSB2aWV3aW5nXCIuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIGEgc2V0IG9mIGNsb3NlZCBicmFjZXMoYHt9YCkgYXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlIG51bWJlciB0aGF0IHlvdSB3YW50IHN1YnN0aXR1dGVkXHJcbiAqIGludG8gcGx1cmFsaXplZCBzdHJpbmdzLiBJbiB0aGUgcHJldmlvdXMgZXhhbXBsZSwgQW5ndWxhciB3aWxsIHJlcGxhY2UgYHt9YCB3aXRoXHJcbiAqIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT5ge3twZXJzb25Db3VudH19YDwvc3Bhbj4uIFRoZSBjbG9zZWQgYnJhY2VzIGB7fWAgaXMgYSBwbGFjZWhvbGRlclxyXG4gKiBmb3IgPHNwYW4gbmctbm9uLWJpbmRhYmxlPnt7bnVtYmVyRXhwcmVzc2lvbn19PC9zcGFuPi5cclxuICpcclxuICogIyBDb25maWd1cmluZyBuZ1BsdXJhbGl6ZSB3aXRoIG9mZnNldFxyXG4gKiBUaGUgYG9mZnNldGAgYXR0cmlidXRlIGFsbG93cyBmdXJ0aGVyIGN1c3RvbWl6YXRpb24gb2YgcGx1cmFsaXplZCB0ZXh0LCB3aGljaCBjYW4gcmVzdWx0IGluXHJcbiAqIGEgYmV0dGVyIHVzZXIgZXhwZXJpZW5jZS4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgdGhlIG1lc3NhZ2UgXCI0IHBlb3BsZSBhcmUgdmlld2luZyB0aGlzIGRvY3VtZW50XCIsXHJcbiAqIHlvdSBtaWdodCBkaXNwbGF5IFwiSm9obiwgS2F0ZSBhbmQgMiBvdGhlcnMgYXJlIHZpZXdpbmcgdGhpcyBkb2N1bWVudFwiLlxyXG4gKiBUaGUgb2Zmc2V0IGF0dHJpYnV0ZSBhbGxvd3MgeW91IHRvIG9mZnNldCBhIG51bWJlciBieSBhbnkgZGVzaXJlZCB2YWx1ZS5cclxuICogTGV0J3MgdGFrZSBhIGxvb2sgYXQgYW4gZXhhbXBsZTpcclxuICpcclxuICogPHByZT5cclxuICogPG5nLXBsdXJhbGl6ZSBjb3VudD1cInBlcnNvbkNvdW50XCIgb2Zmc2V0PTJcclxuICogICAgICAgICAgICAgICB3aGVuPVwieycwJzogJ05vYm9keSBpcyB2aWV3aW5nLicsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICcxJzogJ3t7cGVyc29uMX19IGlzIHZpZXdpbmcuJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgJzInOiAne3twZXJzb24xfX0gYW5kIHt7cGVyc29uMn19IGFyZSB2aWV3aW5nLicsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICdvbmUnOiAne3twZXJzb24xfX0sIHt7cGVyc29uMn19IGFuZCBvbmUgb3RoZXIgcGVyc29uIGFyZSB2aWV3aW5nLicsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7e3BlcnNvbjF9fSwge3twZXJzb24yfX0gYW5kIHt9IG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nfVwiPlxyXG4gKiA8L25nLXBsdXJhbGl6ZT5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIE5vdGljZSB0aGF0IHdlIGFyZSBzdGlsbCB1c2luZyB0d28gcGx1cmFsIGNhdGVnb3JpZXMob25lLCBvdGhlciksIGJ1dCB3ZSBhZGRlZFxyXG4gKiB0aHJlZSBleHBsaWNpdCBudW1iZXIgcnVsZXMgMCwgMSBhbmQgMi5cclxuICogV2hlbiBvbmUgcGVyc29uLCBwZXJoYXBzIEpvaG4sIHZpZXdzIHRoZSBkb2N1bWVudCwgXCJKb2huIGlzIHZpZXdpbmdcIiB3aWxsIGJlIHNob3duLlxyXG4gKiBXaGVuIHRocmVlIHBlb3BsZSB2aWV3IHRoZSBkb2N1bWVudCwgbm8gZXhwbGljaXQgbnVtYmVyIHJ1bGUgaXMgZm91bmQsIHNvXHJcbiAqIGFuIG9mZnNldCBvZiAyIGlzIHRha2VuIG9mZiAzLCBhbmQgQW5ndWxhciB1c2VzIDEgdG8gZGVjaWRlIHRoZSBwbHVyYWwgY2F0ZWdvcnkuXHJcbiAqIEluIHRoaXMgY2FzZSwgcGx1cmFsIGNhdGVnb3J5ICdvbmUnIGlzIG1hdGNoZWQgYW5kIFwiSm9obiwgTWFycnkgYW5kIG9uZSBvdGhlciBwZXJzb24gYXJlIHZpZXdpbmdcIlxyXG4gKiBpcyBzaG93bi5cclxuICpcclxuICogTm90ZSB0aGF0IHdoZW4geW91IHNwZWNpZnkgb2Zmc2V0cywgeW91IG11c3QgcHJvdmlkZSBleHBsaWNpdCBudW1iZXIgcnVsZXMgZm9yXHJcbiAqIG51bWJlcnMgZnJvbSAwIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIG9mZnNldC4gSWYgeW91IHVzZSBhbiBvZmZzZXQgb2YgMywgZm9yIGV4YW1wbGUsXHJcbiAqIHlvdSBtdXN0IHByb3ZpZGUgZXhwbGljaXQgbnVtYmVyIHJ1bGVzIGZvciAwLCAxLCAyIGFuZCAzLiBZb3UgbXVzdCBhbHNvIHByb3ZpZGUgcGx1cmFsIHN0cmluZ3MgZm9yXHJcbiAqIHBsdXJhbCBjYXRlZ29yaWVzIFwib25lXCIgYW5kIFwib3RoZXJcIi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8ZXhwcmVzc2lvbn0gY291bnQgVGhlIHZhcmlhYmxlIHRvIGJlIGJvdW5kZWQgdG8uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB3aGVuIFRoZSBtYXBwaW5nIGJldHdlZW4gcGx1cmFsIGNhdGVnb3J5IHRvIGl0cyBjb3JyZXNwb25kaW5nIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBkZWR1Y3QgZnJvbSB0aGUgdG90YWwgbnVtYmVyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnBlcnNvbjEgPSAnSWdvcic7XHJcbiAgICAgICAgICAgICRzY29wZS5wZXJzb24yID0gJ01pc2tvJztcclxuICAgICAgICAgICAgJHNjb3BlLnBlcnNvbkNvdW50ID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICA8L3NjcmlwdD5cclxuICAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgICBQZXJzb24gMTo8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInBlcnNvbjFcIiB2YWx1ZT1cIklnb3JcIiAvPjxici8+XHJcbiAgICAgICAgICBQZXJzb24gMjo8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInBlcnNvbjJcIiB2YWx1ZT1cIk1pc2tvXCIgLz48YnIvPlxyXG4gICAgICAgICAgTnVtYmVyIG9mIFBlb3BsZTo8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInBlcnNvbkNvdW50XCIgdmFsdWU9XCIxXCIgLz48YnIvPlxyXG5cclxuICAgICAgICAgIDwhLS0tIEV4YW1wbGUgd2l0aCBzaW1wbGUgcGx1cmFsaXphdGlvbiBydWxlcyBmb3IgZW4gbG9jYWxlIC0tLT5cclxuICAgICAgICAgIFdpdGhvdXQgT2Zmc2V0OlxyXG4gICAgICAgICAgPG5nLXBsdXJhbGl6ZSBjb3VudD1cInBlcnNvbkNvdW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlbj1cInsnMCc6ICdOb2JvZHkgaXMgdmlld2luZy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uZSc6ICcxIHBlcnNvbiBpcyB2aWV3aW5nLicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3RoZXInOiAne30gcGVvcGxlIGFyZSB2aWV3aW5nLid9XCI+XHJcbiAgICAgICAgICA8L25nLXBsdXJhbGl6ZT48YnI+XHJcblxyXG4gICAgICAgICAgPCEtLS0gRXhhbXBsZSB3aXRoIG9mZnNldCAtLS0+XHJcbiAgICAgICAgICBXaXRoIE9mZnNldCgyKTpcclxuICAgICAgICAgIDxuZy1wbHVyYWxpemUgY291bnQ9XCJwZXJzb25Db3VudFwiIG9mZnNldD0yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW49XCJ7JzAnOiAnTm9ib2R5IGlzIHZpZXdpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxJzogJ3t7cGVyc29uMX19IGlzIHZpZXdpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcyJzogJ3t7cGVyc29uMX19IGFuZCB7e3BlcnNvbjJ9fSBhcmUgdmlld2luZy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29uZSc6ICd7e3BlcnNvbjF9fSwge3twZXJzb24yfX0gYW5kIG9uZSBvdGhlciBwZXJzb24gYXJlIHZpZXdpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7e3BlcnNvbjF9fSwge3twZXJzb24yfX0gYW5kIHt9IG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nfVwiPlxyXG4gICAgICAgICAgPC9uZy1wbHVyYWxpemU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIHNob3cgY29ycmVjdCBwbHVyYWxpemVkIHN0cmluZycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpmaXJzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJzEgcGVyc29uIGlzIHZpZXdpbmcuJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdJZ29yIGlzIHZpZXdpbmcuJyk7XHJcblxyXG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbkNvdW50JykuZW50ZXIoJzAnKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6Zmlyc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ05vYm9keSBpcyB2aWV3aW5nLicpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ05vYm9keSBpcyB2aWV3aW5nLicpO1xyXG5cclxuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb25Db3VudCcpLmVudGVyKCcyJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCcyIHBlb3BsZSBhcmUgdmlld2luZy4nKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6bGFzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ0lnb3IgYW5kIE1pc2tvIGFyZSB2aWV3aW5nLicpO1xyXG5cclxuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb25Db3VudCcpLmVudGVyKCczJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCczIHBlb3BsZSBhcmUgdmlld2luZy4nKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6bGFzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ0lnb3IsIE1pc2tvIGFuZCBvbmUgb3RoZXIgcGVyc29uIGFyZSB2aWV3aW5nLicpO1xyXG5cclxuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb25Db3VudCcpLmVudGVyKCc0Jyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCc0IHBlb3BsZSBhcmUgdmlld2luZy4nKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6bGFzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ0lnb3IsIE1pc2tvIGFuZCAyIG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBzaG93IGRhdGEtYmluZGVkIG5hbWVzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uQ291bnQnKS5lbnRlcignNCcpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICB0b0JlKCdJZ29yLCBNaXNrbyBhbmQgMiBvdGhlciBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XHJcblxyXG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbjEnKS5lbnRlcignRGknKTtcclxuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb24yJykuZW50ZXIoJ1ZvanRhJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgIHRvQmUoJ0RpLCBWb2p0YSBhbmQgMiBvdGhlciBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ1BsdXJhbGl6ZURpcmVjdGl2ZSA9IFsnJGxvY2FsZScsICckaW50ZXJwb2xhdGUnLCBmdW5jdGlvbigkbG9jYWxlLCAkaW50ZXJwb2xhdGUpIHtcclxuICB2YXIgQlJBQ0UgPSAve30vZztcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgICB2YXIgbnVtYmVyRXhwID0gYXR0ci5jb3VudCxcclxuICAgICAgICAgIHdoZW5FeHAgPSBhdHRyLiRhdHRyLndoZW4gJiYgZWxlbWVudC5hdHRyKGF0dHIuJGF0dHIud2hlbiksIC8vIHdlIGhhdmUge3t9fSBpbiBhdHRyc1xyXG4gICAgICAgICAgb2Zmc2V0ID0gYXR0ci5vZmZzZXQgfHwgMCxcclxuICAgICAgICAgIHdoZW5zID0gc2NvcGUuJGV2YWwod2hlbkV4cCkgfHwge30sXHJcbiAgICAgICAgICB3aGVuc0V4cEZucyA9IHt9LFxyXG4gICAgICAgICAgc3RhcnRTeW1ib2wgPSAkaW50ZXJwb2xhdGUuc3RhcnRTeW1ib2woKSxcclxuICAgICAgICAgIGVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKSxcclxuICAgICAgICAgIGlzV2hlbiA9IC9ed2hlbihNaW51cyk/KC4rKSQvO1xyXG5cclxuICAgICAgZm9yRWFjaChhdHRyLCBmdW5jdGlvbihleHByZXNzaW9uLCBhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICAgICAgaWYgKGlzV2hlbi50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICAgICAgICB3aGVuc1tsb3dlcmNhc2UoYXR0cmlidXRlTmFtZS5yZXBsYWNlKCd3aGVuJywgJycpLnJlcGxhY2UoJ01pbnVzJywgJy0nKSldID1cclxuICAgICAgICAgICAgZWxlbWVudC5hdHRyKGF0dHIuJGF0dHJbYXR0cmlidXRlTmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGZvckVhY2god2hlbnMsIGZ1bmN0aW9uKGV4cHJlc3Npb24sIGtleSkge1xyXG4gICAgICAgIHdoZW5zRXhwRm5zW2tleV0gPVxyXG4gICAgICAgICAgJGludGVycG9sYXRlKGV4cHJlc3Npb24ucmVwbGFjZShCUkFDRSwgc3RhcnRTeW1ib2wgKyBudW1iZXJFeHAgKyAnLScgK1xyXG4gICAgICAgICAgICBvZmZzZXQgKyBlbmRTeW1ib2wpKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gbmdQbHVyYWxpemVXYXRjaCgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KHNjb3BlLiRldmFsKG51bWJlckV4cCkpO1xyXG5cclxuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgLy9pZiBleHBsaWNpdCBudW1iZXIgcnVsZSBzdWNoIGFzIDEsIDIsIDMuLi4gaXMgZGVmaW5lZCwganVzdCB1c2UgaXQuIE90aGVyd2lzZSxcclxuICAgICAgICAgIC8vY2hlY2sgaXQgYWdhaW5zdCBwbHVyYWxpemF0aW9uIHJ1bGVzIGluICRsb2NhbGUgc2VydmljZVxyXG4gICAgICAgICAgaWYgKCEodmFsdWUgaW4gd2hlbnMpKSB2YWx1ZSA9ICRsb2NhbGUucGx1cmFsQ2F0KHZhbHVlIC0gb2Zmc2V0KTtcclxuICAgICAgICAgICByZXR1cm4gd2hlbnNFeHBGbnNbdmFsdWVdKHNjb3BlLCBlbGVtZW50LCB0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZnVuY3Rpb24gbmdQbHVyYWxpemVXYXRjaEFjdGlvbihuZXdWYWwpIHtcclxuICAgICAgICBlbGVtZW50LnRleHQobmV3VmFsKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdSZXBlYXRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdSZXBlYXRgIGRpcmVjdGl2ZSBpbnN0YW50aWF0ZXMgYSB0ZW1wbGF0ZSBvbmNlIHBlciBpdGVtIGZyb20gYSBjb2xsZWN0aW9uLiBFYWNoIHRlbXBsYXRlXHJcbiAqIGluc3RhbmNlIGdldHMgaXRzIG93biBzY29wZSwgd2hlcmUgdGhlIGdpdmVuIGxvb3AgdmFyaWFibGUgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbSxcclxuICogYW5kIGAkaW5kZXhgIGlzIHNldCB0byB0aGUgaXRlbSBpbmRleCBvciBrZXkuXHJcbiAqXHJcbiAqIFNwZWNpYWwgcHJvcGVydGllcyBhcmUgZXhwb3NlZCBvbiB0aGUgbG9jYWwgc2NvcGUgb2YgZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZSwgaW5jbHVkaW5nOlxyXG4gKlxyXG4gKiB8IFZhcmlhYmxlICB8IFR5cGUgICAgICAgICAgICB8IERldGFpbHMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqIHwtLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICogfCBgJGluZGV4YCAgfCB7QHR5cGUgbnVtYmVyfSAgfCBpdGVyYXRvciBvZmZzZXQgb2YgdGhlIHJlcGVhdGVkIGVsZW1lbnQgKDAuLmxlbmd0aC0xKSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8IGAkZmlyc3RgICB8IHtAdHlwZSBib29sZWFufSB8IHRydWUgaWYgdGhlIHJlcGVhdGVkIGVsZW1lbnQgaXMgZmlyc3QgaW4gdGhlIGl0ZXJhdG9yLiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqIHwgYCRtaWRkbGVgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgcmVwZWF0ZWQgZWxlbWVudCBpcyBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBpbiB0aGUgaXRlcmF0b3IuIHxcclxuICogfCBgJGxhc3RgICAgfCB7QHR5cGUgYm9vbGVhbn0gfCB0cnVlIGlmIHRoZSByZXBlYXRlZCBlbGVtZW50IGlzIGxhc3QgaW4gdGhlIGl0ZXJhdG9yLiAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8IGAkZXZlbmAgICB8IHtAdHlwZSBib29sZWFufSB8IHRydWUgaWYgdGhlIGl0ZXJhdG9yIHBvc2l0aW9uIGAkaW5kZXhgIGlzIGV2ZW4gKG90aGVyd2lzZSBmYWxzZSkuICAgICAgICAgICB8XHJcbiAqIHwgYCRvZGRgICAgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgaXRlcmF0b3IgcG9zaXRpb24gYCRpbmRleGAgaXMgb2RkIChvdGhlcndpc2UgZmFsc2UpLiAgICAgICAgICAgIHxcclxuICpcclxuICpcclxuICogIyBTcGVjaWFsIHJlcGVhdCBzdGFydCBhbmQgZW5kIHBvaW50c1xyXG4gKiBUbyByZXBlYXQgYSBzZXJpZXMgb2YgZWxlbWVudHMgaW5zdGVhZCBvZiBqdXN0IG9uZSBwYXJlbnQgZWxlbWVudCwgbmdSZXBlYXQgKGFzIHdlbGwgYXMgb3RoZXIgbmcgZGlyZWN0aXZlcykgc3VwcG9ydHMgZXh0ZW5kaW5nXHJcbiAqIHRoZSByYW5nZSBvZiB0aGUgcmVwZWF0ZXIgYnkgZGVmaW5pbmcgZXhwbGljaXQgc3RhcnQgYW5kIGVuZCBwb2ludHMgYnkgdXNpbmcgKipuZy1yZXBlYXQtc3RhcnQqKiBhbmQgKipuZy1yZXBlYXQtZW5kKiogcmVzcGVjdGl2ZWx5LlxyXG4gKiBUaGUgKipuZy1yZXBlYXQtc3RhcnQqKiBkaXJlY3RpdmUgd29ya3MgdGhlIHNhbWUgYXMgKipuZy1yZXBlYXQqKiwgYnV0IHdpbGwgcmVwZWF0IGFsbCB0aGUgSFRNTCBjb2RlIChpbmNsdWRpbmcgdGhlIHRhZyBpdCdzIGRlZmluZWQgb24pXHJcbiAqIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhlIGVuZGluZyBIVE1MIHRhZyB3aGVyZSAqKm5nLXJlcGVhdC1lbmQqKiBpcyBwbGFjZWQuXHJcbiAqXHJcbiAqIFRoZSBleGFtcGxlIGJlbG93IG1ha2VzIHVzZSBvZiB0aGlzIGZlYXR1cmU6XHJcbiAqIDxwcmU+XHJcbiAqICAgPGhlYWRlciBuZy1yZXBlYXQtc3RhcnQ9XCJpdGVtIGluIGl0ZW1zXCI+XHJcbiAqICAgICBIZWFkZXIge3sgaXRlbSB9fVxyXG4gKiAgIDwvaGVhZGVyPlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJib2R5XCI+XHJcbiAqICAgICBCb2R5IHt7IGl0ZW0gfX1cclxuICogICA8L2Rpdj5cclxuICogICA8Zm9vdGVyIG5nLXJlcGVhdC1lbmQ+XHJcbiAqICAgICBGb290ZXIge3sgaXRlbSB9fVxyXG4gKiAgIDwvZm9vdGVyPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogQW5kIHdpdGggYW4gaW5wdXQgb2Yge0B0eXBlIFsnQScsJ0InXX0gZm9yIHRoZSBpdGVtcyB2YXJpYWJsZSBpbiB0aGUgZXhhbXBsZSBhYm92ZSwgdGhlIG91dHB1dCB3aWxsIGV2YWx1YXRlIHRvOlxyXG4gKiA8cHJlPlxyXG4gKiAgIDxoZWFkZXI+XHJcbiAqICAgICBIZWFkZXIgQVxyXG4gKiAgIDwvaGVhZGVyPlxyXG4gKiAgIDxkaXYgY2xhc3M9XCJib2R5XCI+XHJcbiAqICAgICBCb2R5IEFcclxuICogICA8L2Rpdj5cclxuICogICA8Zm9vdGVyPlxyXG4gKiAgICAgRm9vdGVyIEFcclxuICogICA8L2Zvb3Rlcj5cclxuICogICA8aGVhZGVyPlxyXG4gKiAgICAgSGVhZGVyIEJcclxuICogICA8L2hlYWRlcj5cclxuICogICA8ZGl2IGNsYXNzPVwiYm9keVwiPlxyXG4gKiAgICAgQm9keSBCXHJcbiAqICAgPC9kaXY+XHJcbiAqICAgPGZvb3Rlcj5cclxuICogICAgIEZvb3RlciBCXHJcbiAqICAgPC9mb290ZXI+XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBUaGUgY3VzdG9tIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGZvciBuZ1JlcGVhdCBhbHNvIHN1cHBvcnQgYWxsIG90aGVyIEhUTUwgZGlyZWN0aXZlIHN5bnRheCBmbGF2b3JzIHByb3ZpZGVkIGluIEFuZ3VsYXJKUyAoc3VjaFxyXG4gKiBhcyAqKmRhdGEtbmctcmVwZWF0LXN0YXJ0KiosICoqeC1uZy1yZXBlYXQtc3RhcnQqKiBhbmQgKipuZzpyZXBlYXQtc3RhcnQqKikuXHJcbiAqXHJcbiAqIEBhbmltYXRpb25zXHJcbiAqIGVudGVyIC0gd2hlbiBhIG5ldyBpdGVtIGlzIGFkZGVkIHRvIHRoZSBsaXN0IG9yIHdoZW4gYW4gaXRlbSBpcyByZXZlYWxlZCBhZnRlciBhIGZpbHRlclxyXG4gKiBsZWF2ZSAtIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIGxpc3Qgb3Igd2hlbiBhbiBpdGVtIGlzIGZpbHRlcmVkIG91dFxyXG4gKiBtb3ZlIC0gd2hlbiBhbiBhZGphY2VudCBpdGVtIGlzIGZpbHRlcmVkIG91dCBjYXVzaW5nIGEgcmVvcmRlciBvciB3aGVuIHRoZSBpdGVtIGNvbnRlbnRzIGFyZSByZW9yZGVyZWRcclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBzY29wZVxyXG4gKiBAcHJpb3JpdHkgMTAwMFxyXG4gKiBAcGFyYW0ge3JlcGVhdF9leHByZXNzaW9ufSBuZ1JlcGVhdCBUaGUgZXhwcmVzc2lvbiBpbmRpY2F0aW5nIGhvdyB0byBlbnVtZXJhdGUgYSBjb2xsZWN0aW9uLiBUaGVzZVxyXG4gKiAgIGZvcm1hdHMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ6XHJcbiAqXHJcbiAqICAgKiBgdmFyaWFibGUgaW4gZXhwcmVzc2lvbmAgw6LigqzigJwgd2hlcmUgdmFyaWFibGUgaXMgdGhlIHVzZXIgZGVmaW5lZCBsb29wIHZhcmlhYmxlIGFuZCBgZXhwcmVzc2lvbmBcclxuICogICAgIGlzIGEgc2NvcGUgZXhwcmVzc2lvbiBnaXZpbmcgdGhlIGNvbGxlY3Rpb24gdG8gZW51bWVyYXRlLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBhbGJ1bSBpbiBhcnRpc3QuYWxidW1zYC5cclxuICpcclxuICogICAqIGAoa2V5LCB2YWx1ZSkgaW4gZXhwcmVzc2lvbmAgw6LigqzigJwgd2hlcmUgYGtleWAgYW5kIGB2YWx1ZWAgY2FuIGJlIGFueSB1c2VyIGRlZmluZWQgaWRlbnRpZmllcnMsXHJcbiAqICAgICBhbmQgYGV4cHJlc3Npb25gIGlzIHRoZSBzY29wZSBleHByZXNzaW9uIGdpdmluZyB0aGUgY29sbGVjdGlvbiB0byBlbnVtZXJhdGUuXHJcbiAqXHJcbiAqICAgICBGb3IgZXhhbXBsZTogYChuYW1lLCBhZ2UpIGluIHsnYWRhbSc6MTAsICdhbWFsaWUnOjEyfWAuXHJcbiAqXHJcbiAqICAgKiBgdmFyaWFibGUgaW4gZXhwcmVzc2lvbiB0cmFjayBieSB0cmFja2luZ19leHByZXNzaW9uYCDDouKCrOKAnCBZb3UgY2FuIGFsc28gcHJvdmlkZSBhbiBvcHRpb25hbCB0cmFja2luZyBmdW5jdGlvblxyXG4gKiAgICAgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYXNzb2NpYXRlIHRoZSBvYmplY3RzIGluIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIERPTSBlbGVtZW50cy4gSWYgbm8gdHJhY2tpbmcgZnVuY3Rpb25cclxuICogICAgIGlzIHNwZWNpZmllZCB0aGUgbmctcmVwZWF0IGFzc29jaWF0ZXMgZWxlbWVudHMgYnkgaWRlbnRpdHkgaW4gdGhlIGNvbGxlY3Rpb24uIEl0IGlzIGFuIGVycm9yIHRvIGhhdmVcclxuICogICAgIG1vcmUgdGhhbiBvbmUgdHJhY2tpbmcgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0byB0aGUgc2FtZSBrZXkuIChUaGlzIHdvdWxkIG1lYW4gdGhhdCB0d28gZGlzdGluY3Qgb2JqZWN0cyBhcmVcclxuICogICAgIG1hcHBlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudCwgd2hpY2ggaXMgbm90IHBvc3NpYmxlLikgIEZpbHRlcnMgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGV4cHJlc3Npb24sXHJcbiAqICAgICBiZWZvcmUgc3BlY2lmeWluZyBhIHRyYWNraW5nIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqICAgICBGb3IgZXhhbXBsZTogYGl0ZW0gaW4gaXRlbXNgIGlzIGVxdWl2YWxlbnQgdG8gYGl0ZW0gaW4gaXRlbXMgdHJhY2sgYnkgJGlkKGl0ZW0pJy4gVGhpcyBpbXBsaWVzIHRoYXQgdGhlIERPTSBlbGVtZW50c1xyXG4gKiAgICAgd2lsbCBiZSBhc3NvY2lhdGVkIGJ5IGl0ZW0gaWRlbnRpdHkgaW4gdGhlIGFycmF5LlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBpdGVtIGluIGl0ZW1zIHRyYWNrIGJ5ICRpZChpdGVtKWAuIEEgYnVpbHQgaW4gYCRpZCgpYCBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBhc3NpZ24gYSB1bmlxdWVcclxuICogICAgIGAkJGhhc2hLZXlgIHByb3BlcnR5IHRvIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIFRoaXMgcHJvcGVydHkgaXMgdGhlbiB1c2VkIGFzIGEga2V5IHRvIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnRzXHJcbiAqICAgICB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGl0ZW0gaW4gdGhlIGFycmF5IGJ5IGlkZW50aXR5LiBNb3ZpbmcgdGhlIHNhbWUgb2JqZWN0IGluIGFycmF5IHdvdWxkIG1vdmUgdGhlIERPTVxyXG4gKiAgICAgZWxlbWVudCBpbiB0aGUgc2FtZSB3YXkgaWFuIHRoZSBET00uXHJcbiAqXHJcbiAqICAgICBGb3IgZXhhbXBsZTogYGl0ZW0gaW4gaXRlbXMgdHJhY2sgYnkgaXRlbS5pZGAgaXMgYSB0eXBpY2FsIHBhdHRlcm4gd2hlbiB0aGUgaXRlbXMgY29tZSBmcm9tIHRoZSBkYXRhYmFzZS4gSW4gdGhpc1xyXG4gKiAgICAgY2FzZSB0aGUgb2JqZWN0IGlkZW50aXR5IGRvZXMgbm90IG1hdHRlci4gVHdvIG9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudCBhcyBsb25nIGFzIHRoZWlyIGBpZGBcclxuICogICAgIHByb3BlcnR5IGlzIHNhbWUuXHJcbiAqXHJcbiAqICAgICBGb3IgZXhhbXBsZTogYGl0ZW0gaW4gaXRlbXMgfCBmaWx0ZXI6c2VhcmNoVGV4dCB0cmFjayBieSBpdGVtLmlkYCBpcyBhIHBhdHRlcm4gdGhhdCBtaWdodCBiZSB1c2VkIHRvIGFwcGx5IGEgZmlsdGVyXHJcbiAqICAgICB0byBpdGVtcyBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdHJhY2tpbmcgZXhwcmVzc2lvbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogVGhpcyBleGFtcGxlIGluaXRpYWxpemVzIHRoZSBzY29wZSB0byBhIGxpc3Qgb2YgbmFtZXMgYW5kXHJcbiAqIHRoZW4gdXNlcyBgbmdSZXBlYXRgIHRvIGRpc3BsYXkgZXZlcnkgcGVyc29uOlxyXG4gIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XHJcbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICA8ZGl2IG5nLWluaXQ9XCJmcmllbmRzID0gW1xyXG4gICAgICAgIHtuYW1lOidKb2huJywgYWdlOjI1LCBnZW5kZXI6J2JveSd9LFxyXG4gICAgICAgIHtuYW1lOidKZXNzaWUnLCBhZ2U6MzAsIGdlbmRlcjonZ2lybCd9LFxyXG4gICAgICAgIHtuYW1lOidKb2hhbm5hJywgYWdlOjI4LCBnZW5kZXI6J2dpcmwnfSxcclxuICAgICAgICB7bmFtZTonSm95JywgYWdlOjE1LCBnZW5kZXI6J2dpcmwnfSxcclxuICAgICAgICB7bmFtZTonTWFyeScsIGFnZToyOCwgZ2VuZGVyOidnaXJsJ30sXHJcbiAgICAgICAge25hbWU6J1BldGVyJywgYWdlOjk1LCBnZW5kZXI6J2JveSd9LFxyXG4gICAgICAgIHtuYW1lOidTZWJhc3RpYW4nLCBhZ2U6NTAsIGdlbmRlcjonYm95J30sXHJcbiAgICAgICAge25hbWU6J0VyaWthJywgYWdlOjI3LCBnZW5kZXI6J2dpcmwnfSxcclxuICAgICAgICB7bmFtZTonUGF0cmljaycsIGFnZTo0MCwgZ2VuZGVyOidib3knfSxcclxuICAgICAgICB7bmFtZTonU2FtYW50aGEnLCBhZ2U6NjAsIGdlbmRlcjonZ2lybCd9XHJcbiAgICAgIF1cIj5cclxuICAgICAgICBJIGhhdmUge3tmcmllbmRzLmxlbmd0aH19IGZyaWVuZHMuIFRoZXkgYXJlOlxyXG4gICAgICAgIDxpbnB1dCB0eXBlPVwic2VhcmNoXCIgbmctbW9kZWw9XCJxXCIgcGxhY2Vob2xkZXI9XCJmaWx0ZXIgZnJpZW5kcy4uLlwiIC8+XHJcbiAgICAgICAgPHVsIGNsYXNzPVwiZXhhbXBsZS1hbmltYXRlLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgPGxpIGNsYXNzPVwiYW5pbWF0ZS1yZXBlYXRcIiBuZy1yZXBlYXQ9XCJmcmllbmQgaW4gZnJpZW5kcyB8IGZpbHRlcjpxXCI+XHJcbiAgICAgICAgICAgIFt7eyRpbmRleCArIDF9fV0ge3tmcmllbmQubmFtZX19IHdobyBpcyB7e2ZyaWVuZC5hZ2V9fSB5ZWFycyBvbGQuXHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XHJcbiAgICAgIC5leGFtcGxlLWFuaW1hdGUtY29udGFpbmVyIHtcclxuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xyXG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XHJcbiAgICAgICAgbGlzdC1zdHlsZTpub25lO1xyXG4gICAgICAgIG1hcmdpbjowO1xyXG4gICAgICAgIHBhZGRpbmc6MDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmV4YW1wbGUtYW5pbWF0ZS1jb250YWluZXIgPiBsaSB7XHJcbiAgICAgICAgcGFkZGluZzoxMHB4O1xyXG4gICAgICAgIGxpc3Qtc3R5bGU6bm9uZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLWVudGVyLFxyXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctbGVhdmUsXHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1tb3ZlIHtcclxuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIC1tb3otdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgLW8tdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1lbnRlciB7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6MDtcclxuICAgICAgICBvcGFjaXR5OjA7XHJcbiAgICAgICAgcGFkZGluZy10b3A6MDtcclxuICAgICAgICBwYWRkaW5nLWJvdHRvbTowO1xyXG4gICAgICB9XHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjIwcHg7XHJcbiAgICAgICAgb3BhY2l0eToxO1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLWxlYXZlIHtcclxuICAgICAgICBvcGFjaXR5OjE7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6MjBweDtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgIH1cclxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XHJcbiAgICAgICAgb3BhY2l0eTowO1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjA7XHJcbiAgICAgICAgcGFkZGluZy10b3A6MDtcclxuICAgICAgICBwYWRkaW5nLWJvdHRvbTowO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctbW92ZSB7IH1cclxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLW1vdmUubmctbW92ZS1hY3RpdmUgeyB9XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgIGl0KCdzaG91bGQgcmVuZGVyIGluaXRpYWwgZGF0YSBzZXQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgdmFyIHIgPSB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5yZXBlYXRlcigndWwgbGknKTtcclxuICAgICAgICAgZXhwZWN0KHIuY291bnQoKSkudG9CZSgxMCk7XHJcbiAgICAgICAgIGV4cGVjdChyLnJvdygwKSkudG9FcXVhbChbXCIxXCIsXCJKb2huXCIsXCIyNVwiXSk7XHJcbiAgICAgICAgIGV4cGVjdChyLnJvdygxKSkudG9FcXVhbChbXCIyXCIsXCJKZXNzaWVcIixcIjMwXCJdKTtcclxuICAgICAgICAgZXhwZWN0KHIucm93KDkpKS50b0VxdWFsKFtcIjEwXCIsXCJTYW1hbnRoYVwiLFwiNjBcIl0pO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnZnJpZW5kcy5sZW5ndGgnKSkudG9CZShcIjEwXCIpO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgcmVwZWF0ZXIgd2hlbiBmaWx0ZXIgcHJlZGljYXRlIGNoYW5nZXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgdmFyIHIgPSB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5yZXBlYXRlcigndWwgbGknKTtcclxuICAgICAgICAgZXhwZWN0KHIuY291bnQoKSkudG9CZSgxMCk7XHJcblxyXG4gICAgICAgICBpbnB1dCgncScpLmVudGVyKCdtYScpO1xyXG5cclxuICAgICAgICAgZXhwZWN0KHIuY291bnQoKSkudG9CZSgyKTtcclxuICAgICAgICAgZXhwZWN0KHIucm93KDApKS50b0VxdWFsKFtcIjFcIixcIk1hcnlcIixcIjI4XCJdKTtcclxuICAgICAgICAgZXhwZWN0KHIucm93KDEpKS50b0VxdWFsKFtcIjJcIixcIlNhbWFudGhhXCIsXCI2MFwiXSk7XHJcbiAgICAgICB9KTtcclxuICAgICAgPC9maWxlPlxyXG4gICAgPC9leGFtcGxlPlxyXG4gKi9cclxudmFyIG5nUmVwZWF0RGlyZWN0aXZlID0gWyckcGFyc2UnLCAnJGFuaW1hdGUnLCBmdW5jdGlvbigkcGFyc2UsICRhbmltYXRlKSB7XHJcbiAgdmFyIE5HX1JFTU9WRUQgPSAnJCROR19SRU1PVkVEJztcclxuICB2YXIgbmdSZXBlYXRNaW5FcnIgPSBtaW5FcnIoJ25nUmVwZWF0Jyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcclxuICAgIHByaW9yaXR5OiAxMDAwLFxyXG4gICAgdGVybWluYWw6IHRydWUsXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyLCBsaW5rZXIpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRyKXtcclxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9ICRhdHRyLm5nUmVwZWF0O1xyXG4gICAgICAgIHZhciBtYXRjaCA9IGV4cHJlc3Npb24ubWF0Y2goL15cXHMqKC4rKVxccytpblxccysoLio/KVxccyooXFxzK3RyYWNrXFxzK2J5XFxzKyguKylcXHMqKT8kLyksXHJcbiAgICAgICAgICB0cmFja0J5RXhwLCB0cmFja0J5RXhwR2V0dGVyLCB0cmFja0J5SWRGbiwgdHJhY2tCeUlkQXJyYXlGbiwgdHJhY2tCeUlkT2JqRm4sIGxocywgcmhzLCB2YWx1ZUlkZW50aWZpZXIsIGtleUlkZW50aWZpZXIsXHJcbiAgICAgICAgICBoYXNoRm5Mb2NhbHMgPSB7JGlkOiBoYXNoS2V5fTtcclxuXHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgdGhyb3cgbmdSZXBlYXRNaW5FcnIoJ2lleHAnLCBcIkV4cGVjdGVkIGV4cHJlc3Npb24gaW4gZm9ybSBvZiAnX2l0ZW1fIGluIF9jb2xsZWN0aW9uX1sgdHJhY2sgYnkgX2lkX10nIGJ1dCBnb3QgJ3swfScuXCIsXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGhzID0gbWF0Y2hbMV07XHJcbiAgICAgICAgcmhzID0gbWF0Y2hbMl07XHJcbiAgICAgICAgdHJhY2tCeUV4cCA9IG1hdGNoWzRdO1xyXG5cclxuICAgICAgICBpZiAodHJhY2tCeUV4cCkge1xyXG4gICAgICAgICAgdHJhY2tCeUV4cEdldHRlciA9ICRwYXJzZSh0cmFja0J5RXhwKTtcclxuICAgICAgICAgIHRyYWNrQnlJZEZuID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gYXNzaWduIGtleSwgdmFsdWUsIGFuZCAkaW5kZXggdG8gdGhlIGxvY2FscyBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgaW4gaGFzaCBmdW5jdGlvbnNcclxuICAgICAgICAgICAgaWYgKGtleUlkZW50aWZpZXIpIGhhc2hGbkxvY2Fsc1trZXlJZGVudGlmaWVyXSA9IGtleTtcclxuICAgICAgICAgICAgaGFzaEZuTG9jYWxzW3ZhbHVlSWRlbnRpZmllcl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgaGFzaEZuTG9jYWxzLiRpbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhY2tCeUV4cEdldHRlcigkc2NvcGUsIGhhc2hGbkxvY2Fscyk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cmFja0J5SWRBcnJheUZuID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzaEtleSh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0cmFja0J5SWRPYmpGbiA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF0Y2ggPSBsaHMubWF0Y2goL14oPzooW1xcJFxcd10rKXxcXCgoW1xcJFxcd10rKVxccyosXFxzKihbXFwkXFx3XSspXFwpKSQvKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZ1JlcGVhdE1pbkVycignaWlkZXhwJywgXCInX2l0ZW1fJyBpbiAnX2l0ZW1fIGluIF9jb2xsZWN0aW9uXycgc2hvdWxkIGJlIGFuIGlkZW50aWZpZXIgb3IgJyhfa2V5XywgX3ZhbHVlXyknIGV4cHJlc3Npb24sIGJ1dCBnb3QgJ3swfScuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGhzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVJZGVudGlmaWVyID0gbWF0Y2hbM10gfHwgbWF0Y2hbMV07XHJcbiAgICAgICAga2V5SWRlbnRpZmllciA9IG1hdGNoWzJdO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBhIGxpc3Qgb2YgZWxlbWVudHMgZnJvbSBwcmV2aW91cyBydW4uIFRoaXMgaXMgYSBoYXNoIHdoZXJlIGtleSBpcyB0aGUgaXRlbSBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGl0ZXJhdG9yLCBhbmQgdGhlIHZhbHVlIGlzIG9iamVjdHMgd2l0aCBmb2xsb3dpbmcgcHJvcGVydGllcy5cclxuICAgICAgICAvLyAgIC0gc2NvcGU6IGJvdW5kIHNjb3BlXHJcbiAgICAgICAgLy8gICAtIGVsZW1lbnQ6IHByZXZpb3VzIGVsZW1lbnQuXHJcbiAgICAgICAgLy8gICAtIGluZGV4OiBwb3NpdGlvblxyXG4gICAgICAgIHZhciBsYXN0QmxvY2tNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgLy93YXRjaCBwcm9wc1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKHJocywgZnVuY3Rpb24gbmdSZXBlYXRBY3Rpb24oY29sbGVjdGlvbil7XHJcbiAgICAgICAgICB2YXIgaW5kZXgsIGxlbmd0aCxcclxuICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSAkZWxlbWVudFswXSwgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIG5vZGVcclxuICAgICAgICAgICAgICBuZXh0Tm9kZSxcclxuICAgICAgICAgICAgICAvLyBTYW1lIGFzIGxhc3RCbG9ja01hcCBidXQgaXQgaGFzIHRoZSBjdXJyZW50IHN0YXRlLiBJdCB3aWxsIGJlY29tZSB0aGVcclxuICAgICAgICAgICAgICAvLyBsYXN0QmxvY2tNYXAgb24gdGhlIG5leHQgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgIG5leHRCbG9ja01hcCA9IHt9LFxyXG4gICAgICAgICAgICAgIGFycmF5TGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGNoaWxkU2NvcGUsXHJcbiAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgLy8ga2V5L3ZhbHVlIG9mIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgIHRyYWNrQnlJZCxcclxuICAgICAgICAgICAgICBjb2xsZWN0aW9uS2V5cyxcclxuICAgICAgICAgICAgICBibG9jaywgICAgICAgLy8gbGFzdCBvYmplY3QgaW5mb3JtYXRpb24ge3Njb3BlLCBlbGVtZW50LCBpZH1cclxuICAgICAgICAgICAgICBuZXh0QmxvY2tPcmRlciA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcclxuICAgICAgICAgICAgY29sbGVjdGlvbktleXMgPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICB0cmFja0J5SWRGbiA9IHRyYWNrQnlJZEZuIHx8IHRyYWNrQnlJZEFycmF5Rm47XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFja0J5SWRGbiA9IHRyYWNrQnlJZEZuIHx8IHRyYWNrQnlJZE9iakZuO1xyXG4gICAgICAgICAgICAvLyBpZiBvYmplY3QsIGV4dHJhY3Qga2V5cywgc29ydCB0aGVtIGFuZCB1c2UgdG8gZGV0ZXJtaW5lIG9yZGVyIG9mIGl0ZXJhdGlvbiBvdmVyIG9iaiBwcm9wc1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24uaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkuY2hhckF0KDApICE9ICckJykge1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbktleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uS2V5cy5zb3J0KCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYXJyYXlMZW5ndGggPSBjb2xsZWN0aW9uS2V5cy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gbG9jYXRlIGV4aXN0aW5nIGl0ZW1zXHJcbiAgICAgICAgICBsZW5ndGggPSBuZXh0QmxvY2tPcmRlci5sZW5ndGggPSBjb2xsZWN0aW9uS2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgIGtleSA9IChjb2xsZWN0aW9uID09PSBjb2xsZWN0aW9uS2V5cykgPyBpbmRleCA6IGNvbGxlY3Rpb25LZXlzW2luZGV4XTtcclxuICAgICAgICAgICB2YWx1ZSA9IGNvbGxlY3Rpb25ba2V5XTtcclxuICAgICAgICAgICB0cmFja0J5SWQgPSB0cmFja0J5SWRGbihrZXksIHZhbHVlLCBpbmRleCk7XHJcbiAgICAgICAgICAgaWYobGFzdEJsb2NrTWFwLmhhc093blByb3BlcnR5KHRyYWNrQnlJZCkpIHtcclxuICAgICAgICAgICAgIGJsb2NrID0gbGFzdEJsb2NrTWFwW3RyYWNrQnlJZF1cclxuICAgICAgICAgICAgIGRlbGV0ZSBsYXN0QmxvY2tNYXBbdHJhY2tCeUlkXTtcclxuICAgICAgICAgICAgIG5leHRCbG9ja01hcFt0cmFja0J5SWRdID0gYmxvY2s7XHJcbiAgICAgICAgICAgICBuZXh0QmxvY2tPcmRlcltpbmRleF0gPSBibG9jaztcclxuICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRCbG9ja01hcC5oYXNPd25Qcm9wZXJ0eSh0cmFja0J5SWQpKSB7XHJcbiAgICAgICAgICAgICAvLyByZXN0b3JlIGxhc3RCbG9ja01hcFxyXG4gICAgICAgICAgICAgZm9yRWFjaChuZXh0QmxvY2tPcmRlciwgZnVuY3Rpb24oYmxvY2spIHtcclxuICAgICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLnN0YXJ0Tm9kZSkgbGFzdEJsb2NrTWFwW2Jsb2NrLmlkXSA9IGJsb2NrO1xyXG4gICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgZHVwbGljYXRlIGFuZCB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yXHJcbiAgICAgICAgICAgICB0aHJvdyBuZ1JlcGVhdE1pbkVycignZHVwZXMnLCBcIkR1cGxpY2F0ZXMgaW4gYSByZXBlYXRlciBhcmUgbm90IGFsbG93ZWQuIFVzZSAndHJhY2sgYnknIGV4cHJlc3Npb24gdG8gc3BlY2lmeSB1bmlxdWUga2V5cy4gUmVwZWF0ZXI6IHswfSwgRHVwbGljYXRlIGtleTogezF9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLCAgICAgICB0cmFja0J5SWQpO1xyXG4gICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAvLyBuZXcgbmV2ZXIgYmVmb3JlIHNlZW4gYmxvY2tcclxuICAgICAgICAgICAgIG5leHRCbG9ja09yZGVyW2luZGV4XSA9IHsgaWQ6IHRyYWNrQnlJZCB9O1xyXG4gICAgICAgICAgICAgbmV4dEJsb2NrTWFwW3RyYWNrQnlJZF0gPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgaXRlbXNcclxuICAgICAgICAgIGZvciAoa2V5IGluIGxhc3RCbG9ja01hcCkge1xyXG4gICAgICAgICAgICBpZiAobGFzdEJsb2NrTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICBibG9jayA9IGxhc3RCbG9ja01hcFtrZXldO1xyXG4gICAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGJsb2NrLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgICBmb3JFYWNoKGJsb2NrLmVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7IGVsZW1lbnRbTkdfUkVNT1ZFRF0gPSB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgYmxvY2suc2NvcGUuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgZm9yRWFjaCBmb3IgcGVyZiByZWFzb25zICh0cnlpbmcgdG8gYXZvaWQgI2NhbGwpXHJcbiAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gY29sbGVjdGlvbktleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBrZXkgPSAoY29sbGVjdGlvbiA9PT0gY29sbGVjdGlvbktleXMpID8gaW5kZXggOiBjb2xsZWN0aW9uS2V5c1tpbmRleF07XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29sbGVjdGlvbltrZXldO1xyXG4gICAgICAgICAgICBibG9jayA9IG5leHRCbG9ja09yZGVyW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChibG9jay5zdGFydE5vZGUpIHtcclxuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgc2VlbiB0aGlzIG9iamVjdCwgdGhlbiB3ZSBuZWVkIHRvIHJldXNlIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGFzc29jaWF0ZWQgc2NvcGUvZWxlbWVudFxyXG4gICAgICAgICAgICAgIGNoaWxkU2NvcGUgPSBibG9jay5zY29wZTtcclxuXHJcbiAgICAgICAgICAgICAgbmV4dE5vZGUgPSBwcmV2aW91c05vZGU7XHJcbiAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICB9IHdoaWxlKG5leHROb2RlICYmIG5leHROb2RlW05HX1JFTU9WRURdKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGJsb2NrLnN0YXJ0Tm9kZSA9PSBuZXh0Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBpdGVtIHdoaWNoIGdvdCBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGUubW92ZShibG9jay5lbGVtZW50cywgbnVsbCwganFMaXRlKHByZXZpb3VzTm9kZSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSBibG9jay5lbmROb2RlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIG5ldyBpdGVtIHdoaWNoIHdlIGRvbid0IGtub3cgYWJvdXRcclxuICAgICAgICAgICAgICBjaGlsZFNjb3BlID0gJHNjb3BlLiRuZXcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGRTY29wZVt2YWx1ZUlkZW50aWZpZXJdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChrZXlJZGVudGlmaWVyKSBjaGlsZFNjb3BlW2tleUlkZW50aWZpZXJdID0ga2V5O1xyXG4gICAgICAgICAgICBjaGlsZFNjb3BlLiRpbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBjaGlsZFNjb3BlLiRmaXJzdCA9IChpbmRleCA9PT0gMCk7XHJcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJGxhc3QgPSAoaW5kZXggPT09IChhcnJheUxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgY2hpbGRTY29wZS4kbWlkZGxlID0gIShjaGlsZFNjb3BlLiRmaXJzdCB8fCBjaGlsZFNjb3BlLiRsYXN0KTtcclxuICAgICAgICAgICAgY2hpbGRTY29wZS4kb2RkID0gIShjaGlsZFNjb3BlLiRldmVuID0gaW5kZXglMj09MCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJsb2NrLnN0YXJ0Tm9kZSkge1xyXG4gICAgICAgICAgICAgIGxpbmtlcihjaGlsZFNjb3BlLCBmdW5jdGlvbihjbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoY2xvbmUsIG51bGwsIGpxTGl0ZShwcmV2aW91c05vZGUpKTtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IGNsb25lO1xyXG4gICAgICAgICAgICAgICAgYmxvY2suc2NvcGUgPSBjaGlsZFNjb3BlO1xyXG4gICAgICAgICAgICAgICAgYmxvY2suc3RhcnROb2RlID0gY2xvbmVbMF07XHJcbiAgICAgICAgICAgICAgICBibG9jay5lbGVtZW50cyA9IGNsb25lO1xyXG4gICAgICAgICAgICAgICAgYmxvY2suZW5kTm9kZSA9IGNsb25lW2Nsb25lLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgbmV4dEJsb2NrTWFwW2Jsb2NrLmlkXSA9IGJsb2NrO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsYXN0QmxvY2tNYXAgPSBuZXh0QmxvY2tNYXA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTaG93XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nU2hvd2AgZGlyZWN0aXZlIHNob3dzIGFuZCBoaWRlcyB0aGUgZ2l2ZW4gSFRNTCBlbGVtZW50IGNvbmRpdGlvbmFsbHkgYmFzZWQgb24gdGhlIGV4cHJlc3Npb25cclxuICogcHJvdmlkZWQgdG8gdGhlIG5nU2hvdyBhdHRyaWJ1dGUuIFRoZSBzaG93IGFuZCBoaWRlIG1lY2hhbmlzbSBpcyBhIGFjaGlldmVkIGJ5IHJlbW92aW5nIGFuZCBhZGRpbmdcclxuICogdGhlIGBuZy1oaWRlYCBDU1MgY2xhc3Mgb250byB0aGUgZWxlbWVudC4gVGhlIGAubmctaGlkZWAgQ1NTIGNsYXNzIGlzIGEgcHJlZGVmaW5lZCBDU1MgY2xhc3MgcHJlc2VudFxyXG4gKiBpbiBBbmd1bGFySlMgd2hpY2ggc2V0cyB0aGUgZGlzcGxheSBzdHlsZSB0byBub25lICh1c2luZyBhbiAhaW1wb3J0YW50IGZsYWcpLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiA8IS0tIHdoZW4gJHNjb3BlLm15VmFsdWUgaXMgdHJ1dGh5IChlbGVtZW50IGlzIHZpc2libGUpIC0tPlxyXG4gKiA8ZGl2IG5nLXNob3c9XCJteVZhbHVlXCI+PC9kaXY+XHJcbiAqXHJcbiAqIDwhLS0gd2hlbiAkc2NvcGUubXlWYWx1ZSBpcyBmYWxzeSAoZWxlbWVudCBpcyBoaWRkZW4pIC0tPlxyXG4gKiA8ZGl2IG5nLXNob3c9XCJteVZhbHVlXCIgY2xhc3M9XCJuZy1oaWRlXCI+PC9kaXY+XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBXaGVuIHRoZSBuZ1Nob3cgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gZmFsc2UgdGhlbiB0aGUgbmctaGlkZSBDU1MgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIGNsYXNzIGF0dHJpYnV0ZVxyXG4gKiBvbiB0aGUgZWxlbWVudCBjYXVzaW5nIGl0IHRvIGJlY29tZSBoaWRkZW4uIFdoZW4gdHJ1ZSwgdGhlIG5nLWhpZGUgQ1NTIGNsYXNzIGlzIHJlbW92ZWRcclxuICogZnJvbSB0aGUgZWxlbWVudCBjYXVzaW5nIHRoZSBlbGVtZW50IG5vdCB0byBhcHBlYXIgaGlkZGVuLlxyXG4gKlxyXG4gKiAjIyBXaHkgaXMgIWltcG9ydGFudCB1c2VkP1xyXG4gKlxyXG4gKiBZb3UgbWF5IGJlIHdvbmRlcmluZyB3aHkgIWltcG9ydGFudCBpcyB1c2VkIGZvciB0aGUgLm5nLWhpZGUgQ1NTIGNsYXNzLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGAubmctaGlkZWAgc2VsZWN0b3JcclxuICogY2FuIGJlIGVhc2lseSBvdmVycmlkZGVuIGJ5IGhlYXZpZXIgc2VsZWN0b3JzLiBGb3IgZXhhbXBsZSwgc29tZXRoaW5nIGFzIHNpbXBsZVxyXG4gKiBhcyBjaGFuZ2luZyB0aGUgZGlzcGxheSBzdHlsZSBvbiBhIEhUTUwgbGlzdCBpdGVtIHdvdWxkIG1ha2UgaGlkZGVuIGVsZW1lbnRzIGFwcGVhciB2aXNpYmxlLlxyXG4gKiBUaGlzIGFsc28gYmVjb21lcyBhIGJpZ2dlciBpc3N1ZSB3aGVuIGRlYWxpbmcgd2l0aCBDU1MgZnJhbWV3b3Jrcy5cclxuICpcclxuICogQnkgdXNpbmcgIWltcG9ydGFudCwgdGhlIHNob3cgYW5kIGhpZGUgYmVoYXZpb3Igd2lsbCB3b3JrIGFzIGV4cGVjdGVkIGRlc3BpdGUgYW55IGNsYXNoIGJldHdlZW4gQ1NTIHNlbGVjdG9yXHJcbiAqIHNwZWNpZmljaXR5ICh3aGVuICFpbXBvcnRhbnQgaXNuJ3QgdXNlZCB3aXRoIGFueSBjb25mbGljdGluZyBzdHlsZXMpLiBJZiBhIGRldmVsb3BlciBjaG9vc2VzIHRvIG92ZXJyaWRlIHRoZVxyXG4gKiBzdHlsaW5nIHRvIGNoYW5nZSBob3cgdG8gaGlkZSBhbiBlbGVtZW50IHRoZW4gaXQgaXMganVzdCBhIG1hdHRlciBvZiB1c2luZyAhaW1wb3J0YW50IGluIHRoZWlyIG93biBDU1MgY29kZS5cclxuICpcclxuICogIyMjIE92ZXJyaWRpbmcgLm5nLWhpZGVcclxuICpcclxuICogSWYgeW91IHdpc2ggdG8gY2hhbmdlIHRoZSBoaWRlIGJlaGF2aW9yIHdpdGggbmdTaG93L25nSGlkZSB0aGVuIHRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5XHJcbiAqIHJlc3RhdGluZyB0aGUgc3R5bGVzIGZvciB0aGUgLm5nLWhpZGUgY2xhc3MgaW4gQ1NTOlxyXG4gKiA8cHJlPlxyXG4gKiAubmctaGlkZSB7XHJcbiAqICAgLy8hYW5ub3RhdGUgQ1NTIFNwZWNpZmljaXR5fE5vdCB0byB3b3JyeSwgdGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBBbmd1bGFySlMgZGVmYXVsdC4uLlxyXG4gKiAgIGRpc3BsYXk6YmxvY2shaW1wb3J0YW50O1xyXG4gKlxyXG4gKiAgIC8vdGhpcyBpcyBqdXN0IGFub3RoZXIgZm9ybSBvZiBoaWRpbmcgYW4gZWxlbWVudFxyXG4gKiAgIHBvc2l0aW9uOmFic29sdXRlO1xyXG4gKiAgIHRvcDotOTk5OXB4O1xyXG4gKiAgIGxlZnQ6LTk5OTlweDtcclxuICogfVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogSnVzdCByZW1lbWJlciB0byBpbmNsdWRlIHRoZSBpbXBvcnRhbnQgZmxhZyBzbyB0aGUgQ1NTIG92ZXJyaWRlIHdpbGwgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICMjIEEgbm90ZSBhYm91dCBhbmltYXRpb25zIHdpdGggbmdTaG93XHJcbiAqXHJcbiAqIEFuaW1hdGlvbnMgaW4gbmdTaG93L25nSGlkZSB3b3JrIHdpdGggdGhlIHNob3cgYW5kIGhpZGUgZXZlbnRzIHRoYXQgYXJlIHRyaWdnZXJlZCB3aGVuIHRoZSBkaXJlY3RpdmUgZXhwcmVzc2lvblxyXG4gKiBpcyB0cnVlIGFuZCBmYWxzZS4gVGhpcyBzeXN0ZW0gd29ya3Mgc2ltaWxhciB0byB0aGUgYW5pbWF0aW9uIHN5c3RlbSBwcmVzZW50IHdpdGggbmdDbGFzcywgaG93ZXZlciwgdGhlXHJcbiAqIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHlvdSBtdXN0IGFsc28gaW5jbHVkZSB0aGUgIWltcG9ydGFudCBmbGFnIHRvIG92ZXJyaWRlIHRoZSBkaXNwbGF5IHByb3BlcnR5IHNvXHJcbiAqIHRoYXQgeW91IGNhbiBwZXJmb3JtIGFuIGFuaW1hdGlvbiB3aGVuIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBkdXJpbmcgdGhlIHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICpcclxuICogPHByZT5cclxuICogLy9cclxuICogLy9hIHdvcmtpbmcgZXhhbXBsZSBjYW4gYmUgZm91bmQgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIHBhZ2VcclxuICogLy9cclxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQsIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlIHtcclxuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcclxuICogICBkaXNwbGF5OmJsb2NrIWltcG9ydGFudDtcclxuICogfVxyXG4gKlxyXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLWFkZCB7IC4uLiB9XHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtYWRkLm5nLWhpZGUtYWRkLWFjdGl2ZSB7IC4uLiB9XHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlIHsgLi4uIH1cclxuICogLm15LWVsZW1lbnQubmctaGlkZS1yZW1vdmUubmctaGlkZS1yZW1vdmUtYWN0aXZlIHsgLi4uIH1cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEBhbmltYXRpb25zXHJcbiAqIGFkZENsYXNzOiAubmctaGlkZSAtIGhhcHBlbnMgYWZ0ZXIgdGhlIG5nU2hvdyBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZSBhbmQgdGhlIGp1c3QgYmVmb3JlIGNvbnRlbnRzIGFyZSBzZXQgdG8gdmlzaWJsZVxyXG4gKiByZW1vdmVDbGFzczogLm5nLWhpZGUgLSBoYXBwZW5zIGFmdGVyIHRoZSBuZ1Nob3cgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYSBub24gdHJ1dGh5IHZhbHVlIGFuZCBqdXN0IGJlZm9yZSB0aGUgY29udGVudHMgYXJlIHNldCB0byBoaWRkZW5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdTaG93IElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHlcclxuICogICAgIHRoZW4gdGhlIGVsZW1lbnQgaXMgc2hvd24gb3IgaGlkZGVuIHJlc3BlY3RpdmVseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgQ2xpY2sgbWU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIFNob3c6XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNrLWVsZW1lbnQgYW5pbWF0ZS1zaG93XCIgbmctc2hvdz1cImNoZWNrZWRcIj5cclxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10aHVtYnMtdXBcIj48L3NwYW4+IEkgc2hvdyB1cCB3aGVuIHlvdXIgY2hlY2tib3ggaXMgY2hlY2tlZC5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgSGlkZTpcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlY2stZWxlbWVudCBhbmltYXRlLXNob3dcIiBuZy1oaWRlPVwiY2hlY2tlZFwiPlxyXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLXRodW1icy1kb3duXCI+PC9zcGFuPiBJIGhpZGUgd2hlbiB5b3VyIGNoZWNrYm94IGlzIGNoZWNrZWQuXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XHJcbiAgICAgIC5hbmltYXRlLXNob3cubmctaGlkZS1hZGQsIFxyXG4gICAgICAuYW5pbWF0ZS1zaG93Lm5nLWhpZGUtcmVtb3ZlIHtcclxuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIC1tb3otdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgLW8tdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLXNob3cubmctaGlkZS1hZGQubmctaGlkZS1hZGQtYWN0aXZlLFxyXG4gICAgICAuYW5pbWF0ZS1zaG93Lm5nLWhpZGUtcmVtb3ZlIHtcclxuICAgICAgICBsaW5lLWhlaWdodDowO1xyXG4gICAgICAgIG9wYWNpdHk6MDtcclxuICAgICAgICBwYWRkaW5nOjAgMTBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtc2hvdy5uZy1oaWRlLWFkZCxcclxuICAgICAgLmFuaW1hdGUtc2hvdy5uZy1oaWRlLXJlbW92ZS5uZy1oaWRlLXJlbW92ZS1hY3RpdmUge1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjIwcHg7XHJcbiAgICAgICAgb3BhY2l0eToxO1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5jaGVjay1lbGVtZW50IHtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcclxuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xyXG4gICAgICB9XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctc2hvdyAvIG5nLWhpZGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW46Zmlyc3Q6aGlkZGVuJykuY291bnQoKSkudG9FcXVhbCgxKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW46bGFzdDp2aXNpYmxlJykuY291bnQoKSkudG9FcXVhbCgxKTtcclxuXHJcbiAgICAgICAgIGlucHV0KCdjaGVja2VkJykuY2hlY2soKTtcclxuXHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuOmZpcnN0OnZpc2libGUnKS5jb3VudCgpKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbjpsYXN0OmhpZGRlbicpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcbiAgICAgICB9KTtcclxuICAgIDwvZmlsZT5cclxuICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdTaG93RGlyZWN0aXZlID0gWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICBzY29wZS4kd2F0Y2goYXR0ci5uZ1Nob3csIGZ1bmN0aW9uIG5nU2hvd1dhdGNoQWN0aW9uKHZhbHVlKXtcclxuICAgICAgJGFuaW1hdGVbdG9Cb29sZWFuKHZhbHVlKSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnXShlbGVtZW50LCAnbmctaGlkZScpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufV07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSGlkZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0hpZGVgIGRpcmVjdGl2ZSBzaG93cyBhbmQgaGlkZXMgdGhlIGdpdmVuIEhUTUwgZWxlbWVudCBjb25kaXRpb25hbGx5IGJhc2VkIG9uIHRoZSBleHByZXNzaW9uXHJcbiAqIHByb3ZpZGVkIHRvIHRoZSBuZ0hpZGUgYXR0cmlidXRlLiBUaGUgc2hvdyBhbmQgaGlkZSBtZWNoYW5pc20gaXMgYSBhY2hpZXZlZCBieSByZW1vdmluZyBhbmQgYWRkaW5nXHJcbiAqIHRoZSBgbmctaGlkZWAgQ1NTIGNsYXNzIG9udG8gdGhlIGVsZW1lbnQuIFRoZSBgLm5nLWhpZGVgIENTUyBjbGFzcyBpcyBhIHByZWRlZmluZWQgQ1NTIGNsYXNzIHByZXNlbnRcclxuICogaW4gQW5ndWxhckpTIHdoaWNoIHNldHMgdGhlIGRpc3BsYXkgc3R5bGUgdG8gbm9uZSAodXNpbmcgYW4gIWltcG9ydGFudCBmbGFnKS5cclxuICpcclxuICogPHByZT5cclxuICogPCEtLSB3aGVuICRzY29wZS5teVZhbHVlIGlzIHRydXRoeSAoZWxlbWVudCBpcyBoaWRkZW4pIC0tPlxyXG4gKiA8ZGl2IG5nLWhpZGU9XCJteVZhbHVlXCI+PC9kaXY+XHJcbiAqXHJcbiAqIDwhLS0gd2hlbiAkc2NvcGUubXlWYWx1ZSBpcyBmYWxzeSAoZWxlbWVudCBpcyB2aXNpYmxlKSAtLT5cclxuICogPGRpdiBuZy1oaWRlPVwibXlWYWx1ZVwiIGNsYXNzPVwibmctaGlkZVwiPjwvZGl2PlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogV2hlbiB0aGUgbmdIaWRlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUgdGhlbiB0aGUgLm5nLWhpZGUgQ1NTIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBjbGFzcyBhdHRyaWJ1dGVcclxuICogb24gdGhlIGVsZW1lbnQgY2F1c2luZyBpdCB0byBiZWNvbWUgaGlkZGVuLiBXaGVuIGZhbHNlLCB0aGUgbmctaGlkZSBDU1MgY2xhc3MgaXMgcmVtb3ZlZFxyXG4gKiBmcm9tIHRoZSBlbGVtZW50IGNhdXNpbmcgdGhlIGVsZW1lbnQgbm90IHRvIGFwcGVhciBoaWRkZW4uXHJcbiAqXHJcbiAqICMjIFdoeSBpcyAhaW1wb3J0YW50IHVzZWQ/XHJcbiAqXHJcbiAqIFlvdSBtYXkgYmUgd29uZGVyaW5nIHdoeSAhaW1wb3J0YW50IGlzIHVzZWQgZm9yIHRoZSAubmctaGlkZSBDU1MgY2xhc3MuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYC5uZy1oaWRlYCBzZWxlY3RvclxyXG4gKiBjYW4gYmUgZWFzaWx5IG92ZXJyaWRkZW4gYnkgaGVhdmllciBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCBzb21ldGhpbmcgYXMgc2ltcGxlXHJcbiAqIGFzIGNoYW5naW5nIHRoZSBkaXNwbGF5IHN0eWxlIG9uIGEgSFRNTCBsaXN0IGl0ZW0gd291bGQgbWFrZSBoaWRkZW4gZWxlbWVudHMgYXBwZWFyIHZpc2libGUuXHJcbiAqIFRoaXMgYWxzbyBiZWNvbWVzIGEgYmlnZ2VyIGlzc3VlIHdoZW4gZGVhbGluZyB3aXRoIENTUyBmcmFtZXdvcmtzLlxyXG4gKlxyXG4gKiBCeSB1c2luZyAhaW1wb3J0YW50LCB0aGUgc2hvdyBhbmQgaGlkZSBiZWhhdmlvciB3aWxsIHdvcmsgYXMgZXhwZWN0ZWQgZGVzcGl0ZSBhbnkgY2xhc2ggYmV0d2VlbiBDU1Mgc2VsZWN0b3JcclxuICogc3BlY2lmaWNpdHkgKHdoZW4gIWltcG9ydGFudCBpc24ndCB1c2VkIHdpdGggYW55IGNvbmZsaWN0aW5nIHN0eWxlcykuIElmIGEgZGV2ZWxvcGVyIGNob29zZXMgdG8gb3ZlcnJpZGUgdGhlXHJcbiAqIHN0eWxpbmcgdG8gY2hhbmdlIGhvdyB0byBoaWRlIGFuIGVsZW1lbnQgdGhlbiBpdCBpcyBqdXN0IGEgbWF0dGVyIG9mIHVzaW5nICFpbXBvcnRhbnQgaW4gdGhlaXIgb3duIENTUyBjb2RlLlxyXG4gKlxyXG4gKiAjIyMgT3ZlcnJpZGluZyAubmctaGlkZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2lzaCB0byBjaGFuZ2UgdGhlIGhpZGUgYmVoYXZpb3Igd2l0aCBuZ1Nob3cvbmdIaWRlIHRoZW4gdGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcclxuICogcmVzdGF0aW5nIHRoZSBzdHlsZXMgZm9yIHRoZSAubmctaGlkZSBjbGFzcyBpbiBDU1M6XHJcbiAqIDxwcmU+XHJcbiAqIC5uZy1oaWRlIHtcclxuICogICAvLyFhbm5vdGF0ZSBDU1MgU3BlY2lmaWNpdHl8Tm90IHRvIHdvcnJ5LCB0aGlzIHdpbGwgb3ZlcnJpZGUgdGhlIEFuZ3VsYXJKUyBkZWZhdWx0Li4uXHJcbiAqICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XHJcbiAqXHJcbiAqICAgLy90aGlzIGlzIGp1c3QgYW5vdGhlciBmb3JtIG9mIGhpZGluZyBhbiBlbGVtZW50XHJcbiAqICAgcG9zaXRpb246YWJzb2x1dGU7XHJcbiAqICAgdG9wOi05OTk5cHg7XHJcbiAqICAgbGVmdDotOTk5OXB4O1xyXG4gKiB9XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBKdXN0IHJlbWVtYmVyIHRvIGluY2x1ZGUgdGhlIGltcG9ydGFudCBmbGFnIHNvIHRoZSBDU1Mgb3ZlcnJpZGUgd2lsbCBmdW5jdGlvbi5cclxuICpcclxuICogIyMgQSBub3RlIGFib3V0IGFuaW1hdGlvbnMgd2l0aCBuZ0hpZGVcclxuICpcclxuICogQW5pbWF0aW9ucyBpbiBuZ1Nob3cvbmdIaWRlIHdvcmsgd2l0aCB0aGUgc2hvdyBhbmQgaGlkZSBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGRpcmVjdGl2ZSBleHByZXNzaW9uXHJcbiAqIGlzIHRydWUgYW5kIGZhbHNlLiBUaGlzIHN5c3RlbSB3b3JrcyBzaW1pbGFyIHRvIHRoZSBhbmltYXRpb24gc3lzdGVtIHByZXNlbnQgd2l0aCBuZ0NsYXNzLCBob3dldmVyLCB0aGVcclxuICogb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgeW91IG11c3QgYWxzbyBpbmNsdWRlIHRoZSAhaW1wb3J0YW50IGZsYWcgdG8gb3ZlcnJpZGUgdGhlIGRpc3BsYXkgcHJvcGVydHkgc29cclxuICogdGhhdCB5b3UgY2FuIHBlcmZvcm0gYW4gYW5pbWF0aW9uIHdoZW4gdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGR1cmluZyB0aGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAvL1xyXG4gKiAvL2Egd29ya2luZyBleGFtcGxlIGNhbiBiZSBmb3VuZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgcGFnZVxyXG4gKiAvL1xyXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLWFkZCwgLm15LWVsZW1lbnQubmctaGlkZS1yZW1vdmUge1xyXG4gKiAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xyXG4gKiAgIGRpc3BsYXk6YmxvY2shaW1wb3J0YW50O1xyXG4gKiB9XHJcbiAqXHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtYWRkIHsgLi4uIH1cclxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQubmctaGlkZS1hZGQtYWN0aXZlIHsgLi4uIH1cclxuICogLm15LWVsZW1lbnQubmctaGlkZS1yZW1vdmUgeyAuLi4gfVxyXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLXJlbW92ZS5uZy1oaWRlLXJlbW92ZS1hY3RpdmUgeyAuLi4gfVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogQGFuaW1hdGlvbnNcclxuICogcmVtb3ZlQ2xhc3M6IC5uZy1oaWRlIC0gaGFwcGVucyBhZnRlciB0aGUgbmdIaWRlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlIGFuZCBqdXN0IGJlZm9yZSB0aGUgY29udGVudHMgYXJlIHNldCB0byBoaWRkZW5cclxuICogYWRkQ2xhc3M6IC5uZy1oaWRlIC0gaGFwcGVucyBhZnRlciB0aGUgbmdIaWRlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgbm9uIHRydXRoeSB2YWx1ZSBhbmQganVzdCBiZWZvcmUgdGhlIGNvbnRlbnRzIGFyZSBzZXQgdG8gdmlzaWJsZVxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0hpZGUgSWYgdGhlIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGlzIHRydXRoeSB0aGVuXHJcbiAqICAgICB0aGUgZWxlbWVudCBpcyBzaG93biBvciBoaWRkZW4gcmVzcGVjdGl2ZWx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XHJcbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICBDbGljayBtZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiY2hlY2tlZFwiPjxici8+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgU2hvdzpcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlY2stZWxlbWVudCBhbmltYXRlLWhpZGVcIiBuZy1zaG93PVwiY2hlY2tlZFwiPlxyXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLXRodW1icy11cFwiPjwvc3Bhbj4gSSBzaG93IHVwIHdoZW4geW91ciBjaGVja2JveCBpcyBjaGVja2VkLlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdj5cclxuICAgICAgICBIaWRlOlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaGVjay1lbGVtZW50IGFuaW1hdGUtaGlkZVwiIG5nLWhpZGU9XCJjaGVja2VkXCI+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tdGh1bWJzLWRvd25cIj48L3NwYW4+IEkgaGlkZSB3aGVuIHlvdXIgY2hlY2tib3ggaXMgY2hlY2tlZC5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cclxuICAgICAgLmFuaW1hdGUtaGlkZS5uZy1oaWRlLWFkZCwgXHJcbiAgICAgIC5hbmltYXRlLWhpZGUubmctaGlkZS1yZW1vdmUge1xyXG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgLW1vei10cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcclxuICAgICAgICAtby10cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcclxuICAgICAgICB0cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcclxuICAgICAgICBkaXNwbGF5OmJsb2NrIWltcG9ydGFudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtaGlkZS5uZy1oaWRlLWFkZC5uZy1oaWRlLWFkZC1hY3RpdmUsXHJcbiAgICAgIC5hbmltYXRlLWhpZGUubmctaGlkZS1yZW1vdmUge1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjA7XHJcbiAgICAgICAgb3BhY2l0eTowO1xyXG4gICAgICAgIHBhZGRpbmc6MCAxMHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1oaWRlLm5nLWhpZGUtYWRkLFxyXG4gICAgICAuYW5pbWF0ZS1oaWRlLm5nLWhpZGUtcmVtb3ZlLm5nLWhpZGUtcmVtb3ZlLWFjdGl2ZSB7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6MjBweDtcclxuICAgICAgICBvcGFjaXR5OjE7XHJcbiAgICAgICAgcGFkZGluZzoxMHB4O1xyXG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XHJcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmNoZWNrLWVsZW1lbnQge1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XHJcbiAgICAgIH1cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1zaG93IC8gbmctaGlkZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgLmNoZWNrLWVsZW1lbnQ6Zmlyc3Q6aGlkZGVuJykuY291bnQoKSkudG9FcXVhbCgxKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIC5jaGVjay1lbGVtZW50Omxhc3Q6dmlzaWJsZScpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcblxyXG4gICAgICAgICBpbnB1dCgnY2hlY2tlZCcpLmNoZWNrKCk7XHJcblxyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgLmNoZWNrLWVsZW1lbnQ6Zmlyc3Q6dmlzaWJsZScpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAuY2hlY2stZWxlbWVudDpsYXN0OmhpZGRlbicpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcbiAgICAgICB9KTtcclxuICAgIDwvZmlsZT5cclxuICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdIaWRlRGlyZWN0aXZlID0gWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICBzY29wZS4kd2F0Y2goYXR0ci5uZ0hpZGUsIGZ1bmN0aW9uIG5nSGlkZVdhdGNoQWN0aW9uKHZhbHVlKXtcclxuICAgICAgJGFuaW1hdGVbdG9Cb29sZWFuKHZhbHVlKSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShlbGVtZW50LCAnbmctaGlkZScpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTdHlsZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ1N0eWxlYCBkaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBzZXQgQ1NTIHN0eWxlIG9uIGFuIEhUTUwgZWxlbWVudCBjb25kaXRpb25hbGx5LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ1N0eWxlIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHdoaWNoIGV2YWxzIHRvIGFuXHJcbiAqICAgICAgb2JqZWN0IHdob3NlIGtleXMgYXJlIENTUyBzdHlsZSBuYW1lcyBhbmQgdmFsdWVzIGFyZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBmb3IgdGhvc2UgQ1NTXHJcbiAqICAgICAga2V5cy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGV4YW1wbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwic2V0XCIgbmctY2xpY2s9XCJteVN0eWxlPXtjb2xvcjoncmVkJ31cIj5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiY2xlYXJcIiBuZy1jbGljaz1cIm15U3R5bGU9e31cIj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgICAgIDxzcGFuIG5nLXN0eWxlPVwibXlTdHlsZVwiPlNhbXBsZSBUZXh0PC9zcGFuPlxyXG4gICAgICAgIDxwcmU+bXlTdHlsZT17e215U3R5bGV9fTwvcHJlPlxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic3R5bGUuY3NzXCI+XHJcbiAgICAgICBzcGFuIHtcclxuICAgICAgICAgY29sb3I6IGJsYWNrO1xyXG4gICAgICAgfVxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctc3R5bGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW4nKS5jc3MoJ2NvbG9yJykpLnRvQmUoJ3JnYigwLCAwLCAwKScpO1xyXG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6YnV0dG9uW3ZhbHVlPXNldF0nKS5jbGljaygpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbicpLmNzcygnY29sb3InKSkudG9CZSgncmdiKDI1NSwgMCwgMCknKTtcclxuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgOmJ1dHRvblt2YWx1ZT1jbGVhcl0nKS5jbGljaygpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbicpLmNzcygnY29sb3InKSkudG9CZSgncmdiKDAsIDAsIDApJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2ZpbGU+XHJcbiAgIDwvZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ1N0eWxlRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICBzY29wZS4kd2F0Y2goYXR0ci5uZ1N0eWxlLCBmdW5jdGlvbiBuZ1N0eWxlV2F0Y2hBY3Rpb24obmV3U3R5bGVzLCBvbGRTdHlsZXMpIHtcclxuICAgIGlmIChvbGRTdHlsZXMgJiYgKG5ld1N0eWxlcyAhPT0gb2xkU3R5bGVzKSkge1xyXG4gICAgICBmb3JFYWNoKG9sZFN0eWxlcywgZnVuY3Rpb24odmFsLCBzdHlsZSkgeyBlbGVtZW50LmNzcyhzdHlsZSwgJycpO30pO1xyXG4gICAgfVxyXG4gICAgaWYgKG5ld1N0eWxlcykgZWxlbWVudC5jc3MobmV3U3R5bGVzKTtcclxuICB9LCB0cnVlKTtcclxufSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTd2l0Y2hcclxuICogQHJlc3RyaWN0IEVBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgbmdTd2l0Y2ggZGlyZWN0aXZlIGlzIHVzZWQgdG8gY29uZGl0aW9uYWxseSBzd2FwIERPTSBzdHJ1Y3R1cmUgb24geW91ciB0ZW1wbGF0ZSBiYXNlZCBvbiBhIHNjb3BlIGV4cHJlc3Npb24uXHJcbiAqIEVsZW1lbnRzIHdpdGhpbiBuZ1N3aXRjaCBidXQgd2l0aG91dCBuZ1N3aXRjaFdoZW4gb3IgbmdTd2l0Y2hEZWZhdWx0IGRpcmVjdGl2ZXMgd2lsbCBiZSBwcmVzZXJ2ZWQgYXQgdGhlIGxvY2F0aW9uXHJcbiAqIGFzIHNwZWNpZmllZCBpbiB0aGUgdGVtcGxhdGUuXHJcbiAqXHJcbiAqIFRoZSBkaXJlY3RpdmUgaXRzZWxmIHdvcmtzIHNpbWlsYXIgdG8gbmdJbmNsdWRlLCBob3dldmVyLCBpbnN0ZWFkIG9mIGRvd25sb2FkaW5nIHRlbXBsYXRlIGNvZGUgKG9yIGxvYWRpbmcgaXRcclxuICogZnJvbSB0aGUgdGVtcGxhdGUgY2FjaGUpLCBuZ1N3aXRjaCBzaW1wbHkgY2hvc2VzIG9uZSBvZiB0aGUgbmVzdGVkIGVsZW1lbnRzIGFuZCBtYWtlcyBpdCB2aXNpYmxlIGJhc2VkIG9uIHdoaWNoIGVsZW1lbnRcclxuICogbWF0Y2hlcyB0aGUgdmFsdWUgb2J0YWluZWQgZnJvbSB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uIEluIG90aGVyIHdvcmRzLCB5b3UgZGVmaW5lIGEgY29udGFpbmVyIGVsZW1lbnRcclxuICogKHdoZXJlIHlvdSBwbGFjZSB0aGUgZGlyZWN0aXZlKSwgcGxhY2UgYW4gZXhwcmVzc2lvbiBvbiB0aGUgKipvbj1cIi4uLlwiIGF0dHJpYnV0ZSoqXHJcbiAqIChvciB0aGUgKipuZy1zd2l0Y2g9XCIuLi5cIiBhdHRyaWJ1dGUqKiksIGRlZmluZSBhbnkgaW5uZXIgZWxlbWVudHMgaW5zaWRlIG9mIHRoZSBkaXJlY3RpdmUgYW5kIHBsYWNlXHJcbiAqIGEgd2hlbiBhdHRyaWJ1dGUgcGVyIGVsZW1lbnQuIFRoZSB3aGVuIGF0dHJpYnV0ZSBpcyB1c2VkIHRvIGluZm9ybSBuZ1N3aXRjaCB3aGljaCBlbGVtZW50IHRvIGRpc3BsYXkgd2hlbiB0aGUgb25cclxuICogZXhwcmVzc2lvbiBpcyBldmFsdWF0ZWQuIElmIGEgbWF0Y2hpbmcgZXhwcmVzc2lvbiBpcyBub3QgZm91bmQgdmlhIGEgd2hlbiBhdHRyaWJ1dGUgdGhlbiBhbiBlbGVtZW50IHdpdGggdGhlIGRlZmF1bHRcclxuICogYXR0cmlidXRlIGlzIGRpc3BsYXllZC5cclxuICpcclxuICogQGFuaW1hdGlvbnNcclxuICogZW50ZXIgLSBoYXBwZW5zIGFmdGVyIHRoZSBuZ1N3dGljaCBjb250ZW50cyBjaGFuZ2UgYW5kIHRoZSBtYXRjaGVkIGNoaWxkIGVsZW1lbnQgaXMgcGxhY2VkIGluc2lkZSB0aGUgY29udGFpbmVyXHJcbiAqIGxlYXZlIC0gaGFwcGVucyBqdXN0IGFmdGVyIHRoZSBuZ1N3aXRjaCBjb250ZW50cyBjaGFuZ2UgYW5kIGp1c3QgYmVmb3JlIHRoZSBmb3JtZXIgY29udGVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXHJcbiAqXHJcbiAqIEB1c2FnZVxyXG4gKiA8QU5ZIG5nLXN3aXRjaD1cImV4cHJlc3Npb25cIj5cclxuICogICA8QU5ZIG5nLXN3aXRjaC13aGVuPVwibWF0Y2hWYWx1ZTFcIj4uLi48L0FOWT5cclxuICogICA8QU5ZIG5nLXN3aXRjaC13aGVuPVwibWF0Y2hWYWx1ZTJcIj4uLi48L0FOWT5cclxuICogICA8QU5ZIG5nLXN3aXRjaC1kZWZhdWx0Pi4uLjwvQU5ZPlxyXG4gKiA8L0FOWT5cclxuICpcclxuICogQHNjb3BlXHJcbiAqIEBwYXJhbSB7Kn0gbmdTd2l0Y2h8b24gZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0IDx0dD5uZy1zd2l0Y2gtd2hlbjwvdHQ+LlxyXG4gKiBAcGFyYW1EZXNjcmlwdGlvblxyXG4gKiBPbiBjaGlsZCBlbGVtZW50cyBhZGQ6XHJcbiAqXHJcbiAqICogYG5nU3dpdGNoV2hlbmA6IHRoZSBjYXNlIHN0YXRlbWVudCB0byBtYXRjaCBhZ2FpbnN0LiBJZiBtYXRjaCB0aGVuIHRoaXNcclxuICogICBjYXNlIHdpbGwgYmUgZGlzcGxheWVkLiBJZiB0aGUgc2FtZSBtYXRjaCBhcHBlYXJzIG11bHRpcGxlIHRpbWVzLCBhbGwgdGhlXHJcbiAqICAgZWxlbWVudHMgd2lsbCBiZSBkaXNwbGF5ZWQuXHJcbiAqICogYG5nU3dpdGNoRGVmYXVsdGA6IHRoZSBkZWZhdWx0IGNhc2Ugd2hlbiBubyBvdGhlciBjYXNlIG1hdGNoLiBJZiB0aGVyZVxyXG4gKiAgIGFyZSBtdWx0aXBsZSBkZWZhdWx0IGNhc2VzLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIG5vIG90aGVyXHJcbiAqICAgY2FzZSBtYXRjaC5cclxuICpcclxuICpcclxuICogQGV4YW1wbGVcclxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJzZWxlY3Rpb25cIiBuZy1vcHRpb25zPVwiaXRlbSBmb3IgaXRlbSBpbiBpdGVtc1wiPlxyXG4gICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgIDx0dD5zZWxlY3Rpb249e3tzZWxlY3Rpb259fTwvdHQ+XHJcbiAgICAgICAgPGhyLz5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyXCJcclxuICAgICAgICAgIG5nLXN3aXRjaCBvbj1cInNlbGVjdGlvblwiPlxyXG4gICAgICAgICAgICA8ZGl2IG5nLXN3aXRjaC13aGVuPVwic2V0dGluZ3NcIj5TZXR0aW5ncyBEaXY8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBuZy1zd2l0Y2gtd2hlbj1cImhvbWVcIj5Ib21lIFNwYW48L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBuZy1zd2l0Y2gtZGVmYXVsdD5kZWZhdWx0PC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxyXG4gICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICRzY29wZS5pdGVtcyA9IFsnc2V0dGluZ3MnLCAnaG9tZScsICdvdGhlciddO1xyXG4gICAgICAgICRzY29wZS5zZWxlY3Rpb24gPSAkc2NvcGUuaXRlbXNbMF07XHJcbiAgICAgIH1cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyIHtcclxuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcclxuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xyXG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XHJcbiAgICAgICAgaGVpZ2h0OjQwcHg7XHJcbiAgICAgICAgb3ZlcmZsb3c6aGlkZGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyID4gZGl2IHtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLXN3aXRjaC1jb250YWluZXIgPiAubmctZW50ZXIsXHJcbiAgICAgIC5hbmltYXRlLXN3aXRjaC1jb250YWluZXIgPiAubmctbGVhdmUge1xyXG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgIC1tb3otdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgIC1vLXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICB0cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcblxyXG4gICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xyXG4gICAgICAgIHRvcDowO1xyXG4gICAgICAgIGxlZnQ6MDtcclxuICAgICAgICByaWdodDowO1xyXG4gICAgICAgIGJvdHRvbTowO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyID4gLm5nLWVudGVyIHtcclxuICAgICAgICB0b3A6LTUwcHg7XHJcbiAgICAgIH1cclxuICAgICAgLmFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lciA+IC5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xyXG4gICAgICAgIHRvcDowO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyID4gLm5nLWxlYXZlIHtcclxuICAgICAgICB0b3A6MDtcclxuICAgICAgfVxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyID4gLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XHJcbiAgICAgICAgdG9wOjUwcHg7XHJcbiAgICAgIH1cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICBpdCgnc2hvdWxkIHN0YXJ0IGluIHNldHRpbmdzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIFtuZy1zd2l0Y2hdJykudGV4dCgpKS50b01hdGNoKC9TZXR0aW5ncyBEaXYvKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGl0KCdzaG91bGQgY2hhbmdlIHRvIGhvbWUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBzZWxlY3QoJ3NlbGVjdGlvbicpLm9wdGlvbignaG9tZScpO1xyXG4gICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctc3dpdGNoXScpLnRleHQoKSkudG9NYXRjaCgvSG9tZSBTcGFuLyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpdCgnc2hvdWxkIHNlbGVjdCBkZWZhdWx0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZWN0KCdzZWxlY3Rpb24nKS5vcHRpb24oJ290aGVyJyk7XHJcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIFtuZy1zd2l0Y2hdJykudGV4dCgpKS50b01hdGNoKC9kZWZhdWx0Lyk7XHJcbiAgICAgIH0pO1xyXG4gICAgPC9maWxlPlxyXG4gIDwvZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ1N3aXRjaERpcmVjdGl2ZSA9IFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHJlcXVpcmU6ICduZ1N3aXRjaCcsXHJcblxyXG4gICAgLy8gYXNrcyBmb3IgJHNjb3BlIHRvIGZvb2wgdGhlIEJDIGNvbnRyb2xsZXIgbW9kdWxlXHJcbiAgICBjb250cm9sbGVyOiBbJyRzY29wZScsIGZ1bmN0aW9uIG5nU3dpdGNoQ29udHJvbGxlcigpIHtcclxuICAgICB0aGlzLmNhc2VzID0ge307XHJcbiAgICB9XSxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBuZ1N3aXRjaENvbnRyb2xsZXIpIHtcclxuICAgICAgdmFyIHdhdGNoRXhwciA9IGF0dHIubmdTd2l0Y2ggfHwgYXR0ci5vbixcclxuICAgICAgICAgIHNlbGVjdGVkVHJhbnNjbHVkZXMsXHJcbiAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRzLFxyXG4gICAgICAgICAgc2VsZWN0ZWRTY29wZXMgPSBbXTtcclxuXHJcbiAgICAgIHNjb3BlLiR3YXRjaCh3YXRjaEV4cHIsIGZ1bmN0aW9uIG5nU3dpdGNoV2F0Y2hBY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBmb3IgKHZhciBpPSAwLCBpaT1zZWxlY3RlZFNjb3Blcy5sZW5ndGg7IGk8aWk7IGkrKykge1xyXG4gICAgICAgICAgc2VsZWN0ZWRTY29wZXNbaV0uJGRlc3Ryb3koKTtcclxuICAgICAgICAgICRhbmltYXRlLmxlYXZlKHNlbGVjdGVkRWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsZWN0ZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgICAgIHNlbGVjdGVkU2NvcGVzID0gW107XHJcblxyXG4gICAgICAgIGlmICgoc2VsZWN0ZWRUcmFuc2NsdWRlcyA9IG5nU3dpdGNoQ29udHJvbGxlci5jYXNlc1snIScgKyB2YWx1ZV0gfHwgbmdTd2l0Y2hDb250cm9sbGVyLmNhc2VzWyc/J10pKSB7XHJcbiAgICAgICAgICBzY29wZS4kZXZhbChhdHRyLmNoYW5nZSk7XHJcbiAgICAgICAgICBmb3JFYWNoKHNlbGVjdGVkVHJhbnNjbHVkZXMsIGZ1bmN0aW9uKHNlbGVjdGVkVHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRTY29wZSA9IHNjb3BlLiRuZXcoKTtcclxuICAgICAgICAgICAgc2VsZWN0ZWRTY29wZXMucHVzaChzZWxlY3RlZFNjb3BlKTtcclxuICAgICAgICAgICAgc2VsZWN0ZWRUcmFuc2NsdWRlLnRyYW5zY2x1ZGUoc2VsZWN0ZWRTY29wZSwgZnVuY3Rpb24oY2FzZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gc2VsZWN0ZWRUcmFuc2NsdWRlLmVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudHMucHVzaChjYXNlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoY2FzZUVsZW1lbnQsIGFuY2hvci5wYXJlbnQoKSwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufV07XHJcblxyXG52YXIgbmdTd2l0Y2hXaGVuRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xyXG4gIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcclxuICBwcmlvcml0eTogNTAwLFxyXG4gIHJlcXVpcmU6ICdebmdTd2l0Y2gnLFxyXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzLCB0cmFuc2NsdWRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICAgICAgY3RybC5jYXNlc1snIScgKyBhdHRycy5uZ1N3aXRjaFdoZW5dID0gKGN0cmwuY2FzZXNbJyEnICsgYXR0cnMubmdTd2l0Y2hXaGVuXSB8fCBbXSk7XHJcbiAgICAgIGN0cmwuY2FzZXNbJyEnICsgYXR0cnMubmdTd2l0Y2hXaGVuXS5wdXNoKHsgdHJhbnNjbHVkZTogdHJhbnNjbHVkZSwgZWxlbWVudDogZWxlbWVudCB9KTtcclxuICAgIH07XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBuZ1N3aXRjaERlZmF1bHREaXJlY3RpdmUgPSBuZ0RpcmVjdGl2ZSh7XHJcbiAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxyXG4gIHByaW9yaXR5OiA1MDAsXHJcbiAgcmVxdWlyZTogJ15uZ1N3aXRjaCcsXHJcbiAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMsIHRyYW5zY2x1ZGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCkge1xyXG4gICAgICBjdHJsLmNhc2VzWyc/J10gPSAoY3RybC5jYXNlc1snPyddIHx8IFtdKTtcclxuICAgICAgY3RybC5jYXNlc1snPyddLnB1c2goeyB0cmFuc2NsdWRlOiB0cmFuc2NsdWRlLCBlbGVtZW50OiBlbGVtZW50IH0pO1xyXG4gICAgfTtcclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nVHJhbnNjbHVkZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGlyZWN0aXZlIHRoYXQgbWFya3MgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIHRyYW5zY2x1ZGVkIERPTSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgZGlyZWN0aXZlIHRoYXQgdXNlcyB0cmFuc2NsdXNpb24uXHJcbiAqXHJcbiAqIEFueSBleGlzdGluZyBjb250ZW50IG9mIHRoZSBlbGVtZW50IHRoYXQgdGhpcyBkaXJlY3RpdmUgaXMgcGxhY2VkIG9uIHdpbGwgYmUgcmVtb3ZlZCBiZWZvcmUgdGhlIHRyYW5zY2x1ZGVkIGNvbnRlbnQgaXMgaW5zZXJ0ZWQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGUgbW9kdWxlPVwidHJhbnNjbHVkZVwiPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUudGl0bGUgPSAnTG9yZW0gSXBzdW0nO1xyXG4gICAgICAgICAgICRzY29wZS50ZXh0ID0gJ05lcXVlIHBvcnJvIHF1aXNxdWFtIGVzdCBxdWkgZG9sb3JlbSBpcHN1bSBxdWlhIGRvbG9yLi4uJztcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ3RyYW5zY2x1ZGUnLCBbXSlcclxuICAgICAgICAgIC5kaXJlY3RpdmUoJ3BhbmUnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgc2NvcGU6IHsgdGl0bGU6J0AnIH0sXHJcbiAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiBzdHlsZT1cImJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IGdyYXlcIj57e3RpdGxlfX08L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXHJcbiAgICAgICAgICAgICB9O1xyXG4gICAgICAgICB9KTtcclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICA8aW5wdXQgbmctbW9kZWw9XCJ0aXRsZVwiPjxicj5cclxuICAgICAgICAgPHRleHRhcmVhIG5nLW1vZGVsPVwidGV4dFwiPjwvdGV4dGFyZWE+IDxici8+XHJcbiAgICAgICAgIDxwYW5lIHRpdGxlPVwie3t0aXRsZX19XCI+e3t0ZXh0fX08L3BhbmU+XHJcbiAgICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIGhhdmUgdHJhbnNjbHVkZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlucHV0KCd0aXRsZScpLmVudGVyKCdUSVRMRScpO1xyXG4gICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcignVEVYVCcpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RpdGxlJykpLnRvRXF1YWwoJ1RJVExFJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCdURVhUJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqL1xyXG52YXIgbmdUcmFuc2NsdWRlRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xyXG4gIGNvbnRyb2xsZXI6IFsnJHRyYW5zY2x1ZGUnLCBmdW5jdGlvbigkdHJhbnNjbHVkZSkge1xyXG4gICAgLy8gcmVtZW1iZXIgdGhlIHRyYW5zY2x1c2lvbiBmbiBidXQgY2FsbCBpdCBkdXJpbmcgbGlua2luZyBzbyB0aGF0IHdlIGRvbid0IHByb2Nlc3MgdHJhbnNjbHVzaW9uIGJlZm9yZSBkaXJlY3RpdmVzIG9uXHJcbiAgICAvLyB0aGUgcGFyZW50IGVsZW1lbnQgZXZlbiB3aGVuIHRoZSB0cmFuc2NsdXNpb24gcmVwbGFjZXMgdGhlIGN1cnJlbnQgZWxlbWVudC4gKHdlIGNhbid0IHVzZSBwcmlvcml0eSBoZXJlIGJlY2F1c2VcclxuICAgIC8vIHRoYXQgYXBwbGllcyBvbmx5IHRvIGNvbXBpbGUgZm5zIGFuZCBub3QgY29udHJvbGxlcnNcclxuICAgIHRoaXMuJHRyYW5zY2x1ZGUgPSAkdHJhbnNjbHVkZTtcclxuICB9XSxcclxuXHJcbiAgbGluazogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCBjb250cm9sbGVyKSB7XHJcbiAgICBjb250cm9sbGVyLiR0cmFuc2NsdWRlKGZ1bmN0aW9uKGNsb25lKSB7XHJcbiAgICAgICRlbGVtZW50Lmh0bWwoJycpO1xyXG4gICAgICAkZWxlbWVudC5hcHBlbmQoY2xvbmUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpzY3JpcHRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIExvYWQgY29udGVudCBvZiBhIHNjcmlwdCB0YWcsIHdpdGggdHlwZSBgdGV4dC9uZy10ZW1wbGF0ZWAsIGludG8gYCR0ZW1wbGF0ZUNhY2hlYCwgc28gdGhhdCB0aGVcclxuICogdGVtcGxhdGUgY2FuIGJlIHVzZWQgYnkgYG5nSW5jbHVkZWAsIGBuZ1ZpZXdgIG9yIGRpcmVjdGl2ZSB0ZW1wbGF0ZXMuXHJcbiAqXHJcbiAqIEByZXN0cmljdCBFXHJcbiAqIEBwYXJhbSB7J3RleHQvbmctdGVtcGxhdGUnfSB0eXBlIG11c3QgYmUgc2V0IHRvIGAndGV4dC9uZy10ZW1wbGF0ZSdgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgPGRvYzpleGFtcGxlPlxyXG4gICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgIDxzY3JpcHQgdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIiBpZD1cIi90cGwuaHRtbFwiPlxyXG4gICAgICAgIENvbnRlbnQgb2YgdGhlIHRlbXBsYXRlLlxyXG4gICAgICA8L3NjcmlwdD5cclxuXHJcbiAgICAgIDxhIG5nLWNsaWNrPVwiY3VycmVudFRwbD0nL3RwbC5odG1sJ1wiIGlkPVwidHBsLWxpbmtcIj5Mb2FkIGlubGluZWQgdGVtcGxhdGU8L2E+XHJcbiAgICAgIDxkaXYgaWQ9XCJ0cGwtY29udGVudFwiIG5nLWluY2x1ZGUgc3JjPVwiY3VycmVudFRwbFwiPjwvZGl2PlxyXG4gICAgPC9kb2M6c291cmNlPlxyXG4gICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgaXQoJ3Nob3VsZCBsb2FkIHRlbXBsYXRlIGRlZmluZWQgaW5zaWRlIHNjcmlwdCB0YWcnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBlbGVtZW50KCcjdHBsLWxpbmsnKS5jbGljaygpO1xyXG4gICAgICAgIGV4cGVjdChlbGVtZW50KCcjdHBsLWNvbnRlbnQnKS50ZXh0KCkpLnRvTWF0Y2goL0NvbnRlbnQgb2YgdGhlIHRlbXBsYXRlLyk7XHJcbiAgICAgIH0pO1xyXG4gICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBzY3JpcHREaXJlY3RpdmUgPSBbJyR0ZW1wbGF0ZUNhY2hlJywgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgIHRlcm1pbmFsOiB0cnVlLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xyXG4gICAgICBpZiAoYXR0ci50eXBlID09ICd0ZXh0L25nLXRlbXBsYXRlJykge1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9IGF0dHIuaWQsXHJcbiAgICAgICAgICAgIC8vIElFIGlzIG5vdCBjb25zaXN0ZW50LCBpbiBzY3JpcHRzIHdlIGhhdmUgdG8gcmVhZCAudGV4dCBidXQgaW4gb3RoZXIgbm9kZXMgd2UgaGF2ZSB0byByZWFkIC50ZXh0Q29udGVudFxyXG4gICAgICAgICAgICB0ZXh0ID0gZWxlbWVudFswXS50ZXh0O1xyXG5cclxuICAgICAgICAkdGVtcGxhdGVDYWNoZS5wdXQodGVtcGxhdGVVcmwsIHRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6c2VsZWN0XHJcbiAqIEByZXN0cmljdCBFXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBIVE1MIGBTRUxFQ1RgIGVsZW1lbnQgd2l0aCBhbmd1bGFyIGRhdGEtYmluZGluZy5cclxuICpcclxuICogIyBgbmdPcHRpb25zYFxyXG4gKlxyXG4gKiBPcHRpb25hbGx5IGBuZ09wdGlvbnNgIGF0dHJpYnV0ZSBjYW4gYmUgdXNlZCB0byBkeW5hbWljYWxseSBnZW5lcmF0ZSBhIGxpc3Qgb2YgYDxvcHRpb24+YFxyXG4gKiBlbGVtZW50cyBmb3IgYSBgPHNlbGVjdD5gIGVsZW1lbnQgdXNpbmcgYW4gYXJyYXkgb3IgYW4gb2JqZWN0IG9idGFpbmVkIGJ5IGV2YWx1YXRpbmcgdGhlXHJcbiAqIGBuZ09wdGlvbnNgIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIFdoZW4gYW4gaXRlbSBpbiB0aGUgYDxzZWxlY3Q+YCBtZW51IGlzIHNlbGVjdGVkLCB0aGUgdmFsdWUgb2YgYXJyYXkgZWxlbWVudCBvciBvYmplY3QgcHJvcGVydHlcclxuICogcmVwcmVzZW50ZWQgYnkgdGhlIHNlbGVjdGVkIG9wdGlvbiB3aWxsIGJlIGJvdW5kIHRvIHRoZSBtb2RlbCBpZGVudGlmaWVkIGJ5IHRoZSBgbmdNb2RlbGBcclxuICogZGlyZWN0aXZlIG9mIHRoZSBwYXJlbnQgc2VsZWN0IGVsZW1lbnQuXHJcbiAqXHJcbiAqIE9wdGlvbmFsbHksIGEgc2luZ2xlIGhhcmQtY29kZWQgYDxvcHRpb24+YCBlbGVtZW50LCB3aXRoIHRoZSB2YWx1ZSBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nLCBjYW5cclxuICogYmUgbmVzdGVkIGludG8gdGhlIGA8c2VsZWN0PmAgZWxlbWVudC4gVGhpcyBlbGVtZW50IHdpbGwgdGhlbiByZXByZXNlbnQgYG51bGxgIG9yIFwibm90IHNlbGVjdGVkXCJcclxuICogb3B0aW9uLiBTZWUgZXhhbXBsZSBiZWxvdyBmb3IgZGVtb25zdHJhdGlvbi5cclxuICpcclxuICogTm90ZTogYG5nT3B0aW9uc2AgcHJvdmlkZXMgaXRlcmF0b3IgZmFjaWxpdHkgZm9yIGA8b3B0aW9uPmAgZWxlbWVudCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXHJcbiAqIG9mIHtAbGluayBuZy5kaXJlY3RpdmU6bmdSZXBlYXQgbmdSZXBlYXR9IHdoZW4geW91IHdhbnQgdGhlXHJcbiAqIGBzZWxlY3RgIG1vZGVsIHRvIGJlIGJvdW5kIHRvIGEgbm9uLXN0cmluZyB2YWx1ZS4gVGhpcyBpcyBiZWNhdXNlIGFuIG9wdGlvbiBlbGVtZW50IGNhbiBjdXJyZW50bHlcclxuICogYmUgYm91bmQgdG8gc3RyaW5nIHZhbHVlcyBvbmx5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBUaGUgY29udHJvbCBpcyBjb25zaWRlcmVkIHZhbGlkIG9ubHkgaWYgdmFsdWUgaXMgZW50ZXJlZC5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ1JlcXVpcmVkIEFkZHMgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgYW5kIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBjb25zdHJhaW50IHRvXHJcbiAqICAgIHRoZSBlbGVtZW50IHdoZW4gdGhlIG5nUmVxdWlyZWQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gVXNlIGBuZ1JlcXVpcmVkYCBpbnN0ZWFkIG9mXHJcbiAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxyXG4gKiBAcGFyYW0ge2NvbXByZWhlbnNpb25fZXhwcmVzc2lvbj19IG5nT3B0aW9ucyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcclxuICpcclxuICogICAqIGZvciBhcnJheSBkYXRhIHNvdXJjZXM6XHJcbiAqICAgICAqIGBsYWJlbGAgKipgZm9yYCoqIGB2YWx1ZWAgKipgaW5gKiogYGFycmF5YFxyXG4gKiAgICAgKiBgc2VsZWN0YCAqKmBhc2AqKiBgbGFiZWxgICoqYGZvcmAqKiBgdmFsdWVgICoqYGluYCoqIGBhcnJheWBcclxuICogICAgICogYGxhYmVsYCAgKipgZ3JvdXAgYnlgKiogYGdyb3VwYCAqKmBmb3JgKiogYHZhbHVlYCAqKmBpbmAqKiBgYXJyYXlgXHJcbiAqICAgICAqIGBzZWxlY3RgICoqYGFzYCoqIGBsYWJlbGAgKipgZ3JvdXAgYnlgKiogYGdyb3VwYCAqKmBmb3JgKiogYHZhbHVlYCAqKmBpbmAqKiBgYXJyYXlgICoqYHRyYWNrIGJ5YCoqIGB0cmFja2V4cHJgXHJcbiAqICAgKiBmb3Igb2JqZWN0IGRhdGEgc291cmNlczpcclxuICogICAgICogYGxhYmVsYCAqKmBmb3IgKGAqKmBrZXlgICoqYCxgKiogYHZhbHVlYCoqYCkgaW5gKiogYG9iamVjdGBcclxuICogICAgICogYHNlbGVjdGAgKipgYXNgKiogYGxhYmVsYCAqKmBmb3IgKGAqKmBrZXlgICoqYCxgKiogYHZhbHVlYCoqYCkgaW5gKiogYG9iamVjdGBcclxuICogICAgICogYGxhYmVsYCAqKmBncm91cCBieWAqKiBgZ3JvdXBgICoqYGZvciAoYCoqYGtleWAqKmAsYCoqIGB2YWx1ZWAqKmApIGluYCoqIGBvYmplY3RgXHJcbiAqICAgICAqIGBzZWxlY3RgICoqYGFzYCoqIGBsYWJlbGAgKipgZ3JvdXAgYnlgKiogYGdyb3VwYFxyXG4gKiAgICAgICAgICoqYGZvcmAgYChgKipga2V5YCoqYCxgKiogYHZhbHVlYCoqYCkgaW5gKiogYG9iamVjdGBcclxuICpcclxuICogV2hlcmU6XHJcbiAqXHJcbiAqICAgKiBgYXJyYXlgIC8gYG9iamVjdGA6IGFuIGV4cHJlc3Npb24gd2hpY2ggZXZhbHVhdGVzIHRvIGFuIGFycmF5IC8gb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogICAqIGB2YWx1ZWA6IGxvY2FsIHZhcmlhYmxlIHdoaWNoIHdpbGwgcmVmZXIgdG8gZWFjaCBpdGVtIGluIHRoZSBgYXJyYXlgIG9yIGVhY2ggcHJvcGVydHkgdmFsdWVcclxuICogICAgICBvZiBgb2JqZWN0YCBkdXJpbmcgaXRlcmF0aW9uLlxyXG4gKiAgICogYGtleWA6IGxvY2FsIHZhcmlhYmxlIHdoaWNoIHdpbGwgcmVmZXIgdG8gYSBwcm9wZXJ0eSBuYW1lIGluIGBvYmplY3RgIGR1cmluZyBpdGVyYXRpb24uXHJcbiAqICAgKiBgbGFiZWxgOiBUaGUgcmVzdWx0IG9mIHRoaXMgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBsYWJlbCBmb3IgYDxvcHRpb24+YCBlbGVtZW50LiBUaGVcclxuICogICAgIGBleHByZXNzaW9uYCB3aWxsIG1vc3QgbGlrZWx5IHJlZmVyIHRvIHRoZSBgdmFsdWVgIHZhcmlhYmxlIChlLmcuIGB2YWx1ZS5wcm9wZXJ0eU5hbWVgKS5cclxuICogICAqIGBzZWxlY3RgOiBUaGUgcmVzdWx0IG9mIHRoaXMgZXhwcmVzc2lvbiB3aWxsIGJlIGJvdW5kIHRvIHRoZSBtb2RlbCBvZiB0aGUgcGFyZW50IGA8c2VsZWN0PmBcclxuICogICAgICBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkLCBgc2VsZWN0YCBleHByZXNzaW9uIHdpbGwgZGVmYXVsdCB0byBgdmFsdWVgLlxyXG4gKiAgICogYGdyb3VwYDogVGhlIHJlc3VsdCBvZiB0aGlzIGV4cHJlc3Npb24gd2lsbCBiZSB1c2VkIHRvIGdyb3VwIG9wdGlvbnMgdXNpbmcgdGhlIGA8b3B0Z3JvdXA+YFxyXG4gKiAgICAgIERPTSBlbGVtZW50LlxyXG4gKiAgICogYHRyYWNrZXhwcmA6IFVzZWQgd2hlbiB3b3JraW5nIHdpdGggYW4gYXJyYXkgb2Ygb2JqZWN0cy4gVGhlIHJlc3VsdCBvZiB0aGlzIGV4cHJlc3Npb24gd2lsbCBiZVxyXG4gKiAgICAgIHVzZWQgdG8gaWRlbnRpZnkgdGhlIG9iamVjdHMgaW4gdGhlIGFycmF5LiBUaGUgYHRyYWNrZXhwcmAgd2lsbCBtb3N0IGxpa2VseSByZWZlciB0byB0aGVcclxuICogICAgIGB2YWx1ZWAgdmFyaWFibGUgKGUuZy4gYHZhbHVlLnByb3BlcnR5TmFtZWApLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgIGZ1bmN0aW9uIE15Q250cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAkc2NvcGUuY29sb3JzID0gW1xyXG4gICAgICAgICAgICB7bmFtZTonYmxhY2snLCBzaGFkZTonZGFyayd9LFxyXG4gICAgICAgICAgICB7bmFtZTond2hpdGUnLCBzaGFkZTonbGlnaHQnfSxcclxuICAgICAgICAgICAge25hbWU6J3JlZCcsIHNoYWRlOidkYXJrJ30sXHJcbiAgICAgICAgICAgIHtuYW1lOidibHVlJywgc2hhZGU6J2RhcmsnfSxcclxuICAgICAgICAgICAge25hbWU6J3llbGxvdycsIHNoYWRlOidsaWdodCd9XHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgICAgJHNjb3BlLmNvbG9yID0gJHNjb3BlLmNvbG9yc1syXTsgLy8gcmVkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIk15Q250cmxcIj5cclxuICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbG9yIGluIGNvbG9yc1wiPlxyXG4gICAgICAgICAgICAgIE5hbWU6IDxpbnB1dCBuZy1tb2RlbD1cImNvbG9yLm5hbWVcIj5cclxuICAgICAgICAgICAgICBbPGEgaHJlZiBuZy1jbGljaz1cImNvbG9ycy5zcGxpY2UoJGluZGV4LCAxKVwiPlg8L2E+XVxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgWzxhIGhyZWYgbmctY2xpY2s9XCJjb2xvcnMucHVzaCh7fSlcIj5hZGQ8L2E+XVxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPC91bD5cclxuICAgICAgICAgIDxoci8+XHJcbiAgICAgICAgICBDb2xvciAobnVsbCBub3QgYWxsb3dlZCk6XHJcbiAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwiY29sb3JcIiBuZy1vcHRpb25zPVwiYy5uYW1lIGZvciBjIGluIGNvbG9yc1wiPjwvc2VsZWN0Pjxicj5cclxuXHJcbiAgICAgICAgICBDb2xvciAobnVsbCBhbGxvd2VkKTpcclxuICAgICAgICAgIDxzcGFuICBjbGFzcz1cIm51bGxhYmxlXCI+XHJcbiAgICAgICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJjb2xvclwiIG5nLW9wdGlvbnM9XCJjLm5hbWUgZm9yIGMgaW4gY29sb3JzXCI+XHJcbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPi0tIGNob3NlIGNvbG9yIC0tPC9vcHRpb24+XHJcbiAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgPC9zcGFuPjxici8+XHJcblxyXG4gICAgICAgICAgQ29sb3IgZ3JvdXBlZCBieSBzaGFkZTpcclxuICAgICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJjb2xvclwiIG5nLW9wdGlvbnM9XCJjLm5hbWUgZ3JvdXAgYnkgYy5zaGFkZSBmb3IgYyBpbiBjb2xvcnNcIj5cclxuICAgICAgICAgIDwvc2VsZWN0Pjxici8+XHJcblxyXG5cclxuICAgICAgICAgIFNlbGVjdCA8YSBocmVmIG5nLWNsaWNrPVwiY29sb3I9e25hbWU6J25vdCBpbiBsaXN0J31cIj5ib2d1czwvYT4uPGJyPlxyXG4gICAgICAgICAgPGhyLz5cclxuICAgICAgICAgIEN1cnJlbnRseSBzZWxlY3RlZDoge3sge3NlbGVjdGVkX2NvbG9yOmNvbG9yfSAgfX1cclxuICAgICAgICAgIDxkaXYgc3R5bGU9XCJib3JkZXI6c29saWQgMXB4IGJsYWNrOyBoZWlnaHQ6MjBweFwiXHJcbiAgICAgICAgICAgICAgIG5nLXN0eWxlPVwieydiYWNrZ3JvdW5kLWNvbG9yJzpjb2xvci5uYW1lfVwiPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1vcHRpb25zJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3tzZWxlY3RlZF9jb2xvcjpjb2xvcn0nKSkudG9NYXRjaCgncmVkJyk7XHJcbiAgICAgICAgICAgc2VsZWN0KCdjb2xvcicpLm9wdGlvbignMCcpO1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd7c2VsZWN0ZWRfY29sb3I6Y29sb3J9JykpLnRvTWF0Y2goJ2JsYWNrJyk7XHJcbiAgICAgICAgICAgdXNpbmcoJy5udWxsYWJsZScpLnNlbGVjdCgnY29sb3InKS5vcHRpb24oJycpO1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd7c2VsZWN0ZWRfY29sb3I6Y29sb3J9JykpLnRvTWF0Y2goJ251bGwnKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcblxyXG52YXIgbmdPcHRpb25zRGlyZWN0aXZlID0gdmFsdWVGbih7IHRlcm1pbmFsOiB0cnVlIH0pO1xyXG52YXIgc2VsZWN0RGlyZWN0aXZlID0gWyckY29tcGlsZScsICckcGFyc2UnLCBmdW5jdGlvbigkY29tcGlsZSwgICAkcGFyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vMDAwMDExMTExMDAwMDAwMDAwMDAyMjIyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDMzMzMwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0MDAwMDAwMDAwNTU1NTU1NTU1NTU1NTU1NTUwMDAwMDAwNjY2NjY2NjY2NjY2NjY2NjYwMDAwMDAwMDAwMDAwMDAwNzc3NzAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4OFxyXG4gIHZhciBOR19PUFRJT05TX1JFR0VYUCA9IC9eXFxzKiguKj8pKD86XFxzK2FzXFxzKyguKj8pKT8oPzpcXHMrZ3JvdXBcXHMrYnlcXHMrKC4qKSk/XFxzK2ZvclxccysoPzooW1xcJFxcd11bXFwkXFx3XFxkXSopfCg/OlxcKFxccyooW1xcJFxcd11bXFwkXFx3XFxkXSopXFxzKixcXHMqKFtcXCRcXHddW1xcJFxcd1xcZF0qKVxccypcXCkpKVxccytpblxccysoLio/KSg/Olxccyt0cmFja1xccytieVxccysoLio/KSk/JC8sXHJcbiAgICAgIG51bGxNb2RlbEN0cmwgPSB7JHNldFZpZXdWYWx1ZTogbm9vcH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVxdWlyZTogWydzZWxlY3QnLCAnP25nTW9kZWwnXSxcclxuICAgIGNvbnRyb2xsZXI6IFsnJGVsZW1lbnQnLCAnJHNjb3BlJywgJyRhdHRycycsIGZ1bmN0aW9uKCRlbGVtZW50LCAkc2NvcGUsICRhdHRycykge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICBvcHRpb25zTWFwID0ge30sXHJcbiAgICAgICAgICBuZ01vZGVsQ3RybCA9IG51bGxNb2RlbEN0cmwsXHJcbiAgICAgICAgICBudWxsT3B0aW9uLFxyXG4gICAgICAgICAgdW5rbm93bk9wdGlvbjtcclxuXHJcblxyXG4gICAgICBzZWxmLmRhdGFib3VuZCA9ICRhdHRycy5uZ01vZGVsO1xyXG5cclxuXHJcbiAgICAgIHNlbGYuaW5pdCA9IGZ1bmN0aW9uKG5nTW9kZWxDdHJsXywgbnVsbE9wdGlvbl8sIHVua25vd25PcHRpb25fKSB7XHJcbiAgICAgICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XHJcbiAgICAgICAgbnVsbE9wdGlvbiA9IG51bGxPcHRpb25fO1xyXG4gICAgICAgIHVua25vd25PcHRpb24gPSB1bmtub3duT3B0aW9uXztcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHNlbGYuYWRkT3B0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBvcHRpb25zTWFwW3ZhbHVlXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGlmIChuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID09IHZhbHVlKSB7XHJcbiAgICAgICAgICAkZWxlbWVudC52YWwodmFsdWUpO1xyXG4gICAgICAgICAgaWYgKHVua25vd25PcHRpb24ucGFyZW50KCkpIHVua25vd25PcHRpb24ucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuXHJcbiAgICAgIHNlbGYucmVtb3ZlT3B0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNPcHRpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICBkZWxldGUgb3B0aW9uc01hcFt2YWx1ZV07XHJcbiAgICAgICAgICBpZiAobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclVua25vd25PcHRpb24odmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICBzZWxmLnJlbmRlclVua25vd25PcHRpb24gPSBmdW5jdGlvbih2YWwpIHtcclxuICAgICAgICB2YXIgdW5rbm93blZhbCA9ICc/ICcgKyBoYXNoS2V5KHZhbCkgKyAnID8nO1xyXG4gICAgICAgIHVua25vd25PcHRpb24udmFsKHVua25vd25WYWwpO1xyXG4gICAgICAgICRlbGVtZW50LnByZXBlbmQodW5rbm93bk9wdGlvbik7XHJcbiAgICAgICAgJGVsZW1lbnQudmFsKHVua25vd25WYWwpO1xyXG4gICAgICAgIHVua25vd25PcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTsgLy8gbmVlZGVkIGZvciBJRVxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgc2VsZi5oYXNPcHRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zTWFwLmhhc093blByb3BlcnR5KHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBkaXNhYmxlIHVua25vd24gb3B0aW9uIHNvIHRoYXQgd2UgZG9uJ3QgZG8gd29yayB3aGVuIHRoZSB3aG9sZSBzZWxlY3QgaXMgYmVpbmcgZGVzdHJveWVkXHJcbiAgICAgICAgc2VsZi5yZW5kZXJVbmtub3duT3B0aW9uID0gbm9vcDtcclxuICAgICAgfSk7XHJcbiAgICB9XSxcclxuXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybHMpIHtcclxuICAgICAgLy8gaWYgbmdNb2RlbCBpcyBub3QgZGVmaW5lZCwgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xyXG4gICAgICBpZiAoIWN0cmxzWzFdKSByZXR1cm47XHJcblxyXG4gICAgICB2YXIgc2VsZWN0Q3RybCA9IGN0cmxzWzBdLFxyXG4gICAgICAgICAgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXSxcclxuICAgICAgICAgIG11bHRpcGxlID0gYXR0ci5tdWx0aXBsZSxcclxuICAgICAgICAgIG9wdGlvbnNFeHAgPSBhdHRyLm5nT3B0aW9ucyxcclxuICAgICAgICAgIG51bGxPcHRpb24gPSBmYWxzZSwgLy8gaWYgZmFsc2UsIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBzZWxlY3QgaXQgKHVzZWQgYnkgbmdPcHRpb25zKVxyXG4gICAgICAgICAgZW1wdHlPcHRpb24sXHJcbiAgICAgICAgICAvLyB3ZSBjYW4ndCBqdXN0IGpxTGl0ZSgnPG9wdGlvbj4nKSBzaW5jZSBqcUxpdGUgaXMgbm90IHNtYXJ0IGVub3VnaFxyXG4gICAgICAgICAgLy8gdG8gY3JlYXRlIGl0IGluIDxzZWxlY3Q+IGFuZCBJRSBiYXJmcyBvdGhlcndpc2UuXHJcbiAgICAgICAgICBvcHRpb25UZW1wbGF0ZSA9IGpxTGl0ZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKSksXHJcbiAgICAgICAgICBvcHRHcm91cFRlbXBsYXRlID1qcUxpdGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKSksXHJcbiAgICAgICAgICB1bmtub3duT3B0aW9uID0gb3B0aW9uVGVtcGxhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgIC8vIGZpbmQgXCJudWxsXCIgb3B0aW9uXHJcbiAgICAgIGZvcih2YXIgaSA9IDAsIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbigpLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW5baV0udmFsdWUgPT0gJycpIHtcclxuICAgICAgICAgIGVtcHR5T3B0aW9uID0gbnVsbE9wdGlvbiA9IGNoaWxkcmVuLmVxKGkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxlY3RDdHJsLmluaXQobmdNb2RlbEN0cmwsIG51bGxPcHRpb24sIHVua25vd25PcHRpb24pO1xyXG5cclxuICAgICAgLy8gcmVxdWlyZWQgdmFsaWRhdG9yXHJcbiAgICAgIGlmIChtdWx0aXBsZSAmJiAoYXR0ci5yZXF1aXJlZCB8fCBhdHRyLm5nUmVxdWlyZWQpKSB7XHJcbiAgICAgICAgdmFyIHJlcXVpcmVkVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgncmVxdWlyZWQnLCAhYXR0ci5yZXF1aXJlZCB8fCAodmFsdWUgJiYgdmFsdWUubGVuZ3RoKSk7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbmdNb2RlbEN0cmwuJHBhcnNlcnMucHVzaChyZXF1aXJlZFZhbGlkYXRvcik7XHJcbiAgICAgICAgbmdNb2RlbEN0cmwuJGZvcm1hdHRlcnMudW5zaGlmdChyZXF1aXJlZFZhbGlkYXRvcik7XHJcblxyXG4gICAgICAgIGF0dHIuJG9ic2VydmUoJ3JlcXVpcmVkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXF1aXJlZFZhbGlkYXRvcihuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG9wdGlvbnNFeHApIE9wdGlvbnMoc2NvcGUsIGVsZW1lbnQsIG5nTW9kZWxDdHJsKTtcclxuICAgICAgZWxzZSBpZiAobXVsdGlwbGUpIE11bHRpcGxlKHNjb3BlLCBlbGVtZW50LCBuZ01vZGVsQ3RybCk7XHJcbiAgICAgIGVsc2UgU2luZ2xlKHNjb3BlLCBlbGVtZW50LCBuZ01vZGVsQ3RybCwgc2VsZWN0Q3RybCk7XHJcblxyXG5cclxuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuXHJcblxyXG4gICAgICBmdW5jdGlvbiBTaW5nbGUoc2NvcGUsIHNlbGVjdEVsZW1lbnQsIG5nTW9kZWxDdHJsLCBzZWxlY3RDdHJsKSB7XHJcbiAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHZpZXdWYWx1ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XHJcblxyXG4gICAgICAgICAgaWYgKHNlbGVjdEN0cmwuaGFzT3B0aW9uKHZpZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHVua25vd25PcHRpb24ucGFyZW50KCkpIHVua25vd25PcHRpb24ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQudmFsKHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3VmFsdWUgPT09ICcnKSBlbXB0eU9wdGlvbi5wcm9wKCdzZWxlY3RlZCcsIHRydWUpOyAvLyB0byBtYWtlIElFOSBoYXBweVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZpZXdWYWx1ZSkgJiYgZW1wdHlPcHRpb24pIHtcclxuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnZhbCgnJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0Q3RybC5yZW5kZXJVbmtub3duT3B0aW9uKHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzZWxlY3RFbGVtZW50Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHVua25vd25PcHRpb24ucGFyZW50KCkpIHVua25vd25PcHRpb24ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoc2VsZWN0RWxlbWVudC52YWwoKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gTXVsdGlwbGUoc2NvcGUsIHNlbGVjdEVsZW1lbnQsIGN0cmwpIHtcclxuICAgICAgICB2YXIgbGFzdFZpZXc7XHJcbiAgICAgICAgY3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgaXRlbXMgPSBuZXcgSGFzaE1hcChjdHJsLiR2aWV3VmFsdWUpO1xyXG4gICAgICAgICAgZm9yRWFjaChzZWxlY3RFbGVtZW50LmZpbmQoJ29wdGlvbicpLCBmdW5jdGlvbihvcHRpb24pIHtcclxuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaXNEZWZpbmVkKGl0ZW1zLmdldChvcHRpb24udmFsdWUpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZG8gaXQgb24gZWFjaCB3YXRjaCBzaW5jZSBuZ01vZGVsIHdhdGNoZXMgcmVmZXJlbmNlLCBidXRcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdvcmsgb2YgYW4gYXJyYXksIHNvIHdlIG5lZWQgdG8gc2VlIGlmIGFueXRoaW5nIHdhcyBpbnNlcnRlZC9yZW1vdmVkXHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uIHNlbGVjdE11bHRpcGxlV2F0Y2goKSB7XHJcbiAgICAgICAgICBpZiAoIWVxdWFscyhsYXN0VmlldywgY3RybC4kdmlld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICBsYXN0VmlldyA9IGNvcHkoY3RybC4kdmlld1ZhbHVlKTtcclxuICAgICAgICAgICAgY3RybC4kcmVuZGVyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNlbGVjdEVsZW1lbnQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgZm9yRWFjaChzZWxlY3RFbGVtZW50LmZpbmQoJ29wdGlvbicpLCBmdW5jdGlvbihvcHRpb24pIHtcclxuICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKG9wdGlvbi52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3RybC4kc2V0Vmlld1ZhbHVlKGFycmF5KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBPcHRpb25zKHNjb3BlLCBzZWxlY3RFbGVtZW50LCBjdHJsKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoO1xyXG5cclxuICAgICAgICBpZiAoISAobWF0Y2ggPSBvcHRpb25zRXhwLm1hdGNoKE5HX09QVElPTlNfUkVHRVhQKSkpIHtcclxuICAgICAgICAgIHRocm93IG1pbkVycignbmdPcHRpb25zJykoJ2lleHAnLFxyXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGV4cHJlc3Npb24gaW4gZm9ybSBvZiAnX3NlbGVjdF8gKGFzIF9sYWJlbF8pPyBmb3IgKF9rZXlfLCk/X3ZhbHVlXyBpbiBfY29sbGVjdGlvbl8nIGJ1dCBnb3QgJ3swfScuIEVsZW1lbnQ6IHsxfVwiLFxyXG4gICAgICAgICAgICBvcHRpb25zRXhwLCBzdGFydGluZ1RhZyhzZWxlY3RFbGVtZW50KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGlzcGxheUZuID0gJHBhcnNlKG1hdGNoWzJdIHx8IG1hdGNoWzFdKSxcclxuICAgICAgICAgICAgdmFsdWVOYW1lID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNl0sXHJcbiAgICAgICAgICAgIGtleU5hbWUgPSBtYXRjaFs1XSxcclxuICAgICAgICAgICAgZ3JvdXBCeUZuID0gJHBhcnNlKG1hdGNoWzNdIHx8ICcnKSxcclxuICAgICAgICAgICAgdmFsdWVGbiA9ICRwYXJzZShtYXRjaFsyXSA/IG1hdGNoWzFdIDogdmFsdWVOYW1lKSxcclxuICAgICAgICAgICAgdmFsdWVzRm4gPSAkcGFyc2UobWF0Y2hbN10pLFxyXG4gICAgICAgICAgICB0cmFjayA9IG1hdGNoWzhdLFxyXG4gICAgICAgICAgICB0cmFja0ZuID0gdHJhY2sgPyAkcGFyc2UobWF0Y2hbOF0pIDogbnVsbCxcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBhcnJheSBvZiBhcnJheSBvZiBleGlzdGluZyBvcHRpb24gZ3JvdXBzIGluIERPTS4gV2UgdHJ5IHRvIHJldXNlIHRoZXNlIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIC8vIG9wdGlvbkdyb3Vwc0NhY2hlWzBdIGlzIHRoZSBvcHRpb25zIHdpdGggbm8gb3B0aW9uIGdyb3VwXHJcbiAgICAgICAgICAgIC8vIG9wdGlvbkdyb3Vwc0NhY2hlWz9dWzBdIGlzIHRoZSBwYXJlbnQ6IGVpdGhlciB0aGUgU0VMRUNUIG9yIE9QVEdST1VQIGVsZW1lbnRcclxuICAgICAgICAgICAgb3B0aW9uR3JvdXBzQ2FjaGUgPSBbW3tlbGVtZW50OiBzZWxlY3RFbGVtZW50LCBsYWJlbDonJ31dXTtcclxuXHJcbiAgICAgICAgaWYgKG51bGxPcHRpb24pIHtcclxuICAgICAgICAgIC8vIGNvbXBpbGUgdGhlIGVsZW1lbnQgc2luY2UgdGhlcmUgbWlnaHQgYmUgYmluZGluZ3MgaW4gaXRcclxuICAgICAgICAgICRjb21waWxlKG51bGxPcHRpb24pKHNjb3BlKTtcclxuXHJcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGNsYXNzLCB3aGljaCBpcyBhZGRlZCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugd2UgcmVjb21waWxlIHRoZSBlbGVtZW50IGFuZCBpdFxyXG4gICAgICAgICAgLy8gYmVjb21lcyB0aGUgY29tcGlsYXRpb24gcm9vdFxyXG4gICAgICAgICAgbnVsbE9wdGlvbi5yZW1vdmVDbGFzcygnbmctc2NvcGUnKTtcclxuXHJcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBiZWZvcmUgY2FsbGluZyBzZWxlY3RFbGVtZW50Lmh0bWwoJycpIGJlY2F1c2Ugb3RoZXJ3aXNlIElFIHdpbGxcclxuICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSB0aGUgZWxlbWVudC4gd3RmP1xyXG4gICAgICAgICAgbnVsbE9wdGlvbi5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnRzLCB3ZSdsbCBhZGQgd2hhdCdzIG5lZWRlZCBiYXNlZCBvbiB0aGUgbW9kZWxcclxuICAgICAgICBzZWxlY3RFbGVtZW50Lmh0bWwoJycpO1xyXG5cclxuICAgICAgICBzZWxlY3RFbGVtZW50Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbkdyb3VwLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlc0ZuKHNjb3BlKSB8fCBbXSxcclxuICAgICAgICAgICAgICAgIGxvY2FscyA9IHt9LFxyXG4gICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgb3B0aW9uRWxlbWVudCwgaW5kZXgsIGdyb3VwSW5kZXgsIGxlbmd0aCwgZ3JvdXBMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgIGZvciAoZ3JvdXBJbmRleCA9IDAsIGdyb3VwTGVuZ3RoID0gb3B0aW9uR3JvdXBzQ2FjaGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleCA8IGdyb3VwTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMgZm9yIHRoYXQgZ3JvdXAuIChmaXJzdCBpdGVtIGhhcyB0aGUgcGFyZW50KVxyXG4gICAgICAgICAgICAgICAgb3B0aW9uR3JvdXAgPSBvcHRpb25Hcm91cHNDYWNoZVtncm91cEluZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IoaW5kZXggPSAxLCBsZW5ndGggPSBvcHRpb25Hcm91cC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICgob3B0aW9uRWxlbWVudCA9IG9wdGlvbkdyb3VwW2luZGV4XS5lbGVtZW50KVswXS5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9wdGlvbkVsZW1lbnQudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleU5hbWUpIGxvY2Fsc1trZXlOYW1lXSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tGbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdHJhY2tJbmRleCA9IDA7IHRyYWNrSW5kZXggPCBjb2xsZWN0aW9uLmxlbmd0aDsgdHJhY2tJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2Fsc1t2YWx1ZU5hbWVdID0gY29sbGVjdGlvblt0cmFja0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRm4oc2NvcGUsIGxvY2FscykgPT0ga2V5KSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxzW3ZhbHVlTmFtZV0gPSBjb2xsZWN0aW9uW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2godmFsdWVGbihzY29wZSwgbG9jYWxzKSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAga2V5ID0gc2VsZWN0RWxlbWVudC52YWwoKTtcclxuICAgICAgICAgICAgICBpZiAoa2V5ID09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0gJycpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tGbikge1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFja0luZGV4ID0gMDsgdHJhY2tJbmRleCA8IGNvbGxlY3Rpb24ubGVuZ3RoOyB0cmFja0luZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbHNbdmFsdWVOYW1lXSA9IGNvbGxlY3Rpb25bdHJhY2tJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRm4oc2NvcGUsIGxvY2FscykgPT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlRm4oc2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGxvY2Fsc1t2YWx1ZU5hbWVdID0gY29sbGVjdGlvbltrZXldO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZSkgbG9jYWxzW2tleU5hbWVdID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlRm4oc2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY3RybC4kcmVuZGVyID0gcmVuZGVyO1xyXG5cclxuICAgICAgICAvLyBUT0RPKHZvanRhKTogY2FuJ3Qgd2Ugb3B0aW1pemUgdGhpcyA/XHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKHJlbmRlcik7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICAgICAgIHZhciBvcHRpb25Hcm91cHMgPSB7Jyc6W119LCAvLyBUZW1wb3JhcnkgbG9jYXRpb24gZm9yIHRoZSBvcHRpb24gZ3JvdXBzIGJlZm9yZSB3ZSByZW5kZXIgdGhlbVxyXG4gICAgICAgICAgICAgIG9wdGlvbkdyb3VwTmFtZXMgPSBbJyddLFxyXG4gICAgICAgICAgICAgIG9wdGlvbkdyb3VwTmFtZSxcclxuICAgICAgICAgICAgICBvcHRpb25Hcm91cCxcclxuICAgICAgICAgICAgICBvcHRpb24sXHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdQYXJlbnQsIGV4aXN0aW5nT3B0aW9ucywgZXhpc3RpbmdPcHRpb24sXHJcbiAgICAgICAgICAgICAgbW9kZWxWYWx1ZSA9IGN0cmwuJG1vZGVsVmFsdWUsXHJcbiAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzRm4oc2NvcGUpIHx8IFtdLFxyXG4gICAgICAgICAgICAgIGtleXMgPSBrZXlOYW1lID8gc29ydGVkS2V5cyh2YWx1ZXMpIDogdmFsdWVzLFxyXG4gICAgICAgICAgICAgIGdyb3VwTGVuZ3RoLCBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleCwgaW5kZXgsXHJcbiAgICAgICAgICAgICAgbG9jYWxzID0ge30sXHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQsXHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWRTZXQgPSBmYWxzZSwgLy8gbm90aGluZyBpcyBzZWxlY3RlZCB5ZXRcclxuICAgICAgICAgICAgICBsYXN0RWxlbWVudCxcclxuICAgICAgICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgICAgICAgIGxhYmVsO1xyXG5cclxuICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBpZiAodHJhY2tGbiAmJiBpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWRTZXQgPSBuZXcgSGFzaE1hcChbXSk7XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgdHJhY2tJbmRleCA9IDA7IHRyYWNrSW5kZXggPCBtb2RlbFZhbHVlLmxlbmd0aDsgdHJhY2tJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbHNbdmFsdWVOYW1lXSA9IG1vZGVsVmFsdWVbdHJhY2tJbmRleF07XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFNldC5wdXQodHJhY2tGbihzY29wZSwgbG9jYWxzKSwgbW9kZWxWYWx1ZVt0cmFja0luZGV4XSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNlbGVjdGVkU2V0ID0gbmV3IEhhc2hNYXAobW9kZWxWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBXZSBub3cgYnVpbGQgdXAgdGhlIGxpc3Qgb2Ygb3B0aW9ucyB3ZSBuZWVkICh3ZSBtZXJnZSBsYXRlcilcclxuICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPSBrZXlzLmxlbmd0aCwgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgbG9jYWxzW3ZhbHVlTmFtZV0gPSB2YWx1ZXNba2V5TmFtZSA/IGxvY2Fsc1trZXlOYW1lXT1rZXlzW2luZGV4XTppbmRleF07XHJcbiAgICAgICAgICAgICAgIG9wdGlvbkdyb3VwTmFtZSA9IGdyb3VwQnlGbihzY29wZSwgbG9jYWxzKSB8fCAnJztcclxuICAgICAgICAgICAgaWYgKCEob3B0aW9uR3JvdXAgPSBvcHRpb25Hcm91cHNbb3B0aW9uR3JvdXBOYW1lXSkpIHtcclxuICAgICAgICAgICAgICBvcHRpb25Hcm91cCA9IG9wdGlvbkdyb3Vwc1tvcHRpb25Hcm91cE5hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXBOYW1lcy5wdXNoKG9wdGlvbkdyb3VwTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZFNldC5yZW1vdmUodHJhY2tGbiA/IHRyYWNrRm4oc2NvcGUsIGxvY2FscykgOiB2YWx1ZUZuKHNjb3BlLCBsb2NhbHMpKSAhPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRyYWNrRm4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RlbENhc3QgPSB7fTtcclxuICAgICAgICAgICAgICAgIG1vZGVsQ2FzdFt2YWx1ZU5hbWVdID0gbW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJhY2tGbihzY29wZSwgbW9kZWxDYXN0KSA9PT0gdHJhY2tGbihzY29wZSwgbG9jYWxzKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBtb2RlbFZhbHVlID09PSB2YWx1ZUZuKHNjb3BlLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzZWxlY3RlZFNldCA9IHNlbGVjdGVkU2V0IHx8IHNlbGVjdGVkOyAvLyBzZWUgaWYgYXQgbGVhc3Qgb25lIGl0ZW0gaXMgc2VsZWN0ZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYWJlbCA9IGRpc3BsYXlGbihzY29wZSwgbG9jYWxzKTsgLy8gd2hhdCB3aWxsIGJlIHNlZW4gYnkgdGhlIHVzZXJcclxuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbCA9PT0gdW5kZWZpbmVkID8gJycgOiBsYWJlbDsgLy8gZG9pbmcgZGlzcGxheUZuKHNjb3BlLCBsb2NhbHMpIHx8ICcnIG92ZXJ3cml0ZXMgemVybyB2YWx1ZXNcclxuICAgICAgICAgICAgb3B0aW9uR3JvdXAucHVzaCh7XHJcbiAgICAgICAgICAgICAgaWQ6IHRyYWNrRm4gPyB0cmFja0ZuKHNjb3BlLCBsb2NhbHMpIDogKGtleU5hbWUgPyBrZXlzW2luZGV4XSA6IGluZGV4KSwgICAvLyBlaXRoZXIgdGhlIGluZGV4IGludG8gYXJyYXkgb3Iga2V5IGZyb20gb2JqZWN0XHJcbiAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGJlIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBpZiAobnVsbE9wdGlvbiB8fCBtb2RlbFZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgLy8gaW5zZXJ0IG51bGwgb3B0aW9uIGlmIHdlIGhhdmUgYSBwbGFjZWhvbGRlciwgb3IgdGhlIG1vZGVsIGlzIG51bGxcclxuICAgICAgICAgICAgICBvcHRpb25Hcm91cHNbJyddLnVuc2hpZnQoe2lkOicnLCBsYWJlbDonJywgc2VsZWN0ZWQ6IXNlbGVjdGVkU2V0fSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGVkU2V0KSB7XHJcbiAgICAgICAgICAgICAgLy8gb3B0aW9uIGNvdWxkIG5vdCBiZSBmb3VuZCwgd2UgaGF2ZSB0byBpbnNlcnQgdGhlIHVuZGVmaW5lZCBpdGVtXHJcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXBzWycnXS51bnNoaWZ0KHtpZDonPycsIGxhYmVsOicnLCBzZWxlY3RlZDp0cnVlfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgRE9NIG5vZGVzIHRvIG1hdGNoIHRoZSBvcHRpb25Hcm91cHMgd2UgY29tcHV0ZWQgYWJvdmVcclxuICAgICAgICAgIGZvciAoZ3JvdXBJbmRleCA9IDAsIGdyb3VwTGVuZ3RoID0gb3B0aW9uR3JvdXBOYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgIGdyb3VwSW5kZXggPCBncm91cExlbmd0aDtcclxuICAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb3B0aW9uIGdyb3VwIG5hbWUgb3IgJycgaWYgbm8gZ3JvdXBcclxuICAgICAgICAgICAgb3B0aW9uR3JvdXBOYW1lID0gb3B0aW9uR3JvdXBOYW1lc1tncm91cEluZGV4XTtcclxuXHJcbiAgICAgICAgICAgIC8vIGxpc3Qgb2Ygb3B0aW9ucyBmb3IgdGhhdCBncm91cC4gKGZpcnN0IGl0ZW0gaGFzIHRoZSBwYXJlbnQpXHJcbiAgICAgICAgICAgIG9wdGlvbkdyb3VwID0gb3B0aW9uR3JvdXBzW29wdGlvbkdyb3VwTmFtZV07XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9uR3JvdXBzQ2FjaGUubGVuZ3RoIDw9IGdyb3VwSW5kZXgpIHtcclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGdyb3cgdGhlIG9wdGlvbkdyb3Vwc1xyXG4gICAgICAgICAgICAgIGV4aXN0aW5nUGFyZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogb3B0R3JvdXBUZW1wbGF0ZS5jbG9uZSgpLmF0dHIoJ2xhYmVsJywgb3B0aW9uR3JvdXBOYW1lKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBvcHRpb25Hcm91cC5sYWJlbFxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdPcHRpb25zID0gW2V4aXN0aW5nUGFyZW50XTtcclxuICAgICAgICAgICAgICBvcHRpb25Hcm91cHNDYWNoZS5wdXNoKGV4aXN0aW5nT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQoZXhpc3RpbmdQYXJlbnQuZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdPcHRpb25zID0gb3B0aW9uR3JvdXBzQ2FjaGVbZ3JvdXBJbmRleF07XHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdQYXJlbnQgPSBleGlzdGluZ09wdGlvbnNbMF07ICAvLyBlaXRoZXIgU0VMRUNUIChubyBncm91cCkgb3IgT1BUR1JPVVAgZWxlbWVudFxyXG5cclxuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIE9QVEdST1VQIGxhYmVsIGlmIG5vdCB0aGUgc2FtZS5cclxuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXJlbnQubGFiZWwgIT0gb3B0aW9uR3JvdXBOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBleGlzdGluZ1BhcmVudC5lbGVtZW50LmF0dHIoJ2xhYmVsJywgZXhpc3RpbmdQYXJlbnQubGFiZWwgPSBvcHRpb25Hcm91cE5hbWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBudWxsOyAgLy8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICBmb3IoaW5kZXggPSAwLCBsZW5ndGggPSBvcHRpb25Hcm91cC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uR3JvdXBbaW5kZXhdO1xyXG4gICAgICAgICAgICAgIGlmICgoZXhpc3RpbmdPcHRpb24gPSBleGlzdGluZ09wdGlvbnNbaW5kZXgrMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXVzZSBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBleGlzdGluZ09wdGlvbi5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nT3B0aW9uLmxhYmVsICE9PSBvcHRpb24ubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQudGV4dChleGlzdGluZ09wdGlvbi5sYWJlbCA9IG9wdGlvbi5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdPcHRpb24uaWQgIT09IG9wdGlvbi5pZCkge1xyXG4gICAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC52YWwoZXhpc3RpbmdPcHRpb24uaWQgPSBvcHRpb24uaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbGFzdEVsZW1lbnQucHJvcCgnc2VsZWN0ZWQnKSBwcm92aWRlZCBieSBqUXVlcnkgaGFzIHNpZGUtZWZmZWN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFbGVtZW50WzBdLnNlbGVjdGVkICE9PSBvcHRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQucHJvcCgnc2VsZWN0ZWQnLCAoZXhpc3RpbmdPcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24uc2VsZWN0ZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZ3JvdyBlbGVtZW50c1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBudWxsIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5pZCA9PT0gJycgJiYgbnVsbE9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAvLyBwdXQgYmFjayB0aGUgcHJlLWNvbXBpbGVkIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGxPcHRpb247XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAvLyBqUXVlcnkodjEuNC4yKSBCdWc6IFdlIHNob3VsZCBiZSBhYmxlIHRvIGNoYWluIHRoZSBtZXRob2QgY2FsbHMsIGJ1dFxyXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5IG9uIHNvbWUgYnJvd3NlciB0aGUgLnRleHQoKSByZXR1cm5zIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGVuIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAoZWxlbWVudCA9IG9wdGlvblRlbXBsYXRlLmNsb25lKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAudmFsKG9wdGlvbi5pZClcclxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzZWxlY3RlZCcsIG9wdGlvbi5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KG9wdGlvbi5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdPcHRpb25zLnB1c2goZXhpc3RpbmdPcHRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogb3B0aW9uLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBvcHRpb24uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IG9wdGlvbi5zZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQuYWZ0ZXIoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBleGlzdGluZ1BhcmVudC5lbGVtZW50LmFwcGVuZChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBleGNlc3NpdmUgT1BUSU9OcyBpbiBhIGdyb3VwXHJcbiAgICAgICAgICAgIGluZGV4Kys7IC8vIGluY3JlbWVudCBzaW5jZSB0aGUgZXhpc3RpbmdPcHRpb25zWzBdIGlzIHBhcmVudCBlbGVtZW50IG5vdCBPUFRJT05cclxuICAgICAgICAgICAgd2hpbGUoZXhpc3RpbmdPcHRpb25zLmxlbmd0aCA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgZXhpc3RpbmdPcHRpb25zLnBvcCgpLmVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXhjZXNzaXZlIE9QVEdST1VQcyBmcm9tIHNlbGVjdFxyXG4gICAgICAgICAgd2hpbGUob3B0aW9uR3JvdXBzQ2FjaGUubGVuZ3RoID4gZ3JvdXBJbmRleCkge1xyXG4gICAgICAgICAgICBvcHRpb25Hcm91cHNDYWNoZS5wb3AoKVswXS5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufV07XHJcblxyXG52YXIgb3B0aW9uRGlyZWN0aXZlID0gWyckaW50ZXJwb2xhdGUnLCBmdW5jdGlvbigkaW50ZXJwb2xhdGUpIHtcclxuICB2YXIgbnVsbFNlbGVjdEN0cmwgPSB7XHJcbiAgICBhZGRPcHRpb246IG5vb3AsXHJcbiAgICByZW1vdmVPcHRpb246IG5vb3BcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgIHByaW9yaXR5OiAxMDAsXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgIGlmIChpc1VuZGVmaW5lZChhdHRyLnZhbHVlKSkge1xyXG4gICAgICAgIHZhciBpbnRlcnBvbGF0ZUZuID0gJGludGVycG9sYXRlKGVsZW1lbnQudGV4dCgpLCB0cnVlKTtcclxuICAgICAgICBpZiAoIWludGVycG9sYXRlRm4pIHtcclxuICAgICAgICAgIGF0dHIuJHNldCgndmFsdWUnLCBlbGVtZW50LnRleHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdEN0cmxOYW1lID0gJyRzZWxlY3RDb250cm9sbGVyJyxcclxuICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKSxcclxuICAgICAgICAgICAgc2VsZWN0Q3RybCA9IHBhcmVudC5kYXRhKHNlbGVjdEN0cmxOYW1lKSB8fFxyXG4gICAgICAgICAgICAgIHBhcmVudC5wYXJlbnQoKS5kYXRhKHNlbGVjdEN0cmxOYW1lKTsgLy8gaW4gY2FzZSB3ZSBhcmUgaW4gb3B0Z3JvdXBcclxuXHJcbiAgICAgICAgaWYgKHNlbGVjdEN0cmwgJiYgc2VsZWN0Q3RybC5kYXRhYm91bmQpIHtcclxuICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBPcGVyYSBkZWZhdWx0cyB0byB0cnVlIGFuZCBpZiBub3Qgb3ZlcnJpZGRlbiB0aGlzIG1lc3NlcyB1cCB0aGUgcmVwZWF0ZXIuXHJcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRoZSB2aWV3IHRvIGRyaXZlIHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgbW9kZWwgYW55d2F5LlxyXG4gICAgICAgICAgZWxlbWVudC5wcm9wKCdzZWxlY3RlZCcsIGZhbHNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZWN0Q3RybCA9IG51bGxTZWxlY3RDdHJsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGludGVycG9sYXRlRm4pIHtcclxuICAgICAgICAgIHNjb3BlLiR3YXRjaChpbnRlcnBvbGF0ZUZuLCBmdW5jdGlvbiBpbnRlcnBvbGF0ZVdhdGNoQWN0aW9uKG5ld1ZhbCwgb2xkVmFsKSB7XHJcbiAgICAgICAgICAgIGF0dHIuJHNldCgndmFsdWUnLCBuZXdWYWwpO1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHNlbGVjdEN0cmwucmVtb3ZlT3B0aW9uKG9sZFZhbCk7XHJcbiAgICAgICAgICAgIHNlbGVjdEN0cmwuYWRkT3B0aW9uKG5ld1ZhbCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZWN0Q3RybC5hZGRPcHRpb24oYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2VsZWN0Q3RybC5yZW1vdmVPcHRpb24oYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG59XTtcclxuXHJcbnZhciBzdHlsZURpcmVjdGl2ZSA9IHZhbHVlRm4oe1xyXG4gIHJlc3RyaWN0OiAnRScsXHJcbiAgdGVybWluYWw6IHRydWVcclxufSk7XHJcblxyXG4gIC8vdHJ5IHRvIGJpbmQgdG8ganF1ZXJ5IG5vdyBzbyB0aGF0IG9uZSBjYW4gd3JpdGUgYW5ndWxhci5lbGVtZW50KCkucmVhZCgpXHJcbiAgLy9idXQgd2Ugd2lsbCByZWJpbmQgb24gYm9vdHN0cmFwIGFnYWluLlxyXG4gIGJpbmRKUXVlcnkoKTtcclxuXHJcbiAgcHVibGlzaEV4dGVybmFsQVBJKGFuZ3VsYXIpO1xyXG5cclxuICBqcUxpdGUoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgYW5ndWxhckluaXQoZG9jdW1lbnQsIGJvb3RzdHJhcCk7XHJcbiAgfSk7XHJcblxyXG59KSh3aW5kb3csIGRvY3VtZW50KTtcclxuYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPkBjaGFyc2V0IFwiVVRGLThcIjtbbmdcXFxcOmNsb2FrXSxbbmctY2xvYWtdLFtkYXRhLW5nLWNsb2FrXSxbeC1uZy1jbG9ha10sLm5nLWNsb2FrLC54LW5nLWNsb2FrLC5uZy1oaWRle2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50O31uZ1xcXFw6Zm9ybXtkaXNwbGF5OmJsb2NrO308L3N0eWxlPicpOyIsIjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcclxuXHJcbi8vTGlzdCBmcm9tIG5vZGUtaHRtbHBhcnNlclxyXG52YXIgc2luZ2xlVGFncyA9IHtcclxuICBhcmVhOiAxLFxyXG4gIGJhc2U6IDEsXHJcbiAgYmFzZWZvbnQ6IDEsXHJcbiAgYnI6IDEsXHJcbiAgY29sOiAxLFxyXG4gIGZyYW1lOiAxLFxyXG4gIGhyOiAxLFxyXG4gIGltZzogMSxcclxuICBpbnB1dDogMSxcclxuICBpc2luZGV4OiAxLFxyXG4gIGxpbms6IDEsXHJcbiAgbWV0YTogMSxcclxuICBwYXJhbTogMSxcclxuICBlbWJlZDogMVxyXG59O1xyXG5cclxudmFyIGV4cHIgPSB7XHJcbiAgdXBwZXJDYXNlQ2hhcnM6IC8oW0EtWl0pL2csXHJcbiAgYnJlYWtCZXR3ZWVuVGFnczogLyg8KFxcLz9cXHcrKS4qPz4pKD89PCg/IVxcL1xcMikpL2dpLFxyXG4gIHNpbmdsZVRhZzogKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRhZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIGkgaW4gc2luZ2xlVGFncykge1xyXG4gICAgICB0YWdzLnB1c2goaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnPCcgKyB0YWdzLmpvaW4oJ3w8JyksICdpJyk7XHJcbiAgfSkoKVxyXG59O1xyXG5cclxudmFyIHVuY2Fub24gPSBmdW5jdGlvbihzdHIsIGxldHRlcikge1xyXG4gIHJldHVybiAnLScgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKTtcclxufTtcclxuXHJcbnZhciBIVE1MRW5jb2RlID0gZnVuY3Rpb24odGV4dCkgeyByZXR1cm4gdGV4dDsgfTsgLy8gTm9vcFxyXG5cclxuZXhwb3J0cy5zdHJpbmdpZnlFbGVtZW50ID0gZnVuY3Rpb24gc3RyaW5naWZ5RWxlbWVudChlbGVtZW50KSB7XHJcbiAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcclxuICAgICAgcmV0ID0ge1xyXG4gICAgICAgIHN0YXJ0OiBcIjxcIiArIHRhZ05hbWUsXHJcbiAgICAgICAgZW5kOicnXHJcbiAgICAgIH0sXHJcbiAgICAgIGF0dHJpYnV0ZXMgPSBbXSxcclxuICAgICAgaSxcclxuICAgICAgYXR0cmlidXRlID0gbnVsbDtcclxuXHJcbiAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGgpIHtcclxuICAgIHJldC5zdGFydCArPSBcIiBcIjtcclxuICAgIGZvciAoaSA9IDA7IGk8ZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlcy5pdGVtKGkpO1xyXG4gICAgICBhdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlLm5hbWUgKyAnPVwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICBIVE1MRW5jb2RlKGF0dHJpYnV0ZS5ub2RlVmFsdWUsIHRydWUpICsgJ1wiJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldC5zdGFydCArPSBhdHRyaWJ1dGVzLmpvaW4oXCIgXCIpO1xyXG5cclxuICBpZiAoc2luZ2xlVGFnc1t0YWdOYW1lXSkge1xyXG4gICAgcmV0LnN0YXJ0ICs9IFwiIC8+XCI7XHJcbiAgICByZXQuZW5kID0gJyc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldC5zdGFydCArPSBcIj5cIjtcclxuICAgIHJldC5lbmQgPSBcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0O1xyXG59O1xyXG5cclxudmFyIHJhd1RleHRFbGVtZW50cyA9IC9TQ1JJUFR8U1RZTEUvaTtcclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3R5cGUgKGRvY3R5cGUpIHtcclxuICBpZiAoZG9jdHlwZS5vd25lckRvY3VtZW50ICYmIGRvY3R5cGUub3duZXJEb2N1bWVudC5mdWxsRFQpIHtcclxuICAgIHJldHVybiBkb2N0eXBlLm93bmVyRG9jdW1lbnQuZnVsbERUO1xyXG4gIH1cclxuXHJcbiAgdmFyIGR0ID0gJzwhRE9DVFlQRSAnICsgZG9jdHlwZS5uYW1lO1xyXG4gIGlmIChkb2N0eXBlLnB1YmxpY0lkKSB7XHJcbiAgICAvLyBQdWJsaWMgSUQgbWF5IG5ldmVyIGNvbnRhaW4gZG91YmxlIHF1b3Rlcywgc28gdGhpcyBpcyBhbHdheXMgc2FmZS5cclxuICAgIGR0ICs9ICcgUFVCTElDIFwiJyArIGRvY3R5cGUucHVibGljSWQgKyAnXCIgJztcclxuICB9XHJcbiAgaWYgKCFkb2N0eXBlLnB1YmxpY0lkICYmIGRvY3R5cGUuc3lzdGVtSWQpIHtcclxuICAgIGR0ICs9ICcgU1lTVEVNICc7XHJcbiAgfVxyXG4gIGlmIChkb2N0eXBlLnN5c3RlbUlkKSB7XHJcbiAgICAvLyBTeXN0ZW0gSUQgbWF5IGNvbnRhaW4gZG91YmxlIHF1b3RlcyBPUiBzaW5nbGUgcXVvdGVzLCBub3QgbmV2ZXIgYm90aC5cclxuICAgIGlmIChkb2N0eXBlLnN5c3RlbUlkLmluZGV4T2YoJ1wiJykgPiAtMSkge1xyXG4gICAgICBkdCArPSBcIidcIiArIGRvY3R5cGUuc3lzdGVtSWQgKyBcIidcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGR0ICs9ICdcIicgKyBkb2N0eXBlLnN5c3RlbUlkICsgJ1wiJztcclxuICAgIH1cclxuICB9XHJcbiAgZHQgKz0gJz4nO1xyXG4gIHJldHVybiBkdDtcclxufVxyXG5cclxuZXhwb3J0cy5tYWtlSHRtbEdlbmVyYXRvciA9IGZ1bmN0aW9uIG1ha2VIdG1sR2VuZXJhdG9yKGluZGVudFVuaXQsIGVvbCkge1xyXG4gIGluZGVudFVuaXQgPSBpbmRlbnRVbml0IHx8IFwiXCI7XHJcbiAgZW9sID0gZW9sIHx8IFwiXCI7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZUh0bWxSZWN1cnNpdmUobm9kZSwgcmF3VGV4dCwgY3VySW5kZW50KSB7XHJcbiAgICB2YXIgcmV0ID0gXCJcIiwgcGFyZW50LCBjdXJyZW50LCBpLCBjaGlsZHJlbjtcclxuICAgIGN1ckluZGVudCA9IGN1ckluZGVudCB8fCBcIlwiO1xyXG4gICAgaWYgKG5vZGUpIHtcclxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgJiZcclxuICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRU5USVRZX1JFRkVSRU5DRV9OT0RFKSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUuZW50aXR5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY2hpbGROb2Rlc1Jhd1RleHQgPSByYXdUZXh0IHx8IHJhd1RleHRFbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpO1xyXG4gICAgICBcclxuICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBub2RlLkVMRU1FTlRfTk9ERTpcclxuICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09IFwiVEVNUExBVEVcIikge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY29udGVudC5jaGlsZE5vZGVzO1xyXG4gICAgICAgICAgICBjaGlsZE5vZGVzUmF3VGV4dCA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY3VycmVudCA9IGV4cG9ydHMuc3RyaW5naWZ5RWxlbWVudChub2RlKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNSYXdUZXh0KSB7XHJcbiAgICAgICAgICAgIHJldCArPSBjdXJJbmRlbnQgKyBjdXJyZW50LnN0YXJ0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0ICs9IGN1ckluZGVudCArIGN1cnJlbnQuc3RhcnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBcIkhUTUxcIikgcmV0ICs9IGVvbDtcclxuXHJcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5bMF0ubm9kZVR5cGUgIT09IG5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgcmV0ICs9IGVvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHJldCArPSBnZW5lcmF0ZUh0bWxSZWN1cnNpdmUoY2hpbGRyZW5baV0sIGNoaWxkTm9kZXNSYXdUZXh0LCBjdXJJbmRlbnQgKyBpbmRlbnRVbml0KSB8fCAoaSA9PT0gMCAmJiBjaGlsZHJlbi5sZW5ndGggPiAxID8gZW9sIDogXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLm5vZGVUeXBlICE9PSBub2RlLlRFWFRfTk9ERSB8fCByZXQuY2hhckF0KHJldC5sZW5ndGggLSAxKSA9PT0gZW9sKSB7XHJcbiAgICAgICAgICAgICAgcmV0ICs9IGN1ckluZGVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXQgKz0gY3VycmVudC5lbmQgKyBlb2w7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXQgKz0gKChyYXdUZXh0ID8gbm9kZS5ub2RlVmFsdWUgOiBIVE1MRW5jb2RlKG5vZGUubm9kZVZhbHVlLCBmYWxzZSkpIHx8ICcnKSArIGN1cnJlbnQuZW5kICsgZW9sO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJIRUFEXCIgfHwgbm9kZS5ub2RlTmFtZSA9PT0gXCJCT0RZXCIpIHJldCArPSBlb2w7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2Ugbm9kZS5URVhUX05PREU6XHJcbiAgICAgICAgICAvLyBTa2lwIHB1cmUgd2hpdGVzcGFjZSBub2RlcyBpZiB3ZSdyZSBpbmRlbnRpbmdcclxuICAgICAgICAgIGlmICghaW5kZW50VW5pdCB8fCAhL15bXFxzXFxuXSokLy50ZXN0KG5vZGUubm9kZVZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXQgKz0gKHJhd1RleHQgPyBub2RlLm5vZGVWYWx1ZSA6IEhUTUxFbmNvZGUobm9kZS5ub2RlVmFsdWUsIGZhbHNlKSkgfHwgJyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIG5vZGUuQ09NTUVOVF9OT0RFOlxyXG4gICAgICAgICAgcmV0ICs9IGN1ckluZGVudCArICc8IS0tJyArIG5vZGUubm9kZVZhbHVlICsgJy0tPicgKyBlb2w7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIG5vZGUuRE9DVU1FTlRfTk9ERTpcclxuICAgICAgICAgIGZvciAoaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXQgKz0gZ2VuZXJhdGVIdG1sUmVjdXJzaXZlKG5vZGUuY2hpbGROb2Rlc1tpXSwgY2hpbGROb2Rlc1Jhd1RleHQsIGN1ckluZGVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIG5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFOlxyXG4gICAgICAgICAgcmV0ICs9IHN0cmluZ2lmeURvY3R5cGUobm9kZSk7XHJcbiAgICAgICAgICByZXQgKz0gZW9sOyAvLyBUd28gbmV3bGluZXMgYWZ0ZXIgZG9jdHlwZVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmRvbVRvSHRtbCA9IGZ1bmN0aW9uKGRvbSwgbm9mb3JtYXQsIHJhdykge1xyXG4gIHZhciBodG1sR2VuZXJhdG9yID0gZXhwb3J0cy5tYWtlSHRtbEdlbmVyYXRvcihub2Zvcm1hdCA/IFwiXCIgOiBcIiAgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZm9ybWF0ID8gXCJcIiA6IFwiXFxuXCIpO1xyXG4gIGlmIChkb20udG9BcnJheSkge1xyXG4gICAgLy8gbm9kZSBsaXN0XHJcbiAgICBkb20gPSBkb20udG9BcnJheSgpO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGRvbS5sZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB2YXIgcmV0ID0gXCJcIjtcclxuICAgIGZvciAodmFyIGk9MCxsZW49ZG9tLmxlbmd0aDsgaTxsZW47IGkrKykge1xyXG4gICAgICByZXQgKz0gaHRtbEdlbmVyYXRvcihkb21baV0sIHJhdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBzaW5nbGUgbm9kZVxyXG4gICAgcmV0dXJuIGh0bWxHZW5lcmF0b3IoZG9tLCByYXcpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiA/IGV4cG9ydHMgOiBkb21pbmF0cml4ID0ge30pOyIsIi8qKlxyXG4gKiBPcGVyYXRpdmVcclxuICogLS0tXHJcbiAqIE9wZXJhdGl2ZSBpcyBhIHNtYWxsIEpTIHV0aWxpdHkgZm9yIHNlYW1sZXNzbHkgY3JlYXRpbmcgV2ViIFdvcmtlciBzY3JpcHRzLlxyXG4gKiAtLS1cclxuICogQGF1dGhvciBKYW1lcyBQYWRvbHNleSBodHRwOi8vamFtZXMucGFkb2xzZXkuY29tXHJcbiAqIEByZXBvIGh0dHA6Ly9naXRodWIuY29tL3BhZG9sc2V5L29wZXJhdGl2ZVxyXG4gKiBAdmVyc2lvbiAwLjIuMVxyXG4gKiBAbGljZW5zZSBNSVRcclxuICovXHJcbihmdW5jdGlvbigpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5pbXBvcnRTY3JpcHRzKSB7XHJcblx0XHQvLyBJJ20gYSB3b3JrZXIhIFJ1biB0aGUgYm9pbGVyLXNjcmlwdDpcclxuXHRcdC8vIChPcGVyYXRpdmUgaXRzZWxmIGlzIGNhbGxlZCBpbiBJRTEwIGFzIGEgd29ya2VyLFxyXG5cdFx0Ly8gIHRvIGF2b2lkIFNlY3VyaXR5RXJyb3JzKVxyXG5cdFx0d29ya2VyQm9pbGVyU2NyaXB0KCk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHR2YXIgc2xpY2UgPSBbXS5zbGljZTtcclxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XHJcblxyXG5cdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xyXG5cdHZhciBvcFNjcmlwdCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXTtcclxuXHR2YXIgb3BTY3JpcHRVUkwgPSAvb3BlcmF0aXZlLy50ZXN0KG9wU2NyaXB0LnNyYykgJiYgb3BTY3JpcHQuc3JjO1xyXG5cclxuXHQvLyBEZWZhdWx0IGJhc2UgVVJMICh0byBiZSBwcmVwZW5kZWQgdG8gcmVsYXRpdmUgZGVwZW5kZW5jeSBVUkxzKVxyXG5cdC8vIGlzIGN1cnJlbnQgcGFnZSdzIHBhcmVudCBkaXI6XHJcblx0dmFyIGJhc2VVUkwgPSAoXHJcblx0XHRsb2NhdGlvbi5wcm90b2NvbCArICcvLycgK1xyXG5cdFx0bG9jYXRpb24uaG9zdG5hbWUgK1xyXG5cdFx0KGxvY2F0aW9uLnBvcnQ/JzonK2xvY2F0aW9uLnBvcnQ6JycpICtcclxuXHRcdGxvY2F0aW9uLnBhdGhuYW1lXHJcblx0KS5yZXBsYWNlKC9bXlxcL10rJC8sICcnKTtcclxuXHJcblx0dmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcclxuXHR2YXIgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlcjtcclxuXHJcblx0dmFyIHdvcmtlclZpYUJsb2JTdXBwb3J0ID0gKGZ1bmN0aW9uKCkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0bmV3IFdvcmtlcihtYWtlQmxvYlVSSSgnOycpKTtcclxuXHRcdH0gY2F0Y2goZSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KCkpO1xyXG5cclxuXHQvKipcclxuXHQgKiBQcm92aWRlIE9iamVjdC5jcmVhdGUgc2hpbVxyXG5cdCAqL1xyXG5cdHZhciBvYmpDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKG8pIHtcclxuXHRcdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdFx0Ri5wcm90b3R5cGUgPSBvO1xyXG5cdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gbWFrZUJsb2JVUkkoc2NyaXB0KSB7XHJcblx0XHR2YXIgYmxvYjtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHRibG9iID0gbmV3IEJsb2IoW3NjcmlwdF0sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XHJcblx0XHR9IGNhdGNoIChlKSB7IFxyXG5cdFx0XHRibG9iID0gbmV3IEJsb2JCdWlsZGVyKCk7XHJcblx0XHRcdGJsb2IuYXBwZW5kKHNjcmlwdCk7XHJcblx0XHRcdGJsb2IgPSBibG9iLmdldEJsb2IoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHR9XHJcblxyXG5cdC8vIEluZGljYXRlcyB3aGV0aGVyIG9wZXJhdGl2ZXMgd2lsbCBydW4gd2l0aGluIHdvcmtlcnM6XHJcblx0b3BlcmF0aXZlLmhhc1dvcmtlclN1cHBvcnQgPSAhIXdpbmRvdy5Xb3JrZXI7XHJcblxyXG5cdG9wZXJhdGl2ZS5Qcm9taXNlID0gd2luZG93LlByb21pc2U7XHJcblxyXG5cdC8vIEV4cG9zZTpcclxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gb3BlcmF0aXZlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aW5kb3cub3BlcmF0aXZlID0gb3BlcmF0aXZlO1xyXG5cdH1cclxuXHRcclxuXHJcblx0b3BlcmF0aXZlLnNldFNlbGZVUkwgPSBmdW5jdGlvbih1cmwpIHtcclxuXHRcdG9wU2NyaXB0VVJMID0gdXJsO1xyXG5cdH07XHJcblxyXG5cdG9wZXJhdGl2ZS5zZXRCYXNlVVJMID0gZnVuY3Rpb24oYmFzZSkge1xyXG5cdFx0YmFzZVVSTCA9IGJhc2U7XHJcblx0fTtcclxuXHJcblx0b3BlcmF0aXZlLmdldEJhc2VVUkwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBiYXNlVVJMO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIE9wZXJhdGl2ZTogRXhwb3NlZCBPcGVyYXRpdmUgQ29uc3RydWN0b3JcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIE9iamVjdCBjb250YWluaW5nIG1ldGhvZHMvcHJvcGVydGllc1xyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIE9wZXJhdGl2ZShtb2R1bGUsIGRlcGVuZGVuY2llcykge1xyXG5cclxuXHRcdHZhciBfc2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0bW9kdWxlLmdldCA9IG1vZHVsZS5nZXQgfHwgZnVuY3Rpb24ocHJvcCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpc1twcm9wXTtcclxuXHRcdH07XHJcblxyXG5cdFx0bW9kdWxlLnNldCA9IG1vZHVsZS5zZXQgfHwgZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXNbcHJvcF0gPSB2YWx1ZTtcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5fY3VyVG9rZW4gPSAwO1xyXG5cdFx0dGhpcy5fcXVldWUgPSBbXTtcclxuXHJcblx0XHR0aGlzLmlzRGVzdHJveWVkID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzQ29udGV4dFJlYWR5ID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5tb2R1bGUgPSBtb2R1bGU7XHJcblx0XHR0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcyB8fCBbXTtcclxuXHJcblx0XHR0aGlzLmRhdGFQcm9wZXJ0aWVzID0ge307XHJcblx0XHR0aGlzLmFwaSA9IHt9O1xyXG5cdFx0dGhpcy5jYWxsYmFja3MgPSB7fTtcclxuXHRcdHRoaXMuZGVmZXJyZWRzID0ge307XHJcblxyXG5cdFx0dGhpcy5fZml4RGVwZW5kZW5jeVVSTHMoKTtcclxuXHRcdHRoaXMuX3NldHVwKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgbWV0aG9kTmFtZSBpbiBtb2R1bGUpIHtcclxuXHRcdFx0aWYgKGhhc093bi5jYWxsKG1vZHVsZSwgbWV0aG9kTmFtZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9jcmVhdGVFeHBvc2VkTWV0aG9kKG1ldGhvZE5hbWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hcGkuX19vcGVyYXRpdmVfXyA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gUHJvdmlkZSB0aGUgaW5zdGFuY2UncyBkZXN0cm95IG1ldGhvZCBvbiB0aGUgZXhwb3NlZCBBUEk6XHJcblx0XHR0aGlzLmFwaS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBfc2VsZi5kZXN0cm95KCk7XHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdE9wZXJhdGl2ZS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdFx0X21hcnNoYWw6IGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0cmV0dXJuIHY7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9kZW1hcnNoYWw6IGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0cmV0dXJuIHY7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9lbnF1ZXVlOiBmdW5jdGlvbihmbikge1xyXG5cdFx0XHR0aGlzLl9xdWV1ZS5wdXNoKGZuKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X2ZpeERlcGVuZGVuY3lVUkxzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGRlcHMgPSB0aGlzLmRlcGVuZGVuY2llcztcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkZXBzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG5cdFx0XHRcdHZhciBkZXAgPSBkZXBzW2ldO1xyXG5cdFx0XHRcdGlmICghL1xcL1xcLy8udGVzdChkZXApKSB7XHJcblx0XHRcdFx0XHRkZXBzW2ldID0gZGVwLnJlcGxhY2UoL15cXC8/LywgYmFzZVVSTCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdF9kZXF1ZXVlQWxsOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuXHRcdFx0XHR0aGlzLl9xdWV1ZVtpXS5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3F1ZXVlID0gW107XHJcblx0XHR9LFxyXG5cclxuXHRcdF9idWlsZENvbnRleHRTY3JpcHQ6IGZ1bmN0aW9uKGJvaWxlclNjcmlwdCkge1xyXG5cclxuXHRcdFx0dmFyIHNjcmlwdCA9IFtdO1xyXG5cdFx0XHR2YXIgbW9kdWxlID0gdGhpcy5tb2R1bGU7XHJcblx0XHRcdHZhciBkYXRhUHJvcGVydGllcyA9IHRoaXMuZGF0YVByb3BlcnRpZXM7XHJcblx0XHRcdHZhciBwcm9wZXJ0eTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgaW4gbW9kdWxlKSB7XHJcblx0XHRcdFx0cHJvcGVydHkgPSBtb2R1bGVbaV07XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRzY3JpcHQucHVzaCgnICAgc2VsZltcIicgKyBpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIl0gPSAnICsgcHJvcGVydHkudG9TdHJpbmcoKSArICc7Jyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGRhdGFQcm9wZXJ0aWVzW2ldID0gcHJvcGVydHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc2NyaXB0LmpvaW4oJ1xcbicpICsgKFxyXG5cdFx0XHRcdGJvaWxlclNjcmlwdCA/ICdcXG4oJyArIGJvaWxlclNjcmlwdC50b1N0cmluZygpICsgJygpKTsnIDogJydcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF9jcmVhdGVFeHBvc2VkTWV0aG9kOiBmdW5jdGlvbihtZXRob2ROYW1lKSB7XHJcblxyXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0XHR0aGlzLmFwaVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRpZiAoc2VsZi5pc0Rlc3Ryb3llZCkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpdmU6IENhbm5vdCBydW4gbWV0aG9kLiBPcGVyYXRpdmUgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQnKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB0b2tlbiA9ICsrc2VsZi5fY3VyVG9rZW47XHJcblx0XHRcdFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0dmFyIGNiID0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nICYmIGFyZ3MucG9wKCk7XHJcblxyXG5cdFx0XHRcdGlmICghY2IgJiYgIW9wZXJhdGl2ZS5Qcm9taXNlKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXHJcblx0XHRcdFx0XHRcdCdPcGVyYXRpdmU6IE5vIGNhbGxiYWNrIGhhcyBiZWVuIHBhc3NlZC4gQXNzdW1lZCB0aGF0IHlvdSB3YW50IGEgcHJvbWlzZS4gJyArXHJcblx0XHRcdFx0XHRcdCdCdXQgYG9wZXJhdGl2ZS5Qcm9taXNlYCBpcyBudWxsLiBQbGVhc2UgcHJvdmlkZSBQcm9taXNlIHBvbHlmaWxsL2xpYi4nXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGNiKSB7XHJcblxyXG5cdFx0XHRcdFx0c2VsZi5jYWxsYmFja3NbdG9rZW5dID0gY2I7XHJcblxyXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIGVpdGhlciBjb250ZXh0IHJ1bnMgdGhlIG1ldGhvZCBhc3luYzpcclxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHJ1bk1ldGhvZCgpO1xyXG5cdFx0XHRcdFx0fSwgMSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAob3BlcmF0aXZlLlByb21pc2UpIHtcclxuXHJcblx0XHRcdFx0XHQvLyBObyBDYWxsYmFjayAtLSBQcm9taXNlIHVzZWQ6XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBvcGVyYXRpdmUuUHJvbWlzZShmdW5jdGlvbihkZWZlcnJlZCkge1xyXG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5mdWxmaWwgPSBkZWZlcnJlZC5mdWxmaWxsO1xyXG5cdFx0XHRcdFx0XHRzZWxmLmRlZmVycmVkc1t0b2tlbl0gPSBkZWZlcnJlZDtcclxuXHRcdFx0XHRcdFx0cnVuTWV0aG9kKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBydW5NZXRob2QoKSB7XHJcblx0XHRcdFx0XHRpZiAoc2VsZi5pc0NvbnRleHRSZWFkeSkge1xyXG5cdFx0XHRcdFx0XHRzZWxmLl9ydW5NZXRob2QobWV0aG9kTmFtZSwgdG9rZW4sIGFyZ3MpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5fZW5xdWV1ZShydW5NZXRob2QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIE9wZXJhdGl2ZSBXb3JrZXJcclxuXHQgKi9cclxuXHRPcGVyYXRpdmUuV29ya2VyID0gZnVuY3Rpb24gV29ya2VyKG1vZHVsZSkge1xyXG5cdFx0dGhpcy5fbXNnUXVldWUgPSBbXTtcclxuXHRcdE9wZXJhdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdH07XHJcblxyXG5cdHZhciBXb3JrZXJQcm90byA9IE9wZXJhdGl2ZS5Xb3JrZXIucHJvdG90eXBlID0gb2JqQ3JlYXRlKE9wZXJhdGl2ZS5wcm90b3R5cGUpO1xyXG5cclxuXHRXb3JrZXJQcm90by5fb25Xb3JrZXJNZXNzYWdlID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0dmFyIGRhdGEgPSBlLmRhdGE7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmluZGV4T2YoJ3BpbmdiYWNrJykgPT09IDApIHtcclxuXHRcdFx0aWYgKGRhdGEgPT09ICdwaW5nYmFjazpzdHJ1Y3R1cmVkQ2xvbmluZ1N1cHBvcnQ9Tk8nKSB7XHJcblx0XHRcdFx0Ly8gTm8gc3RydWN0dXJlZENsb25pbmdTdXBwb3J0IHN1cHBvcnQgKG1hcnNoYWwgSlNPTiBmcm9tIG5vdyBvbik6XHJcblx0XHRcdFx0dGhpcy5fbWFyc2hhbCA9IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG8pOyB9O1xyXG5cdFx0XHRcdHRoaXMuX2RlbWFyc2hhbCA9IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIEpTT04ucGFyc2Uobyk7IH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuaXNDb250ZXh0UmVhZHkgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9wb3N0TWVzc2FnZSh7XHJcblx0XHRcdFx0ZGVmaW5pdGlvbnM6IHRoaXMuZGF0YVByb3BlcnRpZXNcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX2RlcXVldWVBbGwoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhID0gdGhpcy5fZGVtYXJzaGFsKGRhdGEpO1xyXG5cclxuXHRcdHN3aXRjaCAoZGF0YS5jbWQpIHtcclxuXHRcdFx0Y2FzZSAnY29uc29sZSc6XHJcblx0XHRcdFx0d2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGVbZGF0YS5tZXRob2RdLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBkYXRhLmFyZ3MpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdyZXN1bHQnOlxyXG5cclxuXHRcdFx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1tkYXRhLnRva2VuXTtcclxuXHRcdFx0XHR2YXIgZGVmZXJyZWQgPSB0aGlzLmRlZmVycmVkc1tkYXRhLnRva2VuXTtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2RhdGEudG9rZW5dO1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmVycmVkc1tkYXRhLnRva2VuXTtcclxuXHJcblx0XHRcdFx0dmFyIGRlZmVycmVkQWN0aW9uID0gZGF0YS5yZXN1bHQgJiYgZGF0YS5yZXN1bHQuaXNEZWZlcnJlZCAmJiBkYXRhLnJlc3VsdC5hY3Rpb247XHJcblxyXG5cdFx0XHRcdGlmIChkZWZlcnJlZCAmJiBkZWZlcnJlZEFjdGlvbikge1xyXG5cdFx0XHRcdFx0ZGVmZXJyZWRbZGVmZXJyZWRBY3Rpb25dKGRhdGEucmVzdWx0LmFyZ3NbMF0pO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRhdGEucmVzdWx0LmFyZ3MpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0V29ya2VyUHJvdG8uX3NldHVwID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIHdvcmtlcjtcclxuXHRcdHZhciBzY3JpcHQgPSB0aGlzLl9idWlsZENvbnRleHRTY3JpcHQoXHJcblx0XHRcdC8vIFRoZSBzY3JpcHQgaXMgbm90IGluY2x1ZGVkIGlmIHdlJ3JlIEV2YWwnaW5nIHRoaXMgZmlsZSBkaXJlY3RseTpcclxuXHRcdFx0d29ya2VyVmlhQmxvYlN1cHBvcnQgPyB3b3JrZXJCb2lsZXJTY3JpcHQgOiAnJ1xyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAodGhpcy5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XHJcblx0XHRcdHNjcmlwdCA9ICdpbXBvcnRTY3JpcHRzKFwiJyArIHRoaXMuZGVwZW5kZW5jaWVzLmpvaW4oJ1wiLCBcIicpICsgJ1wiKTtcXG4nICsgc2NyaXB0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3b3JrZXJWaWFCbG9iU3VwcG9ydCkge1xyXG5cdFx0XHR3b3JrZXIgPSB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoIG1ha2VCbG9iVVJJKHNjcmlwdCkgKTtcclxuXHRcdH0gIGVsc2Uge1xyXG5cdFx0XHRpZiAoIW9wU2NyaXB0VVJMKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcGVyYXJpdHZlOiBObyBvcGVyYXRpdmUuanMgVVJMIGF2YWlsYWJsZS4gUGxlYXNlIHNldCB2aWEgb3BlcmF0aXZlLnNldFNlbGZVUkwoLi4uKScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHdvcmtlciA9IHRoaXMud29ya2VyID0gbmV3IFdvcmtlciggb3BTY3JpcHRVUkwgKTtcclxuXHRcdFx0Ly8gTWFyc2hhbC1hZ25vc3RpYyBpbml0aWFsIG1lc3NhZ2UgaXMgYm9pbGVyLWNvZGU6XHJcblx0XHRcdC8vIChXZSBkb24ndCB5ZXQga25vdyBpZiBzdHJ1Y3R1cmVkLWNsb25pbmcgaXMgc3VwcG9ydGVkIHNvIHdlIHNlbmQgYSBzdHJpbmcpXHJcblx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZSgnRVZBTHwnICsgc2NyaXB0KTtcclxuXHRcdH1cclxuXHJcblx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoWydQSU5HJ10pOyAvLyBJbml0aWFsIFBJTkdcclxuXHJcblx0XHR3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0c2VsZi5fb25Xb3JrZXJNZXNzYWdlKGUpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0V29ya2VyUHJvdG8uX3Bvc3RNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XHJcblx0XHRyZXR1cm4gdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UodGhpcy5fbWFyc2hhbChtc2cpKTtcclxuXHR9O1xyXG5cclxuXHRXb3JrZXJQcm90by5fcnVuTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSwgdG9rZW4sIGFyZ3MpIHtcclxuXHRcdHRoaXMuX3Bvc3RNZXNzYWdlKHtcclxuXHRcdFx0bWV0aG9kOiBtZXRob2ROYW1lLFxyXG5cdFx0XHRhcmdzOiBhcmdzLFxyXG5cdFx0XHR0b2tlbjogdG9rZW5cclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFdvcmtlclByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xyXG5cdFx0T3BlcmF0aXZlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIE9wZXJhdGl2ZSBJRnJhbWVcclxuXHQgKi9cclxuXHRPcGVyYXRpdmUuSWZyYW1lID0gZnVuY3Rpb24gSWZyYW1lKG1vZHVsZSkge1xyXG5cdFx0T3BlcmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0fTtcclxuXHJcblx0dmFyIElmcmFtZVByb3RvID0gT3BlcmF0aXZlLklmcmFtZS5wcm90b3R5cGUgPSBvYmpDcmVhdGUoT3BlcmF0aXZlLnByb3RvdHlwZSk7XHJcblxyXG5cdHZhciBfbG9hZGVkTWV0aG9kTmFtZUkgPSAwO1xyXG5cclxuXHRJZnJhbWVQcm90by5fc2V0dXAgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR2YXIgbG9hZGVkTWV0aG9kTmFtZSA9ICdfX29wZXJhdGl2ZUlGcmFtZUxvYWRlZCcgKyArK19sb2FkZWRNZXRob2ROYW1lSTtcclxuXHJcblx0XHR0aGlzLm1vZHVsZS5pc1dvcmtlciA9IGZhbHNlO1xyXG5cclxuXHRcdHZhciBpZnJhbWUgPSB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoXHJcblx0XHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXHJcblx0XHQpO1xyXG5cclxuXHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuXHRcdHZhciBpV2luID0gdGhpcy5pZnJhbWVXaW5kb3cgPSBpZnJhbWUuY29udGVudFdpbmRvdztcclxuXHRcdHZhciBpRG9jID0gaVdpbi5kb2N1bWVudDtcclxuXHJcblx0XHQvLyBDcm9zcyBicm93c2VyICh0ZXN0ZWQgaW4gSUU4LDkpIHdheSB0byBjYWxsIG1ldGhvZCBmcm9tIHdpdGhpblxyXG5cdFx0Ly8gSUZSQU1FIGFmdGVyIGFsbCA8U2NyaXB0PnMgaGF2ZSBsb2FkZWQ6XHJcblx0XHR3aW5kb3dbbG9hZGVkTWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdHdpbmRvd1tsb2FkZWRNZXRob2ROYW1lXSA9IG51bGw7XHJcblxyXG5cdFx0XHR2YXIgc2NyaXB0ID0gaURvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuXHRcdFx0dmFyIGpzID0gc2VsZi5fYnVpbGRDb250ZXh0U2NyaXB0KGlmcmFtZUJvaWxlclNjcmlwdCk7XHJcblxyXG5cdFx0XHRpZiAoc2NyaXB0LnRleHQgIT09IHZvaWQgMCkge1xyXG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0ganM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c2NyaXB0LmlubmVySFRNTCA9IGpzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpRG9jLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSBpbiBzZWxmLmRhdGFQcm9wZXJ0aWVzKSB7XHJcblx0XHRcdFx0aVdpbltpXSA9IHNlbGYuZGF0YVByb3BlcnRpZXNbaV07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNlbGYuaXNDb250ZXh0UmVhZHkgPSB0cnVlO1xyXG5cdFx0XHRzZWxmLl9kZXF1ZXVlQWxsKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRpRG9jLm9wZW4oKTtcclxuXHRcdGlmICh0aGlzLmRlcGVuZGVuY2llcy5sZW5ndGgpIHtcclxuXHRcdFx0aURvYy53cml0ZShcclxuXHRcdFx0XHQnPHNjcmlwdCBzcmM9XCInICsgdGhpcy5kZXBlbmRlbmNpZXMuam9pbignXCI+PC9zY3JpcHQ+PHNjcmlwdCBzcmM9XCInKSArICdcIj48L3NjcmlwdD4nXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHQvLyBQbGFjZSA8c2NyaXB0PiBhdCBib3R0b20gdG8gdGVsbCBwYXJlbnQtcGFnZSB3aGVuIGRlcGVuZGVuY2llcyBhcmUgbG9hZGVkOlxyXG5cdFx0aURvYy53cml0ZSgnPHNjcmlwdD53aW5kb3cudG9wLicgKyBsb2FkZWRNZXRob2ROYW1lICsgJygpOzwvc2NyaXB0PicpO1xyXG5cdFx0aURvYy5jbG9zZSgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRJZnJhbWVQcm90by5fcnVuTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSwgdG9rZW4sIGFyZ3MpIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW3Rva2VuXTtcclxuXHRcdHZhciBkZWZlcnJlZCA9IHRoaXMuZGVmZXJyZWRzW3Rva2VuXTtcclxuXHRcdGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1t0b2tlbl07XHJcblx0XHRkZWxldGUgdGhpcy5kZWZlcnJlZHNbdG9rZW5dO1xyXG5cdFx0dGhpcy5pZnJhbWVXaW5kb3cuX19ydW5fXyhtZXRob2ROYW1lLCBhcmdzLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGNiID0gY2FsbGJhY2s7XHJcblx0XHRcdGlmIChjYikge1xyXG5cdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcclxuXHRcdFx0XHRjYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignT3BlcmF0aXZlOiBZb3UgaGF2ZSBhbHJlYWR5IHJldHVybmVkLicpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCBkZWZlcnJlZCk7XHJcblx0fTtcclxuXHJcblx0SWZyYW1lUHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5pZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmlmcmFtZSk7XHJcblx0XHRPcGVyYXRpdmUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuXHR9O1xyXG5cclxuXHRvcGVyYXRpdmUuT3BlcmF0aXZlID0gT3BlcmF0aXZlO1xyXG5cclxuXHQvKipcclxuXHQgKiBFeHBvc2VkIG9wZXJhdGl2ZSBmYWN0b3J5XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gb3BlcmF0aXZlKG1vZHVsZSwgZGVwZW5kZW5jaWVzKSB7XHJcblxyXG5cdFx0dmFyIE9wZXJhdGl2ZUNvbnRleHQgPSBvcGVyYXRpdmUuaGFzV29ya2VyU3VwcG9ydCA/XHJcblx0XHRcdE9wZXJhdGl2ZS5Xb3JrZXIgOiBPcGVyYXRpdmUuSWZyYW1lO1xyXG5cclxuXHRcdGlmICh0eXBlb2YgbW9kdWxlID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Ly8gQWxsb3cgYSBzaW5nbGUgZnVuY3Rpb24gdG8gYmUgcGFzc2VkLlxyXG5cdFx0XHR2YXIgbyA9IG5ldyBPcGVyYXRpdmVDb250ZXh0KHsgbWFpbjogbW9kdWxlIH0sIGRlcGVuZGVuY2llcyk7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gby5hcGkubWFpbi5hcHBseShvLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgT3BlcmF0aXZlQ29udGV4dChtb2R1bGUsIGRlcGVuZGVuY2llcykuYXBpO1xyXG5cclxuXHR9XHJcblxyXG4vKipcclxuICogVGhlIGJvaWxlcnBsYXRlIGZvciB0aGUgSWZyYW1lIENvbnRleHRcclxuICogTk9URTpcclxuICogIHRoaXMnbGwgYmUgZXhlY3V0ZWQgd2l0aGluIGFuIGlmcmFtZSwgbm90IGhlcmUuXHJcbiAqICBJbmRlbnRlZCBAIFplcm8gdG8gbWFrZSBuaWNlciBkZWJ1ZyBjb2RlIHdpdGhpbiB3b3JrZXJcclxuICovXHJcbmZ1bmN0aW9uIGlmcmFtZUJvaWxlclNjcmlwdCgpIHtcclxuXHJcblx0Ly8gQ2FsbGVkIGZyb20gcGFyZW50LXdpbmRvdzpcclxuXHR3aW5kb3cuX19ydW5fXyA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGFyZ3MsIGNiLCBkZWZlcnJlZCkge1xyXG5cclxuXHRcdHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0XHR2YXIgaXNEZWZlcnJlZCA9IGZhbHNlO1xyXG5cclxuXHRcdHdpbmRvdy5hc3luYyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpc0FzeW5jID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIGNiO1xyXG5cdFx0fTtcclxuXHJcblx0XHR3aW5kb3cuZGVmZXJyZWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXNEZWZlcnJlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybiBkZWZlcnJlZDtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGNiKSB7XHJcblx0XHRcdGFyZ3MucHVzaChjYik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IHdpbmRvd1ttZXRob2ROYW1lXS5hcHBseSh3aW5kb3csIGFyZ3MpO1xyXG5cclxuXHRcdHdpbmRvdy5hc3luYyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGl2ZTogYXN5bmMoKSBjYWxsZWQgYXQgb2RkIHRpbWUnKTtcclxuXHRcdH07XHJcblxyXG5cdFx0d2luZG93LmRlZmVycmVkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignT3BlcmF0aXZlOiBkZWZlcnJlZCgpIGNhbGxlZCBhdCBvZGQgdGltZScpO1xyXG5cdFx0fTtcclxuXHJcblxyXG5cdFx0aWYgKCFpc0RlZmVycmVkICYmICFpc0FzeW5jICYmIHJlc3VsdCAhPT0gdm9pZCAwKSB7XHJcblx0XHRcdC8vIERlcHJlY2F0ZWQgZGlyZWN0LXJldHVybmluZyBhcyBvZiAwLjIuMFxyXG5cdFx0XHRjYihyZXN1bHQpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYm9pbGVycGxhdGUgZm9yIHRoZSBXb3JrZXIgQmxvYlxyXG4gKiBOT1RFOlxyXG4gKiAgdGhpcydsbCBiZSBleGVjdXRlZCB3aXRoaW4gYW4gaWZyYW1lLCBub3QgaGVyZS5cclxuICogIEluZGVudGVkIEAgWmVybyB0byBtYWtlIG5pY2VyIGRlYnVnIGNvZGUgd2l0aGluIHdvcmtlclxyXG4gKi9cclxuZnVuY3Rpb24gd29ya2VyQm9pbGVyU2NyaXB0KCkge1xyXG5cclxuXHR2YXIgcG9zdE1lc3NhZ2UgPSBzZWxmLnBvc3RNZXNzYWdlO1xyXG5cdHZhciBzdHJ1Y3R1cmVkQ2xvbmluZ1N1cHBvcnQgPSBudWxsO1xyXG5cclxuXHRzZWxmLmNvbnNvbGUgPSB7fTtcclxuXHRzZWxmLmlzV29ya2VyID0gdHJ1ZTtcclxuXHJcblx0Ly8gUHJvdmlkZSBiYXNpYyBjb25zb2xlIGludGVyZmFjZTpcclxuXHRbJ2xvZycsICdkZWJ1ZycsICdlcnJvcicsICdpbmZvJywgJ3dhcm4nLCAndGltZScsICd0aW1lRW5kJ10uZm9yRWFjaChmdW5jdGlvbihtZXRoKSB7XHJcblx0XHRzZWxmLmNvbnNvbGVbbWV0aF0gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cG9zdE1lc3NhZ2Uoe1xyXG5cdFx0XHRcdGNtZDogJ2NvbnNvbGUnLFxyXG5cdFx0XHRcdG1ldGhvZDogbWV0aCxcclxuXHRcdFx0XHRhcmdzOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH0pO1xyXG5cclxuXHRzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihlKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBlLmRhdGE7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnICYmIGRhdGEuaW5kZXhPZignRVZBTHwnKSA9PT0gMCkge1xyXG5cdFx0XHRldmFsKGRhdGEuc3Vic3RyaW5nKDUpKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdHJ1Y3R1cmVkQ2xvbmluZ1N1cHBvcnQgPT0gbnVsbCkge1xyXG5cclxuXHRcdFx0Ly8gZS5kYXRhIG9mIFsnUElORyddIChBbiBhcnJheSkgaW5kaWNhdGVzIHRyYW5zZmVycmFibGVPYmpTdXBwb3J0XHJcblx0XHRcdC8vIGUuZGF0YSBvZiAnXCJQSU5HXCInIChBIHN0cmluZykgaW5kaWNhdGVzIG5vIHN1cHBvcnQgKEFycmF5IGhhcyBiZWVuIHNlcmlhbGl6ZWQpXHJcblx0XHRcdHN0cnVjdHVyZWRDbG9uaW5nU3VwcG9ydCA9IGUuZGF0YVswXSA9PT0gJ1BJTkcnO1xyXG5cclxuXHRcdFx0Ly8gUGluZ2JhY2sgdG8gcGFyZW50IHBhZ2U6XHJcblx0XHRcdHNlbGYucG9zdE1lc3NhZ2UoXHJcblx0XHRcdFx0c3RydWN0dXJlZENsb25pbmdTdXBwb3J0ID9cclxuXHRcdFx0XHRcdCdwaW5nYmFjazpzdHJ1Y3R1cmVkQ2xvbmluZ1N1cHBvcnQ9WUVTJyA6XHJcblx0XHRcdFx0XHQncGluZ2JhY2s6c3RydWN0dXJlZENsb25pbmdTdXBwb3J0PU5PJ1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0aWYgKCFzdHJ1Y3R1cmVkQ2xvbmluZ1N1cHBvcnQpIHtcclxuXHRcdFx0XHRwb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xyXG5cdFx0XHRcdFx0Ly8gTWFyc2hhbCBiZWZvcmUgc2VuZGluZ1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkobXNnKSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghc3RydWN0dXJlZENsb25pbmdTdXBwb3J0KSB7XHJcblx0XHRcdC8vIERlbWFyc2hhbDpcclxuXHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRlZnMgPSBkYXRhLmRlZmluaXRpb25zO1xyXG5cdFx0dmFyIGlzRGVmZXJyZWQgPSBmYWxzZTtcclxuXHRcdHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0XHR2YXIgYXJncyA9IGRhdGEuYXJncztcclxuXHJcblx0XHRpZiAoZGVmcykge1xyXG5cdFx0XHQvLyBJbml0aWFsIGRlZmluaXRpb25zOlxyXG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZnMpIHtcclxuXHRcdFx0XHRzZWxmW2ldID0gZGVmc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0YXJncy5wdXNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHQvLyBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gb3BlcmF0aXZlIG1ldGhvZFxyXG5cdFx0XHRyZXR1cm5SZXN1bHQoe1xyXG5cdFx0XHRcdGFyZ3M6IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHNlbGYuYXN5bmMgPSBmdW5jdGlvbigpIHsgLy8gQXN5bmMgZGVwcmVjYXRlZCBhcyBvZiAwLjIuMFxyXG5cdFx0XHRpc0FzeW5jID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm5SZXN1bHQoeyBhcmdzOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgfSk7IH07XHJcblx0XHR9O1xyXG5cclxuXHRcdHNlbGYuZGVmZXJyZWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXNEZWZlcnJlZCA9IHRydWU7XHJcblx0XHRcdHZhciBkZWYgPSB7fTtcclxuXHRcdFx0ZnVuY3Rpb24gZnVsZmlsbChyKSB7XHJcblx0XHRcdFx0cmV0dXJuUmVzdWx0KHtcclxuXHRcdFx0XHRcdGlzRGVmZXJyZWQ6IHRydWUsXHJcblx0XHRcdFx0XHRhY3Rpb246ICdmdWxmaWxsJyxcclxuXHRcdFx0XHRcdGFyZ3M6IFtyXVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybiBkZWY7XHJcblx0XHRcdH1cclxuXHRcdFx0ZnVuY3Rpb24gcmVqZWN0KHIpIHtcclxuXHRcdFx0XHRyZXR1cm5SZXN1bHQoe1xyXG5cdFx0XHRcdFx0aXNEZWZlcnJlZDogdHJ1ZSxcclxuXHRcdFx0XHRcdGFjdGlvbjogJ3JlamVjdCcsXHJcblx0XHRcdFx0XHRhcmdzOiBbcl1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkZWYuZnVsZmlsID0gZGVmLmZ1bGZpbGwgPSBmdWxmaWxsO1xyXG5cdFx0XHRkZWYucmVqZWN0ID0gcmVqZWN0O1xyXG5cdFx0XHRyZXR1cm4gZGVmO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBDYWxsIGFjdHVhbCBvcGVyYXRpdmUgbWV0aG9kOlxyXG5cdFx0dmFyIHJlc3VsdCA9IHNlbGZbZGF0YS5tZXRob2RdLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG5cclxuXHRcdGlmICghaXNEZWZlcnJlZCAmJiAhaXNBc3luYyAmJiByZXN1bHQgIT09IHZvaWQgMCkge1xyXG5cdFx0XHQvLyBEZXByZWNhdGVkIGRpcmVjdC1yZXR1cm5pbmcgYXMgb2YgMC4yLjBcclxuXHRcdFx0cmV0dXJuUmVzdWx0KHtcclxuXHRcdFx0XHRhcmdzOiBbcmVzdWx0XVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRzZWxmLmRlZmVycmVkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignT3BlcmF0aXZlOiBkZWZlcnJlZCgpIGNhbGxlZCBhdCBvZGQgdGltZScpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzZWxmLmFzeW5jID0gZnVuY3Rpb24oKSB7IC8vIEFzeW5jIGRlcHJlY2F0ZWQgYXMgb2YgMC4yLjBcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpdmU6IGFzeW5jKCkgY2FsbGVkIGF0IG9kZCB0aW1lJyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJldHVyblJlc3VsdChyZXMpIHtcclxuXHRcdFx0cG9zdE1lc3NhZ2Uoe1xyXG5cdFx0XHRcdGNtZDogJ3Jlc3VsdCcsXHJcblx0XHRcdFx0dG9rZW46IGRhdGEudG9rZW4sXHJcblx0XHRcdFx0cmVzdWx0OiByZXNcclxuXHRcdFx0fSk7XHJcblx0XHRcdC8vIE92ZXJyaWRlIHdpdGggZXJyb3ItdGhyb3dlciBpZiB3ZSd2ZSBhbHJlYWR5IHJldHVybmVkOlxyXG5cdFx0XHRyZXR1cm5SZXN1bHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGl2ZTogWW91IGhhdmUgYWxyZWFkeSByZXR1cm5lZC4nKTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxufSgpKTsiLCIoZnVuY3Rpb24oKXtcbmZ1bmN0aW9uIGUoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgfVxufVxuZnVuY3Rpb24gbShhKSB7XG4gIHJldHVybiBmdW5jdGlvbihiKSB7XG4gICAgdGhpc1thXSA9IGJcbiAgfVxufVxuZnVuY3Rpb24gYWEoYSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbYV1cbiAgfVxufVxuZnVuY3Rpb24gYmEoYSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFcbiAgfVxufVxudmFyIHAsIGNhID0gY2EgfHwge30sIHEgPSB0aGlzO1xuZnVuY3Rpb24gZGEoYSkge1xuICBhID0gYS5zcGxpdChcIi5cIik7XG4gIGZvcih2YXIgYiA9IHEsIGM7YyA9IGEuc2hpZnQoKTspIHtcbiAgICBpZihudWxsICE9IGJbY10pIHtcbiAgICAgIGIgPSBiW2NdXG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIGVhKCkge1xufVxuZnVuY3Rpb24gZmEoYSkge1xuICB2YXIgYiA9IHR5cGVvZiBhO1xuICBpZihcIm9iamVjdFwiID09IGIpIHtcbiAgICBpZihhKSB7XG4gICAgICBpZihhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuXCJhcnJheVwiXG4gICAgICB9XG4gICAgICBpZihhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiXG4gICAgICB9XG4gICAgICB2YXIgYyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtcbiAgICAgIGlmKFwiW29iamVjdCBXaW5kb3ddXCIgPT0gYykge1xuICAgICAgICByZXR1cm5cIm9iamVjdFwiXG4gICAgICB9XG4gICAgICBpZihcIltvYmplY3QgQXJyYXldXCIgPT0gYyB8fCBcIm51bWJlclwiID09IHR5cGVvZiBhLmxlbmd0aCAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLnNwbGljZSAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlICYmICFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwic3BsaWNlXCIpKSB7XG4gICAgICAgIHJldHVyblwiYXJyYXlcIlxuICAgICAgfVxuICAgICAgaWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiID09IGMgfHwgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5jYWxsICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUgJiYgIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJjYWxsXCIpKSB7XG4gICAgICAgIHJldHVyblwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIHJldHVyblwibnVsbFwiXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgaWYoXCJmdW5jdGlvblwiID09IGIgJiYgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgYS5jYWxsKSB7XG4gICAgICByZXR1cm5cIm9iamVjdFwiXG4gICAgfVxuICB9XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBzKGEpIHtcbiAgcmV0dXJuXCJhcnJheVwiID09IGZhKGEpXG59XG5mdW5jdGlvbiBnYShhKSB7XG4gIHZhciBiID0gZmEoYSk7XG4gIHJldHVyblwiYXJyYXlcIiA9PSBiIHx8IFwib2JqZWN0XCIgPT0gYiAmJiBcIm51bWJlclwiID09IHR5cGVvZiBhLmxlbmd0aFxufVxuZnVuY3Rpb24gdShhKSB7XG4gIHJldHVyblwic3RyaW5nXCIgPT0gdHlwZW9mIGFcbn1cbmZ1bmN0aW9uIGhhKGEpIHtcbiAgcmV0dXJuXCJmdW5jdGlvblwiID09IGZhKGEpXG59XG5mdW5jdGlvbiB2KGEpIHtcbiAgcmV0dXJuIGFbaWFdIHx8IChhW2lhXSA9ICsramEpXG59XG52YXIgaWEgPSBcImNsb3N1cmVfdWlkX1wiICsgKDFFOSAqIE1hdGgucmFuZG9tKCkgPj4+IDApLCBqYSA9IDA7XG5mdW5jdGlvbiBrYShhLCBiLCBjKSB7XG4gIHJldHVybiBhLmNhbGwuYXBwbHkoYS5iaW5kLCBhcmd1bWVudHMpXG59XG5mdW5jdGlvbiBsYShhLCBiLCBjKSB7XG4gIGlmKCFhKSB7XG4gICAgdGhyb3cgRXJyb3IoKTtcbiAgfVxuICBpZigyIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhciBkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLCBkKTtcbiAgICAgIHJldHVybiBhLmFwcGx5KGIsIGMpXG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYS5hcHBseShiLCBhcmd1bWVudHMpXG4gIH1cbn1cbmZ1bmN0aW9uIHcoYSwgYiwgYykge1xuICB3ID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiYgLTEgIT0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIikgPyBrYSA6IGxhO1xuICByZXR1cm4gdy5hcHBseShudWxsLCBhcmd1bWVudHMpXG59XG52YXIgeCA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICByZXR1cm4rbmV3IERhdGVcbn07XG5mdW5jdGlvbiB5KGEsIGIpIHtcbiAgZnVuY3Rpb24gYygpIHtcbiAgfVxuICBjLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnJhID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGNcbn1cbjtmdW5jdGlvbiBtYShhLCBiKSB7XG4gIGZvcih2YXIgYyA9IDE7YyA8IGFyZ3VtZW50cy5sZW5ndGg7YysrKSB7XG4gICAgdmFyIGQgPSBTdHJpbmcoYXJndW1lbnRzW2NdKS5yZXBsYWNlKC9cXCQvZywgXCIkJCQkXCIpO1xuICAgIGEgPSBhLnJlcGxhY2UoL1xcJXMvLCBkKVxuICB9XG4gIHJldHVybiBhXG59XG5mdW5jdGlvbiBuYShhKSB7XG4gIGlmKCFvYS50ZXN0KGEpKSB7XG4gICAgcmV0dXJuIGFcbiAgfVxuICAtMSAhPSBhLmluZGV4T2YoXCImXCIpICYmIChhID0gYS5yZXBsYWNlKHBhLCBcIiZhbXA7XCIpKTtcbiAgLTEgIT0gYS5pbmRleE9mKFwiPFwiKSAmJiAoYSA9IGEucmVwbGFjZShxYSwgXCImbHQ7XCIpKTtcbiAgLTEgIT0gYS5pbmRleE9mKFwiPlwiKSAmJiAoYSA9IGEucmVwbGFjZShyYSwgXCImZ3Q7XCIpKTtcbiAgLTEgIT0gYS5pbmRleE9mKCdcIicpICYmIChhID0gYS5yZXBsYWNlKHNhLCBcIiZxdW90O1wiKSk7XG4gIHJldHVybiBhXG59XG52YXIgcGEgPSAvJi9nLCBxYSA9IC88L2csIHJhID0gLz4vZywgc2EgPSAvXFxcIi9nLCBvYSA9IC9bJjw+XFxcIl0vO1xudmFyIHosIHRhLCB1YSwgdmE7XG5mdW5jdGlvbiB3YSgpIHtcbiAgcmV0dXJuIHEubmF2aWdhdG9yID8gcS5uYXZpZ2F0b3IudXNlckFnZW50IDogbnVsbFxufVxudmEgPSB1YSA9IHRhID0geiA9ICExO1xudmFyIHhhO1xuaWYoeGEgPSB3YSgpKSB7XG4gIHZhciB5YSA9IHEubmF2aWdhdG9yO1xuICB6ID0gMCA9PSB4YS5pbmRleE9mKFwiT3BlcmFcIik7XG4gIHRhID0gIXogJiYgLTEgIT0geGEuaW5kZXhPZihcIk1TSUVcIik7XG4gIHVhID0gIXogJiYgLTEgIT0geGEuaW5kZXhPZihcIldlYktpdFwiKTtcbiAgdmEgPSAheiAmJiAhdWEgJiYgXCJHZWNrb1wiID09IHlhLnByb2R1Y3Rcbn1cbnZhciB6YSA9IHosIEEgPSB0YSwgQWEgPSB2YSwgQiA9IHVhLCBCYSA9IHEubmF2aWdhdG9yLCBDYSA9IC0xICE9IChCYSAmJiBCYS5wbGF0Zm9ybSB8fCBcIlwiKS5pbmRleE9mKFwiTWFjXCIpO1xuZnVuY3Rpb24gRGEoKSB7XG4gIHZhciBhID0gcS5kb2N1bWVudDtcbiAgcmV0dXJuIGEgPyBhLmRvY3VtZW50TW9kZSA6IHZvaWQgMFxufVxudmFyIEVhO1xuYToge1xuICB2YXIgRmEgPSBcIlwiLCBHYTtcbiAgaWYoemEgJiYgcS5vcGVyYSkge1xuICAgIHZhciBIYSA9IHEub3BlcmEudmVyc2lvbiwgRmEgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIEhhID8gSGEoKSA6IEhhXG4gIH1lbHNlIHtcbiAgICBpZihBYSA/IEdhID0gL3J2XFw6KFteXFwpO10rKShcXCl8OykvIDogQSA/IEdhID0gL01TSUVcXHMrKFteXFwpO10rKShcXCl8OykvIDogQiAmJiAoR2EgPSAvV2ViS2l0XFwvKFxcUyspLyksIEdhKSB7XG4gICAgICB2YXIgSWEgPSBHYS5leGVjKHdhKCkpLCBGYSA9IElhID8gSWFbMV0gOiBcIlwiXG4gICAgfVxuICB9XG4gIGlmKEEpIHtcbiAgICB2YXIgSmEgPSBEYSgpO1xuICAgIGlmKEphID4gcGFyc2VGbG9hdChGYSkpIHtcbiAgICAgIEVhID0gU3RyaW5nKEphKTtcbiAgICAgIGJyZWFrIGFcbiAgICB9XG4gIH1cbiAgRWEgPSBGYVxufVxudmFyIEthID0ge307XG5mdW5jdGlvbiBDKGEpIHtcbiAgdmFyIGI7XG4gIGlmKCEoYiA9IEthW2FdKSkge1xuICAgIGIgPSAwO1xuICAgIGZvcih2YXIgYyA9IFN0cmluZyhFYSkucmVwbGFjZSgvXltcXHNcXHhhMF0rfFtcXHNcXHhhMF0rJC9nLCBcIlwiKS5zcGxpdChcIi5cIiksIGQgPSBTdHJpbmcoYSkucmVwbGFjZSgvXltcXHNcXHhhMF0rfFtcXHNcXHhhMF0rJC9nLCBcIlwiKS5zcGxpdChcIi5cIiksIGYgPSBNYXRoLm1heChjLmxlbmd0aCwgZC5sZW5ndGgpLCBnID0gMDswID09IGIgJiYgZyA8IGY7ZysrKSB7XG4gICAgICB2YXIgaCA9IGNbZ10gfHwgXCJcIiwgbiA9IGRbZ10gfHwgXCJcIiwgayA9IFJlZ0V4cChcIihcXFxcZCopKFxcXFxEKilcIiwgXCJnXCIpLCB0ID0gUmVnRXhwKFwiKFxcXFxkKikoXFxcXEQqKVwiLCBcImdcIik7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBsID0gay5leGVjKGgpIHx8IFtcIlwiLCBcIlwiLCBcIlwiXSwgciA9IHQuZXhlYyhuKSB8fCBbXCJcIiwgXCJcIiwgXCJcIl07XG4gICAgICAgIGlmKDAgPT0gbFswXS5sZW5ndGggJiYgMCA9PSByWzBdLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgYiA9ICgoMCA9PSBsWzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludChsWzFdLCAxMCkpIDwgKDAgPT0gclsxXS5sZW5ndGggPyAwIDogcGFyc2VJbnQoclsxXSwgMTApKSA/IC0xIDogKDAgPT0gbFsxXS5sZW5ndGggPyAwIDogcGFyc2VJbnQobFsxXSwgMTApKSA+ICgwID09IHJbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KHJbMV0sIDEwKSkgPyAxIDogMCkgfHwgKCgwID09IGxbMl0ubGVuZ3RoKSA8ICgwID09IHJbMl0ubGVuZ3RoKSA/IC0xIDogKDAgPT0gbFsyXS5sZW5ndGgpID4gKDAgPT0gclsyXS5sZW5ndGgpID8gMSA6IDApIHx8IChsWzJdIDwgclsyXSA/IC0xIDogbFsyXSA+IHJbMl0gPyAxIDogMClcbiAgICAgIH13aGlsZSgwID09IGIpXG4gICAgfVxuICAgIGIgPSBLYVthXSA9IDAgPD0gYlxuICB9XG4gIHJldHVybiBiXG59XG52YXIgTGEgPSBxLmRvY3VtZW50LCBNYSA9IExhICYmIEEgPyBEYSgpIHx8IChcIkNTUzFDb21wYXRcIiA9PSBMYS5jb21wYXRNb2RlID8gcGFyc2VJbnQoRWEsIDEwKSA6IDUpIDogdm9pZCAwO1xuZnVuY3Rpb24gTmEoYSkge1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5hKSA6IHRoaXMuc3RhY2sgPSBFcnJvcigpLnN0YWNrIHx8IFwiXCI7XG4gIGEgJiYgKHRoaXMubWVzc2FnZSA9IFN0cmluZyhhKSlcbn1cbnkoTmEsIEVycm9yKTtcbk5hLnByb3RvdHlwZS5uYW1lID0gXCJDdXN0b21FcnJvclwiO1xuZnVuY3Rpb24gT2EoYSwgYikge1xuICBiLnVuc2hpZnQoYSk7XG4gIE5hLmNhbGwodGhpcywgbWEuYXBwbHkobnVsbCwgYikpO1xuICBiLnNoaWZ0KCk7XG4gIHRoaXMuSmMgPSBhXG59XG55KE9hLCBOYSk7XG5PYS5wcm90b3R5cGUubmFtZSA9IFwiQXNzZXJ0aW9uRXJyb3JcIjtcbmZ1bmN0aW9uIFBhKGEsIGIpIHtcbiAgdGhyb3cgbmV3IE9hKFwiRmFpbHVyZVwiICsgKGEgPyBcIjogXCIgKyBhIDogXCJcIiksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xufVxuO3ZhciBRYSA9IFJlZ0V4cChcIl4oPzooW146Lz8jLl0rKTopPyg/Oi8vKD86KFteLz8jXSopQCk/KFteLyM/XSo/KSg/OjooWzAtOV0rKSk/KD89Wy8jP118JCkpPyhbXj8jXSspPyg/OlxcXFw/KFteI10qKSk/KD86IyguKikpPyRcIik7XG5mdW5jdGlvbiBSYShhKSB7XG4gIHZhciBiID0gU2EsIGM7XG4gIGZvcihjIGluIGIpIHtcbiAgICBhLmNhbGwodm9pZCAwLCBiW2NdLCBjLCBiKVxuICB9XG59XG5mdW5jdGlvbiBUYShhKSB7XG4gIHZhciBiID0gW10sIGMgPSAwLCBkO1xuICBmb3IoZCBpbiBhKSB7XG4gICAgYltjKytdID0gYVtkXVxuICB9XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBVYShhKSB7XG4gIHZhciBiID0gW10sIGMgPSAwLCBkO1xuICBmb3IoZCBpbiBhKSB7XG4gICAgYltjKytdID0gZFxuICB9XG4gIHJldHVybiBiXG59XG52YXIgVmEgPSBcImNvbnN0cnVjdG9yIGhhc093blByb3BlcnR5IGlzUHJvdG90eXBlT2YgcHJvcGVydHlJc0VudW1lcmFibGUgdG9Mb2NhbGVTdHJpbmcgdG9TdHJpbmcgdmFsdWVPZlwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIFdhKGEsIGIpIHtcbiAgZm9yKHZhciBjLCBkLCBmID0gMTtmIDwgYXJndW1lbnRzLmxlbmd0aDtmKyspIHtcbiAgICBkID0gYXJndW1lbnRzW2ZdO1xuICAgIGZvcihjIGluIGQpIHtcbiAgICAgIGFbY10gPSBkW2NdXG4gICAgfVxuICAgIGZvcih2YXIgZyA9IDA7ZyA8IFZhLmxlbmd0aDtnKyspIHtcbiAgICAgIGMgPSBWYVtnXSwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsIGMpICYmIChhW2NdID0gZFtjXSlcbiAgICB9XG4gIH1cbn1cbjt2YXIgRCA9IEFycmF5LnByb3RvdHlwZSwgWGEgPSBELmluZGV4T2YgPyBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIHJldHVybiBELmluZGV4T2YuY2FsbChhLCBiLCBjKVxufSA6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgYyA9IG51bGwgPT0gYyA/IDAgOiAwID4gYyA/IE1hdGgubWF4KDAsIGEubGVuZ3RoICsgYykgOiBjO1xuICBpZih1KGEpKSB7XG4gICAgcmV0dXJuIHUoYikgJiYgMSA9PSBiLmxlbmd0aCA/IGEuaW5kZXhPZihiLCBjKSA6IC0xXG4gIH1cbiAgZm9yKDtjIDwgYS5sZW5ndGg7YysrKSB7XG4gICAgaWYoYyBpbiBhICYmIGFbY10gPT09IGIpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICB9XG4gIHJldHVybi0xXG59LCBZYSA9IEQuZm9yRWFjaCA/IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgRC5mb3JFYWNoLmNhbGwoYSwgYiwgYylcbn0gOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGZvcih2YXIgZCA9IGEubGVuZ3RoLCBmID0gdShhKSA/IGEuc3BsaXQoXCJcIikgOiBhLCBnID0gMDtnIDwgZDtnKyspIHtcbiAgICBnIGluIGYgJiYgYi5jYWxsKGMsIGZbZ10sIGcsIGEpXG4gIH1cbn07XG5mdW5jdGlvbiBaYShhKSB7XG4gIHJldHVybiBELmNvbmNhdC5hcHBseShELCBhcmd1bWVudHMpXG59XG5mdW5jdGlvbiAkYShhKSB7XG4gIHZhciBiID0gYS5sZW5ndGg7XG4gIGlmKDAgPCBiKSB7XG4gICAgZm9yKHZhciBjID0gQXJyYXkoYiksIGQgPSAwO2QgPCBiO2QrKykge1xuICAgICAgY1tkXSA9IGFbZF1cbiAgICB9XG4gICAgcmV0dXJuIGNcbiAgfVxuICByZXR1cm5bXVxufVxuO2Z1bmN0aW9uIGFiKGEpIHtcbiAgaWYoXCJmdW5jdGlvblwiID09IHR5cGVvZiBhLk4pIHtcbiAgICByZXR1cm4gYS5OKClcbiAgfVxuICBpZih1KGEpKSB7XG4gICAgcmV0dXJuIGEuc3BsaXQoXCJcIilcbiAgfVxuICBpZihnYShhKSkge1xuICAgIGZvcih2YXIgYiA9IFtdLCBjID0gYS5sZW5ndGgsIGQgPSAwO2QgPCBjO2QrKykge1xuICAgICAgYi5wdXNoKGFbZF0pXG4gICAgfVxuICAgIHJldHVybiBiXG4gIH1cbiAgcmV0dXJuIFRhKGEpXG59XG5mdW5jdGlvbiBFKGEsIGIsIGMpIHtcbiAgaWYoXCJmdW5jdGlvblwiID09IHR5cGVvZiBhLmZvckVhY2gpIHtcbiAgICBhLmZvckVhY2goYiwgYylcbiAgfWVsc2Uge1xuICAgIGlmKGdhKGEpIHx8IHUoYSkpIHtcbiAgICAgIFlhKGEsIGIsIGMpXG4gICAgfWVsc2Uge1xuICAgICAgdmFyIGQ7XG4gICAgICBpZihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEua2EpIHtcbiAgICAgICAgZCA9IGEua2EoKVxuICAgICAgfWVsc2Uge1xuICAgICAgICBpZihcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGEuTikge1xuICAgICAgICAgIGlmKGdhKGEpIHx8IHUoYSkpIHtcbiAgICAgICAgICAgIGQgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgZiA9IGEubGVuZ3RoLCBnID0gMDtnIDwgZjtnKyspIHtcbiAgICAgICAgICAgICAgZC5wdXNoKGcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgZCA9IFVhKGEpXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgZCA9IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IodmFyIGYgPSBhYihhKSwgZyA9IGYubGVuZ3RoLCBoID0gMDtoIDwgZztoKyspIHtcbiAgICAgICAgYi5jYWxsKGMsIGZbaF0sIGQgJiYgZFtoXSwgYSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjtmdW5jdGlvbiBiYihhLCBiKSB7XG4gIHRoaXMuTyA9IHt9O1xuICB0aGlzLmogPSBbXTtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZigxIDwgYykge1xuICAgIGlmKGMgJSAyKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlVuZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzXCIpO1xuICAgIH1cbiAgICBmb3IodmFyIGQgPSAwO2QgPCBjO2QgKz0gMikge1xuICAgICAgdGhpcy5zZXQoYXJndW1lbnRzW2RdLCBhcmd1bWVudHNbZCArIDFdKVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGlmKGEpIHtcbiAgICAgIGEgaW5zdGFuY2VvZiBiYiA/IChjID0gYS5rYSgpLCBkID0gYS5OKCkpIDogKGMgPSBVYShhKSwgZCA9IFRhKGEpKTtcbiAgICAgIGZvcih2YXIgZiA9IDA7ZiA8IGMubGVuZ3RoO2YrKykge1xuICAgICAgICB0aGlzLnNldChjW2ZdLCBkW2ZdKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxucCA9IGJiLnByb3RvdHlwZTtcbnAuZiA9IDA7XG5wLmJjID0gMDtcbnAuTiA9IGZ1bmN0aW9uKCkge1xuICBjYih0aGlzKTtcbiAgZm9yKHZhciBhID0gW10sIGIgPSAwO2IgPCB0aGlzLmoubGVuZ3RoO2IrKykge1xuICAgIGEucHVzaCh0aGlzLk9bdGhpcy5qW2JdXSlcbiAgfVxuICByZXR1cm4gYVxufTtcbnAua2EgPSBmdW5jdGlvbigpIHtcbiAgY2IodGhpcyk7XG4gIHJldHVybiB0aGlzLmouY29uY2F0KClcbn07XG5wLmlhID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gZGIodGhpcy5PLCBhKVxufTtcbnAucmVtb3ZlID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gZGIodGhpcy5PLCBhKSA/IChkZWxldGUgdGhpcy5PW2FdLCB0aGlzLmYtLSwgdGhpcy5iYysrLCB0aGlzLmoubGVuZ3RoID4gMiAqIHRoaXMuZiAmJiBjYih0aGlzKSwgITApIDogITFcbn07XG5mdW5jdGlvbiBjYihhKSB7XG4gIGlmKGEuZiAhPSBhLmoubGVuZ3RoKSB7XG4gICAgZm9yKHZhciBiID0gMCwgYyA9IDA7YiA8IGEuai5sZW5ndGg7KSB7XG4gICAgICB2YXIgZCA9IGEualtiXTtcbiAgICAgIGRiKGEuTywgZCkgJiYgKGEualtjKytdID0gZCk7XG4gICAgICBiKytcbiAgICB9XG4gICAgYS5qLmxlbmd0aCA9IGNcbiAgfVxuICBpZihhLmYgIT0gYS5qLmxlbmd0aCkge1xuICAgIGZvcih2YXIgZiA9IHt9LCBjID0gYiA9IDA7YiA8IGEuai5sZW5ndGg7KSB7XG4gICAgICBkID0gYS5qW2JdLCBkYihmLCBkKSB8fCAoYS5qW2MrK10gPSBkLCBmW2RdID0gMSksIGIrK1xuICAgIH1cbiAgICBhLmoubGVuZ3RoID0gY1xuICB9XG59XG5wLmdldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGRiKHRoaXMuTywgYSkgPyB0aGlzLk9bYV0gOiBiXG59O1xucC5zZXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGRiKHRoaXMuTywgYSkgfHwgKHRoaXMuZisrLCB0aGlzLmoucHVzaChhKSwgdGhpcy5iYysrKTtcbiAgdGhpcy5PW2FdID0gYlxufTtcbnAubiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IGJiKHRoaXMpXG59O1xuZnVuY3Rpb24gZGIoYSwgYikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpXG59XG47ZnVuY3Rpb24gRihhLCBiKSB7XG4gIHZhciBjO1xuICBpZihhIGluc3RhbmNlb2YgRikge1xuICAgIHRoaXMuRCA9IHZvaWQgMCAhPT0gYiA/IGIgOiBhLkQsIGViKHRoaXMsIGEucWEpLCBjID0gYS5hYiwgSCh0aGlzKSwgdGhpcy5hYiA9IGMsIGZiKHRoaXMsIGEuamEpLCBnYih0aGlzLCBhLkJhKSwgaGIodGhpcywgYS5IKSwgaWIodGhpcywgYS5SLm4oKSksIGMgPSBhLk1hLCBIKHRoaXMpLCB0aGlzLk1hID0gY1xuICB9ZWxzZSB7XG4gICAgaWYoYSAmJiAoYyA9IFN0cmluZyhhKS5tYXRjaChRYSkpKSB7XG4gICAgICB0aGlzLkQgPSAhIWI7XG4gICAgICBlYih0aGlzLCBjWzFdIHx8IFwiXCIsICEwKTtcbiAgICAgIHZhciBkID0gY1syXSB8fCBcIlwiO1xuICAgICAgSCh0aGlzKTtcbiAgICAgIHRoaXMuYWIgPSBkID8gZGVjb2RlVVJJQ29tcG9uZW50KGQpIDogXCJcIjtcbiAgICAgIGZiKHRoaXMsIGNbM10gfHwgXCJcIiwgITApO1xuICAgICAgZ2IodGhpcywgY1s0XSk7XG4gICAgICBoYih0aGlzLCBjWzVdIHx8IFwiXCIsICEwKTtcbiAgICAgIGliKHRoaXMsIGNbNl0gfHwgXCJcIiwgITApO1xuICAgICAgYyA9IGNbN10gfHwgXCJcIjtcbiAgICAgIEgodGhpcyk7XG4gICAgICB0aGlzLk1hID0gYyA/IGRlY29kZVVSSUNvbXBvbmVudChjKSA6IFwiXCJcbiAgICB9ZWxzZSB7XG4gICAgICB0aGlzLkQgPSAhIWIsIHRoaXMuUiA9IG5ldyBqYihudWxsLCAwLCB0aGlzLkQpXG4gICAgfVxuICB9XG59XG5wID0gRi5wcm90b3R5cGU7XG5wLnFhID0gXCJcIjtcbnAuYWIgPSBcIlwiO1xucC5qYSA9IFwiXCI7XG5wLkJhID0gbnVsbDtcbnAuSCA9IFwiXCI7XG5wLk1hID0gXCJcIjtcbnAubWMgPSAhMTtcbnAuRCA9ICExO1xucC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IFtdLCBiID0gdGhpcy5xYTtcbiAgYiAmJiBhLnB1c2goa2IoYiwgbGIpLCBcIjpcIik7XG4gIGlmKGIgPSB0aGlzLmphKSB7XG4gICAgYS5wdXNoKFwiLy9cIik7XG4gICAgdmFyIGMgPSB0aGlzLmFiO1xuICAgIGMgJiYgYS5wdXNoKGtiKGMsIGxiKSwgXCJAXCIpO1xuICAgIGEucHVzaChlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGIpKSk7XG4gICAgYiA9IHRoaXMuQmE7XG4gICAgbnVsbCAhPSBiICYmIGEucHVzaChcIjpcIiwgU3RyaW5nKGIpKVxuICB9XG4gIGlmKGIgPSB0aGlzLkgpIHtcbiAgICB0aGlzLmphICYmIFwiL1wiICE9IGIuY2hhckF0KDApICYmIGEucHVzaChcIi9cIiksIGEucHVzaChrYihiLCBcIi9cIiA9PSBiLmNoYXJBdCgwKSA/IG1iIDogbmIpKVxuICB9XG4gIChiID0gdGhpcy5SLnRvU3RyaW5nKCkpICYmIGEucHVzaChcIj9cIiwgYik7XG4gIChiID0gdGhpcy5NYSkgJiYgYS5wdXNoKFwiI1wiLCBrYihiLCBvYikpO1xuICByZXR1cm4gYS5qb2luKFwiXCIpXG59O1xucC5uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRih0aGlzKVxufTtcbmZ1bmN0aW9uIGViKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYS5xYSA9IGMgPyBiID8gZGVjb2RlVVJJQ29tcG9uZW50KGIpIDogXCJcIiA6IGI7XG4gIGEucWEgJiYgKGEucWEgPSBhLnFhLnJlcGxhY2UoLzokLywgXCJcIikpXG59XG5mdW5jdGlvbiBmYihhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIGEuamEgPSBjID8gYiA/IGRlY29kZVVSSUNvbXBvbmVudChiKSA6IFwiXCIgOiBiXG59XG5mdW5jdGlvbiBnYihhLCBiKSB7XG4gIEgoYSk7XG4gIGlmKGIpIHtcbiAgICBiID0gTnVtYmVyKGIpO1xuICAgIGlmKGlzTmFOKGIpIHx8IDAgPiBiKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkJhZCBwb3J0IG51bWJlciBcIiArIGIpO1xuICAgIH1cbiAgICBhLkJhID0gYlxuICB9ZWxzZSB7XG4gICAgYS5CYSA9IG51bGxcbiAgfVxufVxuZnVuY3Rpb24gaGIoYSwgYiwgYykge1xuICBIKGEpO1xuICBhLkggPSBjID8gYiA/IGRlY29kZVVSSUNvbXBvbmVudChiKSA6IFwiXCIgOiBiXG59XG5mdW5jdGlvbiBpYihhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIGIgaW5zdGFuY2VvZiBqYiA/IChhLlIgPSBiLCBhLlIucWIoYS5EKSkgOiAoYyB8fCAoYiA9IGtiKGIsIHBiKSksIGEuUiA9IG5ldyBqYihiLCAwLCBhLkQpKVxufVxuZnVuY3Rpb24gSShhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIGEuUi5zZXQoYiwgYylcbn1cbmZ1bmN0aW9uIHFiKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgcyhjKSB8fCAoYyA9IFtTdHJpbmcoYyldKTtcbiAgcmIoYS5SLCBiLCBjKVxufVxuZnVuY3Rpb24gSihhKSB7XG4gIEgoYSk7XG4gIEkoYSwgXCJ6eFwiLCBNYXRoLmZsb29yKDIxNDc0ODM2NDggKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKDIxNDc0ODM2NDggKiBNYXRoLnJhbmRvbSgpKSBeIHgoKSkudG9TdHJpbmcoMzYpKTtcbiAgcmV0dXJuIGFcbn1cbmZ1bmN0aW9uIEgoYSkge1xuICBpZihhLm1jKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJUcmllZCB0byBtb2RpZnkgYSByZWFkLW9ubHkgVXJpXCIpO1xuICB9XG59XG5wLnFiID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLkQgPSBhO1xuICB0aGlzLlIgJiYgdGhpcy5SLnFiKGEpO1xuICByZXR1cm4gdGhpc1xufTtcbmZ1bmN0aW9uIHNiKGEsIGIsIGMsIGQpIHtcbiAgdmFyIGYgPSBuZXcgRihudWxsLCB2b2lkIDApO1xuICBhICYmIGViKGYsIGEpO1xuICBiICYmIGZiKGYsIGIpO1xuICBjICYmIGdiKGYsIGMpO1xuICBkICYmIGhiKGYsIGQpO1xuICByZXR1cm4gZlxufVxuZnVuY3Rpb24ga2IoYSwgYikge1xuICByZXR1cm4gdShhKSA/IGVuY29kZVVSSShhKS5yZXBsYWNlKGIsIHRiKSA6IG51bGxcbn1cbmZ1bmN0aW9uIHRiKGEpIHtcbiAgYSA9IGEuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuXCIlXCIgKyAoYSA+PiA0ICYgMTUpLnRvU3RyaW5nKDE2KSArIChhICYgMTUpLnRvU3RyaW5nKDE2KVxufVxudmFyIGxiID0gL1sjXFwvXFw/QF0vZywgbmIgPSAvW1xcI1xcPzpdL2csIG1iID0gL1tcXCNcXD9dL2csIHBiID0gL1tcXCNcXD9AXS9nLCBvYiA9IC8jL2c7XG5mdW5jdGlvbiBqYihhLCBiLCBjKSB7XG4gIHRoaXMuQyA9IGEgfHwgbnVsbDtcbiAgdGhpcy5EID0gISFjXG59XG5mdW5jdGlvbiBLKGEpIHtcbiAgaWYoIWEuaSAmJiAoYS5pID0gbmV3IGJiLCBhLmYgPSAwLCBhLkMpKSB7XG4gICAgZm9yKHZhciBiID0gYS5DLnNwbGl0KFwiJlwiKSwgYyA9IDA7YyA8IGIubGVuZ3RoO2MrKykge1xuICAgICAgdmFyIGQgPSBiW2NdLmluZGV4T2YoXCI9XCIpLCBmID0gbnVsbCwgZyA9IG51bGw7XG4gICAgICAwIDw9IGQgPyAoZiA9IGJbY10uc3Vic3RyaW5nKDAsIGQpLCBnID0gYltjXS5zdWJzdHJpbmcoZCArIDEpKSA6IGYgPSBiW2NdO1xuICAgICAgZiA9IGRlY29kZVVSSUNvbXBvbmVudChmLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xuICAgICAgZiA9IEwoYSwgZik7XG4gICAgICBhLmFkZChmLCBnID8gZGVjb2RlVVJJQ29tcG9uZW50KGcucmVwbGFjZSgvXFwrL2csIFwiIFwiKSkgOiBcIlwiKVxuICAgIH1cbiAgfVxufVxucCA9IGpiLnByb3RvdHlwZTtcbnAuaSA9IG51bGw7XG5wLmYgPSBudWxsO1xucC5hZGQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIEsodGhpcyk7XG4gIHRoaXMuQyA9IG51bGw7XG4gIGEgPSBMKHRoaXMsIGEpO1xuICB2YXIgYyA9IHRoaXMuaS5nZXQoYSk7XG4gIGMgfHwgdGhpcy5pLnNldChhLCBjID0gW10pO1xuICBjLnB1c2goYik7XG4gIHRoaXMuZisrO1xuICByZXR1cm4gdGhpc1xufTtcbnAucmVtb3ZlID0gZnVuY3Rpb24oYSkge1xuICBLKHRoaXMpO1xuICBhID0gTCh0aGlzLCBhKTtcbiAgcmV0dXJuIHRoaXMuaS5pYShhKSA/ICh0aGlzLkMgPSBudWxsLCB0aGlzLmYgLT0gdGhpcy5pLmdldChhKS5sZW5ndGgsIHRoaXMuaS5yZW1vdmUoYSkpIDogITFcbn07XG5wLmlhID0gZnVuY3Rpb24oYSkge1xuICBLKHRoaXMpO1xuICBhID0gTCh0aGlzLCBhKTtcbiAgcmV0dXJuIHRoaXMuaS5pYShhKVxufTtcbnAua2EgPSBmdW5jdGlvbigpIHtcbiAgSyh0aGlzKTtcbiAgZm9yKHZhciBhID0gdGhpcy5pLk4oKSwgYiA9IHRoaXMuaS5rYSgpLCBjID0gW10sIGQgPSAwO2QgPCBiLmxlbmd0aDtkKyspIHtcbiAgICBmb3IodmFyIGYgPSBhW2RdLCBnID0gMDtnIDwgZi5sZW5ndGg7ZysrKSB7XG4gICAgICBjLnB1c2goYltkXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNcbn07XG5wLk4gPSBmdW5jdGlvbihhKSB7XG4gIEsodGhpcyk7XG4gIHZhciBiID0gW107XG4gIGlmKGEpIHtcbiAgICB0aGlzLmlhKGEpICYmIChiID0gWmEoYiwgdGhpcy5pLmdldChMKHRoaXMsIGEpKSkpXG4gIH1lbHNlIHtcbiAgICBhID0gdGhpcy5pLk4oKTtcbiAgICBmb3IodmFyIGMgPSAwO2MgPCBhLmxlbmd0aDtjKyspIHtcbiAgICAgIGIgPSBaYShiLCBhW2NdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYlxufTtcbnAuc2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICBLKHRoaXMpO1xuICB0aGlzLkMgPSBudWxsO1xuICBhID0gTCh0aGlzLCBhKTtcbiAgdGhpcy5pYShhKSAmJiAodGhpcy5mIC09IHRoaXMuaS5nZXQoYSkubGVuZ3RoKTtcbiAgdGhpcy5pLnNldChhLCBbYl0pO1xuICB0aGlzLmYrKztcbiAgcmV0dXJuIHRoaXNcbn07XG5wLmdldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGMgPSBhID8gdGhpcy5OKGEpIDogW107XG4gIHJldHVybiAwIDwgYy5sZW5ndGggPyBTdHJpbmcoY1swXSkgOiBiXG59O1xuZnVuY3Rpb24gcmIoYSwgYiwgYykge1xuICBhLnJlbW92ZShiKTtcbiAgMCA8IGMubGVuZ3RoICYmIChhLkMgPSBudWxsLCBhLmkuc2V0KEwoYSwgYiksICRhKGMpKSwgYS5mICs9IGMubGVuZ3RoKVxufVxucC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLkMpIHtcbiAgICByZXR1cm4gdGhpcy5DXG4gIH1cbiAgaWYoIXRoaXMuaSkge1xuICAgIHJldHVyblwiXCJcbiAgfVxuICBmb3IodmFyIGEgPSBbXSwgYiA9IHRoaXMuaS5rYSgpLCBjID0gMDtjIDwgYi5sZW5ndGg7YysrKSB7XG4gICAgZm9yKHZhciBkID0gYltjXSwgZiA9IGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZCkpLCBkID0gdGhpcy5OKGQpLCBnID0gMDtnIDwgZC5sZW5ndGg7ZysrKSB7XG4gICAgICB2YXIgaCA9IGY7XG4gICAgICBcIlwiICE9PSBkW2ddICYmIChoICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkW2ddKSkpO1xuICAgICAgYS5wdXNoKGgpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLkMgPSBhLmpvaW4oXCImXCIpXG59O1xucC5uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gbmV3IGpiO1xuICBhLkMgPSB0aGlzLkM7XG4gIHRoaXMuaSAmJiAoYS5pID0gdGhpcy5pLm4oKSwgYS5mID0gdGhpcy5mKTtcbiAgcmV0dXJuIGFcbn07XG5mdW5jdGlvbiBMKGEsIGIpIHtcbiAgdmFyIGMgPSBTdHJpbmcoYik7XG4gIGEuRCAmJiAoYyA9IGMudG9Mb3dlckNhc2UoKSk7XG4gIHJldHVybiBjXG59XG5wLnFiID0gZnVuY3Rpb24oYSkge1xuICBhICYmICF0aGlzLkQgJiYgKEsodGhpcyksIHRoaXMuQyA9IG51bGwsIEUodGhpcy5pLCBmdW5jdGlvbihhLCBjKSB7XG4gICAgdmFyIGQgPSBjLnRvTG93ZXJDYXNlKCk7XG4gICAgYyAhPSBkICYmICh0aGlzLnJlbW92ZShjKSwgcmIodGhpcywgZCwgYSkpXG4gIH0sIHRoaXMpKTtcbiAgdGhpcy5EID0gYVxufTtcbmZ1bmN0aW9uIHViKCkge1xufVxudWIucHJvdG90eXBlLkdhID0gbnVsbDtcbnZhciB2YjtcbmZ1bmN0aW9uIHdiKCkge1xufVxueSh3YiwgdWIpO1xuZnVuY3Rpb24geGIoYSkge1xuICByZXR1cm4oYSA9IHliKGEpKSA/IG5ldyBBY3RpdmVYT2JqZWN0KGEpIDogbmV3IFhNTEh0dHBSZXF1ZXN0XG59XG5mdW5jdGlvbiB6YihhKSB7XG4gIHZhciBiID0ge307XG4gIHliKGEpICYmIChiWzBdID0gITAsIGJbMV0gPSAhMCk7XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiB5YihhKSB7XG4gIGlmKCFhLkdiICYmIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEFjdGl2ZVhPYmplY3QpIHtcbiAgICBmb3IodmFyIGIgPSBbXCJNU1hNTDIuWE1MSFRUUC42LjBcIiwgXCJNU1hNTDIuWE1MSFRUUC4zLjBcIiwgXCJNU1hNTDIuWE1MSFRUUFwiLCBcIk1pY3Jvc29mdC5YTUxIVFRQXCJdLCBjID0gMDtjIDwgYi5sZW5ndGg7YysrKSB7XG4gICAgICB2YXIgZCA9IGJbY107XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoZCksIGEuR2IgPSBkXG4gICAgICB9Y2F0Y2goZikge1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgQWN0aXZlWE9iamVjdC4gQWN0aXZlWCBtaWdodCBiZSBkaXNhYmxlZCwgb3IgTVNYTUwgbWlnaHQgbm90IGJlIGluc3RhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gYS5HYlxufVxudmIgPSBuZXcgd2I7XG5mdW5jdGlvbiBNKCkge1xuICAwICE9IEFiICYmICh0aGlzLkdjID0gRXJyb3IoKS5zdGFjaywgQmJbdih0aGlzKV0gPSB0aGlzKVxufVxudmFyIEFiID0gMCwgQmIgPSB7fTtcbk0ucHJvdG90eXBlLnliID0gITE7XG5NLnByb3RvdHlwZS5JYSA9IGZ1bmN0aW9uKCkge1xuICBpZighdGhpcy55YiAmJiAodGhpcy55YiA9ICEwLCB0aGlzLnUoKSwgMCAhPSBBYikpIHtcbiAgICB2YXIgYSA9IHYodGhpcyk7XG4gICAgZGVsZXRlIEJiW2FdXG4gIH1cbn07XG5NLnByb3RvdHlwZS51ID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuTmIpIHtcbiAgICBmb3IoO3RoaXMuTmIubGVuZ3RoOykge1xuICAgICAgdGhpcy5OYi5zaGlmdCgpKClcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBOKGEsIGIpIHtcbiAgdGhpcy50eXBlID0gYTtcbiAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGhpcy50YXJnZXQgPSBiXG59XG5wID0gTi5wcm90b3R5cGU7XG5wLnUgPSBlKCk7XG5wLklhID0gZSgpO1xucC5uYSA9ICExO1xucC5kZWZhdWx0UHJldmVudGVkID0gITE7XG5wLldhID0gITA7XG5wLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICB0aGlzLldhID0gITFcbn07XG52YXIgQ2IgPSAwO1xuZnVuY3Rpb24gRGIoKSB7XG59XG5wID0gRGIucHJvdG90eXBlO1xucC5rZXkgPSAwO1xucC5lYSA9ICExO1xucC5IYSA9ICExO1xucC5PYSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGYsIGcpIHtcbiAgaWYoaGEoYSkpIHtcbiAgICB0aGlzLkliID0gITBcbiAgfWVsc2Uge1xuICAgIGlmKGEgJiYgYS5oYW5kbGVFdmVudCAmJiBoYShhLmhhbmRsZUV2ZW50KSkge1xuICAgICAgdGhpcy5JYiA9ICExXG4gICAgfWVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGxpc3RlbmVyIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgfVxuICB0aGlzLlcgPSBhO1xuICB0aGlzLlViID0gYjtcbiAgdGhpcy5zcmMgPSBjO1xuICB0aGlzLnR5cGUgPSBkO1xuICB0aGlzLmNhcHR1cmUgPSAhIWY7XG4gIHRoaXMubGIgPSBnO1xuICB0aGlzLkhhID0gITE7XG4gIHRoaXMua2V5ID0gKytDYjtcbiAgdGhpcy5lYSA9ICExXG59O1xucC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHRoaXMuSWIgPyB0aGlzLlcuY2FsbCh0aGlzLmxiIHx8IHRoaXMuc3JjLCBhKSA6IHRoaXMuVy5oYW5kbGVFdmVudC5jYWxsKHRoaXMuVywgYSlcbn07XG52YXIgRWIgPSAhQSB8fCBBICYmIDkgPD0gTWEsIEZiID0gQSAmJiAhQyhcIjlcIik7XG4hQiB8fCBDKFwiNTI4XCIpO1xuQWEgJiYgQyhcIjEuOWJcIikgfHwgQSAmJiBDKFwiOFwiKSB8fCB6YSAmJiBDKFwiOS41XCIpIHx8IEIgJiYgQyhcIjUyOFwiKTtcbkFhICYmICFDKFwiOFwiKSB8fCBBICYmIEMoXCI5XCIpO1xuZnVuY3Rpb24gR2IoYSkge1xuICBHYltcIiBcIl0oYSk7XG4gIHJldHVybiBhXG59XG5HYltcIiBcIl0gPSBlYTtcbmZ1bmN0aW9uIEhiKGEsIGIpIHtcbiAgYSAmJiB0aGlzLk9hKGEsIGIpXG59XG55KEhiLCBOKTtcbnAgPSBIYi5wcm90b3R5cGU7XG5wLnRhcmdldCA9IG51bGw7XG5wLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xucC5vZmZzZXRYID0gMDtcbnAub2Zmc2V0WSA9IDA7XG5wLmNsaWVudFggPSAwO1xucC5jbGllbnRZID0gMDtcbnAuc2NyZWVuWCA9IDA7XG5wLnNjcmVlblkgPSAwO1xucC5idXR0b24gPSAwO1xucC5rZXlDb2RlID0gMDtcbnAuY2hhckNvZGUgPSAwO1xucC5jdHJsS2V5ID0gITE7XG5wLmFsdEtleSA9ICExO1xucC5zaGlmdEtleSA9ICExO1xucC5tZXRhS2V5ID0gITE7XG5wLnljID0gITE7XG5wLnpiID0gbnVsbDtcbnAuT2EgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjID0gdGhpcy50eXBlID0gYS50eXBlO1xuICBOLmNhbGwodGhpcywgYyk7XG4gIHRoaXMudGFyZ2V0ID0gYS50YXJnZXQgfHwgYS5zcmNFbGVtZW50O1xuICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBiO1xuICB2YXIgZCA9IGEucmVsYXRlZFRhcmdldDtcbiAgaWYoZCkge1xuICAgIGlmKEFhKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGE6IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBHYihkLm5vZGVOYW1lKTtcbiAgICAgICAgICBmID0gITA7XG4gICAgICAgICAgYnJlYWsgYVxuICAgICAgICB9Y2F0Y2goZykge1xuICAgICAgICB9XG4gICAgICAgIGYgPSAhMVxuICAgICAgfVxuICAgICAgZiB8fCAoZCA9IG51bGwpXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgXCJtb3VzZW92ZXJcIiA9PSBjID8gZCA9IGEuZnJvbUVsZW1lbnQgOiBcIm1vdXNlb3V0XCIgPT0gYyAmJiAoZCA9IGEudG9FbGVtZW50KVxuICB9XG4gIHRoaXMucmVsYXRlZFRhcmdldCA9IGQ7XG4gIHRoaXMub2Zmc2V0WCA9IEIgfHwgdm9pZCAwICE9PSBhLm9mZnNldFggPyBhLm9mZnNldFggOiBhLmxheWVyWDtcbiAgdGhpcy5vZmZzZXRZID0gQiB8fCB2b2lkIDAgIT09IGEub2Zmc2V0WSA/IGEub2Zmc2V0WSA6IGEubGF5ZXJZO1xuICB0aGlzLmNsaWVudFggPSB2b2lkIDAgIT09IGEuY2xpZW50WCA/IGEuY2xpZW50WCA6IGEucGFnZVg7XG4gIHRoaXMuY2xpZW50WSA9IHZvaWQgMCAhPT0gYS5jbGllbnRZID8gYS5jbGllbnRZIDogYS5wYWdlWTtcbiAgdGhpcy5zY3JlZW5YID0gYS5zY3JlZW5YIHx8IDA7XG4gIHRoaXMuc2NyZWVuWSA9IGEuc2NyZWVuWSB8fCAwO1xuICB0aGlzLmJ1dHRvbiA9IGEuYnV0dG9uO1xuICB0aGlzLmtleUNvZGUgPSBhLmtleUNvZGUgfHwgMDtcbiAgdGhpcy5jaGFyQ29kZSA9IGEuY2hhckNvZGUgfHwgKFwia2V5cHJlc3NcIiA9PSBjID8gYS5rZXlDb2RlIDogMCk7XG4gIHRoaXMuY3RybEtleSA9IGEuY3RybEtleTtcbiAgdGhpcy5hbHRLZXkgPSBhLmFsdEtleTtcbiAgdGhpcy5zaGlmdEtleSA9IGEuc2hpZnRLZXk7XG4gIHRoaXMubWV0YUtleSA9IGEubWV0YUtleTtcbiAgdGhpcy55YyA9IENhID8gYS5tZXRhS2V5IDogYS5jdHJsS2V5O1xuICB0aGlzLnN0YXRlID0gYS5zdGF0ZTtcbiAgdGhpcy56YiA9IGE7XG4gIGEuZGVmYXVsdFByZXZlbnRlZCAmJiB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gIGRlbGV0ZSB0aGlzLm5hXG59O1xucC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICBIYi5yYS5wcmV2ZW50RGVmYXVsdC5jYWxsKHRoaXMpO1xuICB2YXIgYSA9IHRoaXMuemI7XG4gIGlmKGEucHJldmVudERlZmF1bHQpIHtcbiAgICBhLnByZXZlbnREZWZhdWx0KClcbiAgfWVsc2Uge1xuICAgIGlmKGEucmV0dXJuVmFsdWUgPSAhMSwgRmIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGEuY3RybEtleSB8fCAxMTIgPD0gYS5rZXlDb2RlICYmIDEyMyA+PSBhLmtleUNvZGUpIHtcbiAgICAgICAgICBhLmtleUNvZGUgPSAtMVxuICAgICAgICB9XG4gICAgICB9Y2F0Y2goYikge1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnAudSA9IGUoKTtcbnZhciBTYSA9IHt9LCBPID0ge30sIFAgPSB7fSwgSWIgPSB7fTtcbmZ1bmN0aW9uIEpiKGEsIGIsIGMsIGQsIGYpIHtcbiAgaWYocyhiKSkge1xuICAgIGZvcih2YXIgZyA9IDA7ZyA8IGIubGVuZ3RoO2crKykge1xuICAgICAgSmIoYSwgYltnXSwgYywgZCwgZilcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBhOiB7XG4gICAgaWYoIWIpIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpO1xuICAgIH1cbiAgICBkID0gISFkO1xuICAgIHZhciBoID0gTztcbiAgICBiIGluIGggfHwgKGhbYl0gPSB7ZjowLCB0OjB9KTtcbiAgICBoID0gaFtiXTtcbiAgICBkIGluIGggfHwgKGhbZF0gPSB7ZjowLCB0OjB9LCBoLmYrKyk7XG4gICAgdmFyIGggPSBoW2RdLCBnID0gdihhKSwgbjtcbiAgICBoLnQrKztcbiAgICBpZihoW2ddKSB7XG4gICAgICBuID0gaFtnXTtcbiAgICAgIGZvcih2YXIgayA9IDA7ayA8IG4ubGVuZ3RoO2srKykge1xuICAgICAgICBpZihoID0gbltrXSwgaC5XID09IGMgJiYgaC5sYiA9PSBmKSB7XG4gICAgICAgICAgaWYoaC5lYSkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgbltrXS5IYSA9ICExO1xuICAgICAgICAgIGEgPSBuW2tdO1xuICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIG4gPSBoW2ddID0gW10sIGguZisrXG4gICAgfVxuICAgIGsgPSBLYigpO1xuICAgIGggPSBuZXcgRGI7XG4gICAgaC5PYShjLCBrLCBhLCBiLCBkLCBmKTtcbiAgICBoLkhhID0gITE7XG4gICAgay5zcmMgPSBhO1xuICAgIGsuVyA9IGg7XG4gICAgbi5wdXNoKGgpO1xuICAgIFBbZ10gfHwgKFBbZ10gPSBbXSk7XG4gICAgUFtnXS5wdXNoKGgpO1xuICAgIGEuYWRkRXZlbnRMaXN0ZW5lciA/IGEgIT0gcSAmJiBhLndiIHx8IGEuYWRkRXZlbnRMaXN0ZW5lcihiLCBrLCBkKSA6IGEuYXR0YWNoRXZlbnQoYiBpbiBJYiA/IEliW2JdIDogSWJbYl0gPSBcIm9uXCIgKyBiLCBrKTtcbiAgICBhID0gaFxuICB9XG4gIGIgPSBhLmtleTtcbiAgU2FbYl0gPSBhO1xuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gS2IoKSB7XG4gIHZhciBhID0gTGIsIGIgPSBFYiA/IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gYS5jYWxsKGIuc3JjLCBiLlcsIGMpXG4gIH0gOiBmdW5jdGlvbihjKSB7XG4gICAgYyA9IGEuY2FsbChiLnNyYywgYi5XLCBjKTtcbiAgICBpZighYykge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gIH07XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBNYihhLCBiLCBjLCBkLCBmKSB7XG4gIGlmKHMoYikpIHtcbiAgICBmb3IodmFyIGcgPSAwO2cgPCBiLmxlbmd0aDtnKyspIHtcbiAgICAgIE1iKGEsIGJbZ10sIGMsIGQsIGYpXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgZCA9ICEhZDtcbiAgICBhOiB7XG4gICAgICBnID0gTztcbiAgICAgIGlmKGIgaW4gZyAmJiAoZyA9IGdbYl0sIGQgaW4gZyAmJiAoZyA9IGdbZF0sIGEgPSB2KGEpLCBnW2FdKSkpIHtcbiAgICAgICAgYSA9IGdbYV07XG4gICAgICAgIGJyZWFrIGFcbiAgICAgIH1cbiAgICAgIGEgPSBudWxsXG4gICAgfVxuICAgIGlmKGEpIHtcbiAgICAgIGZvcihnID0gMDtnIDwgYS5sZW5ndGg7ZysrKSB7XG4gICAgICAgIGlmKGFbZ10uVyA9PSBjICYmIGFbZ10uY2FwdHVyZSA9PSBkICYmIGFbZ10ubGIgPT0gZikge1xuICAgICAgICAgIE5iKGFbZ10ua2V5KTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBOYihhKSB7XG4gIHZhciBiID0gU2FbYV07XG4gIGlmKCFiIHx8IGIuZWEpIHtcbiAgICByZXR1cm4hMVxuICB9XG4gIHZhciBjID0gYi5zcmMsIGQgPSBiLnR5cGUsIGYgPSBiLlViLCBnID0gYi5jYXB0dXJlO1xuICBjLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBjICE9IHEgJiYgYy53YiB8fCBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoZCwgZiwgZykgOiBjLmRldGFjaEV2ZW50ICYmIGMuZGV0YWNoRXZlbnQoZCBpbiBJYiA/IEliW2RdIDogSWJbZF0gPSBcIm9uXCIgKyBkLCBmKTtcbiAgYyA9IHYoYyk7XG4gIGlmKFBbY10pIHtcbiAgICB2YXIgZiA9IFBbY10sIGggPSBYYShmLCBiKTtcbiAgICAwIDw9IGggJiYgRC5zcGxpY2UuY2FsbChmLCBoLCAxKTtcbiAgICAwID09IGYubGVuZ3RoICYmIGRlbGV0ZSBQW2NdXG4gIH1cbiAgYi5lYSA9ICEwO1xuICBpZihiID0gT1tkXVtnXVtjXSkge1xuICAgIGIuTWIgPSAhMCwgT2IoZCwgZywgYywgYilcbiAgfVxuICBkZWxldGUgU2FbYV07XG4gIHJldHVybiEwXG59XG5mdW5jdGlvbiBPYihhLCBiLCBjLCBkKSB7XG4gIGlmKCFkLlFhICYmIGQuTWIpIHtcbiAgICBmb3IodmFyIGYgPSAwLCBnID0gMDtmIDwgZC5sZW5ndGg7ZisrKSB7XG4gICAgICBkW2ZdLmVhID8gZFtmXS5VYi5zcmMgPSBudWxsIDogKGYgIT0gZyAmJiAoZFtnXSA9IGRbZl0pLCBnKyspXG4gICAgfVxuICAgIGQubGVuZ3RoID0gZztcbiAgICBkLk1iID0gITE7XG4gICAgMCA9PSBnICYmIChkZWxldGUgT1thXVtiXVtjXSwgT1thXVtiXS5mLS0sIDAgPT0gT1thXVtiXS5mICYmIChkZWxldGUgT1thXVtiXSwgT1thXS5mLS0pLCAwID09IE9bYV0uZiAmJiBkZWxldGUgT1thXSlcbiAgfVxufVxuZnVuY3Rpb24gUGIoYSkge1xuICB2YXIgYiA9IDA7XG4gIGlmKG51bGwgIT0gYSkge1xuICAgIGlmKGEgPSB2KGEpLCBQW2FdKSB7XG4gICAgICBhID0gUFthXTtcbiAgICAgIGZvcih2YXIgYyA9IGEubGVuZ3RoIC0gMTswIDw9IGM7Yy0tKSB7XG4gICAgICAgIE5iKGFbY10ua2V5KSwgYisrXG4gICAgICB9XG4gICAgfVxuICB9ZWxzZSB7XG4gICAgUmEoZnVuY3Rpb24oYSwgYykge1xuICAgICAgTmIoYyk7XG4gICAgICBiKytcbiAgICB9KVxuICB9XG59XG5mdW5jdGlvbiBRYihhLCBiLCBjLCBkLCBmKSB7XG4gIHZhciBnID0gMTtcbiAgYiA9IHYoYik7XG4gIGlmKGFbYl0pIHtcbiAgICB2YXIgaCA9IC0tYS50LCBuID0gYVtiXTtcbiAgICBuLlFhID8gbi5RYSsrIDogbi5RYSA9IDE7XG4gICAgdHJ5IHtcbiAgICAgIGZvcih2YXIgayA9IG4ubGVuZ3RoLCB0ID0gMDt0IDwgazt0KyspIHtcbiAgICAgICAgdmFyIGwgPSBuW3RdO1xuICAgICAgICBsICYmICFsLmVhICYmIChnICY9ICExICE9PSBSYihsLCBmKSlcbiAgICAgIH1cbiAgICB9ZmluYWxseSB7XG4gICAgICBhLnQgPSBNYXRoLm1heChoLCBhLnQpLCBuLlFhLS0sIE9iKGMsIGQsIGIsIG4pXG4gICAgfVxuICB9XG4gIHJldHVybiBCb29sZWFuKGcpXG59XG5mdW5jdGlvbiBSYihhLCBiKSB7XG4gIGEuSGEgJiYgTmIoYS5rZXkpO1xuICByZXR1cm4gYS5oYW5kbGVFdmVudChiKVxufVxuZnVuY3Rpb24gTGIoYSwgYikge1xuICBpZihhLmVhKSB7XG4gICAgcmV0dXJuITBcbiAgfVxuICB2YXIgYyA9IGEudHlwZSwgZCA9IE87XG4gIGlmKCEoYyBpbiBkKSkge1xuICAgIHJldHVybiEwXG4gIH1cbiAgdmFyIGQgPSBkW2NdLCBmLCBnO1xuICBpZighRWIpIHtcbiAgICBmID0gYiB8fCBkYShcIndpbmRvdy5ldmVudFwiKTtcbiAgICB2YXIgaCA9ICEwIGluIGQsIG4gPSAhMSBpbiBkO1xuICAgIGlmKGgpIHtcbiAgICAgIGlmKDAgPiBmLmtleUNvZGUgfHwgdm9pZCAwICE9IGYucmV0dXJuVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuITBcbiAgICAgIH1cbiAgICAgIGE6IHtcbiAgICAgICAgdmFyIGsgPSAhMTtcbiAgICAgICAgaWYoMCA9PSBmLmtleUNvZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZi5rZXlDb2RlID0gLTE7XG4gICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgfWNhdGNoKHQpIHtcbiAgICAgICAgICAgIGsgPSAhMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihrIHx8IHZvaWQgMCA9PSBmLnJldHVyblZhbHVlKSB7XG4gICAgICAgICAgZi5yZXR1cm5WYWx1ZSA9ICEwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgayA9IG5ldyBIYjtcbiAgICBrLk9hKGYsIHRoaXMpO1xuICAgIGYgPSAhMDtcbiAgICB0cnkge1xuICAgICAgaWYoaCkge1xuICAgICAgICBmb3IodmFyIGwgPSBbXSwgciA9IGsuY3VycmVudFRhcmdldDtyO3IgPSByLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBsLnB1c2gocilcbiAgICAgICAgfVxuICAgICAgICBnID0gZFshMF07XG4gICAgICAgIGcudCA9IGcuZjtcbiAgICAgICAgZm9yKHZhciBHID0gbC5sZW5ndGggLSAxOyFrLm5hICYmIDAgPD0gRyAmJiBnLnQ7Ry0tKSB7XG4gICAgICAgICAgay5jdXJyZW50VGFyZ2V0ID0gbFtHXSwgZiAmPSBRYihnLCBsW0ddLCBjLCAhMCwgaylcbiAgICAgICAgfVxuICAgICAgICBpZihuKSB7XG4gICAgICAgICAgZm9yKGcgPSBkWyExXSwgZy50ID0gZy5mLCBHID0gMDshay5uYSAmJiBHIDwgbC5sZW5ndGggJiYgZy50O0crKykge1xuICAgICAgICAgICAgay5jdXJyZW50VGFyZ2V0ID0gbFtHXSwgZiAmPSBRYihnLCBsW0ddLCBjLCAhMSwgaylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgZiA9IFJiKGEsIGspXG4gICAgICB9XG4gICAgfWZpbmFsbHkge1xuICAgICAgbCAmJiAobC5sZW5ndGggPSAwKVxuICAgIH1cbiAgICByZXR1cm4gZlxuICB9XG4gIGMgPSBuZXcgSGIoYiwgdGhpcyk7XG4gIHJldHVybiBmID0gUmIoYSwgYylcbn1cbjtmdW5jdGlvbiBTYigpIHtcbiAgTS5jYWxsKHRoaXMpXG59XG55KFNiLCBNKTtcbnAgPSBTYi5wcm90b3R5cGU7XG5wLndiID0gITA7XG5wLnBiID0gbnVsbDtcbnAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgSmIodGhpcywgYSwgYiwgYywgZClcbn07XG5wLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIE1iKHRoaXMsIGEsIGIsIGMsIGQpXG59O1xucC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oYSkge1xuICB2YXIgYiA9IGEudHlwZSB8fCBhLCBjID0gTztcbiAgaWYoYiBpbiBjKSB7XG4gICAgaWYodShhKSkge1xuICAgICAgYSA9IG5ldyBOKGEsIHRoaXMpXG4gICAgfWVsc2Uge1xuICAgICAgaWYoYSBpbnN0YW5jZW9mIE4pIHtcbiAgICAgICAgYS50YXJnZXQgPSBhLnRhcmdldCB8fCB0aGlzXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHZhciBkID0gYTtcbiAgICAgICAgYSA9IG5ldyBOKGIsIHRoaXMpO1xuICAgICAgICBXYShhLCBkKVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZCA9IDEsIGYsIGMgPSBjW2JdLCBiID0gITAgaW4gYywgZztcbiAgICBpZihiKSB7XG4gICAgICBmID0gW107XG4gICAgICBmb3IoZyA9IHRoaXM7ZztnID0gZy5wYikge1xuICAgICAgICBmLnB1c2goZylcbiAgICAgIH1cbiAgICAgIGcgPSBjWyEwXTtcbiAgICAgIGcudCA9IGcuZjtcbiAgICAgIGZvcih2YXIgaCA9IGYubGVuZ3RoIC0gMTshYS5uYSAmJiAwIDw9IGggJiYgZy50O2gtLSkge1xuICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmW2hdLCBkICY9IFFiKGcsIGZbaF0sIGEudHlwZSwgITAsIGEpICYmICExICE9IGEuV2FcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoITEgaW4gYykge1xuICAgICAgaWYoZyA9IGNbITFdLCBnLnQgPSBnLmYsIGIpIHtcbiAgICAgICAgZm9yKGggPSAwOyFhLm5hICYmIGggPCBmLmxlbmd0aCAmJiBnLnQ7aCsrKSB7XG4gICAgICAgICAgYS5jdXJyZW50VGFyZ2V0ID0gZltoXSwgZCAmPSBRYihnLCBmW2hdLCBhLnR5cGUsICExLCBhKSAmJiAhMSAhPSBhLldhXG4gICAgICAgIH1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgZm9yKGYgPSB0aGlzOyFhLm5hICYmIGYgJiYgZy50O2YgPSBmLnBiKSB7XG4gICAgICAgICAgYS5jdXJyZW50VGFyZ2V0ID0gZiwgZCAmPSBRYihnLCBmLCBhLnR5cGUsICExLCBhKSAmJiAhMSAhPSBhLldhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYSA9IEJvb2xlYW4oZClcbiAgfWVsc2Uge1xuICAgIGEgPSAhMFxuICB9XG4gIHJldHVybiBhXG59O1xucC51ID0gZnVuY3Rpb24oKSB7XG4gIFNiLnJhLnUuY2FsbCh0aGlzKTtcbiAgUGIodGhpcyk7XG4gIHRoaXMucGIgPSBudWxsXG59O1xuZnVuY3Rpb24gVGIoYSwgYikge1xuICBNLmNhbGwodGhpcyk7XG4gIHRoaXMuZGEgPSBhIHx8IDE7XG4gIHRoaXMuRWEgPSBiIHx8IHE7XG4gIHRoaXMuZWIgPSB3KHRoaXMuRWMsIHRoaXMpO1xuICB0aGlzLm9iID0geCgpXG59XG55KFRiLCBTYik7XG5wID0gVGIucHJvdG90eXBlO1xucC5lbmFibGVkID0gITE7XG5wLnIgPSBudWxsO1xucC5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5kYSA9IGE7XG4gIHRoaXMuciAmJiB0aGlzLmVuYWJsZWQgPyAodGhpcy5zdG9wKCksIHRoaXMuc3RhcnQoKSkgOiB0aGlzLnIgJiYgdGhpcy5zdG9wKClcbn07XG5wLkVjID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuZW5hYmxlZCkge1xuICAgIHZhciBhID0geCgpIC0gdGhpcy5vYjtcbiAgICAwIDwgYSAmJiBhIDwgMC44ICogdGhpcy5kYSA/IHRoaXMuciA9IHRoaXMuRWEuc2V0VGltZW91dCh0aGlzLmViLCB0aGlzLmRhIC0gYSkgOiAodGhpcy5kaXNwYXRjaEV2ZW50KFViKSwgdGhpcy5lbmFibGVkICYmICh0aGlzLnIgPSB0aGlzLkVhLnNldFRpbWVvdXQodGhpcy5lYiwgdGhpcy5kYSksIHRoaXMub2IgPSB4KCkpKVxuICB9XG59O1xucC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVuYWJsZWQgPSAhMDtcbiAgdGhpcy5yIHx8ICh0aGlzLnIgPSB0aGlzLkVhLnNldFRpbWVvdXQodGhpcy5lYiwgdGhpcy5kYSksIHRoaXMub2IgPSB4KCkpXG59O1xucC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5hYmxlZCA9ICExO1xuICB0aGlzLnIgJiYgKHRoaXMuRWEuY2xlYXJUaW1lb3V0KHRoaXMuciksIHRoaXMuciA9IG51bGwpXG59O1xucC51ID0gZnVuY3Rpb24oKSB7XG4gIFRiLnJhLnUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9wKCk7XG4gIGRlbGV0ZSB0aGlzLkVhXG59O1xudmFyIFViID0gXCJ0aWNrXCI7XG5mdW5jdGlvbiBWYihhKSB7XG4gIE0uY2FsbCh0aGlzKTtcbiAgdGhpcy5lID0gYTtcbiAgdGhpcy5qID0gW11cbn1cbnkoVmIsIE0pO1xudmFyIFdiID0gW107XG5mdW5jdGlvbiBYYihhLCBiLCBjLCBkKSB7XG4gIHMoYykgfHwgKFdiWzBdID0gYywgYyA9IFdiKTtcbiAgZm9yKHZhciBmID0gMDtmIDwgYy5sZW5ndGg7ZisrKSB7XG4gICAgdmFyIGcgPSBKYihiLCBjW2ZdLCBkIHx8IGEsICExLCBhLmUgfHwgYSk7XG4gICAgYS5qLnB1c2goZylcbiAgfVxufVxuVmIucHJvdG90eXBlLnUgPSBmdW5jdGlvbigpIHtcbiAgVmIucmEudS5jYWxsKHRoaXMpO1xuICBZYSh0aGlzLmosIE5iKTtcbiAgdGhpcy5qLmxlbmd0aCA9IDBcbn07XG5WYi5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgRXJyb3IoXCJFdmVudEhhbmRsZXIuaGFuZGxlRXZlbnQgbm90IGltcGxlbWVudGVkXCIpO1xufTtcbmZ1bmN0aW9uIFliKGEsIGIsIGMpIHtcbiAgTS5jYWxsKHRoaXMpO1xuICB0aGlzLm5jID0gYTtcbiAgdGhpcy5kYSA9IGI7XG4gIHRoaXMuZSA9IGM7XG4gIHRoaXMuaGMgPSB3KHRoaXMudGMsIHRoaXMpXG59XG55KFliLCBNKTtcbnAgPSBZYi5wcm90b3R5cGU7XG5wLlhhID0gITE7XG5wLlRiID0gMDtcbnAuciA9IG51bGw7XG5wLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yICYmIChxLmNsZWFyVGltZW91dCh0aGlzLnIpLCB0aGlzLnIgPSBudWxsLCB0aGlzLlhhID0gITEpXG59O1xucC51ID0gZnVuY3Rpb24oKSB7XG4gIFliLnJhLnUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9wKClcbn07XG5wLnRjID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuciA9IG51bGw7XG4gIHRoaXMuWGEgJiYgIXRoaXMuVGIgJiYgKHRoaXMuWGEgPSAhMSwgWmIodGhpcykpXG59O1xuZnVuY3Rpb24gWmIoYSkge1xuICB2YXIgYjtcbiAgYiA9IGEuaGM7XG4gIHZhciBjID0gYS5kYTtcbiAgaWYoIWhhKGIpKSB7XG4gICAgaWYoYiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGIuaGFuZGxlRXZlbnQpIHtcbiAgICAgIGIgPSB3KGIuaGFuZGxlRXZlbnQsIGIpXG4gICAgfWVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGxpc3RlbmVyIGFyZ3VtZW50XCIpO1xuICAgIH1cbiAgfVxuICBiID0gMjE0NzQ4MzY0NyA8IGMgPyAtMSA6IHEuc2V0VGltZW91dChiLCBjIHx8IDApO1xuICBhLnIgPSBiO1xuICBhLm5jLmNhbGwoYS5lKVxufVxuO2Z1bmN0aW9uIFEoYSwgYiwgYywgZCwgZikge1xuICB0aGlzLmIgPSBhO1xuICB0aGlzLmEgPSBiO1xuICB0aGlzLlogPSBjO1xuICB0aGlzLkIgPSBkO1xuICB0aGlzLkNhID0gZiB8fCAxO1xuICB0aGlzLkRhID0gJGI7XG4gIHRoaXMuamIgPSBuZXcgVmIodGhpcyk7XG4gIHRoaXMuU2EgPSBuZXcgVGI7XG4gIHRoaXMuU2Euc2V0SW50ZXJ2YWwoYWMpXG59XG5wID0gUS5wcm90b3R5cGU7XG5wLnYgPSBudWxsO1xucC5KID0gITE7XG5wLnVhID0gbnVsbDtcbnAuc2IgPSBudWxsO1xucC5wYSA9IG51bGw7XG5wLnNhID0gbnVsbDtcbnAuVCA9IG51bGw7XG5wLncgPSBudWxsO1xucC5YID0gbnVsbDtcbnAubCA9IG51bGw7XG5wLkZhID0gMDtcbnAuSyA9IG51bGw7XG5wLnRhID0gbnVsbDtcbnAucCA9IG51bGw7XG5wLmggPSAtMTtcbnAuWGIgPSAhMDtcbnAuYWEgPSAhMTtcbnAub2EgPSAwO1xucC5UYSA9IG51bGw7XG52YXIgJGIgPSA0NUUzLCBhYyA9IDI1MDtcbmZ1bmN0aW9uIGJjKGEsIGIpIHtcbiAgc3dpdGNoKGEpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm5cIk5vbi0yMDAgcmV0dXJuIGNvZGUgKFwiICsgYiArIFwiKVwiO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVyblwiWE1MSFRUUCBmYWlsdXJlIChubyBkYXRhKVwiO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVyblwiSHR0cENvbm5lY3Rpb24gdGltZW91dFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm5cIlVua25vd24gZXJyb3JcIlxuICB9XG59XG52YXIgY2MgPSB7fSwgZGMgPSB7fTtcbmZ1bmN0aW9uIGVjKCkge1xuICByZXR1cm4hQSB8fCBBICYmIDEwIDw9IE1hXG59XG5wID0gUS5wcm90b3R5cGU7XG5wLlkgPSBtKFwidlwiKTtcbnAuc2V0VGltZW91dCA9IG0oXCJEYVwiKTtcbnAuJGIgPSBtKFwib2FcIik7XG5mdW5jdGlvbiBmYyhhLCBiLCBjKSB7XG4gIGEuc2EgPSAxO1xuICBhLlQgPSBKKGIubigpKTtcbiAgYS5YID0gYztcbiAgYS54YiA9ICEwO1xuICBnYyhhLCBudWxsKVxufVxuZnVuY3Rpb24gaGMoYSwgYiwgYywgZCwgZikge1xuICBhLnNhID0gMTtcbiAgYS5UID0gSihiLm4oKSk7XG4gIGEuWCA9IG51bGw7XG4gIGEueGIgPSBjO1xuICBmICYmIChhLlhiID0gITEpO1xuICBnYyhhLCBkKVxufVxuZnVuY3Rpb24gZ2MoYSwgYikge1xuICBhLnBhID0geCgpO1xuICBpYyhhKTtcbiAgYS53ID0gYS5ULm4oKTtcbiAgcWIoYS53LCBcInRcIiwgYS5DYSk7XG4gIGEuRmEgPSAwO1xuICBhLmwgPSBhLmIuaGIoYS5iLllhKCkgPyBiIDogbnVsbCk7XG4gIDAgPCBhLm9hICYmIChhLlRhID0gbmV3IFliKHcoYS5kYywgYSwgYS5sKSwgYS5vYSkpO1xuICBYYihhLmpiLCBhLmwsIFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBhLkFjKTtcbiAgdmFyIGM7XG4gIGlmKGEudikge1xuICAgIGMgPSBhLnY7XG4gICAgdmFyIGQgPSB7fSwgZjtcbiAgICBmb3IoZiBpbiBjKSB7XG4gICAgICBkW2ZdID0gY1tmXVxuICAgIH1cbiAgICBjID0gZFxuICB9ZWxzZSB7XG4gICAgYyA9IHt9XG4gIH1cbiAgYS5YID8gKGEudGEgPSBcIlBPU1RcIiwgY1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIGEubC5zZW5kKGEudywgYS50YSwgYS5YLCBjKSkgOiAoYS50YSA9IFwiR0VUXCIsIGEuWGIgJiYgIUIgJiYgKGMuQ29ubmVjdGlvbiA9IFwiY2xvc2VcIiksIGEubC5zZW5kKGEudywgYS50YSwgbnVsbCwgYykpO1xuICBhLmIuRyhqYyk7XG4gIGlmKGQgPSBhLlgpIHtcbiAgICBmb3IoYyA9IFwiXCIsIGQgPSBkLnNwbGl0KFwiJlwiKSwgZiA9IDA7ZiA8IGQubGVuZ3RoO2YrKykge1xuICAgICAgdmFyIGcgPSBkW2ZdLnNwbGl0KFwiPVwiKTtcbiAgICAgIGlmKDEgPCBnLmxlbmd0aCkge1xuICAgICAgICB2YXIgaCA9IGdbMF0sIGcgPSBnWzFdLCBuID0gaC5zcGxpdChcIl9cIik7XG4gICAgICAgIGMgPSAyIDw9IG4ubGVuZ3RoICYmIFwidHlwZVwiID09IG5bMV0gPyBjICsgKGggKyBcIj1cIiArIGcgKyBcIiZcIikgOiBjICsgKGggKyBcIj1yZWRhY3RlZCZcIilcbiAgICAgIH1cbiAgICB9XG4gIH1lbHNlIHtcbiAgICBjID0gbnVsbFxuICB9XG4gIGEuYS5pbmZvKFwiWE1MSFRUUCBSRVEgKFwiICsgYS5CICsgXCIpIFthdHRlbXB0IFwiICsgYS5DYSArIFwiXTogXCIgKyBhLnRhICsgXCJcXG5cIiArIGEudyArIFwiXFxuXCIgKyBjKVxufVxucC5BYyA9IGZ1bmN0aW9uKGEpIHtcbiAgYSA9IGEudGFyZ2V0O1xuICB2YXIgYiA9IHRoaXMuVGE7XG4gIGIgJiYgMyA9PSBSKGEpID8gKHRoaXMuYS5kZWJ1ZyhcIlRocm90dGxpbmcgcmVhZHlzdGF0ZWNoYW5nZS5cIiksIGIuciB8fCBiLlRiID8gYi5YYSA9ICEwIDogWmIoYikpIDogdGhpcy5kYyhhKVxufTtcbnAuZGMgPSBmdW5jdGlvbihhKSB7XG4gIHRyeSB7XG4gICAgaWYoYSA9PSB0aGlzLmwpIHtcbiAgICAgIGE6IHtcbiAgICAgICAgdmFyIGIgPSBSKHRoaXMubCksIGMgPSB0aGlzLmwubGEsIGQgPSBrYyh0aGlzLmwpO1xuICAgICAgICBpZighZWMoKSB8fCBCICYmICFDKFwiNDIwK1wiKSkge1xuICAgICAgICAgIGlmKDQgPiBiKSB7XG4gICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgaWYoMyA+IGIgfHwgMyA9PSBiICYmICF6YSAmJiAhbGModGhpcy5sKSkge1xuICAgICAgICAgICAgYnJlYWsgYVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFhIHx8ICg0ICE9IGIgfHwgYyA9PSBtYykgfHwgKGMgPT0gbmMgfHwgMCA+PSBkID8gdGhpcy5iLkcob2MpIDogdGhpcy5iLkcocGMpKTtcbiAgICAgICAgcWModGhpcyk7XG4gICAgICAgIHZhciBmID0ga2ModGhpcy5sKTtcbiAgICAgICAgdGhpcy5oID0gZjtcbiAgICAgICAgdmFyIGcgPSBsYyh0aGlzLmwpO1xuICAgICAgICBnIHx8IHRoaXMuYS5kZWJ1ZyhcIk5vIHJlc3BvbnNlIHRleHQgZm9yIHVyaSBcIiArIHRoaXMudyArIFwiIHN0YXR1cyBcIiArIGYpO1xuICAgICAgICB0aGlzLkogPSAyMDAgPT0gZjtcbiAgICAgICAgdGhpcy5hLmluZm8oXCJYTUxIVFRQIFJFU1AgKFwiICsgdGhpcy5CICsgXCIpIFsgYXR0ZW1wdCBcIiArIHRoaXMuQ2EgKyBcIl06IFwiICsgdGhpcy50YSArIFwiXFxuXCIgKyB0aGlzLncgKyBcIlxcblwiICsgYiArIFwiIFwiICsgZik7XG4gICAgICAgIHRoaXMuSiA/ICg0ID09IGIgJiYgUyh0aGlzKSwgdGhpcy54YiA/IChyYyh0aGlzLCBiLCBnKSwgemEgJiYgMyA9PSBiICYmIChYYih0aGlzLmpiLCB0aGlzLlNhLCBVYiwgdGhpcy56YyksIHRoaXMuU2Euc3RhcnQoKSkpIDogKHNjKHRoaXMuYSwgdGhpcy5CLCBnLCBudWxsKSwgdGModGhpcywgZykpLCB0aGlzLkogJiYgIXRoaXMuYWEgJiYgKDQgPT0gYiA/IHRoaXMuYi5tYSh0aGlzKSA6ICh0aGlzLkogPSAhMSwgaWModGhpcykpKSkgOiAoNDAwID09IGYgJiYgMCA8IGcuaW5kZXhPZihcIlVua25vd24gU0lEXCIpID8gKHRoaXMucCA9IDMsIFQodWMpLCB0aGlzLmEuJChcIlhNTEhUVFAgVW5rbm93biBTSUQgKFwiICsgdGhpcy5CICsgXCIpXCIpKSA6ICh0aGlzLnAgPSAwLCBUKHZjKSwgdGhpcy5hLiQoXCJYTUxIVFRQIEJhZCBzdGF0dXMgXCIgKyBmICsgXCIgKFwiICsgdGhpcy5CICsgXCIpXCIpKSwgUyh0aGlzKSwgd2ModGhpcykpXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgdGhpcy5hLiQoXCJDYWxsZWQgYmFjayB3aXRoIGFuIHVuZXhwZWN0ZWQgeG1saHR0cFwiKVxuICAgIH1cbiAgfWNhdGNoKGgpIHtcbiAgICB0aGlzLmEuZGVidWcoXCJGYWlsZWQgY2FsbCB0byBPblhtbEh0dHBSZWFkeVN0YXRlQ2hhbmdlZF9cIiksIHRoaXMubCAmJiBsYyh0aGlzLmwpID8geGModGhpcy5hLCBoLCBcIlJlc3BvbnNlVGV4dDogXCIgKyBsYyh0aGlzLmwpKSA6IHhjKHRoaXMuYSwgaCwgXCJObyByZXNwb25zZSB0ZXh0XCIpXG4gIH1maW5hbGx5IHtcbiAgfVxufTtcbmZ1bmN0aW9uIHJjKGEsIGIsIGMpIHtcbiAgZm9yKHZhciBkID0gITA7IWEuYWEgJiYgYS5GYSA8IGMubGVuZ3RoOykge1xuICAgIHZhciBmID0geWMoYSwgYyk7XG4gICAgaWYoZiA9PSBkYykge1xuICAgICAgNCA9PSBiICYmIChhLnAgPSA0LCBUKHpjKSwgZCA9ICExKTtcbiAgICAgIHNjKGEuYSwgYS5CLCBudWxsLCBcIltJbmNvbXBsZXRlIFJlc3BvbnNlXVwiKTtcbiAgICAgIGJyZWFrXG4gICAgfWVsc2Uge1xuICAgICAgaWYoZiA9PSBjYykge1xuICAgICAgICBhLnAgPSA0O1xuICAgICAgICBUKEFjKTtcbiAgICAgICAgc2MoYS5hLCBhLkIsIGMsIFwiW0ludmFsaWQgQ2h1bmtdXCIpO1xuICAgICAgICBkID0gITE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHNjKGEuYSwgYS5CLCBmLCBudWxsKSwgdGMoYSwgZilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgNCA9PSBiICYmIDAgPT0gYy5sZW5ndGggJiYgKGEucCA9IDEsIFQoQmMpLCBkID0gITEpO1xuICBhLkogPSBhLkogJiYgZDtcbiAgZCB8fCAoc2MoYS5hLCBhLkIsIGMsIFwiW0ludmFsaWQgQ2h1bmtlZCBSZXNwb25zZV1cIiksIFMoYSksIHdjKGEpKVxufVxucC56YyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IFIodGhpcy5sKSwgYiA9IGxjKHRoaXMubCk7XG4gIHRoaXMuRmEgPCBiLmxlbmd0aCAmJiAocWModGhpcyksIHJjKHRoaXMsIGEsIGIpLCB0aGlzLkogJiYgNCAhPSBhICYmIGljKHRoaXMpKVxufTtcbmZ1bmN0aW9uIHljKGEsIGIpIHtcbiAgdmFyIGMgPSBhLkZhLCBkID0gYi5pbmRleE9mKFwiXFxuXCIsIGMpO1xuICBpZigtMSA9PSBkKSB7XG4gICAgcmV0dXJuIGRjXG4gIH1cbiAgYyA9IE51bWJlcihiLnN1YnN0cmluZyhjLCBkKSk7XG4gIGlmKGlzTmFOKGMpKSB7XG4gICAgcmV0dXJuIGNjXG4gIH1cbiAgZCArPSAxO1xuICBpZihkICsgYyA+IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRjXG4gIH1cbiAgdmFyIGYgPSBiLnN1YnN0cihkLCBjKTtcbiAgYS5GYSA9IGQgKyBjO1xuICByZXR1cm4gZlxufVxuZnVuY3Rpb24gQ2MoYSwgYikge1xuICBhLnBhID0geCgpO1xuICBpYyhhKTtcbiAgdmFyIGMgPSBiID8gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIDogXCJcIjtcbiAgYS53ID0gYS5ULm4oKTtcbiAgSShhLncsIFwiRE9NQUlOXCIsIGMpO1xuICBJKGEudywgXCJ0XCIsIGEuQ2EpO1xuICB0cnkge1xuICAgIGEuSyA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiaHRtbGZpbGVcIilcbiAgfWNhdGNoKGQpIHtcbiAgICBhLmEuSShcIkFjdGl2ZVggYmxvY2tlZFwiKTtcbiAgICBTKGEpO1xuICAgIGEucCA9IDc7XG4gICAgVChEYyk7XG4gICAgd2MoYSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGYgPSBcIjxodG1sPjxib2R5PlwiO1xuICBiICYmIChmICs9ICc8c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cIicgKyBjICsgJ1wiXFx4M2Mvc2NyaXB0PicpO1xuICBmICs9IFwiPC9ib2R5PjwvaHRtbD5cIjtcbiAgYS5LLm9wZW4oKTtcbiAgYS5LLndyaXRlKGYpO1xuICBhLksuY2xvc2UoKTtcbiAgYS5LLnBhcmVudFdpbmRvdy5tID0gdyhhLndjLCBhKTtcbiAgYS5LLnBhcmVudFdpbmRvdy5kID0gdyhhLlNiLCBhLCAhMCk7XG4gIGEuSy5wYXJlbnRXaW5kb3cucnBjQ2xvc2UgPSB3KGEuU2IsIGEsICExKTtcbiAgYyA9IGEuSy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBhLksucGFyZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gIGMuaW5uZXJIVE1MID0gJzxpZnJhbWUgc3JjPVwiJyArIGEudyArICdcIj48L2lmcmFtZT4nO1xuICBhLmEuaW5mbyhcIlRSSURFTlQgUkVRIChcIiArIGEuQiArIFwiKSBbIGF0dGVtcHQgXCIgKyBhLkNhICsgXCJdOiBHRVRcXG5cIiArIGEudyk7XG4gIGEuYi5HKGpjKVxufVxucC53YyA9IGZ1bmN0aW9uKGEpIHtcbiAgVSh3KHRoaXMudmMsIHRoaXMsIGEpLCAwKVxufTtcbnAudmMgPSBmdW5jdGlvbihhKSB7XG4gIGlmKCF0aGlzLmFhKSB7XG4gICAgdmFyIGIgPSB0aGlzLmE7XG4gICAgYi5pbmZvKFwiVFJJREVOVCBURVhUIChcIiArIHRoaXMuQiArIFwiKTogXCIgKyBFYyhiLCBhKSk7XG4gICAgcWModGhpcyk7XG4gICAgdGModGhpcywgYSk7XG4gICAgaWModGhpcylcbiAgfVxufTtcbnAuU2IgPSBmdW5jdGlvbihhKSB7XG4gIFUodyh0aGlzLnVjLCB0aGlzLCBhKSwgMClcbn07XG5wLnVjID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmFhIHx8ICh0aGlzLmEuaW5mbyhcIlRSSURFTlQgVEVYVCAoXCIgKyB0aGlzLkIgKyBcIik6IFwiICsgYSA/IFwic3VjY2Vzc1wiIDogXCJmYWlsdXJlXCIpLCBTKHRoaXMpLCB0aGlzLkogPSBhLCB0aGlzLmIubWEodGhpcyksIHRoaXMuYi5HKEZjKSlcbn07XG5wLmxjID0gZnVuY3Rpb24oKSB7XG4gIHFjKHRoaXMpO1xuICB0aGlzLmIubWEodGhpcylcbn07XG5wLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmFhID0gITA7XG4gIFModGhpcylcbn07XG5mdW5jdGlvbiBpYyhhKSB7XG4gIGEuc2IgPSB4KCkgKyBhLkRhO1xuICBHYyhhLCBhLkRhKVxufVxuZnVuY3Rpb24gR2MoYSwgYikge1xuICBpZihudWxsICE9IGEudWEpIHtcbiAgICB0aHJvdyBFcnJvcihcIldhdGNoRG9nIHRpbWVyIG5vdCBudWxsXCIpO1xuICB9XG4gIGEudWEgPSBVKHcoYS54YywgYSksIGIpXG59XG5mdW5jdGlvbiBxYyhhKSB7XG4gIGEudWEgJiYgKHEuY2xlYXJUaW1lb3V0KGEudWEpLCBhLnVhID0gbnVsbClcbn1cbnAueGMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy51YSA9IG51bGw7XG4gIHZhciBhID0geCgpO1xuICAwIDw9IGEgLSB0aGlzLnNiID8gKHRoaXMuSiAmJiB0aGlzLmEuSShcIlJlY2VpdmVkIHdhdGNoZG9nIHRpbWVvdXQgZXZlbiB0aG91Z2ggcmVxdWVzdCBsb2FkZWQgc3VjY2Vzc2Z1bGx5XCIpLCB0aGlzLmEuaW5mbyhcIlRJTUVPVVQ6IFwiICsgdGhpcy53KSwgMiAhPSB0aGlzLnNhICYmIHRoaXMuYi5HKG9jKSwgUyh0aGlzKSwgdGhpcy5wID0gMiwgVChIYyksIHdjKHRoaXMpKSA6ICh0aGlzLmEuJChcIldhdGNoRG9nIHRpbWVyIGNhbGxlZCB0b28gZWFybHlcIiksIEdjKHRoaXMsIHRoaXMuc2IgLSBhKSlcbn07XG5mdW5jdGlvbiB3YyhhKSB7XG4gIGEuYi5IYigpIHx8IGEuYWEgfHwgYS5iLm1hKGEpXG59XG5mdW5jdGlvbiBTKGEpIHtcbiAgcWMoYSk7XG4gIHZhciBiID0gYS5UYTtcbiAgYiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGIuSWEgJiYgYi5JYSgpO1xuICBhLlRhID0gbnVsbDtcbiAgYS5TYS5zdG9wKCk7XG4gIGIgPSBhLmpiO1xuICBZYShiLmosIE5iKTtcbiAgYi5qLmxlbmd0aCA9IDA7XG4gIGEubCAmJiAoYiA9IGEubCwgYS5sID0gbnVsbCwgYi5hYm9ydCgpLCBiLklhKCkpO1xuICBhLksgJiYgKGEuSyA9IG51bGwpXG59XG5wLkViID0gYWEoXCJwXCIpO1xuZnVuY3Rpb24gdGMoYSwgYikge1xuICB0cnkge1xuICAgIGEuYi5QYihhLCBiKSwgYS5iLkcoRmMpXG4gIH1jYXRjaChjKSB7XG4gICAgeGMoYS5hLCBjLCBcIkVycm9yIGluIGh0dHByZXF1ZXN0IGNhbGxiYWNrXCIpXG4gIH1cbn1cbjtmdW5jdGlvbiBJYyhhKSB7XG4gIGEgPSBTdHJpbmcoYSk7XG4gIGlmKC9eXFxzKiQvLnRlc3QoYSkgPyAwIDogL15bXFxdLDp7fVxcc1xcdTIwMjhcXHUyMDI5XSokLy50ZXN0KGEucmVwbGFjZSgvXFxcXFtcIlxcXFxcXC9iZm5ydHVdL2csIFwiQFwiKS5yZXBsYWNlKC9cIlteXCJcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHgwMC1cXHgwOFxceDBhLVxceDFmXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZywgXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OltcXHNcXHUyMDI4XFx1MjAyOV0qXFxbKSsvZywgXCJcIikpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBldmFsKFwiKFwiICsgYSArIFwiKVwiKVxuICAgIH1jYXRjaChiKSB7XG4gICAgfVxuICB9XG4gIHRocm93IEVycm9yKFwiSW52YWxpZCBKU09OIHN0cmluZzogXCIgKyBhKTtcbn1cbmZ1bmN0aW9uIEpjKGEpIHtcbiAgcmV0dXJuIGV2YWwoXCIoXCIgKyBhICsgXCIpXCIpXG59XG5mdW5jdGlvbiBLYyhhKSB7XG4gIHZhciBiID0gW107XG4gIExjKG5ldyBNYyh2b2lkIDApLCBhLCBiKTtcbiAgcmV0dXJuIGIuam9pbihcIlwiKVxufVxuZnVuY3Rpb24gTWMoYSkge1xuICB0aGlzLlZhID0gYVxufVxuZnVuY3Rpb24gTGMoYSwgYiwgYykge1xuICBzd2l0Y2godHlwZW9mIGIpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBOYyhiLCBjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGMucHVzaChpc0Zpbml0ZShiKSAmJiAhaXNOYU4oYikgPyBiIDogXCJudWxsXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGMucHVzaChiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGMucHVzaChcIm51bGxcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZihudWxsID09IGIpIHtcbiAgICAgICAgYy5wdXNoKFwibnVsbFwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmKHMoYikpIHtcbiAgICAgICAgdmFyIGQgPSBiLmxlbmd0aDtcbiAgICAgICAgYy5wdXNoKFwiW1wiKTtcbiAgICAgICAgZm9yKHZhciBmID0gXCJcIiwgZyA9IDA7ZyA8IGQ7ZysrKSB7XG4gICAgICAgICAgYy5wdXNoKGYpLCBmID0gYltnXSwgTGMoYSwgYS5WYSA/IGEuVmEuY2FsbChiLCBTdHJpbmcoZyksIGYpIDogZiwgYyksIGYgPSBcIixcIlxuICAgICAgICB9XG4gICAgICAgIGMucHVzaChcIl1cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjLnB1c2goXCJ7XCIpO1xuICAgICAgZCA9IFwiXCI7XG4gICAgICBmb3IoZyBpbiBiKSB7XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBnKSAmJiAoZiA9IGJbZ10sIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZiAmJiAoYy5wdXNoKGQpLCBOYyhnLCBjKSwgYy5wdXNoKFwiOlwiKSwgTGMoYSwgYS5WYSA/IGEuVmEuY2FsbChiLCBnLCBmKSA6IGYsIGMpLCBkID0gXCIsXCIpKVxuICAgICAgfVxuICAgICAgYy5wdXNoKFwifVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHR5cGVvZiBiKTtcbiAgfVxufVxudmFyIE9jID0geydcIic6J1xcXFxcIicsIFwiXFxcXFwiOlwiXFxcXFxcXFxcIiwgXCIvXCI6XCJcXFxcL1wiLCBcIlxcYlwiOlwiXFxcXGJcIiwgXCJcXGZcIjpcIlxcXFxmXCIsIFwiXFxuXCI6XCJcXFxcblwiLCBcIlxcclwiOlwiXFxcXHJcIiwgXCJcXHRcIjpcIlxcXFx0XCIsIFwiXFx4MEJcIjpcIlxcXFx1MDAwYlwifSwgUGMgPSAvXFx1ZmZmZi8udGVzdChcIlxcdWZmZmZcIikgPyAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHVmZmZmXS9nIDogL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4ZmZdL2c7XG5mdW5jdGlvbiBOYyhhLCBiKSB7XG4gIGIucHVzaCgnXCInLCBhLnJlcGxhY2UoUGMsIGZ1bmN0aW9uKGEpIHtcbiAgICBpZihhIGluIE9jKSB7XG4gICAgICByZXR1cm4gT2NbYV1cbiAgICB9XG4gICAgdmFyIGIgPSBhLmNoYXJDb2RlQXQoMCksIGYgPSBcIlxcXFx1XCI7XG4gICAgMTYgPiBiID8gZiArPSBcIjAwMFwiIDogMjU2ID4gYiA/IGYgKz0gXCIwMFwiIDogNDA5NiA+IGIgJiYgKGYgKz0gXCIwXCIpO1xuICAgIHJldHVybiBPY1thXSA9IGYgKyBiLnRvU3RyaW5nKDE2KVxuICB9KSwgJ1wiJylcbn1cbjtmdW5jdGlvbiBRYyhhKSB7XG4gIHJldHVybiBSYyhhIHx8IGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyLCBbXSlcbn1cbmZ1bmN0aW9uIFJjKGEsIGIpIHtcbiAgdmFyIGMgPSBbXTtcbiAgaWYoMCA8PSBYYShiLCBhKSkge1xuICAgIGMucHVzaChcIlsuLi5jaXJjdWxhciByZWZlcmVuY2UuLi5dXCIpXG4gIH1lbHNlIHtcbiAgICBpZihhICYmIDUwID4gYi5sZW5ndGgpIHtcbiAgICAgIGMucHVzaChTYyhhKSArIFwiKFwiKTtcbiAgICAgIGZvcih2YXIgZCA9IGEuYXJndW1lbnRzLCBmID0gMDtmIDwgZC5sZW5ndGg7ZisrKSB7XG4gICAgICAgIDAgPCBmICYmIGMucHVzaChcIiwgXCIpO1xuICAgICAgICB2YXIgZztcbiAgICAgICAgZyA9IGRbZl07XG4gICAgICAgIHN3aXRjaCh0eXBlb2YgZykge1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGcgPSBnID8gXCJvYmplY3RcIiA6IFwibnVsbFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgZyA9IFN0cmluZyhnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBnID0gZyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBnID0gKGcgPSBTYyhnKSkgPyBnIDogXCJbZm5dXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZyA9IHR5cGVvZiBnXG4gICAgICAgIH1cbiAgICAgICAgNDAgPCBnLmxlbmd0aCAmJiAoZyA9IGcuc3Vic3RyKDAsIDQwKSArIFwiLi4uXCIpO1xuICAgICAgICBjLnB1c2goZylcbiAgICAgIH1cbiAgICAgIGIucHVzaChhKTtcbiAgICAgIGMucHVzaChcIilcXG5cIik7XG4gICAgICB0cnkge1xuICAgICAgICBjLnB1c2goUmMoYS5jYWxsZXIsIGIpKVxuICAgICAgfWNhdGNoKGgpIHtcbiAgICAgICAgYy5wdXNoKFwiW2V4Y2VwdGlvbiB0cnlpbmcgdG8gZ2V0IGNhbGxlcl1cXG5cIilcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICBhID8gYy5wdXNoKFwiWy4uLmxvbmcgc3RhY2suLi5dXCIpIDogYy5wdXNoKFwiW2VuZF1cIilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGMuam9pbihcIlwiKVxufVxuZnVuY3Rpb24gU2MoYSkge1xuICBpZihUY1thXSkge1xuICAgIHJldHVybiBUY1thXVxuICB9XG4gIGEgPSBTdHJpbmcoYSk7XG4gIGlmKCFUY1thXSkge1xuICAgIHZhciBiID0gL2Z1bmN0aW9uIChbXlxcKF0rKS8uZXhlYyhhKTtcbiAgICBUY1thXSA9IGIgPyBiWzFdIDogXCJbQW5vbnltb3VzXVwiXG4gIH1cbiAgcmV0dXJuIFRjW2FdXG59XG52YXIgVGMgPSB7fTtcbmZ1bmN0aW9uIFVjKGEsIGIsIGMsIGQsIGYpIHtcbiAgdGhpcy5yZXNldChhLCBiLCBjLCBkLCBmKVxufVxuVWMucHJvdG90eXBlLkNjID0gMDtcblVjLnByb3RvdHlwZS5CYiA9IG51bGw7XG5VYy5wcm90b3R5cGUuQWIgPSBudWxsO1xudmFyIFZjID0gMDtcblVjLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGYpIHtcbiAgdGhpcy5DYyA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIGYgPyBmIDogVmMrKztcbiAgdGhpcy5RYyA9IGQgfHwgeCgpO1xuICB0aGlzLnphID0gYTtcbiAgdGhpcy5vYyA9IGI7XG4gIHRoaXMuSWMgPSBjO1xuICBkZWxldGUgdGhpcy5CYjtcbiAgZGVsZXRlIHRoaXMuQWJcbn07XG5VYy5wcm90b3R5cGUuWWIgPSBtKFwiemFcIik7XG5mdW5jdGlvbiBWKGEpIHtcbiAgdGhpcy5wYyA9IGFcbn1cblYucHJvdG90eXBlLlJhID0gbnVsbDtcblYucHJvdG90eXBlLnphID0gbnVsbDtcblYucHJvdG90eXBlLmZiID0gbnVsbDtcblYucHJvdG90eXBlLkZiID0gbnVsbDtcbmZ1bmN0aW9uIFdjKGEsIGIpIHtcbiAgdGhpcy5uYW1lID0gYTtcbiAgdGhpcy52YWx1ZSA9IGJcbn1cbldjLnByb3RvdHlwZS50b1N0cmluZyA9IGFhKFwibmFtZVwiKTtcbnZhciBYYyA9IG5ldyBXYyhcIlNFVkVSRVwiLCAxRTMpLCBZYyA9IG5ldyBXYyhcIldBUk5JTkdcIiwgOTAwKSwgWmMgPSBuZXcgV2MoXCJJTkZPXCIsIDgwMCksICRjID0gbmV3IFdjKFwiQ09ORklHXCIsIDcwMCksIGFkID0gbmV3IFdjKFwiRklORVwiLCA1MDApO1xucCA9IFYucHJvdG90eXBlO1xucC5nZXRQYXJlbnQgPSBhYShcIlJhXCIpO1xucC5ZYiA9IG0oXCJ6YVwiKTtcbmZ1bmN0aW9uIGJkKGEpIHtcbiAgaWYoYS56YSkge1xuICAgIHJldHVybiBhLnphXG4gIH1cbiAgaWYoYS5SYSkge1xuICAgIHJldHVybiBiZChhLlJhKVxuICB9XG4gIFBhKFwiUm9vdCBsb2dnZXIgaGFzIG5vIGxldmVsIHNldC5cIik7XG4gIHJldHVybiBudWxsXG59XG5wLmxvZyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgaWYoYS52YWx1ZSA+PSBiZCh0aGlzKS52YWx1ZSkge1xuICAgIGZvcihhID0gdGhpcy5rYyhhLCBiLCBjKSwgYiA9IFwibG9nOlwiICsgYS5vYywgcS5jb25zb2xlICYmIChxLmNvbnNvbGUudGltZVN0YW1wID8gcS5jb25zb2xlLnRpbWVTdGFtcChiKSA6IHEuY29uc29sZS5tYXJrVGltZWxpbmUgJiYgcS5jb25zb2xlLm1hcmtUaW1lbGluZShiKSksIHEubXNXcml0ZVByb2ZpbGVyTWFyayAmJiBxLm1zV3JpdGVQcm9maWxlck1hcmsoYiksIGIgPSB0aGlzO2I7KSB7XG4gICAgICBjID0gYjtcbiAgICAgIHZhciBkID0gYTtcbiAgICAgIGlmKGMuRmIpIHtcbiAgICAgICAgZm9yKHZhciBmID0gMCwgZyA9IHZvaWQgMDtnID0gYy5GYltmXTtmKyspIHtcbiAgICAgICAgICBnKGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGIgPSBiLmdldFBhcmVudCgpXG4gICAgfVxuICB9XG59O1xucC5rYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgdmFyIGQgPSBuZXcgVWMoYSwgU3RyaW5nKGIpLCB0aGlzLnBjKTtcbiAgaWYoYykge1xuICAgIGQuQmIgPSBjO1xuICAgIHZhciBmO1xuICAgIHZhciBnID0gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBoO1xuICAgICAgdmFyIG4gPSBkYShcIndpbmRvdy5sb2NhdGlvbi5ocmVmXCIpO1xuICAgICAgaWYodShjKSkge1xuICAgICAgICBoID0ge21lc3NhZ2U6YywgbmFtZTpcIlVua25vd24gZXJyb3JcIiwgbGluZU51bWJlcjpcIk5vdCBhdmFpbGFibGVcIiwgZmlsZU5hbWU6biwgc3RhY2s6XCJOb3QgYXZhaWxhYmxlXCJ9XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHZhciBrLCB0LCBsID0gITE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgayA9IGMubGluZU51bWJlciB8fCBjLkhjIHx8IFwiTm90IGF2YWlsYWJsZVwiXG4gICAgICAgIH1jYXRjaChyKSB7XG4gICAgICAgICAgayA9IFwiTm90IGF2YWlsYWJsZVwiLCBsID0gITBcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHQgPSBjLmZpbGVOYW1lIHx8IGMuZmlsZW5hbWUgfHwgYy5zb3VyY2VVUkwgfHwgcS4kZ29vZ0RlYnVnRm5hbWUgfHwgblxuICAgICAgICB9Y2F0Y2goRykge1xuICAgICAgICAgIHQgPSBcIk5vdCBhdmFpbGFibGVcIiwgbCA9ICEwXG4gICAgICAgIH1cbiAgICAgICAgaCA9ICFsICYmIGMubGluZU51bWJlciAmJiBjLmZpbGVOYW1lICYmIGMuc3RhY2sgPyBjIDoge21lc3NhZ2U6Yy5tZXNzYWdlLCBuYW1lOmMubmFtZSwgbGluZU51bWJlcjprLCBmaWxlTmFtZTp0LCBzdGFjazpjLnN0YWNrIHx8IFwiTm90IGF2YWlsYWJsZVwifVxuICAgICAgfVxuICAgICAgZiA9IFwiTWVzc2FnZTogXCIgKyBuYShoLm1lc3NhZ2UpICsgJ1xcblVybDogPGEgaHJlZj1cInZpZXctc291cmNlOicgKyBoLmZpbGVOYW1lICsgJ1wiIHRhcmdldD1cIl9uZXdcIj4nICsgaC5maWxlTmFtZSArIFwiPC9hPlxcbkxpbmU6IFwiICsgaC5saW5lTnVtYmVyICsgXCJcXG5cXG5Ccm93c2VyIHN0YWNrOlxcblwiICsgbmEoaC5zdGFjayArIFwiLT4gXCIpICsgXCJbZW5kXVxcblxcbkpTIHN0YWNrIHRyYXZlcnNhbDpcXG5cIiArIG5hKFFjKGcpICsgXCItPiBcIilcbiAgICB9Y2F0Y2goU2QpIHtcbiAgICAgIGYgPSBcIkV4Y2VwdGlvbiB0cnlpbmcgdG8gZXhwb3NlIGV4Y2VwdGlvbiEgWW91IHdpbiwgd2UgbG9zZS4gXCIgKyBTZFxuICAgIH1cbiAgICBkLkFiID0gZlxuICB9XG4gIHJldHVybiBkXG59O1xucC5JID0gZnVuY3Rpb24oYSwgYikge1xuICB0aGlzLmxvZyhYYywgYSwgYilcbn07XG5wLiQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMubG9nKFljLCBhLCBiKVxufTtcbnAuaW5mbyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdGhpcy5sb2coWmMsIGEsIGIpXG59O1xuZnVuY3Rpb24gVyhhLCBiKSB7XG4gIGEubG9nKGFkLCBiLCB2b2lkIDApXG59XG52YXIgY2QgPSB7fSwgZGQgPSBudWxsO1xuZnVuY3Rpb24gZWQoYSkge1xuICBkZCB8fCAoZGQgPSBuZXcgVihcIlwiKSwgY2RbXCJcIl0gPSBkZCwgZGQuWWIoJGMpKTtcbiAgdmFyIGI7XG4gIGlmKCEoYiA9IGNkW2FdKSkge1xuICAgIGIgPSBuZXcgVihhKTtcbiAgICB2YXIgYyA9IGEubGFzdEluZGV4T2YoXCIuXCIpLCBkID0gYS5zdWJzdHIoYyArIDEpLCBjID0gZWQoYS5zdWJzdHIoMCwgYykpO1xuICAgIGMuZmIgfHwgKGMuZmIgPSB7fSk7XG4gICAgYy5mYltkXSA9IGI7XG4gICAgYi5SYSA9IGM7XG4gICAgY2RbYV0gPSBiXG4gIH1cbiAgcmV0dXJuIGJcbn1cbjtmdW5jdGlvbiBYKCkge1xuICB0aGlzLnEgPSBlZChcImdvb2cubmV0LkJyb3dzZXJDaGFubmVsXCIpXG59XG5mdW5jdGlvbiBzYyhhLCBiLCBjLCBkKSB7XG4gIGEuaW5mbyhcIlhNTEhUVFAgVEVYVCAoXCIgKyBiICsgXCIpOiBcIiArIEVjKGEsIGMpICsgKGQgPyBcIiBcIiArIGQgOiBcIlwiKSlcbn1cblgucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmluZm8oYSlcbn07XG5mdW5jdGlvbiB4YyhhLCBiLCBjKSB7XG4gIGEuSSgoYyB8fCBcIkV4Y2VwdGlvblwiKSArIGIpXG59XG5YLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLnEuaW5mbyhhKVxufTtcblgucHJvdG90eXBlLiQgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMucS4kKGEpXG59O1xuWC5wcm90b3R5cGUuSSA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLkkoYSlcbn07XG5mdW5jdGlvbiBFYyhhLCBiKSB7XG4gIGlmKCFiIHx8IGIgPT0gZmQpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGMgPSBKYyhiKTtcbiAgICBpZihjKSB7XG4gICAgICBmb3IodmFyIGQgPSAwO2QgPCBjLmxlbmd0aDtkKyspIHtcbiAgICAgICAgaWYocyhjW2RdKSkge1xuICAgICAgICAgIHZhciBmID0gY1tkXTtcbiAgICAgICAgICBpZighKDIgPiBmLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhciBnID0gZlsxXTtcbiAgICAgICAgICAgIGlmKHMoZykgJiYgISgxID4gZy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIHZhciBoID0gZ1swXTtcbiAgICAgICAgICAgICAgaWYoXCJub29wXCIgIT0gaCAmJiBcInN0b3BcIiAhPSBoKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBuID0gMTtuIDwgZy5sZW5ndGg7bisrKSB7XG4gICAgICAgICAgICAgICAgICBnW25dID0gXCJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gS2MoYylcbiAgfWNhdGNoKGspIHtcbiAgICByZXR1cm4gYS5kZWJ1ZyhcIkV4Y2VwdGlvbiBwYXJzaW5nIGV4cGVjdGVkIEpTIGFycmF5IC0gcHJvYmFibHkgd2FzIG5vdCBKU1wiKSwgYlxuICB9XG59XG47ZnVuY3Rpb24gZ2QoYSwgYikge1xuICB0aGlzLk9jID0gbmV3IE1jKGEpO1xuICB0aGlzLlAgPSBiID8gSmMgOiBJY1xufVxuZ2QucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5QKGEpXG59O1xudmFyIG1jID0gNywgbmMgPSA4O1xuZnVuY3Rpb24gaGQoYSkge1xuICBNLmNhbGwodGhpcyk7XG4gIHRoaXMuaGVhZGVycyA9IG5ldyBiYjtcbiAgdGhpcy52YSA9IGEgfHwgbnVsbFxufVxueShoZCwgU2IpO1xuaGQucHJvdG90eXBlLnEgPSBlZChcImdvb2cubmV0LlhocklvXCIpO1xudmFyIGlkID0gL15odHRwcz8kL2k7XG5wID0gaGQucHJvdG90eXBlO1xucC5TID0gITE7XG5wLmcgPSBudWxsO1xucC5iYiA9IG51bGw7XG5wLlBhID0gXCJcIjtcbnAuSmIgPSBcIlwiO1xucC5sYSA9IDA7XG5wLnAgPSBcIlwiO1xucC5pYiA9ICExO1xucC5OYSA9ICExO1xucC5tYiA9ICExO1xucC5jYSA9ICExO1xucC4kYSA9IDA7XG5wLmZhID0gbnVsbDtcbnAuV2IgPSBcIlwiO1xucC5jYyA9ICExO1xucC5zZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBpZih0aGlzLmcpIHtcbiAgICB0aHJvdyBFcnJvcihcIltnb29nLm5ldC5YaHJJb10gT2JqZWN0IGlzIGFjdGl2ZSB3aXRoIGFub3RoZXIgcmVxdWVzdD1cIiArIHRoaXMuUGEgKyBcIjsgbmV3VXJpPVwiICsgYSk7XG4gIH1cbiAgYiA9IGIgPyBiLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiO1xuICB0aGlzLlBhID0gYTtcbiAgdGhpcy5wID0gXCJcIjtcbiAgdGhpcy5sYSA9IDA7XG4gIHRoaXMuSmIgPSBiO1xuICB0aGlzLmliID0gITE7XG4gIHRoaXMuUyA9ICEwO1xuICB0aGlzLmcgPSB0aGlzLnZhID8geGIodGhpcy52YSkgOiB4Yih2Yik7XG4gIHRoaXMuYmIgPSB0aGlzLnZhID8gdGhpcy52YS5HYSB8fCAodGhpcy52YS5HYSA9IHpiKHRoaXMudmEpKSA6IHZiLkdhIHx8ICh2Yi5HYSA9IHpiKHZiKSk7XG4gIHRoaXMuZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB3KHRoaXMuT2IsIHRoaXMpO1xuICB0cnkge1xuICAgIFcodGhpcy5xLCBZKHRoaXMsIFwiT3BlbmluZyBYaHJcIikpLCB0aGlzLm1iID0gITAsIHRoaXMuZy5vcGVuKGIsIGEsICEwKSwgdGhpcy5tYiA9ICExXG4gIH1jYXRjaChmKSB7XG4gICAgVyh0aGlzLnEsIFkodGhpcywgXCJFcnJvciBvcGVuaW5nIFhocjogXCIgKyBmLm1lc3NhZ2UpKTtcbiAgICBqZCh0aGlzLCBmKTtcbiAgICByZXR1cm5cbiAgfVxuICBhID0gYyB8fCBcIlwiO1xuICB2YXIgZyA9IHRoaXMuaGVhZGVycy5uKCk7XG4gIGQgJiYgRShkLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgZy5zZXQoYiwgYSlcbiAgfSk7XG4gIGQgPSBxLkZvcm1EYXRhICYmIGEgaW5zdGFuY2VvZiBxLkZvcm1EYXRhO1xuICBcIlBPU1RcIiAhPSBiIHx8IChnLmlhKFwiQ29udGVudC1UeXBlXCIpIHx8IGQpIHx8IGcuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLThcIik7XG4gIEUoZywgZnVuY3Rpb24oYSwgYikge1xuICAgIHRoaXMuZy5zZXRSZXF1ZXN0SGVhZGVyKGIsIGEpXG4gIH0sIHRoaXMpO1xuICB0aGlzLldiICYmICh0aGlzLmcucmVzcG9uc2VUeXBlID0gdGhpcy5XYik7XG4gIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gdGhpcy5nICYmICh0aGlzLmcud2l0aENyZWRlbnRpYWxzID0gdGhpcy5jYyk7XG4gIHRyeSB7XG4gICAgdGhpcy5mYSAmJiAocS5jbGVhclRpbWVvdXQodGhpcy5mYSksIHRoaXMuZmEgPSBudWxsKSwgMCA8IHRoaXMuJGEgJiYgKFcodGhpcy5xLCBZKHRoaXMsIFwiV2lsbCBhYm9ydCBhZnRlciBcIiArIHRoaXMuJGEgKyBcIm1zIGlmIGluY29tcGxldGVcIikpLCB0aGlzLmZhID0gcS5zZXRUaW1lb3V0KHcodGhpcy5EYSwgdGhpcyksIHRoaXMuJGEpKSwgVyh0aGlzLnEsIFkodGhpcywgXCJTZW5kaW5nIHJlcXVlc3RcIikpLCB0aGlzLk5hID0gITAsIHRoaXMuZy5zZW5kKGEpLCB0aGlzLk5hID0gITFcbiAgfWNhdGNoKGgpIHtcbiAgICBXKHRoaXMucSwgWSh0aGlzLCBcIlNlbmQgZXJyb3I6IFwiICsgaC5tZXNzYWdlKSksIGpkKHRoaXMsIGgpXG4gIH1cbn07XG5wLkRhID0gZnVuY3Rpb24oKSB7XG4gIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNhICYmIHRoaXMuZyAmJiAodGhpcy5wID0gXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aGlzLiRhICsgXCJtcywgYWJvcnRpbmdcIiwgdGhpcy5sYSA9IG5jLCBXKHRoaXMucSwgWSh0aGlzLCB0aGlzLnApKSwgdGhpcy5kaXNwYXRjaEV2ZW50KFwidGltZW91dFwiKSwgdGhpcy5hYm9ydChuYykpXG59O1xuZnVuY3Rpb24gamQoYSwgYikge1xuICBhLlMgPSAhMTtcbiAgYS5nICYmIChhLmNhID0gITAsIGEuZy5hYm9ydCgpLCBhLmNhID0gITEpO1xuICBhLnAgPSBiO1xuICBhLmxhID0gNTtcbiAga2QoYSk7XG4gIGxkKGEpXG59XG5mdW5jdGlvbiBrZChhKSB7XG4gIGEuaWIgfHwgKGEuaWIgPSAhMCwgYS5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksIGEuZGlzcGF0Y2hFdmVudChcImVycm9yXCIpKVxufVxucC5hYm9ydCA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5nICYmIHRoaXMuUyAmJiAoVyh0aGlzLnEsIFkodGhpcywgXCJBYm9ydGluZ1wiKSksIHRoaXMuUyA9ICExLCB0aGlzLmNhID0gITAsIHRoaXMuZy5hYm9ydCgpLCB0aGlzLmNhID0gITEsIHRoaXMubGEgPSBhIHx8IG1jLCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSwgdGhpcy5kaXNwYXRjaEV2ZW50KFwiYWJvcnRcIiksIGxkKHRoaXMpKVxufTtcbnAudSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmcgJiYgKHRoaXMuUyAmJiAodGhpcy5TID0gITEsIHRoaXMuY2EgPSAhMCwgdGhpcy5nLmFib3J0KCksIHRoaXMuY2EgPSAhMSksIGxkKHRoaXMsICEwKSk7XG4gIGhkLnJhLnUuY2FsbCh0aGlzKVxufTtcbnAuT2IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5tYiB8fCB0aGlzLk5hIHx8IHRoaXMuY2EgPyBtZCh0aGlzKSA6IHRoaXMuc2MoKVxufTtcbnAuc2MgPSBmdW5jdGlvbigpIHtcbiAgbWQodGhpcylcbn07XG5mdW5jdGlvbiBtZChhKSB7XG4gIGlmKGEuUyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBjYSkge1xuICAgIGlmKGEuYmJbMV0gJiYgNCA9PSBSKGEpICYmIDIgPT0ga2MoYSkpIHtcbiAgICAgIFcoYS5xLCBZKGEsIFwiTG9jYWwgcmVxdWVzdCBlcnJvciBkZXRlY3RlZCBhbmQgaWdub3JlZFwiKSlcbiAgICB9ZWxzZSB7XG4gICAgICBpZihhLk5hICYmIDQgPT0gUihhKSkge1xuICAgICAgICBxLnNldFRpbWVvdXQodyhhLk9iLCBhKSwgMClcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgaWYoYS5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKSwgNCA9PSBSKGEpKSB7XG4gICAgICAgICAgVyhhLnEsIFkoYSwgXCJSZXF1ZXN0IGNvbXBsZXRlXCIpKTtcbiAgICAgICAgICBhLlMgPSAhMTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGIgPSBrYyhhKSwgYywgZDtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgc3dpdGNoKGIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDE6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMjAyOlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDY6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMzA0OlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDEyMjM6XG4gICAgICAgICAgICAgICAgICBkID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBkID0gITFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIShjID0gZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgIGlmKGYgPSAwID09PSBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBTdHJpbmcoYS5QYSkubWF0Y2goUWEpWzFdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYoIWcgJiYgc2VsZi5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGggPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sLCBnID0gaC5zdWJzdHIoMCwgaC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmID0gIWlkLnRlc3QoZyA/IGcudG9Mb3dlckNhc2UoKSA6IFwiXCIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYyA9IGZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGMpIHtcbiAgICAgICAgICAgICAgYS5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksIGEuZGlzcGF0Y2hFdmVudChcInN1Y2Nlc3NcIilcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgYS5sYSA9IDY7XG4gICAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG4gPSAyIDwgUihhKSA/IGEuZy5zdGF0dXNUZXh0IDogXCJcIlxuICAgICAgICAgICAgICB9Y2F0Y2goaykge1xuICAgICAgICAgICAgICAgIFcoYS5xLCBcIkNhbiBub3QgZ2V0IHN0YXR1czogXCIgKyBrLm1lc3NhZ2UpLCBuID0gXCJcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGEucCA9IG4gKyBcIiBbXCIgKyBrYyhhKSArIFwiXVwiO1xuICAgICAgICAgICAgICBrZChhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1maW5hbGx5IHtcbiAgICAgICAgICAgIGxkKGEpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBsZChhLCBiKSB7XG4gIGlmKGEuZykge1xuICAgIHZhciBjID0gYS5nLCBkID0gYS5iYlswXSA/IGVhIDogbnVsbDtcbiAgICBhLmcgPSBudWxsO1xuICAgIGEuYmIgPSBudWxsO1xuICAgIGEuZmEgJiYgKHEuY2xlYXJUaW1lb3V0KGEuZmEpLCBhLmZhID0gbnVsbCk7XG4gICAgYiB8fCBhLmRpc3BhdGNoRXZlbnQoXCJyZWFkeVwiKTtcbiAgICB0cnkge1xuICAgICAgYy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBkXG4gICAgfWNhdGNoKGYpIHtcbiAgICAgIGEucS5JKFwiUHJvYmxlbSBlbmNvdW50ZXJlZCByZXNldHRpbmcgb25yZWFkeXN0YXRlY2hhbmdlOiBcIiArIGYubWVzc2FnZSlcbiAgICB9XG4gIH1cbn1cbnAuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuISF0aGlzLmdcbn07XG5mdW5jdGlvbiBSKGEpIHtcbiAgcmV0dXJuIGEuZyA/IGEuZy5yZWFkeVN0YXRlIDogMFxufVxuZnVuY3Rpb24ga2MoYSkge1xuICB0cnkge1xuICAgIHJldHVybiAyIDwgUihhKSA/IGEuZy5zdGF0dXMgOiAtMVxuICB9Y2F0Y2goYikge1xuICAgIHJldHVybiBhLnEuJChcIkNhbiBub3QgZ2V0IHN0YXR1czogXCIgKyBiLm1lc3NhZ2UpLCAtMVxuICB9XG59XG5mdW5jdGlvbiBsYyhhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGEuZyA/IGEuZy5yZXNwb25zZVRleHQgOiBcIlwiXG4gIH1jYXRjaChiKSB7XG4gICAgcmV0dXJuIFcoYS5xLCBcIkNhbiBub3QgZ2V0IHJlc3BvbnNlVGV4dDogXCIgKyBiLm1lc3NhZ2UpLCBcIlwiXG4gIH1cbn1cbnAuRWIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHUodGhpcy5wKSA/IHRoaXMucCA6IFN0cmluZyh0aGlzLnApXG59O1xuZnVuY3Rpb24gWShhLCBiKSB7XG4gIHJldHVybiBiICsgXCIgW1wiICsgYS5KYiArIFwiIFwiICsgYS5QYSArIFwiIFwiICsga2MoYSkgKyBcIl1cIlxufVxuO2Z1bmN0aW9uIG5kKCkge1xuICB0aGlzLlZiID0geCgpXG59XG5uZXcgbmQ7XG5uZC5wcm90b3R5cGUuc2V0ID0gbShcIlZiXCIpO1xubmQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2V0KHgoKSlcbn07XG5uZC5wcm90b3R5cGUuZ2V0ID0gYWEoXCJWYlwiKTtcbmZ1bmN0aW9uIG9kKGEsIGIsIGMsIGQsIGYpIHtcbiAgKG5ldyBYKS5kZWJ1ZyhcIlRlc3RMb2FkSW1hZ2VXaXRoUmV0cmllczogXCIgKyBmKTtcbiAgaWYoMCA9PSBkKSB7XG4gICAgYyghMSlcbiAgfWVsc2Uge1xuICAgIHZhciBnID0gZiB8fCAwO1xuICAgIGQtLTtcbiAgICBwZChhLCBiLCBmdW5jdGlvbihmKSB7XG4gICAgICBmID8gYyghMCkgOiBxLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9kKGEsIGIsIGMsIGQsIGcpXG4gICAgICB9LCBnKVxuICAgIH0pXG4gIH1cbn1cbmZ1bmN0aW9uIHBkKGEsIGIsIGMpIHtcbiAgZnVuY3Rpb24gZChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZi5kZWJ1ZyhcIlRlc3RMb2FkSW1hZ2U6IFwiICsgYiksIGcub25sb2FkID0gbnVsbCwgZy5vbmVycm9yID0gbnVsbCwgZy5vbmFib3J0ID0gbnVsbCwgZy5vbnRpbWVvdXQgPSBudWxsLCBxLmNsZWFyVGltZW91dChoKSwgYyhhKVxuICAgICAgfWNhdGNoKGQpIHtcbiAgICAgICAgeGMoZiwgZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGYgPSBuZXcgWDtcbiAgZi5kZWJ1ZyhcIlRlc3RMb2FkSW1hZ2U6IGxvYWRpbmcgXCIgKyBhKTtcbiAgdmFyIGcgPSBuZXcgSW1hZ2UsIGggPSBudWxsO1xuICBnLm9ubG9hZCA9IGQoITAsIFwibG9hZGVkXCIpO1xuICBnLm9uZXJyb3IgPSBkKCExLCBcImVycm9yXCIpO1xuICBnLm9uYWJvcnQgPSBkKCExLCBcImFib3J0XCIpO1xuICBnLm9udGltZW91dCA9IGQoITEsIFwidGltZW91dFwiKTtcbiAgaCA9IHEuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZihnLm9udGltZW91dCkge1xuICAgICAgZy5vbnRpbWVvdXQoKVxuICAgIH1cbiAgfSwgYik7XG4gIGcuc3JjID0gYVxufVxuO2Z1bmN0aW9uIHFkKGEsIGIpIHtcbiAgdGhpcy5iID0gYTtcbiAgdGhpcy5hID0gYjtcbiAgdGhpcy5QID0gbmV3IGdkKG51bGwsICEwKVxufVxucCA9IHFkLnByb3RvdHlwZTtcbnAudiA9IG51bGw7XG5wLkEgPSBudWxsO1xucC5VYSA9ICExO1xucC5hYyA9IG51bGw7XG5wLkthID0gbnVsbDtcbnAubmIgPSBudWxsO1xucC5IID0gbnVsbDtcbnAuYyA9IG51bGw7XG5wLmggPSAtMTtcbnAuTCA9IG51bGw7XG5wLndhID0gbnVsbDtcbnAuWSA9IG0oXCJ2XCIpO1xucC5aYiA9IG0oXCJQXCIpO1xucC5nYiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5IID0gYTtcbiAgYSA9IHJkKHRoaXMuYiwgdGhpcy5IKTtcbiAgVChzZCk7XG4gIHRoaXMuYWMgPSB4KCk7XG4gIHZhciBiID0gdGhpcy5iLkNiO1xuICBudWxsICE9IGIgPyAodGhpcy5MID0gdGhpcy5iLmNvcnJlY3RIb3N0UHJlZml4KGJbMF0pLCAodGhpcy53YSA9IGJbMV0pID8gKHRoaXMuYyA9IDEsIHRkKHRoaXMpKSA6ICh0aGlzLmMgPSAyLCB1ZCh0aGlzKSkpIDogKHFiKGEsIFwiTU9ERVwiLCBcImluaXRcIiksIHRoaXMuQSA9IG5ldyBRKHRoaXMsIHRoaXMuYSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCksIHRoaXMuQS5ZKHRoaXMudiksIGhjKHRoaXMuQSwgYSwgITEsIG51bGwsICEwKSwgdGhpcy5jID0gMClcbn07XG5mdW5jdGlvbiB0ZChhKSB7XG4gIHZhciBiID0gdmQoYS5iLCBhLndhLCBcIi9tYWlsL2ltYWdlcy9jbGVhcmRvdC5naWZcIik7XG4gIEooYik7XG4gIG9kKGIudG9TdHJpbmcoKSwgNUUzLCB3KGEuaWMsIGEpLCAzLCAyRTMpO1xuICBhLkcoamMpXG59XG5wLmljID0gZnVuY3Rpb24oYSkge1xuICBpZihhKSB7XG4gICAgdGhpcy5jID0gMiwgdWQodGhpcylcbiAgfWVsc2Uge1xuICAgIFQod2QpO1xuICAgIHZhciBiID0gdGhpcy5iO1xuICAgIGIuYS5kZWJ1ZyhcIlRlc3QgQ29ubmVjdGlvbiBCbG9ja2VkXCIpO1xuICAgIGIuaCA9IGIuVS5oO1xuICAgIFooYiwgOSlcbiAgfVxuICBhICYmIHRoaXMuRyhwYylcbn07XG5mdW5jdGlvbiB1ZChhKSB7XG4gIGEuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiBzdGFydGluZyBzdGFnZSAyXCIpO1xuICBhLkEgPSBuZXcgUShhLCBhLmEsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDApO1xuICBhLkEuWShhLnYpO1xuICB2YXIgYiA9IHhkKGEuYiwgYS5MLCBhLkgpO1xuICBUKHlkKTtcbiAgaWYoZWMoKSkge1xuICAgIHFiKGIsIFwiVFlQRVwiLCBcInhtbGh0dHBcIiksIGhjKGEuQSwgYiwgITEsIGEuTCwgITEpXG4gIH1lbHNlIHtcbiAgICBxYihiLCBcIlRZUEVcIiwgXCJodG1sXCIpO1xuICAgIHZhciBjID0gYS5BO1xuICAgIGEgPSBCb29sZWFuKGEuTCk7XG4gICAgYy5zYSA9IDM7XG4gICAgYy5UID0gSihiLm4oKSk7XG4gICAgQ2MoYywgYSlcbiAgfVxufVxucC5oYiA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHRoaXMuYi5oYihhKVxufTtcbnAuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5BICYmICh0aGlzLkEuY2FuY2VsKCksIHRoaXMuQSA9IG51bGwpO1xuICB0aGlzLmggPSAtMVxufTtcbnAuSGIgPSBiYSghMSk7XG5wLlBiID0gZnVuY3Rpb24oYSwgYikge1xuICB0aGlzLmggPSBhLmg7XG4gIGlmKDAgPT0gdGhpcy5jKSB7XG4gICAgaWYodGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IEdvdCBkYXRhIGZvciBzdGFnZSAxXCIpLCBiKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuUC5wYXJzZShiKVxuICAgICAgfWNhdGNoKGQpIHtcbiAgICAgICAgeGModGhpcy5hLCBkKTtcbiAgICAgICAgemQodGhpcy5iLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLkwgPSB0aGlzLmIuY29ycmVjdEhvc3RQcmVmaXgoY1swXSk7XG4gICAgICB0aGlzLndhID0gY1sxXVxuICAgIH1lbHNlIHtcbiAgICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiBOdWxsIHJlc3BvbnNlVGV4dFwiKSwgemQodGhpcy5iLCB0aGlzKVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGlmKDIgPT0gdGhpcy5jKSB7XG4gICAgICBpZih0aGlzLlVhKSB7XG4gICAgICAgIFQoQWQpLCB0aGlzLm5iID0geCgpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKFwiMTExMTFcIiA9PSBiKSB7XG4gICAgICAgICAgaWYoVChCZCksIHRoaXMuVWEgPSAhMCwgdGhpcy5LYSA9IHgoKSwgYyA9IHRoaXMuS2EgLSB0aGlzLmFjLCBlYygpIHx8IDUwMCA+IGMpIHtcbiAgICAgICAgICAgIHRoaXMuaCA9IDIwMCwgdGhpcy5BLmNhbmNlbCgpLCB0aGlzLmEuZGVidWcoXCJUZXN0IGNvbm5lY3Rpb24gc3VjY2VlZGVkOyB1c2luZyBzdHJlYW1pbmcgY29ubmVjdGlvblwiKSwgVChDZCksIERkKHRoaXMuYiwgdGhpcywgITApXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgVChFZCksIHRoaXMuS2EgPSB0aGlzLm5iID0geCgpLCB0aGlzLlVhID0gITFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnAubWEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oID0gdGhpcy5BLmg7XG4gIGlmKCF0aGlzLkEuSikge1xuICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiByZXF1ZXN0IGZhaWxlZCwgaW4gc3RhdGUgXCIgKyB0aGlzLmMpLCAwID09IHRoaXMuYyA/IFQoRmQpIDogMiA9PSB0aGlzLmMgJiYgVChHZCksIHpkKHRoaXMuYiwgdGhpcylcbiAgfWVsc2Uge1xuICAgIGlmKDAgPT0gdGhpcy5jKSB7XG4gICAgICB0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogcmVxdWVzdCBjb21wbGV0ZSBmb3IgaW5pdGlhbCBjaGVja1wiKSwgdGhpcy53YSA/ICh0aGlzLmMgPSAxLCB0ZCh0aGlzKSkgOiAodGhpcy5jID0gMiwgdWQodGhpcykpXG4gICAgfWVsc2Uge1xuICAgICAgaWYoMiA9PSB0aGlzLmMpIHtcbiAgICAgICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHJlcXVlc3QgY29tcGxldGUgZm9yIHN0YWdlIDJcIik7XG4gICAgICAgIHZhciBhID0gITE7XG4gICAgICAgIChhID0gZWMoKSA/IHRoaXMuVWEgOiAyMDAgPiB0aGlzLm5iIC0gdGhpcy5LYSA/ICExIDogITApID8gKHRoaXMuYS5kZWJ1ZyhcIlRlc3QgY29ubmVjdGlvbiBzdWNjZWVkZWQ7IHVzaW5nIHN0cmVhbWluZyBjb25uZWN0aW9uXCIpLCBUKENkKSwgRGQodGhpcy5iLCB0aGlzLCAhMCkpIDogKHRoaXMuYS5kZWJ1ZyhcIlRlc3QgY29ubmVjdGlvbiBmYWlsZWQ7IG5vdCB1c2luZyBzdHJlYW1pbmdcIiksIFQoSGQpLCBEZCh0aGlzLmIsIHRoaXMsICExKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5wLllhID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmIuWWEoKVxufTtcbnAuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYi5pc0FjdGl2ZSgpXG59O1xucC5HID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmIuRyhhKVxufTtcbmZ1bmN0aW9uIElkKGEsIGIpIHtcbiAgdGhpcy52YiA9IGEgfHwgbnVsbDtcbiAgdGhpcy5jID0gSmQ7XG4gIHRoaXMucyA9IFtdO1xuICB0aGlzLlEgPSBbXTtcbiAgdGhpcy5hID0gbmV3IFg7XG4gIHRoaXMuUCA9IG5ldyBnZChudWxsLCAhMCk7XG4gIHRoaXMuQ2IgPSBiIHx8IG51bGxcbn1cbmZ1bmN0aW9uIEtkKGEsIGIpIHtcbiAgdGhpcy5MYiA9IGE7XG4gIHRoaXMubWFwID0gYjtcbiAgdGhpcy5GYyA9IG51bGxcbn1cbnAgPSBJZC5wcm90b3R5cGU7XG5wLnYgPSBudWxsO1xucC54YSA9IG51bGw7XG5wLm8gPSBudWxsO1xucC5rID0gbnVsbDtcbnAuSCA9IG51bGw7XG5wLkxhID0gbnVsbDtcbnAudWIgPSBudWxsO1xucC5MID0gbnVsbDtcbnAuZmMgPSAhMDtcbnAuQWEgPSAwO1xucC5xYyA9IDA7XG5wLkphID0gITE7XG5wLmUgPSBudWxsO1xucC5GID0gbnVsbDtcbnAuTSA9IG51bGw7XG5wLmJhID0gbnVsbDtcbnAuVSA9IG51bGw7XG5wLnJiID0gbnVsbDtcbnAuZWMgPSAhMDtcbnAueWEgPSAtMTtcbnAuS2IgPSAtMTtcbnAuaCA9IC0xO1xucC5WID0gMDtcbnAuZ2EgPSAwO1xucC5nYyA9IDVFMztcbnAuQmMgPSAxRTQ7XG5wLmtiID0gMjtcbnAuRGIgPSAyRTQ7XG5wLm9hID0gMDtcbnAuWmEgPSAhMTtcbnAuaGEgPSA4O1xudmFyIEpkID0gMSwgTGQgPSBuZXcgU2I7XG5mdW5jdGlvbiBNZChhLCBiKSB7XG4gIE4uY2FsbCh0aGlzLCBcInN0YXRldmVudFwiLCBhKTtcbiAgdGhpcy5QYyA9IGJcbn1cbnkoTWQsIE4pO1xuZnVuY3Rpb24gTmQoYSwgYiwgYywgZCkge1xuICBOLmNhbGwodGhpcywgXCJ0aW1pbmdldmVudFwiLCBhKTtcbiAgdGhpcy5zaXplID0gYjtcbiAgdGhpcy5OYyA9IGM7XG4gIHRoaXMuTWMgPSBkXG59XG55KE5kLCBOKTtcbnZhciBqYyA9IDEsIHBjID0gMiwgb2MgPSAzLCBGYyA9IDQ7XG5mdW5jdGlvbiBPZChhLCBiKSB7XG4gIE4uY2FsbCh0aGlzLCBcInNlcnZlcnJlYWNoYWJpbGl0eVwiLCBhKTtcbiAgdGhpcy5MYyA9IGJcbn1cbnkoT2QsIE4pO1xudmFyIHNkID0gMywgd2QgPSA0LCB5ZCA9IDUsIEJkID0gNiwgQWQgPSA3LCBFZCA9IDgsIEZkID0gOSwgR2QgPSAxMCwgSGQgPSAxMSwgQ2QgPSAxMiwgdWMgPSAxMywgdmMgPSAxNCwgemMgPSAxNSwgQWMgPSAxNiwgQmMgPSAxNywgSGMgPSAxOCwgRGMgPSAyMiwgZmQgPSBcInkyZiVcIjtcbnAgPSBJZC5wcm90b3R5cGU7XG5wLmdiID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZikge1xuICB0aGlzLmEuZGVidWcoXCJjb25uZWN0KClcIik7XG4gIFQoMCk7XG4gIHRoaXMuSCA9IGI7XG4gIHRoaXMueGEgPSBjIHx8IHt9O1xuICBkICYmIHZvaWQgMCAhPT0gZiAmJiAodGhpcy54YS5PU0lEID0gZCwgdGhpcy54YS5PQUlEID0gZik7XG4gIHRoaXMuYS5kZWJ1ZyhcImNvbm5lY3RUZXN0XygpXCIpO1xuICBQZCh0aGlzKSAmJiAodGhpcy5VID0gbmV3IHFkKHRoaXMsIHRoaXMuYSksIHRoaXMuVS5ZKHRoaXMudiksIHRoaXMuVS5aYih0aGlzLlApLCB0aGlzLlUuZ2IoYSkpXG59O1xucC5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYS5kZWJ1ZyhcImRpc2Nvbm5lY3QoKVwiKTtcbiAgUWQodGhpcyk7XG4gIGlmKDMgPT0gdGhpcy5jKSB7XG4gICAgdmFyIGEgPSB0aGlzLkFhKyssIGIgPSB0aGlzLkxhLm4oKTtcbiAgICBJKGIsIFwiU0lEXCIsIHRoaXMuWik7XG4gICAgSShiLCBcIlJJRFwiLCBhKTtcbiAgICBJKGIsIFwiVFlQRVwiLCBcInRlcm1pbmF0ZVwiKTtcbiAgICBSZCh0aGlzLCBiKTtcbiAgICBhID0gbmV3IFEodGhpcywgdGhpcy5hLCB0aGlzLlosIGEsIHZvaWQgMCk7XG4gICAgYS5zYSA9IDI7XG4gICAgYS5UID0gSihiLm4oKSk7XG4gICAgYiA9IG5ldyBJbWFnZTtcbiAgICBiLnNyYyA9IGEuVDtcbiAgICBiLm9ubG9hZCA9IGIub25lcnJvciA9IHcoYS5sYywgYSk7XG4gICAgYS5wYSA9IHgoKTtcbiAgICBpYyhhKVxuICB9XG4gIFRkKHRoaXMpXG59O1xuZnVuY3Rpb24gUWQoYSkge1xuICBhLlUgJiYgKGEuVS5hYm9ydCgpLCBhLlUgPSBudWxsKTtcbiAgYS5rICYmIChhLmsuY2FuY2VsKCksIGEuayA9IG51bGwpO1xuICBhLk0gJiYgKHEuY2xlYXJUaW1lb3V0KGEuTSksIGEuTSA9IG51bGwpO1xuICBVZChhKTtcbiAgYS5vICYmIChhLm8uY2FuY2VsKCksIGEubyA9IG51bGwpO1xuICBhLkYgJiYgKHEuY2xlYXJUaW1lb3V0KGEuRiksIGEuRiA9IG51bGwpXG59XG5wLlkgPSBtKFwidlwiKTtcbnAuJGIgPSBtKFwib2FcIik7XG5wLkhiID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwID09IHRoaXMuY1xufTtcbnAuWmIgPSBtKFwiUFwiKTtcbmZ1bmN0aW9uIFZkKGEpIHtcbiAgYS5vIHx8IGEuRiB8fCAoYS5GID0gVSh3KGEuUmIsIGEpLCAwKSwgYS5WID0gMClcbn1cbnAuUmIgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuRiA9IG51bGw7XG4gIHRoaXMuYS5kZWJ1ZyhcInN0YXJ0Rm9yd2FyZENoYW5uZWxfXCIpO1xuICBpZihQZCh0aGlzKSkge1xuICAgIGlmKHRoaXMuYyA9PSBKZCkge1xuICAgICAgaWYoYSkge1xuICAgICAgICB0aGlzLmEuSShcIk5vdCBzdXBwb3NlZCB0byByZXRyeSB0aGUgb3BlblwiKVxuICAgICAgfWVsc2Uge1xuICAgICAgICB0aGlzLmEuZGVidWcoXCJvcGVuXygpXCIpO1xuICAgICAgICB0aGlzLkFhID0gTWF0aC5mbG9vcigxRTUgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgYSA9IHRoaXMuQWErKztcbiAgICAgICAgdmFyIGIgPSBuZXcgUSh0aGlzLCB0aGlzLmEsIFwiXCIsIGEsIHZvaWQgMCk7XG4gICAgICAgIGIuWSh0aGlzLnYpO1xuICAgICAgICB2YXIgYyA9IFdkKHRoaXMpLCBkID0gdGhpcy5MYS5uKCk7XG4gICAgICAgIEkoZCwgXCJSSURcIiwgYSk7XG4gICAgICAgIHRoaXMudmIgJiYgSShkLCBcIkNWRVJcIiwgdGhpcy52Yik7XG4gICAgICAgIFJkKHRoaXMsIGQpO1xuICAgICAgICBmYyhiLCBkLCBjKTtcbiAgICAgICAgdGhpcy5vID0gYjtcbiAgICAgICAgdGhpcy5jID0gMlxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIDMgPT0gdGhpcy5jICYmIChhID8gWGQodGhpcywgYSkgOiAwID09IHRoaXMucy5sZW5ndGggPyB0aGlzLmEuZGVidWcoXCJzdGFydEZvcndhcmRDaGFubmVsXyByZXR1cm5lZDogbm90aGluZyB0byBzZW5kXCIpIDogdGhpcy5vID8gdGhpcy5hLkkoXCJzdGFydEZvcndhcmRDaGFubmVsXyByZXR1cm5lZDogY29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIpIDogKFhkKHRoaXMpLCB0aGlzLmEuZGVidWcoXCJzdGFydEZvcndhcmRDaGFubmVsXyBmaW5pc2hlZCwgc2VudCByZXF1ZXN0XCIpKSlcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBYZChhLCBiKSB7XG4gIHZhciBjLCBkO1xuICBiID8gNiA8IGEuaGEgPyAoYS5zID0gYS5RLmNvbmNhdChhLnMpLCBhLlEubGVuZ3RoID0gMCwgYyA9IGEuQWEgLSAxLCBkID0gV2QoYSkpIDogKGMgPSBiLkIsIGQgPSBiLlgpIDogKGMgPSBhLkFhKyssIGQgPSBXZChhKSk7XG4gIHZhciBmID0gYS5MYS5uKCk7XG4gIEkoZiwgXCJTSURcIiwgYS5aKTtcbiAgSShmLCBcIlJJRFwiLCBjKTtcbiAgSShmLCBcIkFJRFwiLCBhLnlhKTtcbiAgUmQoYSwgZik7XG4gIGMgPSBuZXcgUShhLCBhLmEsIGEuWiwgYywgYS5WICsgMSk7XG4gIGMuWShhLnYpO1xuICBjLnNldFRpbWVvdXQoTWF0aC5yb3VuZCgwLjUgKiBhLkRiKSArIE1hdGgucm91bmQoMC41ICogYS5EYiAqIE1hdGgucmFuZG9tKCkpKTtcbiAgYS5vID0gYztcbiAgZmMoYywgZiwgZClcbn1cbmZ1bmN0aW9uIFJkKGEsIGIpIHtcbiAgaWYoYS5lKSB7XG4gICAgdmFyIGMgPSBhLmUuZ2V0QWRkaXRpb25hbFBhcmFtcyhhKTtcbiAgICBjICYmIEUoYywgZnVuY3Rpb24oYSwgYykge1xuICAgICAgSShiLCBjLCBhKVxuICAgIH0pXG4gIH1cbn1cbmZ1bmN0aW9uIFdkKGEpIHtcbiAgdmFyIGIgPSBNYXRoLm1pbihhLnMubGVuZ3RoLCAxRTMpLCBjID0gW1wiY291bnQ9XCIgKyBiXSwgZDtcbiAgNiA8IGEuaGEgJiYgMCA8IGIgPyAoZCA9IGEuc1swXS5MYiwgYy5wdXNoKFwib2ZzPVwiICsgZCkpIDogZCA9IDA7XG4gIGZvcih2YXIgZiA9IDA7ZiA8IGI7ZisrKSB7XG4gICAgdmFyIGcgPSBhLnNbZl0uTGIsIGggPSBhLnNbZl0ubWFwLCBnID0gNiA+PSBhLmhhID8gZiA6IGcgLSBkO1xuICAgIHRyeSB7XG4gICAgICBFKGgsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgYy5wdXNoKFwicmVxXCIgKyBnICsgXCJfXCIgKyBiICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYSkpXG4gICAgICB9KVxuICAgIH1jYXRjaChuKSB7XG4gICAgICBjLnB1c2goXCJyZXFcIiArIGcgKyBcIl90eXBlPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KFwiX2JhZG1hcFwiKSksIGEuZSAmJiBhLmUuYmFkTWFwRXJyb3IoYSwgaClcbiAgICB9XG4gIH1cbiAgYS5RID0gYS5RLmNvbmNhdChhLnMuc3BsaWNlKDAsIGIpKTtcbiAgcmV0dXJuIGMuam9pbihcIiZcIilcbn1cbmZ1bmN0aW9uIFlkKGEpIHtcbiAgYS5rIHx8IGEuTSB8fCAoYS50YiA9IDEsIGEuTSA9IFUodyhhLlFiLCBhKSwgMCksIGEuZ2EgPSAwKVxufVxuZnVuY3Rpb24gWmQoYSkge1xuICBpZihhLmsgfHwgYS5NKSB7XG4gICAgcmV0dXJuIGEuYS5JKFwiUmVxdWVzdCBhbHJlYWR5IGluIHByb2dyZXNzXCIpLCAhMVxuICB9XG4gIGlmKDMgPD0gYS5nYSkge1xuICAgIHJldHVybiExXG4gIH1cbiAgYS5hLmRlYnVnKFwiR29pbmcgdG8gcmV0cnkgR0VUXCIpO1xuICBhLnRiKys7XG4gIGEuTSA9IFUodyhhLlFiLCBhKSwgJGQoYSwgYS5nYSkpO1xuICBhLmdhKys7XG4gIHJldHVybiEwXG59XG5wLlFiID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuTSA9IG51bGw7XG4gIGlmKFBkKHRoaXMpKSB7XG4gICAgdGhpcy5hLmRlYnVnKFwiQ3JlYXRpbmcgbmV3IEh0dHBSZXF1ZXN0XCIpO1xuICAgIHRoaXMuayA9IG5ldyBRKHRoaXMsIHRoaXMuYSwgdGhpcy5aLCBcInJwY1wiLCB0aGlzLnRiKTtcbiAgICB0aGlzLmsuWSh0aGlzLnYpO1xuICAgIHRoaXMuay4kYih0aGlzLm9hKTtcbiAgICB2YXIgYSA9IHRoaXMudWIubigpO1xuICAgIEkoYSwgXCJSSURcIiwgXCJycGNcIik7XG4gICAgSShhLCBcIlNJRFwiLCB0aGlzLlopO1xuICAgIEkoYSwgXCJDSVwiLCB0aGlzLnJiID8gXCIwXCIgOiBcIjFcIik7XG4gICAgSShhLCBcIkFJRFwiLCB0aGlzLnlhKTtcbiAgICBSZCh0aGlzLCBhKTtcbiAgICBpZihlYygpKSB7XG4gICAgICBJKGEsIFwiVFlQRVwiLCBcInhtbGh0dHBcIiksIGhjKHRoaXMuaywgYSwgITAsIHRoaXMuTCwgITEpXG4gICAgfWVsc2Uge1xuICAgICAgSShhLCBcIlRZUEVcIiwgXCJodG1sXCIpO1xuICAgICAgdmFyIGIgPSB0aGlzLmssIGMgPSBCb29sZWFuKHRoaXMuTCk7XG4gICAgICBiLnNhID0gMztcbiAgICAgIGIuVCA9IEooYS5uKCkpO1xuICAgICAgQ2MoYiwgYylcbiAgICB9XG4gICAgdGhpcy5hLmRlYnVnKFwiTmV3IFJlcXVlc3QgY3JlYXRlZFwiKVxuICB9XG59O1xuZnVuY3Rpb24gUGQoYSkge1xuICBpZihhLmUpIHtcbiAgICB2YXIgYiA9IGEuZS5va1RvTWFrZVJlcXVlc3QoYSk7XG4gICAgaWYoMCAhPSBiKSB7XG4gICAgICByZXR1cm4gYS5hLmRlYnVnKFwiSGFuZGxlciByZXR1cm5lZCBlcnJvciBjb2RlIGZyb20gb2tUb01ha2VSZXF1ZXN0XCIpLCBaKGEsIGIpLCAhMVxuICAgIH1cbiAgfVxuICByZXR1cm4hMFxufVxuZnVuY3Rpb24gRGQoYSwgYiwgYykge1xuICBhLmEuZGVidWcoXCJUZXN0IENvbm5lY3Rpb24gRmluaXNoZWRcIik7XG4gIGEucmIgPSBhLmVjICYmIGM7XG4gIGEuaCA9IGIuaDtcbiAgYS5hLmRlYnVnKFwiY29ubmVjdENoYW5uZWxfKClcIik7XG4gIGEuamMoSmQsIDApO1xuICBhLkxhID0gcmQoYSwgYS5IKTtcbiAgVmQoYSlcbn1cbmZ1bmN0aW9uIHpkKGEsIGIpIHtcbiAgYS5hLmRlYnVnKFwiVGVzdCBDb25uZWN0aW9uIEZhaWxlZFwiKTtcbiAgYS5oID0gYi5oO1xuICBaKGEsIDIpXG59XG5wLlBiID0gZnVuY3Rpb24oYSwgYikge1xuICBpZigwICE9IHRoaXMuYyAmJiAodGhpcy5rID09IGEgfHwgdGhpcy5vID09IGEpKSB7XG4gICAgaWYodGhpcy5oID0gYS5oLCB0aGlzLm8gPT0gYSAmJiAzID09IHRoaXMuYykge1xuICAgICAgaWYoNyA8IHRoaXMuaGEpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYyA9IHRoaXMuUC5wYXJzZShiKVxuICAgICAgICB9Y2F0Y2goZCkge1xuICAgICAgICAgIGMgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYocyhjKSAmJiAzID09IGMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGYgPSBjO1xuICAgICAgICAgIGlmKDAgPT0gZlswXSkge1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBpZih0aGlzLmEuZGVidWcoXCJTZXJ2ZXIgY2xhaW1zIG91ciBiYWNrY2hhbm5lbCBpcyBtaXNzaW5nLlwiKSwgdGhpcy5NKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hLmRlYnVnKFwiQnV0IHdlIGFyZSBjdXJyZW50bHkgc3RhcnRpbmcgdGhlIHJlcXVlc3QuXCIpXG4gICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmspIHtcbiAgICAgICAgICAgICAgICAgIGlmKHRoaXMuay5wYSArIDNFMyA8IHRoaXMuby5wYSkge1xuICAgICAgICAgICAgICAgICAgICBVZCh0aGlzKSwgdGhpcy5rLmNhbmNlbCgpLCB0aGlzLmsgPSBudWxsXG4gICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmEuJChcIldlIGRvIG5vdCBoYXZlIGEgQmFja0NoYW5uZWwgZXN0YWJsaXNoZWRcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgWmQodGhpcyk7XG4gICAgICAgICAgICAgICAgVCgxOSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIHRoaXMuS2IgPSBmWzFdLCBjID0gdGhpcy5LYiAtIHRoaXMueWEsIDAgPCBjICYmIChmID0gZlsyXSwgdGhpcy5hLmRlYnVnKGYgKyBcIiBieXRlcyAoaW4gXCIgKyBjICsgXCIgYXJyYXlzKSBhcmUgb3V0c3RhbmRpbmcgb24gdGhlIEJhY2tDaGFubmVsXCIpLCAzNzUwMCA+IGYgJiYgKHRoaXMucmIgJiYgMCA9PSB0aGlzLmdhKSAmJiAhdGhpcy5iYSAmJiAodGhpcy5iYSA9IFUodyh0aGlzLnJjLCB0aGlzKSwgNkUzKSkpXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgdGhpcy5hLmRlYnVnKFwiQmFkIFBPU1QgcmVzcG9uc2UgZGF0YSByZXR1cm5lZFwiKSwgWih0aGlzLCAxMSlcbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBiICE9IGZkICYmICh0aGlzLmEuZGVidWcoXCJCYWQgZGF0YSByZXR1cm5lZCAtIG1pc3NpbmcvaW52YWxkIG1hZ2ljIGNvb2tpZVwiKSwgWih0aGlzLCAxMSkpXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgaWYodGhpcy5rID09IGEgJiYgVWQodGhpcyksICEvXltcXHNcXHhhMF0qJC8udGVzdChiKSkge1xuICAgICAgICBjID0gdGhpcy5QLnBhcnNlKGIpO1xuICAgICAgICBmb3IodmFyIGYgPSB0aGlzLmUgJiYgdGhpcy5lLmNoYW5uZWxIYW5kbGVNdWx0aXBsZUFycmF5cyA/IFtdIDogbnVsbCwgZyA9IDA7ZyA8IGMubGVuZ3RoO2crKykge1xuICAgICAgICAgIHZhciBoID0gY1tnXTtcbiAgICAgICAgICB0aGlzLnlhID0gaFswXTtcbiAgICAgICAgICBoID0gaFsxXTtcbiAgICAgICAgICAyID09IHRoaXMuYyA/IFwiY1wiID09IGhbMF0gPyAodGhpcy5aID0gaFsxXSwgdGhpcy5MID0gdGhpcy5jb3JyZWN0SG9zdFByZWZpeChoWzJdKSwgaCA9IGhbM10sIHRoaXMuaGEgPSBudWxsICE9IGggPyBoIDogNiwgdGhpcy5jID0gMywgdGhpcy5lICYmIHRoaXMuZS5jaGFubmVsT3BlbmVkKHRoaXMpLCB0aGlzLnViID0geGQodGhpcywgdGhpcy5MLCB0aGlzLkgpLCBZZCh0aGlzKSkgOiBcInN0b3BcIiA9PSBoWzBdICYmIFoodGhpcywgNykgOiAzID09IHRoaXMuYyAmJiAoXCJzdG9wXCIgPT0gaFswXSA/IChmICYmIGYubGVuZ3RoICYmICh0aGlzLmUuY2hhbm5lbEhhbmRsZU11bHRpcGxlQXJyYXlzKHRoaXMsIGYpLCBmLmxlbmd0aCA9IDApLCBaKHRoaXMsIDcpKSA6IFwibm9vcFwiICE9IGhbMF0gJiYgKGYgPyBmLnB1c2goaCkgOiB0aGlzLmUgJiYgdGhpcy5lLmNoYW5uZWxIYW5kbGVBcnJheSh0aGlzLCBoKSksIHRoaXMuZ2EgPSAwKVxuICAgICAgICB9XG4gICAgICAgIGYgJiYgZi5sZW5ndGggJiYgdGhpcy5lLmNoYW5uZWxIYW5kbGVNdWx0aXBsZUFycmF5cyh0aGlzLCBmKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnAuY29ycmVjdEhvc3RQcmVmaXggPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0aGlzLmZjID8gdGhpcy5lID8gdGhpcy5lLmNvcnJlY3RIb3N0UHJlZml4KGEpIDogYSA6IG51bGxcbn07XG5wLnJjID0gZnVuY3Rpb24oKSB7XG4gIG51bGwgIT0gdGhpcy5iYSAmJiAodGhpcy5iYSA9IG51bGwsIHRoaXMuay5jYW5jZWwoKSwgdGhpcy5rID0gbnVsbCwgWmQodGhpcyksIFQoMjApKVxufTtcbmZ1bmN0aW9uIFVkKGEpIHtcbiAgbnVsbCAhPSBhLmJhICYmIChxLmNsZWFyVGltZW91dChhLmJhKSwgYS5iYSA9IG51bGwpXG59XG5wLm1hID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmEuZGVidWcoXCJSZXF1ZXN0IGNvbXBsZXRlXCIpO1xuICB2YXIgYjtcbiAgaWYodGhpcy5rID09IGEpIHtcbiAgICBVZCh0aGlzKSwgdGhpcy5rID0gbnVsbCwgYiA9IDJcbiAgfWVsc2Uge1xuICAgIGlmKHRoaXMubyA9PSBhKSB7XG4gICAgICB0aGlzLm8gPSBudWxsLCBiID0gMVxuICAgIH1lbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICB0aGlzLmggPSBhLmg7XG4gIGlmKDAgIT0gdGhpcy5jKSB7XG4gICAgaWYoYS5KKSB7XG4gICAgICAxID09IGIgPyAoYiA9IHgoKSAtIGEucGEsIExkLmRpc3BhdGNoRXZlbnQobmV3IE5kKExkLCBhLlggPyBhLlgubGVuZ3RoIDogMCwgYiwgdGhpcy5WKSksIFZkKHRoaXMpLCB0aGlzLlEubGVuZ3RoID0gMCkgOiBZZCh0aGlzKVxuICAgIH1lbHNlIHtcbiAgICAgIHZhciBjID0gYS5FYigpO1xuICAgICAgaWYoMyA9PSBjIHx8IDcgPT0gYyB8fCAwID09IGMgJiYgMCA8IHRoaXMuaCkge1xuICAgICAgICB0aGlzLmEuZGVidWcoXCJOb3QgcmV0cnlpbmcgZHVlIHRvIGVycm9yIHR5cGVcIilcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdGhpcy5hLmRlYnVnKFwiTWF5YmUgcmV0cnlpbmcsIGxhc3QgZXJyb3I6IFwiICsgYmMoYywgdGhpcy5oKSk7XG4gICAgICAgIHZhciBkO1xuICAgICAgICBpZihkID0gMSA9PSBiKSB7XG4gICAgICAgICAgdGhpcy5vIHx8IHRoaXMuRiA/ICh0aGlzLmEuSShcIlJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKSwgZCA9ICExKSA6IHRoaXMuYyA9PSBKZCB8fCB0aGlzLlYgPj0gKHRoaXMuSmEgPyAwIDogdGhpcy5rYikgPyBkID0gITEgOiAodGhpcy5hLmRlYnVnKFwiR29pbmcgdG8gcmV0cnkgUE9TVFwiKSwgdGhpcy5GID0gVSh3KHRoaXMuUmIsIHRoaXMsIGEpLCAkZCh0aGlzLCB0aGlzLlYpKSwgdGhpcy5WKyssIGQgPSAhMClcbiAgICAgICAgfVxuICAgICAgICBpZihkIHx8IDIgPT0gYiAmJiBaZCh0aGlzKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIkV4Y2VlZGVkIG1heCBudW1iZXIgb2YgcmV0cmllc1wiKVxuICAgICAgfVxuICAgICAgdGhpcy5hLmRlYnVnKFwiRXJyb3I6IEhUVFAgcmVxdWVzdCBmYWlsZWRcIik7XG4gICAgICBzd2l0Y2goYykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgWih0aGlzLCA1KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIFoodGhpcywgMTApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgWih0aGlzLCA2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIFoodGhpcywgMTIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFoodGhpcywgMilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiAkZChhLCBiKSB7XG4gIHZhciBjID0gYS5nYyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGEuQmMpO1xuICBhLmlzQWN0aXZlKCkgfHwgKGEuYS5kZWJ1ZyhcIkluYWN0aXZlIGNoYW5uZWxcIiksIGMgKj0gMik7XG4gIHJldHVybiBjICogYlxufVxucC5qYyA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYoISgwIDw9IFhhKGFyZ3VtZW50cywgdGhpcy5jKSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhbm5lbCBzdGF0ZTogXCIgKyB0aGlzLmMpO1xuICB9XG59O1xuZnVuY3Rpb24gWihhLCBiKSB7XG4gIGEuYS5pbmZvKFwiRXJyb3IgY29kZSBcIiArIGIpO1xuICBpZigyID09IGIgfHwgOSA9PSBiKSB7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIGEuZSAmJiAoYyA9IGEuZS5nZXROZXR3b3JrVGVzdEltYWdlVXJpKGEpKTtcbiAgICB2YXIgZCA9IHcoYS5EYywgYSk7XG4gICAgYyB8fCAoYyA9IG5ldyBGKFwiLy93d3cuZ29vZ2xlLmNvbS9pbWFnZXMvY2xlYXJkb3QuZ2lmXCIpLCBKKGMpKTtcbiAgICBwZChjLnRvU3RyaW5nKCksIDFFNCwgZClcbiAgfWVsc2Uge1xuICAgIFQoMilcbiAgfVxuICBhZShhLCBiKVxufVxucC5EYyA9IGZ1bmN0aW9uKGEpIHtcbiAgYSA/ICh0aGlzLmEuaW5mbyhcIlN1Y2Nlc3NmdWxseSBwaW5nZWQgZ29vZ2xlLmNvbVwiKSwgVCgyKSkgOiAodGhpcy5hLmluZm8oXCJGYWlsZWQgdG8gcGluZyBnb29nbGUuY29tXCIpLCBUKDEpLCBhZSh0aGlzLCA4KSlcbn07XG5mdW5jdGlvbiBhZShhLCBiKSB7XG4gIGEuYS5kZWJ1ZyhcIkh0dHBDaGFubmVsOiBlcnJvciAtIFwiICsgYik7XG4gIGEuYyA9IDA7XG4gIGEuZSAmJiBhLmUuY2hhbm5lbEVycm9yKGEsIGIpO1xuICBUZChhKTtcbiAgUWQoYSlcbn1cbmZ1bmN0aW9uIFRkKGEpIHtcbiAgYS5jID0gMDtcbiAgYS5oID0gLTE7XG4gIGlmKGEuZSkge1xuICAgIGlmKDAgPT0gYS5RLmxlbmd0aCAmJiAwID09IGEucy5sZW5ndGgpIHtcbiAgICAgIGEuZS5jaGFubmVsQ2xvc2VkKGEpXG4gICAgfWVsc2Uge1xuICAgICAgYS5hLmRlYnVnKFwiTnVtYmVyIG9mIHVuZGVsaXZlcmVkIG1hcHMsIHBlbmRpbmc6IFwiICsgYS5RLmxlbmd0aCArIFwiLCBvdXRnb2luZzogXCIgKyBhLnMubGVuZ3RoKTtcbiAgICAgIHZhciBiID0gJGEoYS5RKSwgYyA9ICRhKGEucyk7XG4gICAgICBhLlEubGVuZ3RoID0gMDtcbiAgICAgIGEucy5sZW5ndGggPSAwO1xuICAgICAgYS5lLmNoYW5uZWxDbG9zZWQoYSwgYiwgYylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJkKGEsIGIpIHtcbiAgdmFyIGMgPSB2ZChhLCBudWxsLCBiKTtcbiAgYS5hLmRlYnVnKFwiR2V0Rm9yd2FyZENoYW5uZWxVcmk6IFwiICsgYyk7XG4gIHJldHVybiBjXG59XG5mdW5jdGlvbiB4ZChhLCBiLCBjKSB7XG4gIGIgPSB2ZChhLCBhLllhKCkgPyBiIDogbnVsbCwgYyk7XG4gIGEuYS5kZWJ1ZyhcIkdldEJhY2tDaGFubmVsVXJpOiBcIiArIGIpO1xuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gdmQoYSwgYiwgYykge1xuICB2YXIgZCA9IGMgaW5zdGFuY2VvZiBGID8gYy5uKCkgOiBuZXcgRihjLCB2b2lkIDApO1xuICBpZihcIlwiICE9IGQuamEpIHtcbiAgICBiICYmIGZiKGQsIGIgKyBcIi5cIiArIGQuamEpLCBnYihkLCBkLkJhKVxuICB9ZWxzZSB7XG4gICAgdmFyIGYgPSB3aW5kb3cubG9jYXRpb24sIGQgPSBzYihmLnByb3RvY29sLCBiID8gYiArIFwiLlwiICsgZi5ob3N0bmFtZSA6IGYuaG9zdG5hbWUsIGYucG9ydCwgYylcbiAgfVxuICBhLnhhICYmIEUoYS54YSwgZnVuY3Rpb24oYSwgYikge1xuICAgIEkoZCwgYiwgYSlcbiAgfSk7XG4gIEkoZCwgXCJWRVJcIiwgYS5oYSk7XG4gIFJkKGEsIGQpO1xuICByZXR1cm4gZFxufVxucC5oYiA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYoYSAmJiAhdGhpcy5aYSkge1xuICAgIHRocm93IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIHNlY29uZGFyeSBkb21haW4gY2FwYWJsZSBYaHJJbyBvYmplY3QuXCIpO1xuICB9XG4gIGEgPSBuZXcgaGQ7XG4gIGEuY2MgPSB0aGlzLlphO1xuICByZXR1cm4gYVxufTtcbnAuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuISF0aGlzLmUgJiYgdGhpcy5lLmlzQWN0aXZlKHRoaXMpXG59O1xuZnVuY3Rpb24gVShhLCBiKSB7XG4gIGlmKCFoYShhKSkge1xuICAgIHRocm93IEVycm9yKFwiRm4gbXVzdCBub3QgYmUgbnVsbCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIHJldHVybiBxLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgYSgpXG4gIH0sIGIpXG59XG5wLkcgPSBmdW5jdGlvbihhKSB7XG4gIExkLmRpc3BhdGNoRXZlbnQobmV3IE9kKExkLCBhKSlcbn07XG5mdW5jdGlvbiBUKGEpIHtcbiAgTGQuZGlzcGF0Y2hFdmVudChuZXcgTWQoTGQsIGEpKVxufVxucC5ZYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5aYSB8fCAhZWMoKVxufTtcbmZ1bmN0aW9uIGJlKCkge1xufVxucCA9IGJlLnByb3RvdHlwZTtcbnAuY2hhbm5lbEhhbmRsZU11bHRpcGxlQXJyYXlzID0gbnVsbDtcbnAub2tUb01ha2VSZXF1ZXN0ID0gYmEoMCk7XG5wLmNoYW5uZWxPcGVuZWQgPSBlKCk7XG5wLmNoYW5uZWxIYW5kbGVBcnJheSA9IGUoKTtcbnAuY2hhbm5lbEVycm9yID0gZSgpO1xucC5jaGFubmVsQ2xvc2VkID0gZSgpO1xucC5nZXRBZGRpdGlvbmFsUGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybnt9XG59O1xucC5nZXROZXR3b3JrVGVzdEltYWdlVXJpID0gYmEobnVsbCk7XG5wLmlzQWN0aXZlID0gYmEoITApO1xucC5iYWRNYXBFcnJvciA9IGUoKTtcbnAuY29ycmVjdEhvc3RQcmVmaXggPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBhXG59O1xudmFyICQsIGNlLCBkZSA9IFtdLnNsaWNlO1xuY2UgPSB7MDpcIk9rXCIsIDQ6XCJVc2VyIGlzIGxvZ2dpbmcgb3V0XCIsIDY6XCJVbmtub3duIHNlc3Npb24gSURcIiwgNzpcIlN0b3BwZWQgYnkgc2VydmVyXCIsIDg6XCJHZW5lcmFsIG5ldHdvcmsgZXJyb3JcIiwgMjpcIlJlcXVlc3QgZmFpbGVkXCIsIDk6XCJCbG9ja2VkIGJ5IGEgbmV0d29yayBhZG1pbmlzdHJhdG9yXCIsIDU6XCJObyBkYXRhIGZyb20gc2VydmVyXCIsIDEwOlwiR290IGJhZCBkYXRhIGZyb20gdGhlIHNlcnZlclwiLCAxMTpcIkdvdCBhIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcIn07XG4kID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYywgZCwgZiwgZywgaCwgbiwgaywgdCwgbCwgcjtcbiAgdCA9IHRoaXM7XG4gIGEgfHwgKGEgPSBcImNoYW5uZWxcIik7XG4gIGEubWF0Y2goLzpcXC9cXC8vKSAmJiBhLnJlcGxhY2UoL153cy8sIFwiaHR0cFwiKTtcbiAgYiB8fCAoYiA9IHt9KTtcbiAgcyhiIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBiKSAmJiAoYiA9IHt9KTtcbiAgbiA9IGIucmVjb25uZWN0VGltZSB8fCAzRTM7XG4gIHIgPSBmdW5jdGlvbihhKSB7XG4gICAgdC5yZWFkeVN0YXRlID0gdC5yZWFkeVN0YXRlID0gYVxuICB9O1xuICByKHRoaXMuQ0xPU0VEKTtcbiAgbCA9IG51bGw7XG4gIGcgPSBiLktjO1xuICBjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEsIGI7XG4gICAgYiA9IGFyZ3VtZW50c1swXTtcbiAgICBhID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gZGUuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHRbYl0gPyB0W2JdLmFwcGx5KHQsIGEpIDogdm9pZCAwXG4gICAgfWNhdGNoKGMpIHtcbiAgICAgIHRocm93IGEgPSBjLCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY29uc29sZSAmJiBudWxsICE9PSBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IoYS5zdGFjayksIGE7XG4gICAgfVxuICB9O1xuICBkID0gbmV3IGJlO1xuICBkLmNoYW5uZWxPcGVuZWQgPSBmdW5jdGlvbigpIHtcbiAgICBnID0gbDtcbiAgICByKCQuT1BFTik7XG4gICAgcmV0dXJuIGMoXCJvbm9wZW5cIilcbiAgfTtcbiAgZiA9IG51bGw7XG4gIGQuY2hhbm5lbEVycm9yID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBkO1xuICAgIGQgPSBjZVtiXTtcbiAgICBmID0gYjtcbiAgICByKCQuY2IpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYyhcIm9uZXJyb3JcIiwgZCwgYilcbiAgICB9Y2F0Y2goZykge1xuICAgIH1cbiAgfTtcbiAgayA9IG51bGw7XG4gIGQuY2hhbm5lbENsb3NlZCA9IGZ1bmN0aW9uKGEsIGQsIGcpIHtcbiAgICBpZih0LnJlYWR5U3RhdGUgIT09ICQuQ0xPU0VEKSB7XG4gICAgICBsID0gbnVsbDtcbiAgICAgIGEgPSBmID8gY2VbZl0gOiBcIkNsb3NlZFwiO1xuICAgICAgcigkLkNMT1NFRCk7XG4gICAgICB0cnkge1xuICAgICAgICBjKFwib25jbG9zZVwiLCBhLCBkLCBnKVxuICAgICAgfWNhdGNoKGVlKSB7XG4gICAgICB9XG4gICAgICBiLnJlY29ubmVjdCAmJiAoNyAhPT0gZiAmJiAwICE9PSBmKSAmJiAoZCA9IDYgPT09IGYgPyAwIDogbiwgY2xlYXJUaW1lb3V0KGspLCBrID0gc2V0VGltZW91dChoLCBkKSk7XG4gICAgICByZXR1cm4gZiA9IG51bGxcbiAgICB9XG4gIH07XG4gIGQuY2hhbm5lbEhhbmRsZUFycmF5ID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjKFwib25tZXNzYWdlXCIsIGIpXG4gIH07XG4gIGggPSBmdW5jdGlvbigpIHtcbiAgICBpZihsKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlJlY29ubmVjdCgpIGNhbGxlZCBmcm9tIGludmFsaWQgc3RhdGVcIik7XG4gICAgfVxuICAgIHIoJC5DT05ORUNUSU5HKTtcbiAgICBjKFwib25jb25uZWN0aW5nXCIpO1xuICAgIGNsZWFyVGltZW91dChrKTtcbiAgICBsID0gbmV3IElkKGIuYXBwVmVyc2lvbiwgbnVsbCAhPSBnID8gZy5DYiA6IHZvaWQgMCk7XG4gICAgYi5jcm9zc0RvbWFpblhociAmJiAobC5aYSA9ICEwKTtcbiAgICBsLmUgPSBkO1xuICAgIGYgPSBudWxsO1xuICAgIGlmKGIuZmFpbEZhc3QpIHtcbiAgICAgIHZhciBoID0gbDtcbiAgICAgIGguSmEgPSAhMDtcbiAgICAgIGguYS5pbmZvKFwic2V0RmFpbEZhc3Q6IHRydWVcIik7XG4gICAgICAoaC5vIHx8IGguRikgJiYgaC5WID4gKGguSmEgPyAwIDogaC5rYikgJiYgKGguYS5pbmZvKFwiUmV0cnkgY291bnQgXCIgKyBoLlYgKyBcIiA+IG5ldyBtYXhSZXRyaWVzIFwiICsgKGguSmEgPyAwIDogaC5rYikgKyBcIi4gRmFpbCBpbW1lZGlhdGVseSFcIiksIGgubyA/IChoLm8uY2FuY2VsKCksIGgubWEoaC5vKSkgOiAocS5jbGVhclRpbWVvdXQoaC5GKSwgaC5GID0gbnVsbCwgWihoLCAyKSkpXG4gICAgfVxuICAgIHJldHVybiBsLmdiKFwiXCIgKyBhICsgXCIvdGVzdFwiLCBcIlwiICsgYSArIFwiL2JpbmRcIiwgYi5leHRyYVBhcmFtcywgbnVsbCAhPSBnID8gZy5aIDogdm9pZCAwLCBudWxsICE9IGcgPyBnLnlhIDogdm9pZCAwKVxuICB9O1xuICB0aGlzLm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZih0LnJlYWR5U3RhdGUgIT09IHQuQ0xPU0VEKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkFscmVhZHkgb3BlblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGgoKVxuICB9O1xuICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KGspO1xuICAgIGYgPSAwO1xuICAgIGlmKHQucmVhZHlTdGF0ZSAhPT0gJC5DTE9TRUQpIHtcbiAgICAgIHJldHVybiByKCQuY2IpLCBsLmRpc2Nvbm5lY3QoKVxuICAgIH1cbiAgfTtcbiAgdGhpcy5zZW5kTWFwID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBiO1xuICAgIGlmKChiID0gdC5yZWFkeVN0YXRlKSA9PT0gJC5jYiB8fCBiID09PSAkLkNMT1NFRCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3Qgc2VuZCB0byBhIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIH1cbiAgICBiID0gbDtcbiAgICBpZigwID09IGIuYykge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbjogc2VuZGluZyBtYXAgd2hlbiBzdGF0ZSBpcyBjbG9zZWRcIik7XG4gICAgfVxuICAgIDFFMyA9PSBiLnMubGVuZ3RoICYmIGIuYS5JKFwiQWxyZWFkeSBoYXZlIDEwMDAgcXVldWVkIG1hcHMgdXBvbiBxdWV1ZWluZyBcIiArIEtjKGEpKTtcbiAgICBiLnMucHVzaChuZXcgS2QoYi5xYysrLCBhKSk7XG4gICAgMiAhPSBiLmMgJiYgMyAhPSBiLmMgfHwgVmQoYilcbiAgfTtcbiAgdGhpcy5zZW5kID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRNYXAoe0pTT046S2MoYSl9KVxuICB9O1xuICBoKCk7XG4gIHJldHVybiB0aGlzXG59O1xuJC5wcm90b3R5cGUuQ09OTkVDVElORyA9ICQuQ09OTkVDVElORyA9ICQuQ09OTkVDVElORyA9IDA7XG4kLnByb3RvdHlwZS5PUEVOID0gJC5PUEVOID0gJC5PUEVOID0gMTtcbiQucHJvdG90eXBlLkNMT1NJTkcgPSAkLkNMT1NJTkcgPSAkLmNiID0gMjtcbiQucHJvdG90eXBlLkNMT1NFRCA9ICQuQ0xPU0VEID0gJC5DTE9TRUQgPSAzO1xuKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBleHBvcnRzICYmIG51bGwgIT09IGV4cG9ydHMgPyBleHBvcnRzIDogd2luZG93KS5CQ1NvY2tldCA9ICQ7XG5cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKXtcbihmdW5jdGlvbigpe3ZhciByPXtleHBvcnRzOnt9fSxlPXIuZXhwb3J0cztlLm5hbWU9XCJ0ZXh0XCIsZS51cmk9XCJodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dHYxXCIsZS5jcmVhdGU9ZnVuY3Rpb24ocil7aWYobnVsbCE9ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgRXJyb3IoXCJJbml0aWFsIGRhdGEgbXVzdCBiZSBhIHN0cmluZ1wiKTtyZXR1cm4gcnx8XCJcIn07dmFyIHQ9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24ocil7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfSxuPWZ1bmN0aW9uKHIpe2lmKCF0KHIpKXRocm93IEVycm9yKFwiT3AgbXVzdCBiZSBhbiBhcnJheSBvZiBjb21wb25lbnRzXCIpO2Zvcih2YXIgZT1udWxsLG49MDtyLmxlbmd0aD5uO24rKyl7dmFyIG89cltuXTtzd2l0Y2godHlwZW9mIG8pe2Nhc2VcIm9iamVjdFwiOmlmKCEoXCJudW1iZXJcIj09dHlwZW9mIG8uZCYmby5kPjApKXRocm93IEVycm9yKFwiT2JqZWN0IGNvbXBvbmVudHMgbXVzdCBiZSBkZWxldGVzIG9mIHNpemUgPiAwXCIpO2JyZWFrO2Nhc2VcInN0cmluZ1wiOmlmKCEoby5sZW5ndGg+MCkpdGhyb3cgRXJyb3IoXCJJbnNlcnRzIGNhbm5vdCBiZSBlbXB0eVwiKTticmVhaztjYXNlXCJudW1iZXJcIjppZighKG8+MCkpdGhyb3cgRXJyb3IoXCJTa2lwIGNvbXBvbmVudHMgbXVzdCBiZSA+MFwiKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl0aHJvdyBFcnJvcihcIkFkamFjZW50IHNraXAgY29tcG9uZW50cyBzaG91bGQgYmUgY29tYmluZWRcIil9ZT1vfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IEVycm9yKFwiT3AgaGFzIGEgdHJhaWxpbmcgc2tpcFwiKX0sbz1mdW5jdGlvbihyKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGUmJjAhPT1lLmQ/MD09PXIubGVuZ3RoP3IucHVzaChlKTp0eXBlb2YgZT09dHlwZW9mIHJbci5sZW5ndGgtMV0/XCJvYmplY3RcIj09dHlwZW9mIGU/cltyLmxlbmd0aC0xXS5kKz1lLmQ6cltyLmxlbmd0aC0xXSs9ZTpyLnB1c2goZSk6dm9pZCAwfX0scz1mdW5jdGlvbihyKXt2YXIgZT0wLHQ9MCxuPWZ1bmN0aW9uKG4sbyl7aWYoZT09PXIubGVuZ3RoKXJldHVybi0xPT09bj9udWxsOm47dmFyIHMsaT1yW2VdO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBpPy0xPT09bnx8bj49aS10PyhzPWktdCwrK2UsdD0wLHMpOih0Kz1uLG4pOlwic3RyaW5nXCI9PXR5cGVvZiBpPy0xPT09bnx8XCJpXCI9PT1vfHxuPj1pLmxlbmd0aC10PyhzPWkuc2xpY2UodCksKytlLHQ9MCxzKToocz1pLnNsaWNlKHQsdCtuKSx0Kz1uLHMpOi0xPT09bnx8XCJkXCI9PT1vfHxuPj1pLmQtdD8ocz17ZDppLmQtdH0sKytlLHQ9MCxzKToodCs9bix7ZDpufSl9LG89ZnVuY3Rpb24oKXtyZXR1cm4gcltlXX07cmV0dXJuW24sb119LGk9ZnVuY3Rpb24ocil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/cjpyLmxlbmd0aHx8ci5kfSxhPWZ1bmN0aW9uKHIpe3JldHVybiByLmxlbmd0aD4wJiZcIm51bWJlclwiPT10eXBlb2YgcltyLmxlbmd0aC0xXSYmci5wb3AoKSxyfTtlLm5vcm1hbGl6ZT1mdW5jdGlvbihyKXtmb3IodmFyIGU9W10sdD1vKGUpLG49MDtyLmxlbmd0aD5uO24rKyl0KHJbbl0pO3JldHVybiBhKGUpfSxlLmFwcGx5PWZ1bmN0aW9uKHIsZSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgRXJyb3IoXCJTbmFwc2hvdCBzaG91bGQgYmUgYSBzdHJpbmdcIik7bihlKTtmb3IodmFyIHQ9W10sbz0wO2UubGVuZ3RoPm87bysrKXt2YXIgcz1lW29dO3N3aXRjaCh0eXBlb2Ygcyl7Y2FzZVwibnVtYmVyXCI6aWYocz5yLmxlbmd0aCl0aHJvdyBFcnJvcihcIlRoZSBvcCBpcyB0b28gbG9uZyBmb3IgdGhpcyBkb2N1bWVudFwiKTt0LnB1c2goci5zbGljZSgwLHMpKSxyPXIuc2xpY2Uocyk7YnJlYWs7Y2FzZVwic3RyaW5nXCI6dC5wdXNoKHMpO2JyZWFrO2Nhc2VcIm9iamVjdFwiOnI9ci5zbGljZShzLmQpfX1yZXR1cm4gdC5qb2luKFwiXCIpK3J9LGUudHJhbnNmb3JtPWZ1bmN0aW9uKHIsZSx0KXtpZihcImxlZnRcIiE9dCYmXCJyaWdodFwiIT10KXRocm93IEVycm9yKFwic2lkZSAoXCIrdCtcIikgbXVzdCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtuKHIpLG4oZSk7Zm9yKHZhciBjPVtdLGY9byhjKSx1PXMociksaD11WzBdLHA9dVsxXSxiPTA7ZS5sZW5ndGg+YjtiKyspe3ZhciBsLGcsbT1lW2JdO3N3aXRjaCh0eXBlb2YgbSl7Y2FzZVwibnVtYmVyXCI6Zm9yKGw9bTtsPjA7KWc9aChsLFwiaVwiKSxmKGcpLFwic3RyaW5nXCIhPXR5cGVvZiBnJiYobC09aShnKSk7YnJlYWs7Y2FzZVwic3RyaW5nXCI6XCJsZWZ0XCI9PT10JiZcInN0cmluZ1wiPT10eXBlb2YgcCgpJiZmKGgoLTEpKSxmKG0ubGVuZ3RoKTticmVhaztjYXNlXCJvYmplY3RcIjpmb3IobD1tLmQ7bD4wOylzd2l0Y2goZz1oKGwsXCJpXCIpLHR5cGVvZiBnKXtjYXNlXCJudW1iZXJcIjpsLT1nO2JyZWFrO2Nhc2VcInN0cmluZ1wiOmYoZyk7YnJlYWs7Y2FzZVwib2JqZWN0XCI6bC09Zy5kfX19Zm9yKDttPWgoLTEpOylmKG0pO3JldHVybiBhKGMpfSxlLmNvbXBvc2U9ZnVuY3Rpb24ocixlKXtuKHIpLG4oZSk7Zm9yKHZhciB0PVtdLGM9byh0KSxmPXMocilbMF0sdT0wO2UubGVuZ3RoPnU7dSsrKXt2YXIgaCxwLGI9ZVt1XTtzd2l0Y2godHlwZW9mIGIpe2Nhc2VcIm51bWJlclwiOmZvcihoPWI7aD4wOylwPWYoaCxcImRcIiksYyhwKSxcIm9iamVjdFwiIT10eXBlb2YgcCYmKGgtPWkocCkpO2JyZWFrO2Nhc2VcInN0cmluZ1wiOmMoYik7YnJlYWs7Y2FzZVwib2JqZWN0XCI6Zm9yKGg9Yi5kO2g+MDspc3dpdGNoKHA9ZihoLFwiZFwiKSx0eXBlb2YgcCl7Y2FzZVwibnVtYmVyXCI6Yyh7ZDpwfSksaC09cDticmVhaztjYXNlXCJzdHJpbmdcIjpoLT1wLmxlbmd0aDticmVhaztjYXNlXCJvYmplY3RcIjpjKHApfX19Zm9yKDtiPWYoLTEpOyljKGIpO3JldHVybiBhKHQpfTt2YXIgYz1mdW5jdGlvbihyLGUpe2Zvcih2YXIgdD0wLG49MDtlLmxlbmd0aD5uO24rKyl7dmFyIG89ZVtuXTtpZih0Pj1yKWJyZWFrO3N3aXRjaCh0eXBlb2Ygbyl7Y2FzZVwibnVtYmVyXCI6aWYodCtvPj1yKXJldHVybiByO3QrPW87YnJlYWs7Y2FzZVwic3RyaW5nXCI6dCs9by5sZW5ndGgscis9by5sZW5ndGg7YnJlYWs7Y2FzZVwib2JqZWN0XCI6ci09TWF0aC5taW4oby5kLHItdCl9fXJldHVybiByfTtlLnRyYW5zZm9ybUN1cnNvcj1mdW5jdGlvbihyLGUsdCl7dmFyIG49MDtpZih0KXtmb3IodmFyIG89MDtlLmxlbmd0aD5vO28rKyl7dmFyIHM9ZVtvXTtzd2l0Y2godHlwZW9mIHMpe2Nhc2VcIm51bWJlclwiOm4rPXM7YnJlYWs7Y2FzZVwic3RyaW5nXCI6bis9cy5sZW5ndGh9fXJldHVybltuLG5dfXJldHVybltjKHJbMF0sZSksYyhyWzFdLGUpXX07dmFyIGY9d2luZG93Lm90dHlwZXM9d2luZG93Lm90dHlwZXN8fHt9LHU9ci5leHBvcnRzO2ZbdS5uYW1lXT11LHUudXJpJiYoZlt1LnVyaV09dSl9KSgpOy8vIFRleHQgZG9jdW1lbnQgQVBJIGZvciB0aGUgJ3RleHQnIHR5cGUuXG5cbi8vIFRoZSBBUEkgaW1wbGVtZW50cyB0aGUgc3RhbmRhcmQgdGV4dCBBUEkgbWV0aG9kcy4gSW4gcGFydGljdWxhcjpcbi8vXG4vLyAtIGdldExlbmd0aCgpIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgaW4gY2hhcmFjdGVyc1xuLy8gLSBnZXRUZXh0KCkgcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZG9jdW1lbnRcbi8vIC0gaW5zZXJ0KHBvcywgdGV4dCwgW2NhbGxiYWNrXSkgaW5zZXJ0cyB0ZXh0IGF0IHBvc2l0aW9uIHBvcyBpbiB0aGUgZG9jdW1lbnRcbi8vIC0gcmVtb3ZlKHBvcywgbGVuZ3RoLCBbY2FsbGJhY2tdKSByZW1vdmVzIGxlbmd0aCBjaGFyYWN0ZXJzIGF0IHBvc2l0aW9uIHBvc1xuLy9cbi8vIEV2ZW50cyBhcmUgaW1wbGVtZW50ZWQgYnkganVzdCBhZGRpbmcgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZHMgdG8geW91clxuLy8gY29udGV4dCBvYmplY3QuXG4vLyBvbkluc2VydChwb3MsIHRleHQpOiBDYWxsZWQgd2hlbiB0ZXh0IGlzIGluc2VydGVkLlxuLy8gb25SZW1vdmUocG9zLCBsZW5ndGgpOiBDYWxsZWQgd2hlbiB0ZXh0IGlzIHJlbW92ZWQuXG5cbnZhciBfdHlwZXMgPSAodHlwZW9mIGJyZXF1aXJlICE9PSAndW5kZWZpbmVkJykgP1xuICBicmVxdWlyZSgnb3R0eXBlcycpIDogd2luZG93Lm90dHlwZXM7XG5cbl90eXBlc1snaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3RleHR2MSddLmFwaSA9IHtcbiAgcHJvdmlkZXM6IHt0ZXh0OiB0cnVlfSxcbiAgXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmdcbiAgZ2V0TGVuZ3RoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZ2V0U25hcHNob3QoKS5sZW5ndGg7IH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBkb2N1bWVudFxuICBnZXRUZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZ2V0U25hcHNob3QoKTsgfSxcblxuICAvLyBJbnNlcnQgdGhlIHNwZWNpZmllZCB0ZXh0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbiAgaW5zZXJ0OiBmdW5jdGlvbihwb3MsIHRleHQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VibWl0T3AoW3BvcywgdGV4dF0sIGNhbGxiYWNrKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKHBvcywgbGVuZ3RoLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnN1Ym1pdE9wKFtwb3MsIHtkOmxlbmd0aH1dLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLy8gV2hlbiB5b3UgdXNlIHRoaXMgQVBJLCB5b3Ugc2hvdWxkIGltcGxlbWVudCB0aGVzZSB0d28gbWV0aG9kc1xuICAvLyBpbiB5b3VyIGVkaXRpbmcgY29udGV4dC5cbiAgLy9vbkluc2VydDogZnVuY3Rpb24ocG9zLCB0ZXh0KSB7fSxcbiAgLy9vblJlbW92ZTogZnVuY3Rpb24ocG9zLCByZW1vdmVkTGVuZ3RoKSB7fSxcblxuICBfb25PcDogZnVuY3Rpb24ob3ApIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgc3BvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IG9wW2ldO1xuICAgICAgc3dpdGNoICh0eXBlb2YgY29tcG9uZW50KSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcG9zICs9IGNvbXBvbmVudDtcbiAgICAgICAgICBzcG9zICs9IGNvbXBvbmVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBpZiAodGhpcy5vbkluc2VydCkgdGhpcy5vbkluc2VydChwb3MsIGNvbXBvbmVudCk7XG4gICAgICAgICAgcG9zICs9IGNvbXBvbmVudC5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKHRoaXMub25SZW1vdmUpIHRoaXMub25SZW1vdmUocG9zLCBjb21wb25lbnQuZCk7XG4gICAgICAgICAgc3BvcyArPSBjb21wb25lbnQuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vLyBUaGlzIGlzIGEgcHJlbHVkZSB3aGljaCBjb21lcyBiZWZvcmUgdGhlIEpTIGJsb2Igb2YgZWFjaCBKUyB0eXBlIGZvciB0aGUgd2ViLlxuKGZ1bmN0aW9uKCl7XG4gIHZhciBtb2R1bGUgPSB7ZXhwb3J0czp7fX07XG4gIHZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8vIFRoZXNlIG1ldGhvZHMgbGV0IHlvdSBidWlsZCBhIHRyYW5zZm9ybSBmdW5jdGlvbiBmcm9tIGEgdHJhbnNmb3JtQ29tcG9uZW50XG4vLyBmdW5jdGlvbiBmb3IgT1QgdHlwZXMgbGlrZSBKU09OMCBpbiB3aGljaCBvcGVyYXRpb25zIGFyZSBsaXN0cyBvZiBjb21wb25lbnRzXG4vLyBhbmQgdHJhbnNmb3JtaW5nIHRoZW0gcmVxcmV1aXJlcyBOXjIgd29yay4gSSBmaW5kIGl0IGtpbmQgb2YgbmFzdHkgdGhhdCBJIG5lZWRcbi8vIHRoaXMsIGJ1dCBJJ20gbm90IHJlYWxseSBzdXJlIHdoYXQgYSBiZXR0ZXIgc29sdXRpb24gaXMuIE1heWJlIEkgc2hvdWxkIGRvXG4vLyB0aGlzIGF1dG9tYXRpY2FsbHkgdG8gdHlwZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcG9zZSBmdW5jdGlvbiBkZWZpbmVkLlxuXG4vLyBBZGQgdHJhbnNmb3JtIGFuZCB0cmFuc2Zvcm1YIGZ1bmN0aW9ucyBmb3IgYW4gT1QgdHlwZSB3aGljaCBoYXNcbi8vIHRyYW5zZm9ybUNvbXBvbmVudCBkZWZpbmVkLiAgdHJhbnNmb3JtQ29tcG9uZW50KGRlc3RpbmF0aW9uIGFycmF5LFxuLy8gY29tcG9uZW50LCBvdGhlciBjb21wb25lbnQsIHNpZGUpXG5leHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0gPSBmdW5jdGlvbih0eXBlLCB0cmFuc2Zvcm1Db21wb25lbnQsIGNoZWNrVmFsaWRPcCwgYXBwZW5kKSB7XG4gIHZhciB0cmFuc2Zvcm1Db21wb25lbnRYID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGRlc3RMZWZ0LCBkZXN0UmlnaHQpIHtcbiAgICB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdExlZnQsIGxlZnQsIHJpZ2h0LCAnbGVmdCcpO1xuICAgIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0UmlnaHQsIHJpZ2h0LCBsZWZ0LCAncmlnaHQnKTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtWCA9IHR5cGUudHJhbnNmb3JtWCA9IGZ1bmN0aW9uKGxlZnRPcCwgcmlnaHRPcCkge1xuICAgIGNoZWNrVmFsaWRPcChsZWZ0T3ApO1xuICAgIGNoZWNrVmFsaWRPcChyaWdodE9wKTtcbiAgICB2YXIgbmV3UmlnaHRPcCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaWdodE9wLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmlnaHRDb21wb25lbnQgPSByaWdodE9wW2ldO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBuZXdMZWZ0T3AgYnkgY29tcG9zaW5nIGxlZnRPcCBieSByaWdodENvbXBvbmVudFxuICAgICAgdmFyIG5ld0xlZnRPcCA9IFtdO1xuICAgICAgdmFyIGsgPSAwO1xuICAgICAgd2hpbGUgKGsgPCBsZWZ0T3AubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0QyA9IFtdO1xuICAgICAgICB0cmFuc2Zvcm1Db21wb25lbnRYKGxlZnRPcFtrXSwgcmlnaHRDb21wb25lbnQsIG5ld0xlZnRPcCwgbmV4dEMpO1xuICAgICAgICBrKys7XG5cbiAgICAgICAgaWYgKG5leHRDLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbmV4dENbMF07XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dEMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGs7IGogPCBsZWZ0T3AubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGFwcGVuZChuZXdMZWZ0T3AsIGxlZnRPcFtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICAgIHZhciBwYWlyID0gdHJhbnNmb3JtWChsZWZ0T3Auc2xpY2UoayksIG5leHRDKTtcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHBhaXJbMF0ubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIGFwcGVuZChuZXdMZWZ0T3AsIHBhaXJbMF1bbF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHBhaXJbMV0ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGFwcGVuZChuZXdSaWdodE9wLCBwYWlyWzFdW3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyaWdodENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICAgIGFwcGVuZChuZXdSaWdodE9wLCByaWdodENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBsZWZ0T3AgPSBuZXdMZWZ0T3A7XG4gICAgfVxuICAgIHJldHVybiBbbGVmdE9wLCBuZXdSaWdodE9wXTtcbiAgfTtcblxuICAvLyBUcmFuc2Zvcm1zIG9wIHdpdGggc3BlY2lmaWVkIHR5cGUgKCdsZWZ0JyBvciAncmlnaHQnKSBieSBvdGhlck9wLlxuICB0eXBlLnRyYW5zZm9ybSA9IHR5cGVbJ3RyYW5zZm9ybSddID0gZnVuY3Rpb24ob3AsIG90aGVyT3AsIHR5cGUpIHtcbiAgICBpZiAoISh0eXBlID09PSAnbGVmdCcgfHwgdHlwZSA9PT0gJ3JpZ2h0JykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgJ2xlZnQnIG9yICdyaWdodCdcIik7XG5cbiAgICBpZiAob3RoZXJPcC5sZW5ndGggPT09IDApIHJldHVybiBvcDtcblxuICAgIGlmIChvcC5sZW5ndGggPT09IDEgJiYgb3RoZXJPcC5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gdHJhbnNmb3JtQ29tcG9uZW50KFtdLCBvcFswXSwgb3RoZXJPcFswXSwgdHlwZSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybVgob3AsIG90aGVyT3ApWzBdO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1YKG90aGVyT3AsIG9wKVsxXTtcbiAgfTtcbn07XG4vLyBERVBSRUNBVEVEIVxuLy9cbi8vIFRoaXMgdHlwZSB3b3JrcywgYnV0IGlzIG5vdCBleHBvcnRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIHRoaXMgbGlicmFyeS5cblxuXG4vLyBBIHNpbXBsZSB0ZXh0IGltcGxlbWVudGF0aW9uXG4vL1xuLy8gT3BlcmF0aW9ucyBhcmUgbGlzdHMgb2YgY29tcG9uZW50cy5cbi8vIEVhY2ggY29tcG9uZW50IGVpdGhlciBpbnNlcnRzIG9yIGRlbGV0ZXMgYXQgYSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuLy9cbi8vIENvbXBvbmVudHMgYXJlIGVpdGhlcjpcbi8vICB7aTonc3RyJywgcDoxMDB9OiBJbnNlcnQgJ3N0cicgYXQgcG9zaXRpb24gMTAwIGluIHRoZSBkb2N1bWVudFxuLy8gIHtkOidzdHInLCBwOjEwMH06IERlbGV0ZSAnc3RyJyBhdCBwb3NpdGlvbiAxMDAgaW4gdGhlIGRvY3VtZW50XG4vL1xuLy8gQ29tcG9uZW50cyBpbiBhbiBvcGVyYXRpb24gYXJlIGV4ZWN1dGVkIHNlcXVlbnRpYWxseSwgc28gdGhlIHBvc2l0aW9uIG9mIGNvbXBvbmVudHNcbi8vIGFzc3VtZXMgcHJldmlvdXMgY29tcG9uZW50cyBoYXZlIGFscmVhZHkgZXhlY3V0ZWQuXG4vL1xuLy8gRWc6IFRoaXMgb3A6XG4vLyAgIFt7aTonYWJjJywgcDowfV1cbi8vIGlzIGVxdWl2YWxlbnQgdG8gdGhpcyBvcDpcbi8vICAgW3tpOidhJywgcDowfSwge2k6J2InLCBwOjF9LCB7aTonYycsIHA6Mn1dXG5cbi8vIE5PVEU6IFRoZSBnbG9iYWwgc2NvcGUgaGVyZSBpcyBzaGFyZWQgd2l0aCBvdGhlciBzaGFyZWpzIGZpbGVzIHdoZW4gYnVpbHQgd2l0aCBjbG9zdXJlLlxuLy8gQmUgY2FyZWZ1bCB3aGF0IGVuZHMgdXAgaW4geW91ciBuYW1lc3BhY2UuXG5cbnZhciB0ZXh0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICd0ZXh0MCcsXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0djAnLFxuICBjcmVhdGU6IGZ1bmN0aW9uKGluaXRpYWwpIHtcbiAgICBpZiAoKGluaXRpYWwgIT0gbnVsbCkgJiYgdHlwZW9mIGluaXRpYWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsIHx8ICcnO1xuICB9XG59O1xuXG4vKiogSW5zZXJ0IHMyIGludG8gczEgYXQgcG9zLiAqL1xudmFyIHN0ckluamVjdCA9IGZ1bmN0aW9uKHMxLCBwb3MsIHMyKSB7XG4gIHJldHVybiBzMS5zbGljZSgwLCBwb3MpICsgczIgKyBzMS5zbGljZShwb3MpO1xufTtcblxuLyoqIENoZWNrIHRoYXQgYW4gb3BlcmF0aW9uIGNvbXBvbmVudCBpcyB2YWxpZC4gVGhyb3dzIGlmIGl0cyBpbnZhbGlkLiAqL1xudmFyIGNoZWNrVmFsaWRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIGlmICh0eXBlb2YgYy5wICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudCBtaXNzaW5nIHBvc2l0aW9uIGZpZWxkJyk7XG5cbiAgaWYgKCh0eXBlb2YgYy5pID09PSAnc3RyaW5nJykgPT09ICh0eXBlb2YgYy5kID09PSAnc3RyaW5nJykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnQgbmVlZHMgYW4gaSBvciBkIGZpZWxkJyk7XG5cbiAgaWYgKGMucCA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGlvbiBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcbn07XG5cbi8qKiBDaGVjayB0aGF0IGFuIG9wZXJhdGlvbiBpcyB2YWxpZCAqL1xudmFyIGNoZWNrVmFsaWRPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICBjaGVja1ZhbGlkQ29tcG9uZW50KG9wW2ldKTtcbiAgfVxufTtcblxuLyoqIEFwcGx5IG9wIHRvIHNuYXBzaG90ICovXG50ZXh0LmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIHZhciBkZWxldGVkO1xuXG4gIGNoZWNrVmFsaWRPcChvcCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3BbaV07XG4gICAgaWYgKGNvbXBvbmVudC5pICE9IG51bGwpIHtcbiAgICAgIHNuYXBzaG90ID0gc3RySW5qZWN0KHNuYXBzaG90LCBjb21wb25lbnQucCwgY29tcG9uZW50LmkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVkID0gc25hcHNob3Quc2xpY2UoY29tcG9uZW50LnAsIGNvbXBvbmVudC5wICsgY29tcG9uZW50LmQubGVuZ3RoKTtcbiAgICAgIGlmIChjb21wb25lbnQuZCAhPT0gZGVsZXRlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVsZXRlIGNvbXBvbmVudCAnXCIgKyBjb21wb25lbnQuZCArIFwiJyBkb2VzIG5vdCBtYXRjaCBkZWxldGVkIHRleHQgJ1wiICsgZGVsZXRlZCArIFwiJ1wiKTtcblxuICAgICAgc25hcHNob3QgPSBzbmFwc2hvdC5zbGljZSgwLCBjb21wb25lbnQucCkgKyBzbmFwc2hvdC5zbGljZShjb21wb25lbnQucCArIGNvbXBvbmVudC5kLmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzbmFwc2hvdDtcbn07XG5cbi8qKlxuICogQXBwZW5kIGEgY29tcG9uZW50IHRvIHRoZSBlbmQgb2YgbmV3T3AuIEV4cG9ydGVkIGZvciB1c2UgYnkgdGhlIHJhbmRvbSBvcFxuICogZ2VuZXJhdG9yIGFuZCB0aGUgSlNPTjAgdHlwZS5cbiAqL1xudmFyIGFwcGVuZCA9IHRleHQuX2FwcGVuZCA9IGZ1bmN0aW9uKG5ld09wLCBjKSB7XG4gIGlmIChjLmkgPT09ICcnIHx8IGMuZCA9PT0gJycpIHJldHVybjtcblxuICBpZiAobmV3T3AubGVuZ3RoID09PSAwKSB7XG4gICAgbmV3T3AucHVzaChjKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdCA9IG5ld09wW25ld09wLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QuaSAhPSBudWxsICYmIGMuaSAhPSBudWxsICYmIGxhc3QucCA8PSBjLnAgJiYgYy5wIDw9IGxhc3QucCArIGxhc3QuaS5sZW5ndGgpIHtcbiAgICAgIC8vIENvbXBvc2UgdGhlIGluc2VydCBpbnRvIHRoZSBwcmV2aW91cyBpbnNlcnRcbiAgICAgIG5ld09wW25ld09wLmxlbmd0aCAtIDFdID0ge2k6c3RySW5qZWN0KGxhc3QuaSwgYy5wIC0gbGFzdC5wLCBjLmkpLCBwOmxhc3QucH07XG5cbiAgICB9IGVsc2UgaWYgKGxhc3QuZCAhPSBudWxsICYmIGMuZCAhPSBudWxsICYmIGMucCA8PSBsYXN0LnAgJiYgbGFzdC5wIDw9IGMucCArIGMuZC5sZW5ndGgpIHtcbiAgICAgIC8vIENvbXBvc2UgdGhlIGRlbGV0ZXMgdG9nZXRoZXJcbiAgICAgIG5ld09wW25ld09wLmxlbmd0aCAtIDFdID0ge2Q6c3RySW5qZWN0KGMuZCwgbGFzdC5wIC0gYy5wLCBsYXN0LmQpLCBwOmMucH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3T3AucHVzaChjKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBDb21wb3NlIG9wMSBhbmQgb3AyIHRvZ2V0aGVyICovXG50ZXh0LmNvbXBvc2UgPSBmdW5jdGlvbihvcDEsIG9wMikge1xuICBjaGVja1ZhbGlkT3Aob3AxKTtcbiAgY2hlY2tWYWxpZE9wKG9wMik7XG4gIHZhciBuZXdPcCA9IG9wMS5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wMi5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZChuZXdPcCwgb3AyW2ldKTtcbiAgfVxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vKiogQ2xlYW4gdXAgYW4gb3AgKi9cbnRleHQubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG5ld09wID0gW107XG5cbiAgLy8gTm9ybWFsaXplIHNob3VsZCBhbGxvdyBvcHMgd2hpY2ggYXJlIGEgc2luZ2xlICh1bndyYXBwZWQpIGNvbXBvbmVudDpcbiAgLy8ge2k6J2FzZGYnLCBwOjIzfS5cbiAgLy8gVGhlcmUncyBubyBnb29kIHdheSB0byB0ZXN0IGlmIHNvbWV0aGluZyBpcyBhbiBhcnJheTpcbiAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG4gIC8vIHNvIHRoaXMgaXMgcHJvYmFibHkgdGhlIGxlYXN0IGJhZCBzb2x1dGlvbi5cbiAgaWYgKG9wLmkgIT0gbnVsbCB8fCBvcC5wICE9IG51bGwpIG9wID0gW29wXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcbiAgICBpZiAoYy5wID09IG51bGwpIGMucCA9IDA7XG5cbiAgICBhcHBlbmQobmV3T3AsIGMpO1xuICB9XG5cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLy8gVGhpcyBoZWxwZXIgbWV0aG9kIHRyYW5zZm9ybXMgYSBwb3NpdGlvbiBieSBhbiBvcCBjb21wb25lbnQuXG4vL1xuLy8gSWYgYyBpcyBhbiBpbnNlcnQsIGluc2VydEFmdGVyIHNwZWNpZmllcyB3aGV0aGVyIHRoZSB0cmFuc2Zvcm1cbi8vIGlzIHB1c2hlZCBhZnRlciB0aGUgaW5zZXJ0ICh0cnVlKSBvciBiZWZvcmUgaXQgKGZhbHNlKS5cbi8vXG4vLyBpbnNlcnRBZnRlciBpcyBvcHRpb25hbCBmb3IgZGVsZXRlcy5cbnZhciB0cmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcywgYywgaW5zZXJ0QWZ0ZXIpIHtcbiAgLy8gVGhpcyB3aWxsIGdldCBjb2xsYXBzZWQgaW50byBhIGdpYW50IHRlcm5hcnkgYnkgdWdsaWZ5LlxuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICBpZiAoYy5wIDwgcG9zIHx8IChjLnAgPT09IHBvcyAmJiBpbnNlcnRBZnRlcikpIHtcbiAgICAgIHJldHVybiBwb3MgKyBjLmkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJIHRoaW5rIHRoaXMgY291bGQgYWxzbyBiZSB3cml0dGVuIGFzOiBNYXRoLm1pbihjLnAsIE1hdGgubWluKGMucCAtXG4gICAgLy8gb3RoZXJDLnAsIG90aGVyQy5kLmxlbmd0aCkpIGJ1dCBJIHRoaW5rIGl0cyBoYXJkZXIgdG8gcmVhZCB0aGF0IHdheSwgYW5kXG4gICAgLy8gaXQgY29tcGlsZXMgdXNpbmcgdGVybmFyeSBvcGVyYXRvcnMgYW55d2F5IHNvIGl0cyBubyBzbG93ZXIgd3JpdHRlbiBsaWtlXG4gICAgLy8gdGhpcy5cbiAgICBpZiAocG9zIDw9IGMucCkge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBjLnAgKyBjLmQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYy5wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zIC0gYy5kLmxlbmd0aDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEhlbHBlciBtZXRob2QgdG8gdHJhbnNmb3JtIGEgY3Vyc29yIHBvc2l0aW9uIGFzIGEgcmVzdWx0IG9mIGFuIG9wLlxuLy9cbi8vIExpa2UgdHJhbnNmb3JtUG9zaXRpb24gYWJvdmUsIGlmIGMgaXMgYW4gaW5zZXJ0LCBpbnNlcnRBZnRlciBzcGVjaWZpZXNcbi8vIHdoZXRoZXIgdGhlIGN1cnNvciBwb3NpdGlvbiBpcyBwdXNoZWQgYWZ0ZXIgYW4gaW5zZXJ0ICh0cnVlKSBvciBiZWZvcmUgaXRcbi8vIChmYWxzZSkuXG50ZXh0LnRyYW5zZm9ybUN1cnNvciA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBvcCwgc2lkZSkge1xuICB2YXIgaW5zZXJ0QWZ0ZXIgPSBzaWRlID09PSAncmlnaHQnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb24gPSB0cmFuc2Zvcm1Qb3NpdGlvbihwb3NpdGlvbiwgb3BbaV0sIGluc2VydEFmdGVyKTtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbjtcbn07XG5cbi8vIFRyYW5zZm9ybSBhbiBvcCBjb21wb25lbnQgYnkgYW5vdGhlciBvcCBjb21wb25lbnQuIEFzeW1tZXRyaWMuXG4vLyBUaGUgcmVzdWx0IHdpbGwgYmUgYXBwZW5kZWQgdG8gZGVzdGluYXRpb24uXG4vL1xuLy8gZXhwb3J0ZWQgZm9yIHVzZSBpbiBKU09OIHR5cGVcbnZhciB0cmFuc2Zvcm1Db21wb25lbnQgPSB0ZXh0Ll90YyA9IGZ1bmN0aW9uKGRlc3QsIGMsIG90aGVyQywgc2lkZSkge1xuICAvL3ZhciBjSW50ZXJzZWN0LCBpbnRlcnNlY3RFbmQsIGludGVyc2VjdFN0YXJ0LCBuZXdDLCBvdGhlckludGVyc2VjdCwgcztcblxuICBjaGVja1ZhbGlkQ29tcG9uZW50KGMpO1xuICBjaGVja1ZhbGlkQ29tcG9uZW50KG90aGVyQyk7XG5cbiAgaWYgKGMuaSAhPSBudWxsKSB7XG4gICAgLy8gSW5zZXJ0LlxuICAgIGFwcGVuZChkZXN0LCB7aTpjLmksIHA6dHJhbnNmb3JtUG9zaXRpb24oYy5wLCBvdGhlckMsIHNpZGUgPT09ICdyaWdodCcpfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVsZXRlXG4gICAgaWYgKG90aGVyQy5pICE9IG51bGwpIHtcbiAgICAgIC8vIERlbGV0ZSB2cyBpbnNlcnRcbiAgICAgIHZhciBzID0gYy5kO1xuICAgICAgaWYgKGMucCA8IG90aGVyQy5wKSB7XG4gICAgICAgIGFwcGVuZChkZXN0LCB7ZDpzLnNsaWNlKDAsIG90aGVyQy5wIC0gYy5wKSwgcDpjLnB9KTtcbiAgICAgICAgcyA9IHMuc2xpY2Uob3RoZXJDLnAgLSBjLnApO1xuICAgICAgfVxuICAgICAgaWYgKHMgIT09ICcnKVxuICAgICAgICBhcHBlbmQoZGVzdCwge2Q6IHMsIHA6IGMucCArIG90aGVyQy5pLmxlbmd0aH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlbGV0ZSB2cyBkZWxldGVcbiAgICAgIGlmIChjLnAgPj0gb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpXG4gICAgICAgIGFwcGVuZChkZXN0LCB7ZDogYy5kLCBwOiBjLnAgLSBvdGhlckMuZC5sZW5ndGh9KTtcbiAgICAgIGVsc2UgaWYgKGMucCArIGMuZC5sZW5ndGggPD0gb3RoZXJDLnApXG4gICAgICAgIGFwcGVuZChkZXN0LCBjKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGV5IG92ZXJsYXAgc29tZXdoZXJlLlxuICAgICAgICB2YXIgbmV3QyA9IHtkOiAnJywgcDogYy5wfTtcblxuICAgICAgICBpZiAoYy5wIDwgb3RoZXJDLnApXG4gICAgICAgICAgbmV3Qy5kID0gYy5kLnNsaWNlKDAsIG90aGVyQy5wIC0gYy5wKTtcblxuICAgICAgICBpZiAoYy5wICsgYy5kLmxlbmd0aCA+IG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKVxuICAgICAgICAgIG5ld0MuZCArPSBjLmQuc2xpY2Uob3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGggLSBjLnApO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgZW50aXJlbHkgb3B0aW9uYWwgLSBJJ20ganVzdCBjaGVja2luZyB0aGUgZGVsZXRlZCB0ZXh0IGluXG4gICAgICAgIC8vIHRoZSB0d28gb3BzIG1hdGNoZXNcbiAgICAgICAgdmFyIGludGVyc2VjdFN0YXJ0ID0gTWF0aC5tYXgoYy5wLCBvdGhlckMucCk7XG4gICAgICAgIHZhciBpbnRlcnNlY3RFbmQgPSBNYXRoLm1pbihjLnAgKyBjLmQubGVuZ3RoLCBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCk7XG4gICAgICAgIHZhciBjSW50ZXJzZWN0ID0gYy5kLnNsaWNlKGludGVyc2VjdFN0YXJ0IC0gYy5wLCBpbnRlcnNlY3RFbmQgLSBjLnApO1xuICAgICAgICB2YXIgb3RoZXJJbnRlcnNlY3QgPSBvdGhlckMuZC5zbGljZShpbnRlcnNlY3RTdGFydCAtIG90aGVyQy5wLCBpbnRlcnNlY3RFbmQgLSBvdGhlckMucCk7XG4gICAgICAgIGlmIChjSW50ZXJzZWN0ICE9PSBvdGhlckludGVyc2VjdClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZSBvcHMgZGVsZXRlIGRpZmZlcmVudCB0ZXh0IGluIHRoZSBzYW1lIHJlZ2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcblxuICAgICAgICBpZiAobmV3Qy5kICE9PSAnJykge1xuICAgICAgICAgIG5ld0MucCA9IHRyYW5zZm9ybVBvc2l0aW9uKG5ld0MucCwgb3RoZXJDKTtcbiAgICAgICAgICBhcHBlbmQoZGVzdCwgbmV3Qyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbnZhciBpbnZlcnRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHJldHVybiAoYy5pICE9IG51bGwpID8ge2Q6Yy5pLCBwOmMucH0gOiB7aTpjLmQsIHA6Yy5wfTtcbn07XG5cbi8vIE5vIG5lZWQgdG8gdXNlIGFwcGVuZCBmb3IgaW52ZXJ0LCBiZWNhdXNlIHRoZSBjb21wb25lbnRzIHdvbid0IGJlIGFibGUgdG9cbi8vIGNhbmNlbCBvbmUgYW5vdGhlci5cbnRleHQuaW52ZXJ0ID0gZnVuY3Rpb24ob3ApIHtcbiAgLy8gU2hhbGxvdyBjb3B5ICYgcmV2ZXJzZSB0aGF0IHN1Y2thLlxuICBvcCA9IG9wLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgb3BbaV0gPSBpbnZlcnRDb21wb25lbnQob3BbaV0pO1xuICB9XG4gIHJldHVybiBvcDtcbn07XG5cbmV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybSh0ZXh0LCB0cmFuc2Zvcm1Db21wb25lbnQsIGNoZWNrVmFsaWRPcCwgYXBwZW5kKTtcblxuLypcbiBUaGlzIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSlNPTiBPVCB0eXBlLlxuXG4gU3BlYyBpcyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9TaGFyZUpTL3dpa2kvSlNPTi1PcGVyYXRpb25zXG5cbiBOb3RlOiBUaGlzIGlzIGJlaW5nIG1hZGUgb2Jzb2xldGUuIEl0IHdpbGwgc29vbiBiZSByZXBsYWNlZCBieSB0aGUgSlNPTjIgdHlwZS5cbiovXG5cbi8qKlxuICogVVRJTElUWSBGVU5DVElPTlNcbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIG9iamVjdCBpcyBhbiBBcnJheSBpbnN0YW5jZS4gQ2FuJ3QgdXNlIEFycmF5LmlzQXJyYXlcbiAqIHlldCBiZWNhdXNlIGl0cyBub3Qgc3VwcG9ydGVkIG9uIElFOC5cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgcGFzc2VkIG9iamVjdCB1c2luZyBKU09OIHNlcmlhbGl6YXRpb24gKHdoaWNoIGlzIHNsb3cpLlxuICpcbiAqIGhheCwgY29waWVkIGZyb20gdGVzdC90eXBlcy9qc29uLiBBcHBhcmVudGx5IHRoaXMgaXMgc3RpbGwgdGhlIGZhc3Rlc3Qgd2F5XG4gKiB0byBkZWVwIGNsb25lIGFuIG9iamVjdCwgYXNzdW1pbmcgd2UgaGF2ZSBicm93c2VyIHN1cHBvcnQgZm9yIEpTT04uICBAc2VlXG4gKiBodHRwOi8vanNwZXJmLmNvbS9jbG9uaW5nLWFuLW9iamVjdC8xMlxuICovXG52YXIgY2xvbmUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcbn07XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSBUZXh0IE9UIHR5cGUuIFRoaXMgaXMgdXNlZCBmb3IgdGhlIEpTT04gU3RyaW5nIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7Kn1cbiAqL1xuaWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJylcbiAgdmFyIHRleHQgPSB3aW5kb3cub3R0eXBlcy50ZXh0O1xuXG4vKipcbiAqIEpTT04gT1QgVHlwZVxuICogQHR5cGUgeyp9XG4gKi9cbnZhciBqc29uID0geyBcbiAgbmFtZTogJ2pzb24wJyxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL0pTT052MCdcbn07XG5cbmpzb24uY3JlYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyBOdWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkIGlmIHlvdSBkb24ndCBwYXNzIGFuIGFyZ3VtZW50LlxuICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRhdGE7XG59O1xuXG5qc29uLmludmVydENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIGNfID0ge3A6IGMucH07XG5cbiAgaWYgKGMuc2kgIT09IHZvaWQgMCkgY18uc2QgPSBjLnNpO1xuICBpZiAoYy5zZCAhPT0gdm9pZCAwKSBjXy5zaSA9IGMuc2Q7XG4gIGlmIChjLm9pICE9PSB2b2lkIDApIGNfLm9kID0gYy5vaTtcbiAgaWYgKGMub2QgIT09IHZvaWQgMCkgY18ub2kgPSBjLm9kO1xuICBpZiAoYy5saSAhPT0gdm9pZCAwKSBjXy5sZCA9IGMubGk7XG4gIGlmIChjLmxkICE9PSB2b2lkIDApIGNfLmxpID0gYy5sZDtcbiAgaWYgKGMubmEgIT09IHZvaWQgMCkgY18ubmEgPSAtYy5uYTtcblxuICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgY18ubG0gPSBjLnBbYy5wLmxlbmd0aC0xXTtcbiAgICBjXy5wID0gYy5wLnNsaWNlKDAsYy5wLmxlbmd0aC0xKS5jb25jYXQoW2MubG1dKTtcbiAgfVxuXG4gIHJldHVybiBjXztcbn07XG5cbmpzb24uaW52ZXJ0ID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG9wXyA9IG9wLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB2YXIgaW9wID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3BfLmxlbmd0aDsgaSsrKSB7XG4gICAgaW9wLnB1c2goanNvbi5pbnZlcnRDb21wb25lbnQob3BfW2ldKSk7XG4gIH1cbiAgcmV0dXJuIGlvcDtcbn07XG5cbmpzb24uY2hlY2tWYWxpZE9wID0gZnVuY3Rpb24ob3ApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICBpZiAoIWlzQXJyYXkob3BbaV0ucCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBhdGgnKTtcbiAgfVxufTtcblxuanNvbi5jaGVja0xpc3QgPSBmdW5jdGlvbihlbGVtKSB7XG4gIGlmICghaXNBcnJheShlbGVtKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBsaXN0Jyk7XG59O1xuXG5qc29uLmNoZWNrT2JqID0gZnVuY3Rpb24oZWxlbSkge1xuICBpZiAoZWxlbS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhbiBvYmplY3QgKGl0IHdhcyBcIiArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgXCIpXCIpO1xuICB9XG59O1xuXG5qc29uLmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wKTtcblxuICBvcCA9IGNsb25lKG9wKTtcblxuICB2YXIgY29udGFpbmVyID0ge1xuICAgIGRhdGE6IHNuYXBzaG90XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG5cbiAgICB2YXIgcGFyZW50ID0gbnVsbDtcbiAgICB2YXIgcGFyZW50S2V5ID0gbnVsbDtcbiAgICB2YXIgZWxlbSA9IGNvbnRhaW5lcjtcbiAgICB2YXIga2V5ID0gJ2RhdGEnO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLnAubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwID0gYy5wW2pdO1xuXG4gICAgICBwYXJlbnQgPSBlbGVtO1xuICAgICAgcGFyZW50S2V5ID0ga2V5O1xuICAgICAgZWxlbSA9IGVsZW1ba2V5XTtcbiAgICAgIGtleSA9IHA7XG5cbiAgICAgIGlmIChwYXJlbnQgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICAvLyBOdW1iZXIgYWRkXG4gICAgaWYgKGMubmEgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtW2tleV0gIT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIG51bWJlcicpO1xuXG4gICAgICBlbGVtW2tleV0gKz0gYy5uYTtcbiAgICB9XG5cbiAgICAvLyBTdHJpbmcgaW5zZXJ0XG4gICAgZWxzZSBpZiAoYy5zaSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW0gIT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIHN0cmluZyAoaXQgd2FzICcrSlNPTi5zdHJpbmdpZnkoZWxlbSkrJyknKTtcblxuICAgICAgcGFyZW50W3BhcmVudEtleV0gPSBlbGVtLnNsaWNlKDAsa2V5KSArIGMuc2kgKyBlbGVtLnNsaWNlKGtleSk7XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nIGRlbGV0ZVxuICAgIGVsc2UgaWYgKGMuc2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtICE9ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBzdHJpbmcnKTtcblxuICAgICAgaWYgKGVsZW0uc2xpY2Uoa2V5LGtleSArIGMuc2QubGVuZ3RoKSAhPT0gYy5zZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGVkIHN0cmluZyBkb2VzIG5vdCBtYXRjaCcpO1xuXG4gICAgICBwYXJlbnRbcGFyZW50S2V5XSA9IGVsZW0uc2xpY2UoMCxrZXkpICsgZWxlbS5zbGljZShrZXkgKyBjLnNkLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCByZXBsYWNlXG4gICAgZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhlIGxpc3QgZWxlbWVudCBtYXRjaGVzIGMubGRcbiAgICAgIGVsZW1ba2V5XSA9IGMubGk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBpbnNlcnRcbiAgICBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDAsIGMubGkpO1xuICAgIH1cblxuICAgIC8vIExpc3QgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGUgbGlzdCBlbGVtZW50IG1hdGNoZXMgYy5sZCBoZXJlIHRvby5cbiAgICAgIGVsZW0uc3BsaWNlKGtleSwxKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IG1vdmVcbiAgICBlbHNlIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgaWYgKGMubG0gIT0ga2V5KSB7XG4gICAgICAgIHZhciBlID0gZWxlbVtrZXldO1xuICAgICAgICAvLyBSZW1vdmUgaXQuLi5cbiAgICAgICAgZWxlbS5zcGxpY2Uoa2V5LDEpO1xuICAgICAgICAvLyBBbmQgaW5zZXJ0IGl0IGJhY2suXG4gICAgICAgIGVsZW0uc3BsaWNlKGMubG0sMCxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPYmplY3QgaW5zZXJ0IC8gcmVwbGFjZVxuICAgIGVsc2UgaWYgKGMub2kgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja09iaihlbGVtKTtcblxuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoYXQgZWxlbVtrZXldID09IGMub2RcbiAgICAgIGVsZW1ba2V5XSA9IGMub2k7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IGRlbGV0ZVxuICAgIGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja09iaihlbGVtKTtcblxuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoYXQgZWxlbVtrZXldID09IGMub2RcbiAgICAgIGRlbGV0ZSBlbGVtW2tleV07XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgLyBtaXNzaW5nIGluc3RydWN0aW9uIGluIG9wJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5kYXRhO1xufTtcblxuLy8gSGVscGVyIGZvciBpbmNyZW1lbnRhbGx5IGFwcGx5aW5nIGFuIG9wZXJhdGlvbiB0byBhIHNuYXBzaG90LiBDYWxscyB5aWVsZFxuLy8gYWZ0ZXIgZWFjaCBvcCBjb21wb25lbnQgaGFzIGJlZW4gYXBwbGllZC5cbmpzb24uaW5jcmVtZW50YWxBcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCwgX3lpZWxkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc21hbGxPcCA9IFtvcFtpXV07XG4gICAgc25hcHNob3QgPSBqc29uLmFwcGx5KHNuYXBzaG90LCBzbWFsbE9wKTtcbiAgICAvLyBJJ2QganVzdCBjYWxsIHRoaXMgeWllbGQsIGJ1dCB0aGF0cyBhIHJlc2VydmVkIGtleXdvcmQuIEJhaCFcbiAgICBfeWllbGQoc21hbGxPcCwgc25hcHNob3QpO1xuICB9XG4gIFxuICByZXR1cm4gc25hcHNob3Q7XG59O1xuXG4vLyBDaGVja3MgaWYgdHdvIHBhdGhzLCBwMSBhbmQgcDIgbWF0Y2guXG52YXIgcGF0aE1hdGNoZXMgPSBqc29uLnBhdGhNYXRjaGVzID0gZnVuY3Rpb24ocDEsIHAyLCBpZ25vcmVMYXN0KSB7XG4gIGlmIChwMS5sZW5ndGggIT0gcDIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHAxW2ldICE9PSBwMltpXSAmJiAoIWlnbm9yZUxhc3QgfHwgaSAhPT0gcDEubGVuZ3RoIC0gMSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBfY29udmVydFRvVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICB2YXIgbmV3QyA9IHtwOiBjb21wb25lbnQucFtjb21wb25lbnQucC5sZW5ndGggLSAxXX07XG4gIGlmIChjb21wb25lbnQuc2kgIT0gbnVsbCkge1xuICAgIG5ld0MuaSA9IGNvbXBvbmVudC5zaTtcbiAgfSBlbHNlIHtcbiAgICBuZXdDLmQgPSBjb21wb25lbnQuc2Q7XG4gIH1cbiAgcmV0dXJuIG5ld0M7XG59O1xuXG5qc29uLmFwcGVuZCA9IGZ1bmN0aW9uKGRlc3QsYykge1xuICBjID0gY2xvbmUoYyk7XG5cbiAgdmFyIGxhc3Q7XG5cbiAgaWYgKGRlc3QubGVuZ3RoICE9IDAgJiYgcGF0aE1hdGNoZXMoYy5wLCAobGFzdCA9IGRlc3RbZGVzdC5sZW5ndGggLSAxXSkucCkpIHtcbiAgICBpZiAobGFzdC5uYSAhPSBudWxsICYmIGMubmEgIT0gbnVsbCkge1xuICAgICAgZGVzdFtkZXN0Lmxlbmd0aCAtIDFdID0ge3A6IGxhc3QucCwgbmE6IGxhc3QubmEgKyBjLm5hfTtcbiAgICB9IGVsc2UgaWYgKGxhc3QubGkgIT09IHVuZGVmaW5lZCAmJiBjLmxpID09PSB1bmRlZmluZWQgJiYgYy5sZCA9PT0gbGFzdC5saSkge1xuICAgICAgLy8gaW5zZXJ0IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGRlbGV0ZSBiZWNvbWVzIGEgbm9vcC5cbiAgICAgIGlmIChsYXN0LmxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbGVhdmUgdGhlIGRlbGV0ZSBwYXJ0IG9mIHRoZSByZXBsYWNlXG4gICAgICAgIGRlbGV0ZSBsYXN0LmxpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhc3Qub2QgIT09IHVuZGVmaW5lZCAmJiBsYXN0Lm9pID09PSB1bmRlZmluZWQgJiYgYy5vaSAhPT0gdW5kZWZpbmVkICYmIGMub2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGFzdC5vaSA9IGMub2k7XG4gICAgfSBlbHNlIGlmIChsYXN0Lm9pICE9PSB1bmRlZmluZWQgJiYgYy5vZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGUgbGFzdCBwYXRoIGNvbXBvbmVudCBpbnNlcnRlZCBzb21ldGhpbmcgdGhhdCB0aGUgbmV3IGNvbXBvbmVudCBkZWxldGVzIChvciByZXBsYWNlcykuXG4gICAgICAvLyBKdXN0IG1lcmdlIHRoZW0uXG4gICAgICBpZiAoYy5vaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhc3Qub2kgPSBjLm9pO1xuICAgICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIGxhc3Qub2k7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbiBpbnNlcnQgZGlyZWN0bHkgZm9sbG93ZWQgYnkgYSBkZWxldGUgdHVybnMgaW50byBhIG5vLW9wIGFuZCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgZGVzdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMubG0gIT09IHVuZGVmaW5lZCAmJiBjLnBbYy5wLmxlbmd0aCAtIDFdID09PSBjLmxtKSB7XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0LnB1c2goYyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlc3QubGVuZ3RoICE9IDAgJiYgcGF0aE1hdGNoZXMoYy5wLCBsYXN0LnAsIHRydWUpKSB7XG4gICAgaWYgKChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKSAmJiAobGFzdC5zaSAhPSBudWxsIHx8IGxhc3Quc2QgIT0gbnVsbCkpIHtcbiAgICAgIC8vIFRyeSB0byBjb21wb3NlIHRoZSBzdHJpbmcgb3BzIHRvZ2V0aGVyIHVzaW5nIHRleHQncyBlcXVpdmFsZW50IG1ldGhvZHNcbiAgICAgIHZhciB0ZXh0T3AgPSBbX2NvbnZlcnRUb1RleHRDb21wb25lbnQobGFzdCldO1xuICAgICAgdGV4dC5fYXBwZW5kKHRleHRPcCwgX2NvbnZlcnRUb1RleHRDb21wb25lbnQoYykpO1xuICAgICAgXG4gICAgICAvLyBUaGVuIGNvbnZlcnQgYmFjay5cbiAgICAgIGlmICh0ZXh0T3AubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGRlc3QucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0QyA9IHRleHRPcFswXTtcbiAgICAgICAgbGFzdC5wW2xhc3QucC5sZW5ndGggLSAxXSA9IHRleHRDLnA7XG4gICAgICAgIGlmICh0ZXh0Qy5pICE9IG51bGwpXG4gICAgICAgICAgbGFzdC5zaSA9IHRleHRDLmk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsYXN0LnNkID0gdGV4dEMuZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdC5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZXN0LnB1c2goYyk7XG4gIH1cbn07XG5cbmpzb24uY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSxvcDIpIHtcbiAganNvbi5jaGVja1ZhbGlkT3Aob3AxKTtcbiAganNvbi5jaGVja1ZhbGlkT3Aob3AyKTtcblxuICB2YXIgbmV3T3AgPSBjbG9uZShvcDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XG4gICAganNvbi5hcHBlbmQobmV3T3Asb3AyW2ldKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPcDtcbn07XG5cbmpzb24ubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG5ld09wID0gW107XG5cbiAgb3AgPSBpc0FycmF5KG9wKSA/IG9wIDogW29wXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcbiAgICBpZiAoYy5wID09IG51bGwpIGMucCA9IFtdO1xuXG4gICAganNvbi5hcHBlbmQobmV3T3AsYyk7XG4gIH1cblxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgYW4gb3AgYXQgb3RoZXJQYXRoIG1heSBhZmZlY3QgYW4gb3AgYXQgcGF0aFxuanNvbi5jYW5PcEFmZmVjdE9wID0gZnVuY3Rpb24ob3RoZXJQYXRoLHBhdGgpIHtcbiAgaWYgKG90aGVyUGF0aC5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICBwYXRoID0gcGF0aC5zbGljZSgwLHBhdGgubGVuZ3RoIC0gMSk7XG4gIG90aGVyUGF0aCA9IG90aGVyUGF0aC5zbGljZSgwLG90aGVyUGF0aC5sZW5ndGggLSAxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyUGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gb3RoZXJQYXRoW2ldO1xuICAgIGlmIChpID49IHBhdGgubGVuZ3RoIHx8IHAgIT0gcGF0aFtpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2FtZVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHRyYW5zZm9ybSBjIHNvIGl0IGFwcGxpZXMgdG8gYSBkb2N1bWVudCB3aXRoIG90aGVyQyBhcHBsaWVkLlxuanNvbi50cmFuc2Zvcm1Db21wb25lbnQgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHR5cGUpIHtcbiAgYyA9IGNsb25lKGMpO1xuXG4gIGlmIChjLm5hICE9PSB2b2lkIDApXG4gICAgYy5wLnB1c2goMCk7XG5cbiAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKVxuICAgIG90aGVyQy5wLnB1c2goMCk7XG5cbiAgdmFyIGNvbW1vbjtcbiAgaWYgKGpzb24uY2FuT3BBZmZlY3RPcChvdGhlckMucCwgYy5wKSlcbiAgICBjb21tb24gPSBvdGhlckMucC5sZW5ndGggLSAxO1xuXG4gIHZhciBjb21tb24yO1xuICBpZiAoanNvbi5jYW5PcEFmZmVjdE9wKGMucCxvdGhlckMucCkpXG4gICAgY29tbW9uMiA9IGMucC5sZW5ndGggLSAxO1xuXG4gIHZhciBjcGxlbmd0aCA9IGMucC5sZW5ndGg7XG4gIHZhciBvdGhlckNwbGVuZ3RoID0gb3RoZXJDLnAubGVuZ3RoO1xuXG4gIGlmIChjLm5hICE9PSB2b2lkIDApIC8vIGhheFxuICAgIGMucC5wb3AoKTtcblxuICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApXG4gICAgb3RoZXJDLnAucG9wKCk7XG5cbiAgaWYgKG90aGVyQy5uYSkge1xuICAgIGlmIChjb21tb24yICE9IG51bGwgJiYgb3RoZXJDcGxlbmd0aCA+PSBjcGxlbmd0aCAmJiBvdGhlckMucFtjb21tb24yXSA9PSBjLnBbY29tbW9uMl0pIHtcbiAgICAgIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgICBjLmxkID0ganNvbi5hcHBseShjbG9uZShjLmxkKSxbb2NdKTtcbiAgICAgIH0gZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgICAgYy5vZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5vZCksW29jXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGpzb24uYXBwZW5kKGRlc3QsYyk7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvLyBpZiBjIGlzIGRlbGV0aW5nIHNvbWV0aGluZywgYW5kIHRoYXQgdGhpbmcgaXMgY2hhbmdlZCBieSBvdGhlckMsIHdlIG5lZWQgdG9cbiAgLy8gdXBkYXRlIGMgdG8gcmVmbGVjdCB0aGF0IGNoYW5nZSBmb3IgaW52ZXJ0aWJpbGl0eS5cbiAgLy8gVE9ETyB0aGlzIGlzIHByb2JhYmx5IG5vdCBuZWVkZWQgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBpbnZlcnRpYmlsaXR5XG4gIGlmIChjb21tb24yICE9IG51bGwgJiYgb3RoZXJDcGxlbmd0aCA+IGNwbGVuZ3RoICYmIGMucFtjb21tb24yXSA9PSBvdGhlckMucFtjb21tb24yXSkge1xuICAgIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICBjLmxkID0ganNvbi5hcHBseShjbG9uZShjLmxkKSxbb2NdKTtcbiAgICB9IGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgIGMub2QgPSBqc29uLmFwcGx5KGNsb25lKGMub2QpLFtvY10pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21tb24gIT0gbnVsbCkge1xuICAgIHZhciBjb21tb25PcGVyYW5kID0gY3BsZW5ndGggPT0gb3RoZXJDcGxlbmd0aDtcblxuICAgIC8vIHRyYW5zZm9ybSBiYXNlZCBvbiBvdGhlckNcbiAgICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApIHtcbiAgICAgIC8vIHRoaXMgY2FzZSBpcyBoYW5kbGVkIGFib3ZlIGR1ZSB0byBpY2t5IHBhdGggaGF4XG4gICAgfSBlbHNlIGlmIChvdGhlckMuc2kgIT09IHZvaWQgMCB8fCBvdGhlckMuc2QgIT09IHZvaWQgMCkge1xuICAgICAgLy8gU3RyaW5nIG9wIHZzIHN0cmluZyBvcCAtIHBhc3MgdGhyb3VnaCB0byB0ZXh0IHR5cGVcbiAgICAgIGlmIChjLnNpICE9PSB2b2lkIDAgfHwgYy5zZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZCkgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIGEgc3RyaW5nPycpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgYW4gb3AgY29tcG9uZW50IHRvIGEgdGV4dCBvcCBjb21wb25lbnQgc28gd2UgY2FuIHVzZSB0aGVcbiAgICAgICAgLy8gdGV4dCB0eXBlJ3MgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gICAgICAgIHZhciB0YzEgPSBfY29udmVydFRvVGV4dENvbXBvbmVudChjKTtcbiAgICAgICAgdmFyIHRjMiA9IF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KG90aGVyQyk7XG5cbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIGFjdHVhbGx5IHRyYW5zZm9ybVxuICAgICAgICB0ZXh0Ll90YyhyZXMsIHRjMSwgdGMyLCB0eXBlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIC4uLi4gdGhlbiBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayBpbnRvIGEgSlNPTiBvcCBhZ2Fpbi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBUZXh0IGNvbXBvbmVudFxuICAgICAgICAgIHZhciB0YyA9IHJlc1tpXTtcbiAgICAgICAgICAvLyBKU09OIGNvbXBvbmVudFxuICAgICAgICAgIHZhciBqYyA9IHtwOiBjLnAuc2xpY2UoMCwgY29tbW9uKX07XG4gICAgICAgICAgamMucC5wdXNoKHRjLnApO1xuXG4gICAgICAgICAgaWYgKHRjLmkgIT0gbnVsbCkgamMuc2kgPSB0Yy5pO1xuICAgICAgICAgIGlmICh0Yy5kICE9IG51bGwpIGpjLnNkID0gdGMuZDtcbiAgICAgICAgICBqc29uLmFwcGVuZChkZXN0LCBqYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCAmJiBvdGhlckMubGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIG5vb3BcblxuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfSBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAvLyB3ZSdyZSB0cnlpbmcgdG8gZGVsZXRlIHRoZSBzYW1lIGVsZW1lbnQsIC0+IG5vb3BcbiAgICAgICAgICBpZiAoYy5saSAhPT0gdm9pZCAwICYmIHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgLy8gd2UncmUgYm90aCByZXBsYWNpbmcgb25lIGVsZW1lbnQgd2l0aCBhbm90aGVyLiBvbmx5IG9uZSBjYW4gc3Vydml2ZVxuICAgICAgICAgICAgYy5sZCA9IGNsb25lKG90aGVyQy5saSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCA9PT0gdW5kZWZpbmVkICYmIGNvbW1vbk9wZXJhbmQgJiYgYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gaW4gbGkgdnMuIGxpLCBsZWZ0IHdpbnMuXG4gICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKVxuICAgICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPD0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgIH1cblxuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcbiAgICAgICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA8PSBjLmxtKVxuICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgIC8vIGNoYW5naW5nIGMuZnJvbSBpcyBoYW5kbGVkIGFib3ZlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICAgICAgLy8gdGhleSBkZWxldGVkIHRoZSB0aGluZyB3ZSdyZSB0cnlpbmcgdG8gbW92ZVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcbiAgICAgICAgICB2YXIgcCA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgICAgdmFyIGZyb20gPSBjLnBbY29tbW9uXTtcbiAgICAgICAgICB2YXIgdG8gPSBjLmxtO1xuICAgICAgICAgIGlmIChwIDwgdG8gfHwgKHAgPT09IHRvICYmIGZyb20gPCB0bykpXG4gICAgICAgICAgICBjLmxtLS07XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA8IGMucFtjb21tb25dKSB7XG4gICAgICAgIGMucFtjb21tb25dLS07XG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgIGlmIChvdGhlckNwbGVuZ3RoIDwgY3BsZW5ndGgpIHtcbiAgICAgICAgICAvLyB3ZSdyZSBiZWxvdyB0aGUgZGVsZXRlZCBlbGVtZW50LCBzbyAtPiBub29wXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgLy8gd2UncmUgcmVwbGFjaW5nLCB0aGV5J3JlIGRlbGV0aW5nLiB3ZSBiZWNvbWUgYW4gaW5zZXJ0LlxuICAgICAgICAgICAgZGVsZXRlIGMubGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHRyeWluZyB0byBkZWxldGUgdGhlIHNhbWUgZWxlbWVudCwgLT4gbm9vcFxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwICYmIGNwbGVuZ3RoID09PSBvdGhlckNwbGVuZ3RoKSB7XG4gICAgICAgIC8vIGxtIHZzIGxtLCBoZXJlIHdlIGdvIVxuICAgICAgICB2YXIgZnJvbSA9IGMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBjLmxtO1xuICAgICAgICB2YXIgb3RoZXJGcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIG90aGVyVG8gPSBvdGhlckMubG07XG4gICAgICAgIGlmIChvdGhlckZyb20gIT09IG90aGVyVG8pIHtcbiAgICAgICAgICAvLyBpZiBvdGhlckZyb20gPT0gb3RoZXJUbywgd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2Ugb3VyIG9wLlxuXG4gICAgICAgICAgLy8gd2hlcmUgZGlkIG15IHRoaW5nIGdvP1xuICAgICAgICAgIGlmIChmcm9tID09PSBvdGhlckZyb20pIHtcbiAgICAgICAgICAgIC8vIHRoZXkgbW92ZWQgaXQhIHRpZSBicmVhay5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgYy5wW2NvbW1vbl0gPSBvdGhlclRvO1xuICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIC8vIHVnaFxuICAgICAgICAgICAgICAgIGMubG0gPSBvdGhlclRvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZXkgbW92ZWQgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG90aGVyRnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgICAgIGlmIChmcm9tID4gb3RoZXJUbykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPT09IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgaWYgKG90aGVyRnJvbSA+IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgLy8gdWdoLCBhZ2FpblxuICAgICAgICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0ZXAgMjogd2hlcmUgYW0gaSBnb2luZyB0byBwdXQgaXQ/XG4gICAgICAgICAgICBpZiAodG8gPiBvdGhlckZyb20pIHtcbiAgICAgICAgICAgICAgYy5sbS0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICAgICAgYy5sbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvID4gb3RoZXJUbykge1xuICAgICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGJvdGggbW92aW5nIGluIHRoZSBzYW1lIGRpcmVjdGlvbiwgdGllIGJyZWFrXG4gICAgICAgICAgICAgIGlmICgob3RoZXJUbyA+IG90aGVyRnJvbSAmJiB0byA+IGZyb20pIHx8XG4gICAgICAgICAgICAgICAgICAob3RoZXJUbyA8IG90aGVyRnJvbSAmJiB0byA8IGZyb20pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpIGMubG0rKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKSBjLmxtKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IG90aGVyRnJvbSkgYy5sbS0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkID09PSB1bmRlZmluZWQgJiYgY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAvLyBsaVxuICAgICAgICB2YXIgZnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcbiAgICAgICAgcCA9IGMucFtjb21tb25dO1xuICAgICAgICBpZiAocCA+IGZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsZCwgbGQrbGksIHNpLCBzZCwgbmEsIG9pLCBvZCwgb2krb2QsIGFueSBsaSBvbiBhbiBlbGVtZW50IGJlbmVhdGhcbiAgICAgICAgLy8gdGhlIGxtXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGkuZS4gdGhpbmdzIGNhcmUgYWJvdXQgd2hlcmUgdGhlaXIgaXRlbSBpcyBhZnRlciB0aGUgbW92ZS5cbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBvdGhlckMubG07XG4gICAgICAgIHAgPSBjLnBbY29tbW9uXTtcbiAgICAgICAgaWYgKHAgPT09IGZyb20pIHtcbiAgICAgICAgICBjLnBbY29tbW9uXSA9IHRvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwID4gZnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgICBpZiAocCA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgIGVsc2UgaWYgKHAgPT09IHRvICYmIGZyb20gPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCAmJiBvdGhlckMub2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIGlmIChjLm9pICE9PSB2b2lkIDAgJiYgY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIC8vIHdlIGluc2VydGVkIHdoZXJlIHNvbWVvbmUgZWxzZSByZXBsYWNlZFxuICAgICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBsZWZ0IHdpbnNcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSB3aW4sIG1ha2Ugb3VyIG9wIHJlcGxhY2Ugd2hhdCB0aGV5IGluc2VydGVkXG4gICAgICAgICAgICBjLm9kID0gb3RoZXJDLm9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAtPiBub29wIGlmIHRoZSBvdGhlciBjb21wb25lbnQgaXMgZGVsZXRpbmcgdGhlIHNhbWUgb2JqZWN0IChvciBhbnkgcGFyZW50KVxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCAmJiBjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBsZWZ0IHdpbnMgaWYgd2UgdHJ5IHRvIGluc2VydCBhdCB0aGUgc2FtZSBwbGFjZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCx7cDogYy5wLCBvZDpvdGhlckMub2l9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLnBbY29tbW9uXSA9PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZClcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlbGV0ZSBjLm9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAganNvbi5hcHBlbmQoZGVzdCxjKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5leHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0oanNvbiwganNvbi50cmFuc2Zvcm1Db21wb25lbnQsIGpzb24uY2hlY2tWYWxpZE9wLCBqc29uLmFwcGVuZCk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBqc29uO1xuLy8gVGhpcyBpcyBpbmNsdWRlZCBhZnRlciB0aGUgSlMgZm9yIGVhY2ggdHlwZSB3aGVuIHdlIGJ1aWxkIGZvciB0aGUgd2ViLlxuXG4gIHZhciBfdHlwZXMgPSB3aW5kb3cub3R0eXBlcyA9IHdpbmRvdy5vdHR5cGVzIHx8IHt9O1xuICB2YXIgX3QgPSBtb2R1bGUuZXhwb3J0cztcbiAgX3R5cGVzW190Lm5hbWVdID0gX3Q7XG5cbiAgaWYgKF90LnVyaSkgX3R5cGVzW190LnVyaV0gPSBfdDtcbn0pKCk7XG4vLyBKU09OIGRvY3VtZW50IEFQSSBmb3IgdGhlICdqc29uMCcgdHlwZS5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX19zbGljZSA9IFtdLnNsaWNlO1xuICB2YXIgX3R5cGVzID0gdHlwZW9mIGJyZXF1aXJlICE9PSAndW5kZWZpbmVkJyA/IGJyZXF1aXJlKCdvdHR5cGVzJykgOiB3aW5kb3cub3R0eXBlcztcbiAgdmFyIF90eXBlID0gX3R5cGVzWydodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvSlNPTnYwJ107XG5cbiAgLy8gSGVscGVyc1xuXG4gIGZ1bmN0aW9uIGRlcGF0aChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHBhdGhbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICByZXR1cm4gcGF0aFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJhdmVyc2Uoc25hcHNob3QsIHBhdGgpIHtcbiAgICB2YXIga2V5ID0gJ2RhdGEnO1xuICAgIHZhciBlbGVtID0geyBkYXRhOiBzbmFwc2hvdCB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbGVtID0gZWxlbVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwYXRoJyk7XG4gICAgICB9XG4gICAgICBrZXkgPSBwYXRoW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtOiBlbGVtLFxuICAgICAga2V5OiBrZXlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aEVxdWFscyhwMSwgcDIpIHtcbiAgICBpZiAocDEubGVuZ3RoICE9PSBwMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwMS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHAxW2ldICE9PSBwMltpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udGFpbnNQYXRoKHAxLCBwMikge1xuICAgIGlmIChwMS5sZW5ndGggPCBwMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcGF0aEVxdWFscyggcDEuc2xpY2UoMCxwMi5sZW5ndGgpLCBwMik7XG4gIH1cblxuICAvLyBkb2VzIG5vdGhpbmcsIHVzZWQgYXMgYSBkZWZhdWx0IGNhbGxiYWNrXG4gIGZ1bmN0aW9uIG51bGxGdW5jdGlvbigpe31cblxuICAvLyBoZWxwZXIgZm9yIGNyZWF0aW5nIGZ1bmN0aW9ucyB3aXRoIHRoZSBtZXRob2Qgc2lnbmF0dXJlIGZ1bmMoW3BhdGhdLGFyZzEsYXJnMiwuLi4sW2NiXSlcbiAgLy8gcG9wdWxhdGVzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyB3aXRoIGEgZGVmYXVsdCBwYXRoIGFuZCBjYWxsYmFja1xuICBmdW5jdGlvbiBub3JtYWxpemVBcmdzKG9iaixhcmdzLGZ1bmMpe1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICB2YXIgcGF0aF9wcmVmaXggPSBvYmoucGF0aCB8fCBbXTtcblxuICAgIGlmIChmdW5jLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGgtMV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZ3MucHVzaChudWxsRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA8IGZ1bmMubGVuZ3RoKSB7XG4gICAgICBhcmdzLnVuc2hpZnQocGF0aF9wcmVmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzWzBdID0gcGF0aF9wcmVmaXguY29uY2F0KGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jLmFwcGx5KG9iaixhcmdzKTtcbiAgfTtcblxuXG4gIC8vIFN1YkRvY1xuICAvLyB0aGlzIG9iamVjdCBpcyByZXR1cm5lZCBmcm9tIGNvbnRleHQuY3JlYXRlQ29udGV4dEF0KClcblxuICB2YXIgU3ViRG9jID0gZnVuY3Rpb24oY29udGV4dCwgcGF0aCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCBbXTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLl91cGRhdGVQYXRoID0gZnVuY3Rpb24ob3Ape1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gb3BbaV07XG4gICAgICBpZihjLmxtICE9PSB1bmRlZmluZWQgJiYgY29udGFpbnNQYXRoKHRoaXMucGF0aCxjLnApKXtcbiAgICAgICAgdmFyIG5ld19wYXRoX3ByZWZpeCA9IGMucC5zbGljZSgwLGMucC5sZW5ndGgtMSk7XG4gICAgICAgIG5ld19wYXRoX3ByZWZpeC5wdXNoKGMubG0pO1xuICAgICAgICB0aGlzLnBhdGggPSBuZXdfcGF0aF9wcmVmaXguY29uY2F0KHRoaXMucGF0aC5zbGljZShuZXdfcGF0aF9wcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUuY3JlYXRlQ29udGV4dEF0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBhdGggPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuY3JlYXRlQ29udGV4dEF0KHRoaXMucGF0aC5jb25jYXQoZGVwYXRoKHBhdGgpKSk7XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCl7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldChwYXRoKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHBhdGgsdmFsdWUsY2IpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLHZhbHVlLGNiKXtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2V0KHBhdGgsIHZhbHVlLCBjYik7XG4gICAgfSk7XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihwYXRoLCBwb3MsIHZhbHVlLCBjYikge1xuICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIHBvcywgdmFsdWUsIGNiKXtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuaW5zZXJ0KHBhdGgsIHBvcywgdmFsdWUsIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHBhdGgsIGNiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucmVtb3ZlKHBhdGgsIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihwYXRoLCB2YWx1ZSwgY2IpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCB2YWx1ZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuaW5zZXJ0KHBhdGgsIHRoaXMuZ2V0KCkubGVuZ3RoLCB2YWx1ZSwgY2IpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHBhdGgsIGZyb20sIHRvLCBjYikge1xuICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIGZyb20sIHRvLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5tb3ZlKHBhdGgsIGZyb20sIHRvLCBjYik7XG4gICAgfSk7XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwYXRoLCBhbW91bnQsIGNiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgYW1vdW50LCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5hZGQocGF0aCwgYW1vdW50LCBjYik7XG4gICAgfSk7XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBjYikge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuYWRkTGlzdGVuZXIodGhpcy5wYXRoLCBldmVudCwgY2IpO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZW1vdmVMaXN0ZW5lcihsKTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldExlbmd0aChwYXRoKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRUZXh0KHBhdGgpO1xuICAgIH0pO1xuICB9O1xuICBcbiAgU3ViRG9jLnByb3RvdHlwZS5kZWxldGVUZXh0ID0gZnVuY3Rpb24ocGF0aCwgcG9zLCBsZW5ndGgsIGNiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgcG9zLCBsZW5ndGgsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmRlbGV0ZVRleHQocGF0aCwgbGVuZ3RoLCBwb3MsIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHQuX3JlbW92ZVN1YkRvYyh0aGlzKTtcbiAgfTtcblxuXG4gIC8vIEpTT04gQVBJIG1ldGhvZHNcbiAgLy8gdGhlc2UgbWV0aG9kcyBhcmUgbWl4ZWQgaW4gdG8gdGhlIGNvbnRleHQgcmV0dXJuIGZyb20gZG9jLmNyZWF0ZUNvbnRleHQoKVxuXG4gIF90eXBlLmFwaSA9IHtcblxuICAgIHByb3ZpZGVzOiB7XG4gICAgICBqc29uOiB0cnVlXG4gICAgfSxcblxuICAgIF9maXhDb21wb25lbnRQYXRoczogZnVuY3Rpb24oYykge1xuICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGMubmEgIT09IHVuZGVmaW5lZCB8fCBjLnNpICE9PSB1bmRlZmluZWQgfHwgYy5zZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvX3JlbW92ZSA9IFtdO1xuICAgICAgdmFyIF9yZWYgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3JlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbCA9IF9yZWZbaV07XG4gICAgICAgIHZhciBkdW1teSA9IHtcbiAgICAgICAgICBwOiBsLnBhdGgsXG4gICAgICAgICAgbmE6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHhmb3JtZWQgPSBfdHlwZS50cmFuc2Zvcm1Db21wb25lbnQoW10sIGR1bW15LCBjLCAnbGVmdCcpO1xuICAgICAgICBpZiAoeGZvcm1lZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0b19yZW1vdmUucHVzaChpKTtcbiAgICAgICAgfSBlbHNlIGlmICh4Zm9ybWVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGwucGF0aCA9IHhmb3JtZWRbMF0ucDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgYXNzdW1wdGlvbiBpbiBqc29uLWFwaTogeGZvcm1pbmcgYW4gJ25hJyBvcCB3aWxsIGFsd2F5cyByZXN1bHQgaW4gMCBvciAxIGNvbXBvbmVudHMuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvX3JlbW92ZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIgLSBhO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b19yZW1vdmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaSA9IHRvX3JlbW92ZVtqXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGksIDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0sXG5cbiAgICBfZml4UGF0aHM6IGZ1bmN0aW9uKG9wKSB7XG4gICAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBvcFtpXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLl9maXhDb21wb25lbnRQYXRocyhjKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSxcblxuICAgIF9zdWJtaXQ6IGZ1bmN0aW9uKG9wLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5fZml4UGF0aHMob3ApO1xuICAgICAgcmV0dXJuIHRoaXMuc3VibWl0T3Aob3AsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgX2FkZFN1YkRvYzogZnVuY3Rpb24oc3ViZG9jKXtcbiAgICAgIHRoaXMuX3N1YmRvY3MgfHwgKHRoaXMuX3N1YmRvY3MgPSBbXSk7XG4gICAgICB0aGlzLl9zdWJkb2NzLnB1c2goc3ViZG9jKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVN1YkRvYzogZnVuY3Rpb24oc3ViZG9jKXtcbiAgICAgIHRoaXMuX3N1YmRvY3MgfHwgKHRoaXMuX3N1YmRvY3MgPSBbXSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3ViZG9jcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmKHRoaXMuX3N1YmRvY3NbaV0gPT09IHN1YmRvYykgdGhpcy5fc3ViZG9jcy5zcGxpY2UoaSwxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlU3ViZG9jUGF0aHM6IGZ1bmN0aW9uKG9wKXtcbiAgICAgIHRoaXMuX3N1YmRvY3MgfHwgKHRoaXMuX3N1YmRvY3MgPSBbXSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3ViZG9jcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuX3N1YmRvY3NbaV0uX3VwZGF0ZVBhdGgob3ApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVDb250ZXh0QXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgdmFyIHN1YmRvYyA9ICBuZXcgU3ViRG9jKHRoaXMsIGRlcGF0aChwYXRoKSk7XG4gICAgICB0aGlzLl9hZGRTdWJEb2Moc3ViZG9jKTtcbiAgICAgIHJldHVybiBzdWJkb2M7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgaWYgKCFwYXRoKSByZXR1cm4gdGhpcy5nZXRTbmFwc2hvdCgpOyAgXG4gICAgICBcbiAgICAgIHZhciBfcmVmID0gdHJhdmVyc2UodGhpcy5nZXRTbmFwc2hvdCgpLCBwYXRoKTtcbiAgICAgIHJldHVybiBfcmVmLmVsZW1bX3JlZi5rZXldO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBjYikge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgdmFsdWUsIGNiKSB7XG4gICAgICAgIHZhciBfcmVmID0gdHJhdmVyc2UodGhpcy5nZXRTbmFwc2hvdCgpLCBwYXRoKTtcbiAgICAgICAgdmFyIGVsZW0gPSBfcmVmLmVsZW07XG4gICAgICAgIHZhciBrZXkgPSBfcmVmLmtleTtcbiAgICAgICAgdmFyIG9wID0ge1xuICAgICAgICAgIHA6IHBhdGhcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZWxlbS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICBvcC5saSA9IHZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlb2YgZWxlbVtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3AubGQgPSBlbGVtW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG9wLm9pID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGVtW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcC5vZCA9IGVsZW1ba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcGF0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdChbb3BdLCBjYik7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihwYXRoLCBjYikge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgY2IpIHtcbiAgICAgICAgdmFyIF9yZWYgPSB0cmF2ZXJzZSh0aGlzLmdldFNuYXBzaG90KCksIHBhdGgpO1xuICAgICAgICB2YXIgZWxlbSA9IF9yZWYuZWxlbTtcbiAgICAgICAgdmFyIGtleSA9IF9yZWYua2V5O1xuICAgICAgICB2YXIgb3AgPSB7XG4gICAgICAgICAgcDogcGF0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZWxlbWVudCBhdCB0aGF0IHBhdGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgIG9wLmxkID0gZWxlbVtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG9wLm9kID0gZWxlbVtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBhdGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJtaXQoW29wXSwgY2IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24ocGF0aCwgcG9zLCB2YWx1ZSwgY2IpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIHBvcywgdmFsdWUsIGNiKSB7XG4gICAgICAgIHZhciBfcmVmID0gdHJhdmVyc2UodGhpcy5nZXRTbmFwc2hvdCgpLCBwYXRoKTtcbiAgICAgICAgdmFyIGVsZW0gPSBfcmVmLmVsZW07XG4gICAgICAgIHZhciBrZXkgPSBfcmVmLmtleTtcbiAgICAgICAgdmFyIG9wID0ge1xuICAgICAgICAgIHA6IHBhdGguY29uY2F0KHBvcylcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZWxlbVtrZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgIG9wLmxpID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1ba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBvcC5zaSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdChbb3BdLCBjYik7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgbW92ZTogZnVuY3Rpb24ocGF0aCwgZnJvbSwgdG8sIGNiKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCBmcm9tLCB0bywgY2IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb3AgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcDogcGF0aC5jb25jYXQoZnJvbSksXG4gICAgICAgICAgICBsbTogdG9cbiAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdChvcCwgZnVuY3Rpb24oKXtcbiAgICAgICAgICBzZWxmLl91cGRhdGVTdWJkb2NQYXRocyhvcCk7XG4gICAgICAgICAgaWYoY2IpIGNiLmFwcGx5KGNiLGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHB1c2g6IGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBjYikge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgdmFsdWUsIGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydChwYXRoLCB0aGlzLmdldCgpLmxlbmd0aCwgdmFsdWUsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKHBhdGgsIGFtb3VudCwgY2IpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBjYikge1xuICAgICAgICB2YXIgb3AgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcDogcGF0aCxcbiAgICAgICAgICAgIG5hOiBhbW91bnRcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJtaXQob3AsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldChwYXRoKS5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRUZXh0OiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChwYXRoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBkZWxldGVUZXh0OiBmdW5jdGlvbihwYXRoLCBsZW5ndGgsIHBvcywgY2IpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIGxlbmd0aCwgcG9zLCBjYikge1xuICAgICAgICB2YXIgX3JlZiA9IHRyYXZlcnNlKHRoaXMuZ2V0U25hcHNob3QoKSwgcGF0aCk7XG4gICAgICAgIHZhciBvcCA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwOiBwYXRoLmNvbmNhdChwb3MpLFxuICAgICAgICAgICAgc2Q6IF9yZWYuZWxlbVtfcmVmLmtleV0uc2xpY2UocG9zLCBwb3MgKyBsZW5ndGgpXG4gICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJtaXQob3AsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhZGRMaXN0ZW5lcjogZnVuY3Rpb24ocGF0aCwgZXZlbnQsIGNiKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCB2YWx1ZSwgY2IpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGNiOiBjYlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaSA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIF9vbk9wOiBmdW5jdGlvbihvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG9wW2ldO1xuICAgICAgICB0aGlzLl9maXhDb21wb25lbnRQYXRocyhjKTtcblxuICAgICAgICBpZihjLmxtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTdWJkb2NQYXRocyhbY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoX3BhdGggPSBjLm5hID09PSB1bmRlZmluZWQgPyBjLnAuc2xpY2UoMCwgYy5wLmxlbmd0aCAtIDEpIDogYy5wO1xuXG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzW2xdO1xuICAgICAgICAgIHZhciBjYiA9IGxpc3RlbmVyLmNiO1xuXG4gICAgICAgICAgaWYgKHBhdGhFcXVhbHMobGlzdGVuZXIucGF0aCwgbWF0Y2hfcGF0aCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobGlzdGVuZXIuZXZlbnQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgICBpZiAoYy5saSAhPT0gdW5kZWZpbmVkICYmIGMubGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2IoYy5wW2MucC5sZW5ndGggLSAxXSwgYy5saSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjLm9pICE9PSB1bmRlZmluZWQgJiYgYy5vZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLm9pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMuc2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2IoYy5wW2MucC5sZW5ndGggLSAxXSwgYy5zaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIGlmIChjLmxpID09PSB1bmRlZmluZWQgJiYgYy5sZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLmxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMub2kgPT09IHVuZGVmaW5lZCAmJiBjLm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMucFtjLnAubGVuZ3RoIC0gMV0sIGMub2QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5zZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLnNkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgIGlmIChjLmxpICE9PSB1bmRlZmluZWQgJiYgYy5sZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLmxkLCBjLmxpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMucFtjLnAubGVuZ3RoIC0gMV0sIGMub2QsIGMub2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgaWYgKGMubG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2IoYy5wW2MucC5sZW5ndGggLSAxXSwgYy5sbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICAgIGlmIChjLm5hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMubmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF90eXBlLmNhbk9wQWZmZWN0T3AobGlzdGVuZXIucGF0aCwgbWF0Y2hfcGF0aClcbiAgICAgICAgICAgICAgJiYgbGlzdGVuZXIuZXZlbnQgPT09ICdjaGlsZCBvcCcpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZF9wYXRoID0gYy5wLnNsaWNlKGxpc3RlbmVyLnBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgIGNiKGNoaWxkX3BhdGgsIGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbi8vIFRoaXMgZmlsZSBpcyBpbmNsdWRlZCBhdCB0aGUgdG9wIG9mIHRoZSBjb21waWxlZCBjbGllbnQgSlMuXG5cbi8vIEFsbCB0aGUgbW9kdWxlcyB3aWxsIGp1c3QgYWRkIHN0dWZmIHRvIGV4cG9ydHMsIGFuZCBpdCdsbCBhbGwgZ2V0IGV4cG9ydGVkLlxudmFyIGV4cG9ydHMgPSB3aW5kb3cuc2hhcmVqcyA9IHt2ZXJzaW9uOiAnMC43LjAnfTtcblxuLy8gVGhpcyBpcyBhIHNpbXBsZSByZXdyaXRlIG9mIG1pY3JvZXZlbnQuanMuIEkndmUgY2hhbmdlZCB0aGVcbi8vIGZ1bmN0aW9uIG5hbWVzIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBub2RlLmpzIEV2ZW50RW1pdHRlci5cbi8vXG4vLyBtaWNyb2V2ZW50LmpzIGlzIGNvcHlyaWdodCBKZXJvbWUgRXRpZW5uZSwgYW5kIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qZXJvbWVldGllbm5lL21pY3JvZXZlbnQuanNcblxudmFyIE1pY3JvRXZlbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAoZXZlbnRzW2V2ZW50XSA9IGV2ZW50c1tldmVudF0gfHwgW10pLnB1c2goZm4pO1xufTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudF0gPSBldmVudHNbZXZlbnRdIHx8IFtdO1xuXG4gIC8vIFNhZGx5LCBubyBJRTggc3VwcG9ydCBmb3IgaW5kZXhPZi5cbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgbGlzdGVuZXJzW2ldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpKys7XG4gIH1cblxuICAvLyBDb21wYWN0IHRoZSBsaXN0IHdoZW4gbm8gZXZlbnQgaGFuZGxlciBpcyBhY3R1YWxseSBydW5uaW5nLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGV2ZW50c1tldmVudF0gPSBbXTtcbiAgICB2YXIgZm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE9ubHkgYWRkIGJhY2sgZXZlbnQgaGFuZGxlcnMgd2hpY2ggZXhpc3QuXG4gICAgICBpZiAoKGZuID0gbGlzdGVuZXJzW2ldKSkgZXZlbnRzW2V2ZW50XS5wdXNoKGZuKTtcbiAgICB9XG4gIH0sIDApO1xufTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaWYgKCFldmVudHMgfHwgIWV2ZW50c1tldmVudF0pIHtcbiAgICBpZiAoZXZlbnQgPT0gJ2Vycm9yJykge1xuICAgICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IGV2ZW50c1tldmVudF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXSkge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICB2YXIgbGlzdGVuZXIsIF90aGlzID0gdGhpcztcbiAgdGhpcy5vbihldmVudCwgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcbn07XG5cbk1pY3JvRXZlbnQubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHByb3RvID0gb2JqLnByb3RvdHlwZSB8fCBvYmo7XG4gIHByb3RvLm9uID0gTWljcm9FdmVudC5wcm90b3R5cGUub247XG4gIHByb3RvLnJlbW92ZUxpc3RlbmVyID0gTWljcm9FdmVudC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIHByb3RvLmVtaXQgPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5lbWl0O1xuICBwcm90by5vbmNlID0gTWljcm9FdmVudC5wcm90b3R5cGUub25jZTtcbiAgcmV0dXJuIG9iajtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IE1pY3JvRXZlbnQ7XG5cbnZhciB0eXBlcywgTWljcm9FdmVudDtcblxuaWYgKHR5cGVvZiBicmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB0eXBlcyA9IGJyZXF1aXJlKCdvdHR5cGVzJyk7XG4gIE1pY3JvRXZlbnQgPSBicmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59IGVsc2Uge1xuICB0eXBlcyA9IHdpbmRvdy5vdHR5cGVzO1xufVxuXG4vKlxuICogQSBEb2MgaXMgYSBjbGllbnQncyB2aWV3IG9uIGEgc2hhcmVqcyBkb2N1bWVudC5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIGRpcmVjdGx5LiBDcmVhdGUgdGhlbSBieSBjYWxsaW5nIHRoZVxuICogZG9jdW1lbnQgZ2V0dGluZyBmdW5jdGlvbnMgaW4gY29ubmVjdGlvbi5cbiAqXG4gKiBEb2N1bWVudHMgYXJlIGV2ZW50IGVtaXR0ZXJzLiBVc2UgZG9jLm9uKGV2ZW50bmFtZSwgZm4pIHRvIHN1YnNjcmliZS5cbiAqXG4gKiBEb2N1bWVudHMgY3VycmVudGx5IGdldCBtaXhlZCBpbiB3aXRoIHRoZWlyIHR5cGUncyBBUEkgbWV0aG9kcy4gU28sIHlvdSBjYW5cbiAqIC5pbnNlcnQoJ2ZvbycsIDApIGludG8gYSB0ZXh0IGRvY3VtZW50IGFuZCBzdHVmZiBsaWtlIHRoYXQuXG4gKlxuICogRXZlbnRzOlxuICogLSBiZWZvcmUgb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCBiZWZvcmUgYW4gb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gdGhlXG4gKiAgIGRvY3VtZW50LlxuICogLSBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIHJpZ2h0IGFmdGVyIGFuIG9wZXJhdGlvbiAob3IgcGFydCBvZiBhblxuICogICBvcGVyYXRpb24pIGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50LiBTdWJtaXR0aW5nIGFub3RoZXIgb3AgaGVyZSBpc1xuICogICBpbnZhbGlkIC0gd2FpdCB1bnRpbCAnYWZ0ZXIgb3AnIGlmIHlvdSB3YW50IHRvIHN1Ym1pdCBtb3JlIG9wZXJhdGlvbnMuICAtXG4gKiAgIGNoYW5nZWQgKG9wKVxuICogLSBhZnRlciBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIGFmdGVyIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiBhcHBsaWVkLiBZb3VcbiAqICAgY2FuIHN1Ym1pdCBtb3JlIG9wcyBoZXJlLlxuICogLSBzdWJzY3JpYmVkIChlcnJvcik6IFRoZSBkb2N1bWVudCB3YXMgc3Vic2NyaWJlZFxuICogLSB1bnN1YnNjcmliZWQgKGVycm9yKTogVGhlIGRvY3VtZW50IHdhcyB1bnN1YnNjcmliZWRcbiAqIC0gY3JlYXRlZDogVGhlIGRvY3VtZW50IHdhcyBjcmVhdGVkLiBUaGF0IG1lYW5zIGl0cyB0eXBlIHdhcyBzZXQgYW5kIGl0IGhhc1xuICogICBzb21lIGluaXRpYWwgZGF0YS5cbiAqIC0gZXJyb3JcbiAqL1xudmFyIERvYyA9IGV4cG9ydHMuRG9jID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgY29sbGVjdGlvbiwgbmFtZSkge1xuICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgdGhpcy52ZXJzaW9uID0gdGhpcy50eXBlID0gbnVsbDtcblxuICAvLyAqKioqIFN0YXRlIGluIGRvY3VtZW50OlxuIFxuICAvLyBBY3Rpb24uIFRoaXMgaXMgZWl0aGVyIG51bGwsIG9yIG9uZSBvZiB0aGUgYWN0aW9ucyAoc3Vic2NyaWJlLFxuICAvLyB1bnN1YnNjcmliZSwgZmV0Y2gsIHN1Ym1pdCkuIE9ubHkgb25lIGFjdGlvbiBjYW4gYmUgaGFwcGVuaW5nIGF0IGEgdGltZSB0b1xuICAvLyBwcmV2ZW50IG1lIGZyb20gZ29pbmcgbWFkLlxuICAvL1xuICAvLyBQb3NzaWJsZSB2YWx1ZXM6XG4gIC8vIC0gc3Vic2NyaWJlXG4gIC8vIC0gdW5zdWJzY3JpYmVcbiAgLy8gLSBmZXRjaFxuICAvLyAtIHN1Ym1pdFxuICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gXG4gIC8vIFRoZSBkYXRhIHRoZSBkb2N1bWVudCBvYmplY3Qgc3RvcmVzIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0aHJlZSBzdGF0ZXM6XG4gIC8vICAgLSBObyBkYXRhLiAobnVsbCkgV2UgaG9uZXN0bHkgZG9uJ3Qga25vdyB3aGF0cyBnb2luZyBvbi5cbiAgLy8gICAtIEZsb2F0aW5nICgnZmxvYXRpbmcnKTogd2UgaGF2ZSBhIGxvY2FsbHkgY3JlYXRlZCBkb2N1bWVudCB0aGF0IGhhc24ndFxuICAvLyAgICAgYmVlbiBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIgeWV0KVxuICAvLyAgIC0gTGl2ZSAoJ3JlYWR5JykgKHdlIGhhdmUgZGF0YSB0aGF0cyBjdXJyZW50IG9uIHRoZSBzZXJ2ZXIgYXQgc29tZSB2ZXJzaW9uKS5cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgLy8gT3VyIHN1YnNjcmlwdGlvbiBzdGF0dXMuIEVpdGhlciB3ZSdyZSBzdWJzY3JpYmVkIG9uIHRoZSBzZXJ2ZXIsIG9yIHdlIGFyZW4ndC5cbiAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gIC8vIEVpdGhlciB3ZSB3YW50IHRvIGJlIHN1YnNjcmliZWQgKHRydWUpLCB3ZSB3YW50IGEgbmV3IHNuYXBzaG90IGZyb20gdGhlXG4gIC8vIHNlcnZlciAoJ2ZldGNoJyksIG9yIHdlIGRvbid0IGNhcmUgKGZhbHNlKS4gIFRoaXMgaXMgYWxzbyB1c2VkIHdoZW4gd2VcbiAgLy8gZGlzY29ubmVjdCAmIHJlY29ubmVjdCB0byBkZWNpZGUgd2hhdCB0byBkby5cbiAgdGhpcy53YW50U3Vic2NyaWJlID0gZmFsc2U7XG4gIC8vIFRoaXMgbGlzdCBpcyB1c2VkIGZvciBzdWJzY3JpYmUgYW5kIHVuc3Vic2NyaWJlLCBzaW5jZSB3ZSdsbCBvbmx5IHdhbnQgdG9cbiAgLy8gZG8gb25lIHRoaW5nIGF0IGEgdGltZS5cbiAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzID0gW107XG5cblxuICAvLyAqKiogZW5kIHN0YXRlIHN0dWZmLlxuXG4gIC8vIFRoaXMgZG9lc24ndCBwcm92aWRlIGFueSBzdGFuZGFyZCBBUEkgYWNjZXNzIHJpZ2h0IG5vdy5cbiAgdGhpcy5wcm92aWRlcyA9IHt9O1xuXG4gIC8vIFRoZSBlZGl0aW5nIGNvbnRleHRzLiBUaGVzZSBhcmUgdXN1YWxseSBpbnN0YW5jZXMgb2YgdGhlIHR5cGUgQVBJIHdoZW4gdGhlXG4gIC8vIGRvY3VtZW50IGlzIHJlYWR5IGZvciBlZGl0cy5cbiAgdGhpcy5lZGl0aW5nQ29udGV4dHMgPSBbXTtcbiAgXG4gIC8vIFRoZSBvcCB0aGF0IGlzIGN1cnJlbnRseSByb3VuZHRyaXBwaW5nIHRvIHRoZSBzZXJ2ZXIsIG9yIG51bGwuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gcmVjb25uZWN0cywgdGhlIGluZmxpZ2h0IG9wIGlzIHJlc3VibWl0dGVkLlxuICAvL1xuICAvLyBUaGlzIGhhcyB0aGUgc2FtZSBmb3JtYXQgYXMgYW4gZW50cnkgaW4gcGVuZGluZ0RhdGEsIHdoaWNoIGlzOlxuICAvLyB7W2NyZWF0ZTp7Li4ufV0sIFtkZWw6dHJ1ZV0sIFtvcDouLi5dLCBjYWxsYmFja3M6Wy4uLl0sIHNyYzosIHNlcTp9XG4gIHRoaXMuaW5mbGlnaHREYXRhID0gbnVsbDtcblxuICAvLyBBbGwgb3BzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgdG8gYWNrbm93bGVkZ2UgQGluZmxpZ2h0RGF0YVxuICAvLyBUaGlzIHVzZWQgdG8ganVzdCBiZSBhIHNpbmdsZSBvcGVyYXRpb24sIGJ1dCBjcmVhdGVzICYgZGVsZXRlcyBjYW4ndCBiZSBjb21wb3NlZCB3aXRoXG4gIC8vIHJlZ3VsYXIgb3BlcmF0aW9ucy5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhIGxpc3Qgb2Yge1tjcmVhdGU6ey4uLn1dLCBbZGVsOnRydWVdLCBbb3A6Li4uXSwgY2FsbGJhY2tzOlsuLi5dfVxuICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG59O1xuXG5NaWNyb0V2ZW50Lm1peGluKERvYyk7XG5cbkRvYy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBkb2MgPSB0aGlzO1xuICB0aGlzLnVuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgIC8vIERvbid0IGNhcmUgaWYgdGhlcmUncyBhbiBlcnJvciB1bnN1YnNjcmliaW5nLlxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRoZXJlJ2xsIHByb2JhYmx5IGJlIG5vdGhpbmcgaGVyZSBzZWVpbmcgYXMgaG93IHdlIGp1c3QgdW5zdWJzY3JpYmVkLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkb2MuX3N1YnNjcmliZUNhbGxiYWNrc1tpXSgnRG9jdW1lbnQgZGVzdHJveWVkJyk7XG4gICAgICB9XG4gICAgICBkb2MuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0sIDApO1xuXG4gICAgZG9jLmNvbm5lY3Rpb24uX2Rlc3Ryb3lEb2MoZG9jKTtcbiAgICBkb2MucmVtb3ZlQ29udGV4dHMoKTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxuXG4vLyAqKioqKiogTWFuaXB1bGF0aW5nIHRoZSBkb2N1bWVudCBzbmFwc2hvdCwgdmVyc2lvbiBhbmQgdHlwZS5cblxuLy8gU2V0IHRoZSBkb2N1bWVudCdzIHR5cGUsIGFuZCBhc3NvY2lhdGVkIHByb3BlcnRpZXMuIE1vc3Qgb2YgdGhlIGxvZ2ljIGluXG4vLyB0aGlzIGZ1bmN0aW9uIGV4aXN0cyB0byB1cGRhdGUgdGhlIGRvY3VtZW50IGJhc2VkIG9uIGFueSBhZGRlZCAmIHJlbW92ZWQgQVBJXG4vLyBtZXRob2RzLlxuRG9jLnByb3RvdHlwZS5fc2V0VHlwZSA9IGZ1bmN0aW9uKG5ld1R5cGUpIHtcbiAgaWYgKHR5cGVvZiBuZXdUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdHlwZXNbbmV3VHlwZV0pIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdHlwZSBcIiArIG5ld1R5cGUpO1xuICAgIG5ld1R5cGUgPSB0eXBlc1tuZXdUeXBlXTtcbiAgfVxuICB0aGlzLnJlbW92ZUNvbnRleHRzKCk7XG5cbiAgLy8gU2V0IHRoZSBuZXcgdHlwZVxuICB0aGlzLnR5cGUgPSBuZXdUeXBlO1xuXG4gIC8vIElmIHdlIHJlbW92ZWQgdGhlIHR5cGUgZnJvbSB0aGUgb2JqZWN0LCBhbHNvIHJlbW92ZSBpdHMgc25hcHNob3QuXG4gIGlmICghbmV3VHlwZSkge1xuICAgIHRoaXMucHJvdmlkZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChuZXdUeXBlLmFwaSkge1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgdHlwZSdzIEFQSS5cbiAgICB0aGlzLnByb3ZpZGVzID0gbmV3VHlwZS5hcGkucHJvdmlkZXM7XG4gIH1cbn07XG5cbi8vIEluamVzdCBzbmFwc2hvdCBkYXRhLiBUaGlzIGRhdGEgbXVzdCBpbmNsdWRlIGEgdmVyc2lvbiwgc25hcHNob3QgYW5kIHR5cGUuXG4vLyBUaGlzIGlzIHVzZWQgYm90aCB0byBpbmplc3QgZGF0YSB0aGF0IHdhcyBleHBvcnRlZCB3aXRoIGEgd2VicGFnZSBhbmQgZGF0YVxuLy8gdGhhdCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGR1cmluZyBhIGZldGNoLlxuRG9jLnByb3RvdHlwZS5pbmplc3REYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5zdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKCdJZ25vcmluZyBhdHRlbXB0IHRvIGluamVzdCBkYXRhIGluIHN0YXRlJywgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YS52ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gaW4gaW5qZXN0ZWQgZGF0YScpO1xuXG5cbiAgdGhpcy52ZXJzaW9uID0gZGF0YS52O1xuICB0aGlzLnNuYXBzaG90ID0gZGF0YS5zbmFwc2hvdDtcbiAgdGhpcy5fc2V0VHlwZShkYXRhLnR5cGUpO1xuXG4gIHRoaXMuc3RhdGUgPSAncmVhZHknO1xuICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG59O1xuXG4vLyBHZXQgYW5kIHJldHVybiB0aGUgY3VycmVudCBkb2N1bWVudCBzbmFwc2hvdC5cbkRvYy5wcm90b3R5cGUuZ2V0U25hcHNob3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc25hcHNob3Q7XG59O1xuXG4vLyBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYXQgYSB0aW1lIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBhIHNuYXBzaG90IGFuZFxuLy8geW91IGNhbiBzdGFydCBhcHBseWluZyBvcGVyYXRpb25zLiBUaGlzIG1heSBiZSBpbW1lZGlhdGVseS5cbkRvYy5wcm90b3R5cGUud2hlblJlYWR5ID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT09ICdyZWFkeScpIHtcbiAgICBmbigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICB9XG59O1xuXG5Eb2MucHJvdG90eXBlLmhhc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5mbGlnaHREYXRhICE9IG51bGwgfHwgISF0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aDtcbn07XG5cblxuLy8gKioqKiBIZWxwZXJzIGZvciBuZXR3b3JrIG1lc3NhZ2VzXG5cbi8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjb25uZWN0aW9uIGZyb20gdGhpcyBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIG1lc3NhZ2UuYyA9IHRoaXMuY29sbGVjdGlvbjtcbiAgbWVzc2FnZS5kID0gdGhpcy5uYW1lO1xuICB0aGlzLmNvbm5lY3Rpb24uc2VuZChtZXNzYWdlKTtcbn07XG5cbi8vIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBjb25uZWN0aW9uIHdoZW4gaXQgcmVjZWl2ZXMgYSBtZXNzYWdlIGZvciB0aGUgZG9jdW1lbnQuXG5Eb2MucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKCEobXNnLmMgPT09IHRoaXMuY29sbGVjdGlvbiAmJiBtc2cuZCA9PT0gdGhpcy5uYW1lKSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIGl0cyBhIHNhbml0eSBjaGVjayBmb3IgYnVncyBpbiB0aGUgY29ubmVjdGlvbiBjb2RlLlxuICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBtZXNzYWdlIGZvciB3cm9uZyBkb2N1bWVudC5cIik7XG4gIH1cblxuICAvLyBtc2cuYSA9IHRoZSBhY3Rpb24uXG4gIHN3aXRjaCAobXNnLmEpIHtcbiAgICBjYXNlICdmZXRjaCc6XG4gICAgICAvLyBXZSdyZSBkb25lIGZldGNoaW5nLiBUaGlzIG1lc3NhZ2UgaGFzIG5vIG90aGVyIGluZm9ybWF0aW9uLlxuICAgICAgaWYgKG1zZy5kYXRhKSB0aGlzLmluamVzdERhdGEobXNnLmRhdGEpO1xuICAgICAgdGhpcy5fZmluaXNoU3ViKCdmZXRjaCcsIG1zZy5lcnJvcik7XG4gICAgICBpZiAodGhpcy53YW50U3Vic2NyaWJlID09PSAnZmV0Y2gnKSB0aGlzLndhbnRTdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCdmZXRjaCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzdWInOlxuICAgICAgLy8gU3Vic2NyaWJlIHJlcGx5LlxuICAgICAgaWYgKG1zZy5lcnJvciAmJiBtc2cuZXJyb3IgIT09ICdBbHJlYWR5IHN1YnNjcmliZWQnKSB7XG4gICAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IHN1YnNjcmliZTogXCIgKyBtc2cuZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbXNnLmVycm9yKTtcbiAgICAgICAgLy8gVGhlcmUncyBwcm9iYWJseSBhIHJlYXNvbiB3ZSBjb3VsZG4ndCBzdWJzY3JpYmUuIERvbid0IHJldHJ5LlxuICAgICAgICB0aGlzLl9zZXRXYW50U3Vic2NyaWJlKGZhbHNlLCBudWxsLCBtc2cuZXJyb3IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobXNnLmRhdGEpIHRoaXMuaW5qZXN0RGF0YShtc2cuZGF0YSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnc3Vic2NyaWJlJyk7XG4gICAgICAgIHRoaXMuX2ZpbmlzaFN1Yih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xlYXJBY3Rpb24oJ3N1YnNjcmliZScpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1bnN1Yic6XG4gICAgICAvLyBVbnN1YnNjcmliZSByZXBseVxuICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlJyk7XG5cbiAgICAgIHRoaXMuX2ZpbmlzaFN1YihmYWxzZSwgbXNnLmVycm9yKTtcbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCd1bnN1YnNjcmliZScpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhY2snOlxuICAgICAgLy8gQWNrbm93bGVkZ2UgYSBsb2NhbGx5IHN1Ym1pdHRlZCBvcGVyYXRpb24uXG4gICAgICAvL1xuICAgICAgLy8gVXN1YWxseSB3ZSBkbyBub3RoaW5nIGhlcmUgLSBhbGwgdGhlIGludGVyZXN0aW5nIGxvZ2ljIGhhcHBlbnMgd2hlbiB3ZVxuICAgICAgLy8gZ2V0IHNlbnQgb3VyIG9wIGJhY2sgaW4gdGhlIG9wIHN0cmVhbSAod2hpY2ggaGFwcGVucyBldmVuIGlmIHdlIGFyZW4ndFxuICAgICAgLy8gc3Vic2NyaWJlZCkuIEhvd2V2ZXIsIGlmIHRoZSBvcCBkb2Vzbid0IGdldCBhY2NlcHRlZCwgd2Ugc3RpbGwgbmVlZCB0b1xuICAgICAgLy8gY2xlYXIgc29tZSBzdGF0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbWVzc2FnZSBlcnJvciBpcyAnT3AgYWxyZWFkeSBzdWJtaXR0ZWQnLCB0aGF0IG1lYW5zIHdlJ3ZlXG4gICAgICAvLyByZXNlbnQgYW4gb3AgdGhhdCB0aGUgc2VydmVyIGFscmVhZHkgZ290LiBJdCB3aWxsIGFsc28gYmUgY29uZmlybWVkXG4gICAgICAvLyBub3JtYWxseS5cbiAgICAgIGlmIChtc2cuZXJyb3IgJiYgbXNnLmVycm9yICE9PSAnT3AgYWxyZWFkeSBzdWJtaXR0ZWQnKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgaGFzIHJlamVjdGVkIGFuIG9wIGZyb20gdGhlIGNsaWVudCBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIC8vIFdlJ2xsIHNlbmQgdGhlIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHVzZXIgYW5kIHRyeSB0byByb2xsIGJhY2sgdGhlIGNoYW5nZS5cbiAgICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdPcGVyYXRpb24gd2FzIHJlamVjdGVkICgnICsgbXNnLmVycm9yICsgJykuIFRyeWluZyB0byByb2xsYmFjayBjaGFuZ2UgbG9jYWxseS4nKTtcbiAgICAgICAgICB0aGlzLl90cnlSb2xsYmFjayh0aGlzLmluZmxpZ2h0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSSBtYW5hZ2VkIHRvIGdldCBpbnRvIHRoaXMgc3RhdGUgb25jZS4gSSdtIG5vdCBzdXJlIGhvdyBpdCBoYXBwZW5lZC5cbiAgICAgICAgICAvLyBUaGUgb3Agd2FzIG1heWJlIGRvdWJsZS1hY2tub3dsZWRnZWQ/XG4gICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignU2Vjb25kIGFja25vd2xlZGdlbWVudCBtZXNzYWdlIChlcnJvcikgcmVjZWl2ZWQnLCBtc2csIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIHRoaXMuX2NsZWFySW5mbGlnaHRPcChtc2cuZXJyb3IpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcCc6XG4gICAgICBpZiAodGhpcy5pbmZsaWdodERhdGEgJiZcbiAgICAgICAgICBtc2cuc3JjID09PSB0aGlzLmluZmxpZ2h0RGF0YS5zcmMgJiZcbiAgICAgICAgICBtc2cuc2VxID09PSB0aGlzLmluZmxpZ2h0RGF0YS5zZXEpIHtcbiAgICAgICAgLy8gVGhpcyBvbmUgaXMgbWluZS4gQWNjZXB0IGl0IGFzIGFja25vd2xlZGdlZC5cbiAgICAgICAgdGhpcy5fb3BBY2tub3dsZWRnZWQobXNnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cudiAhPT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIC8vIEkgc2hvdWxkIGFkZCB0aGUgbmFtZSBvZiB0aGUgZG9jdW1lbnQgdG8gYWxsIGVycm9ycyAtIG1vc3RseSB0aGlzIGlzXG4gICAgICAgIC8vIHRvIHRyYWNrIGRvd24gb25lIHBhcnRpY3VsYXIgYnVnLlxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ0luIGRvY3VtZW50ICcgKyB0aGlzLm5hbWUgKyAnIGV4cGVjdGVkIHZlcnNpb24gJyArIHRoaXMudmVyc2lvbiArICcgYnV0IGdvdCAnICsgbXNnLnYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB4Zih0aGlzLmluZmxpZ2h0RGF0YSwgbXNnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhmKHRoaXMucGVuZGluZ0RhdGFbaV0sIG1zZyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgdGhpcy5fb3RBcHBseShtc2csIGZhbHNlKTtcbiAgICAgIHRoaXMuX2FmdGVyT3RBcHBseShtc2csIGZhbHNlKTtcbiAgICAgIC8vY29uc29sZS5sb2coJ2FwcGxpZWQnLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWV0YSc6XG4gICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgbWV0YSBvcDonLCBtc2cpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignVW5oYW5kbGVkIGRvY3VtZW50IG1lc3NhZ2U6JywgbXNnKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDYWxsZWQgd2hlbmV2ZXIgKHlvdSBndWVzc2VkIGl0ISkgdGhlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcy4gVGhpcyB3aWxsXG4vLyBoYXBwZW4gd2hlbiB3ZSBnZXQgZGlzY29ubmVjdGVkICYgcmVjb25uZWN0LlxuRG9jLnByb3RvdHlwZS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuICBpZiAoc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSkge1xuICAgICAgdGhpcy5fc2VuZE9wRGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgIC8vIFdlIGdvIGludG8gdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbmNlIHdlIGhhdmUgYSBzZXNzaW9uSUQuIFdlIGNhbid0IHNlbmRcbiAgICAvLyBuZXcgb3BzIHVudGlsIHRoZW4sIHNvIHdlIG5lZWQgdG8gZmx1c2ggYWdhaW4uXG4gICAgdGhpcy5mbHVzaCgpO1xuICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlZCcpO1xuICB9XG59O1xuXG5cblxuXG4vLyAqKioqKiogRGVhbGluZyB3aXRoIGFjdGlvbnNcblxuRG9jLnByb3RvdHlwZS5fY2xlYXJBY3Rpb24gPSBmdW5jdGlvbihleHBlY3RlZEFjdGlvbikge1xuICBpZiAodGhpcy5hY3Rpb24gIT09IGV4cGVjdGVkQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdVbmV4cGVjdGVkIGFjdGlvbiAnICsgdGhpcy5hY3Rpb24gKyAnIGV4cGVjdGVkOiAnICsgZXhwZWN0ZWRBY3Rpb24pO1xuICB9XG4gIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuXG5cbi8vIFNlbmQgdGhlIG5leHQgcGVuZGluZyBvcCB0byB0aGUgc2VydmVyLCBpZiB3ZSBjYW4uXG4vL1xuLy8gT25seSBvbmUgb3BlcmF0aW9uIGNhbiBiZSBpbi1mbGlnaHQgYXQgYSB0aW1lLiBJZiBhbiBvcGVyYXRpb24gaXMgYWxyZWFkeSBvblxuLy8gaXRzIHdheSwgb3Igd2UncmUgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbkRvYy5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCB8fCB0aGlzLmFjdGlvbikgcmV0dXJuO1xuXG4gIHZhciBvcERhdGE7XG4gIC8vIFB1bXAgYW5kIGR1bXAgYW55IG5vLW9wcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcGVuZGluZyBvcCBsaXN0LlxuICB3aGlsZSAodGhpcy5wZW5kaW5nRGF0YS5sZW5ndGggJiYgaXNOb09wKG9wRGF0YSA9IHRoaXMucGVuZGluZ0RhdGFbMF0pKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IG9wRGF0YS5jYWxsYmFja3M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrc1tpXShvcERhdGEuZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBGaXJzdCBjb25zaWRlciBjaGFuZ2luZyBzdGF0ZVxuICBpZiAodGhpcy5zdWJzY3JpYmVkICYmICF0aGlzLndhbnRTdWJzY3JpYmUpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICd1bnN1YnNjcmliZSc7XG4gICAgdGhpcy5fc2VuZCh7YTondW5zdWInfSk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuc3Vic2NyaWJlZCAmJiB0aGlzLndhbnRTdWJzY3JpYmUgPT09ICdmZXRjaCcpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICdmZXRjaCc7XG4gICAgdGhpcy5fc2VuZCh0aGlzLnN0YXRlID09PSAncmVhZHknID8ge2E6J2ZldGNoJywgdjp0aGlzLnZlcnNpb259IDoge2E6J2ZldGNoJ30pO1xuICB9IGVsc2UgaWYgKCF0aGlzLnN1YnNjcmliZWQgJiYgdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgdGhpcy5hY3Rpb24gPSAnc3Vic2NyaWJlJztcbiAgICB0aGlzLl9zZW5kKHRoaXMuc3RhdGUgPT09ICdyZWFkeScgPyB7YTonc3ViJywgdjp0aGlzLnZlcnNpb259IDoge2E6J3N1Yid9KTtcbiAgfSBlbHNlIGlmICghdGhpcy5wYXVzZWQgJiYgdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGggJiYgdGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgIC8vIFRyeSBhbmQgc2VuZCBhbnkgcGVuZGluZyBvcHMuIFdlIGNhbid0IHNlbmQgb3BzIHdoaWxlIGluIFxuICAgIHRoaXMuaW5mbGlnaHREYXRhID0gdGhpcy5wZW5kaW5nRGF0YS5zaGlmdCgpO1xuXG4gICAgLy8gRGVsYXkgZm9yIGRlYnVnZ2luZy5cbiAgICAvL3ZhciB0aGF0ID0gdGhpcztcbiAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRoYXQuX3NlbmRPcERhdGEoKTsgfSwgMTAwMCk7XG5cbiAgICAvLyBUaGlzIGFsc28gc2V0cyBhY3Rpb24gdG8gJ3N1Ym1pdCcuXG4gICAgdGhpcy5fc2VuZE9wRGF0YSgpO1xuICB9XG59O1xuXG5cbi8vICoqKioqKiBTdWJzY3JpYmluZywgdW5zdWJzY3JpYmluZyBhbmQgZmV0Y2hpbmdcblxuLy8gVGhlc2UgZnVuY3Rpb25zIGlhcmUgY29waWVkIGludG8gdGhlIHF1ZXJ5IGNsYXNzIGFzIHdlbGwsIHNvIGJlIGNhcmVmdWwgbWFraW5nXG4vLyBjaGFuZ2VzIGhlcmUuXG5cbi8vIFZhbHVlIGlzIHRydWUsIGZhbHNlIG9yICdmZXRjaCcuXG5Eb2MucHJvdG90eXBlLl9zZXRXYW50U3Vic2NyaWJlID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrLCBlcnIpIHtcbiAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gdGhpcy53YW50U3Vic2NyaWJlICYmXG4gICAgICAodGhpcy5zdWJzY3JpYmVkID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2ZldGNoJyAmJiB0aGlzLnN1YnNjcmliZWQpKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgaWYgKCF0aGlzLndhbnRTdWJzY3JpYmUgIT09ICF2YWx1ZSkge1xuICAgIC8vIENhbGwgYWxsIHRoZSBjdXJyZW50IHN1YnNjcmliZS91bnN1YnNjcmliZSBjYWxsYmFja3MuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFNob3VsZCBJIHJldHVybiBhbiBlcnJvciBoZXJlPyBXaGF0IGhhcHBlbmVkIGlzIHRoZSB1c2VyIHVuc3ViY3JpYmVkXG4gICAgICAvLyB3aXRoIGEgY2FsbGJhY2sgdGhlbiByZXN1YnNjcmliZWQgc3RyYWlnaHQgYWZ0ZXIuIERvZXMgdGhhdCBtZWFuIHRoZVxuICAgICAgLy8gdW5zdWJzY3JpYmUgZmFpbGVkP1xuICAgICAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzW2ldKGVycik7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gSWYgd2Ugd2FudCB0byBzdWJzY3JpYmUsIGRvbid0IHdlYWtlbiBpdCB0byBhIGZldGNoLlxuICBpZiAodmFsdWUgIT09ICdmZXRjaCcgfHwgdGhpcy53YW50U3Vic2NyaWJlICE9PSB0cnVlKVxuICAgIHRoaXMud2FudFN1YnNjcmliZSA9IHZhbHVlO1xuXG4gIGlmIChjYWxsYmFjaykgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vLyBPcGVuIHRoZSBkb2N1bWVudC4gVGhlcmUgaXMgbm8gY2FsbGJhY2sgYW5kIG5vIGVycm9yIGhhbmRsaW5nIGlmIHlvdSdyZVxuLy8gYWxyZWFkeSBjb25uZWN0ZWQuXG4vL1xuLy8gT25seSBjYWxsIHRoaXMgb25jZSBwZXIgZG9jdW1lbnQuXG5Eb2MucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUodHJ1ZSwgY2FsbGJhY2spO1xufTtcblxuLy8gVW5zdWJzY3JpYmUuIFRoZSBkYXRhIHdpbGwgc3RheSBhcm91bmQgaW4gbG9jYWwgbWVtb3J5LCBidXQgd2UnbGwgc3RvcFxuLy8gcmVjZWl2aW5nIHVwZGF0ZXMuXG5Eb2MucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZShmYWxzZSwgY2FsbGJhY2spO1xufTtcblxuLy8gQ2FsbCB0byByZXF1ZXN0IGZyZXNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUoJ2ZldGNoJywgY2FsbGJhY2spO1xufTtcblxuLy8gQ2FsbGVkIHdoZW4gb3VyIHN1YnNjcmliZSwgZmV0Y2ggb3IgdW5zdWJzY3JpYmUgbWVzc2FnZXMgYXJlIGFja25vd2xlZGdlZC5cbkRvYy5wcm90b3R5cGUuX2ZpbmlzaFN1YiA9IGZ1bmN0aW9uKHZhbHVlLCBlcnJvcikge1xuICBpZiAodmFsdWUgPT09IHRoaXMud2FudFN1YnNjcmliZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuXG4vLyBPcGVyYXRpb25zXG5cblxuLy8gKioqKioqKioqKioqIERlYWxpbmcgd2l0aCBvcGVyYXRpb25zLlxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IG9wRGF0YSB0byBjb250YWluIGEgbm8tb3AuXG52YXIgc2V0Tm9PcCA9IGZ1bmN0aW9uKG9wRGF0YSkge1xuICBkZWxldGUgb3BEYXRhLm9wO1xuICBkZWxldGUgb3BEYXRhLmNyZWF0ZTtcbiAgZGVsZXRlIG9wRGF0YS5kZWw7XG59O1xuXG52YXIgaXNOb09wID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIHJldHVybiAhb3BEYXRhLm9wICYmICFvcERhdGEuY3JlYXRlICYmICFvcERhdGEuZGVsO1xufVxuXG4vLyBUcnkgdG8gY29tcG9zZSBkYXRhMiBpbnRvIGRhdGExLiBSZXR1cm5zIHRydXRoeSBpZiBpdCBzdWNjZWVkcywgb3RoZXJ3aXNlIGZhbHN5LlxudmFyIHRyeUNvbXBvc2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhMSwgZGF0YTIpIHtcbiAgaWYgKGRhdGExLmNyZWF0ZSAmJiBkYXRhMi5kZWwpIHtcbiAgICBzZXROb09wKGRhdGExKTtcbiAgfSBlbHNlIGlmIChkYXRhMS5jcmVhdGUgJiYgZGF0YTIub3ApIHtcbiAgICAvLyBDb21wb3NlIHRoZSBkYXRhIGludG8gdGhlIGNyZWF0ZSBkYXRhLlxuICAgIHZhciBkYXRhID0gKGRhdGExLmNyZWF0ZS5kYXRhID09PSB1bmRlZmluZWQpID8gdHlwZS5jcmVhdGUoKSA6IGRhdGExLmNyZWF0ZS5kYXRhO1xuICAgIGRhdGExLmNyZWF0ZS5kYXRhID0gdHlwZS5hcHBseShkYXRhLCBkYXRhMi5vcCk7XG4gIH0gZWxzZSBpZiAoaXNOb09wKGRhdGExKSkge1xuICAgIGRhdGExLmNyZWF0ZSA9IGRhdGEyLmNyZWF0ZTtcbiAgICBkYXRhMS5kZWwgPSBkYXRhMi5kZWw7XG4gICAgZGF0YTEub3AgPSBkYXRhMi5vcDtcbiAgfSBlbHNlIGlmIChkYXRhMS5vcCAmJiBkYXRhMi5vcCAmJiB0eXBlLmNvbXBvc2UpIHtcbiAgICBkYXRhMS5vcCA9IHR5cGUuY29tcG9zZShkYXRhMS5vcCwgZGF0YTIub3ApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFRyYW5zZm9ybSBzZXJ2ZXIgb3AgZGF0YSBieSBhIGNsaWVudCBvcCwgYW5kIHZpY2UgdmVyc2EuIE9wcyBhcmUgZWRpdGVkIGluIHBsYWNlLlxudmFyIHhmID0gZnVuY3Rpb24oY2xpZW50LCBzZXJ2ZXIpIHtcbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdyZSBpbiBmb3Igc29tZSBmdW4uIFRoZXJlIGFyZSBzb21lIGxvY2FsIG9wZXJhdGlvbnNcbiAgLy8gd2hpY2ggYXJlIHRvdGFsbHkgaW52YWxpZCAtIGVpdGhlciB0aGUgY2xpZW50IGNvbnRpbnVlZCBlZGl0aW5nIGFcbiAgLy8gZG9jdW1lbnQgdGhhdCBzb21lb25lIGVsc2UgZGVsZXRlZCBvciBhIGRvY3VtZW50IHdhcyBjcmVhdGVkIGJvdGggb24gdGhlXG4gIC8vIGNsaWVudCBhbmQgb24gdGhlIHNlcnZlci4gSW4gZWl0aGVyIGNhc2UsIHRoZSBsb2NhbCBkb2N1bWVudCBpcyB3YXlcbiAgLy8gaW52YWxpZCBhbmQgdGhlIGNsaWVudCdzIG9wcyBhcmUgdXNlbGVzcy5cbiAgLy9cbiAgLy8gVGhlIGNsaWVudCBiZWNvbWVzIGEgbm8tb3AsIGFuZCB3ZSBrZWVwIHRoZSBzZXJ2ZXIgb3AgZW50aXJlbHkuXG4gIGlmIChzZXJ2ZXIuY3JlYXRlIHx8IHNlcnZlci5kZWwpIHJldHVybiBzZXROb09wKGNsaWVudCk7XG4gIGlmIChjbGllbnQuY3JlYXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIFRoaXMgaXMgYSBidWcuJyk7XG5cbiAgLy8gVGhlIGNsaWVudCBoYXMgZGVsZXRlZCB0aGUgZG9jdW1lbnQgd2hpbGUgdGhlIHNlcnZlciBlZGl0ZWQgaXQuIEtpbGwgdGhlXG4gIC8vIHNlcnZlcidzIG9wLlxuICBpZiAoY2xpZW50LmRlbCkgcmV0dXJuIHNldE5vT3Aoc2VydmVyKTtcblxuICAvLyBXZSBvbmx5IGdldCBoZXJlIGlmIGVpdGhlciB0aGUgc2VydmVyIG9yIGNsaWVudCBvcHMgYXJlIG5vLW9wLiBDYXJyeSBvbixcbiAgLy8gbm90aGluZyB0byBzZWUgaGVyZS5cbiAgaWYgKCFzZXJ2ZXIub3AgfHwgIWNsaWVudC5vcCkgcmV0dXJuO1xuXG4gIC8vIFRoZXkgYm90aCBlZGl0ZWQgdGhlIGRvY3VtZW50LiBUaGlzIGlzIHRoZSBub3JtYWwgY2FzZSBmb3IgdGhpcyBmdW5jdGlvbiAtXG4gIC8vIGFzIGluLCBtb3N0IG9mIHRoZSB0aW1lIHdlJ2xsIGVuZCB1cCBkb3duIGhlcmUuXG4gIC8vXG4gIC8vIFlvdSBzaG91bGQgYmUgd29uZGVyaW5nIHdoeSBJJ20gdXNpbmcgY2xpZW50LnR5cGUgaW5zdGVhZCBvZiB0aGlzLnR5cGUuXG4gIC8vIFRoZSByZWFzb24gaXMsIGlmIHdlIGdldCBvcHMgYXQgYW4gb2xkIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50LCB0aGlzLnR5cGVcbiAgLy8gbWlnaHQgYmUgdW5kZWZpbmVkIG9yIGEgdG90YWxseSBkaWZmZXJlbnQgdHlwZS4gQnkgcGlubmluZyB0aGUgdHlwZSB0byB0aGVcbiAgLy8gb3AgZGF0YSwgd2UgbWFrZSBzdXJlIHRoZSByaWdodCB0eXBlIGhhcyBpdHMgdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbGxlZC5cbiAgaWYgKGNsaWVudC50eXBlLnRyYW5zZm9ybVgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xpZW50LnR5cGUudHJhbnNmb3JtWChjbGllbnQub3AsIHNlcnZlci5vcCk7XG4gICAgY2xpZW50Lm9wID0gcmVzdWx0WzBdO1xuICAgIHNlcnZlci5vcCA9IHJlc3VsdFsxXTtcbiAgfSBlbHNlIHtcbiAgICAvL2NvbnNvbGUubG9nKCd4ZicsIEpTT04uc3RyaW5naWZ5KGNsaWVudC5vcCksIEpTT04uc3RyaW5naWZ5KHNlcnZlci5vcCkpO1xuICAgIHZhciBfYyA9IGNsaWVudC50eXBlLnRyYW5zZm9ybShjbGllbnQub3AsIHNlcnZlci5vcCwgJ2xlZnQnKTtcbiAgICB2YXIgX3MgPSBjbGllbnQudHlwZS50cmFuc2Zvcm0oc2VydmVyLm9wLCBjbGllbnQub3AsICdyaWdodCcpO1xuICAgIGNsaWVudC5vcCA9IF9jOyBzZXJ2ZXIub3AgPSBfcztcbiAgICAvL2NvbnNvbGUubG9nKCctPicsIEpTT04uc3RyaW5naWZ5KGNsaWVudC5vcCksIEpTT04uc3RyaW5naWZ5KHNlcnZlci5vcCkpO1xuICB9XG59O1xuXG4vLyBJbnRlcm5hbCBtZXRob2QgdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGdpdmVuIG9wIGRhdGEgdG8gb3VyIGxvY2FsIG1vZGVsLlxuLy9cbi8vIF9hZnRlck90QXBwbHkoKSBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyd2FyZHMuXG5Eb2MucHJvdG90eXBlLl9vdEFwcGx5ID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0KSB7XG4gIC8vIExvY2sgdGhlIGRvY3VtZW50LiBOb2JvZHkgaXMgYWxsb3dlZCB0byBjYWxsIHN1Ym1pdE9wKCkgdW50aWwgX2FmdGVyT3RBcHBseSBpcyBjYWxsZWQuXG4gIHRoaXMubG9ja2VkID0gdHJ1ZTtcblxuICBpZiAob3BEYXRhLmNyZWF0ZSkge1xuICAgIC8vIElmIHRoZSB0eXBlIGlzIGN1cnJlbnRseSBzZXQsIGl0IG1lYW5zIHdlIHRyaWVkIGNyZWF0aW5nIHRoZSBkb2N1bWVudFxuICAgIC8vIGFuZCBzb21lb25lIGVsc2Ugd29uLiBjbGllbnQgY3JlYXRlIHggc2VydmVyIGNyZWF0ZSA9IHNlcnZlciBjcmVhdGUuXG4gICAgdmFyIGNyZWF0ZSA9IG9wRGF0YS5jcmVhdGU7XG4gICAgdGhpcy5fc2V0VHlwZShjcmVhdGUudHlwZSk7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHRoaXMudHlwZS5jcmVhdGUoY3JlYXRlLmRhdGEpO1xuXG4gICAgLy8gVGhpcyBpcyBhIGJpdCBoZWF2eXdlaWdodCwgYnV0IEkgd2FudCB0aGUgY3JlYXRlZCBldmVudCB0byBmaXJlIG91dHNpZGUgb2YgdGhlIGxvY2suXG4gICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgY29udGV4dCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3BEYXRhLmRlbCkge1xuICAgIC8vIFRoZSB0eXBlIHNob3VsZCBhbHdheXMgZXhpc3QgaW4gdGhpcyBjYXNlLiBkZWwgeCBfID0gZGVsXG4gICAgdmFyIG9sZFNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdDtcbiAgICB0aGlzLl9zZXRUeXBlKG51bGwpO1xuICAgIHRoaXMub25jZSgndW5sb2NrJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoJ2RlbCcsIGNvbnRleHQsIG9sZFNuYXBzaG90KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcERhdGEub3ApIHtcbiAgICBpZiAoIXRoaXMudHlwZSkgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBkb2VzIG5vdCBleGlzdCcpO1xuXG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICB2YXIgb3AgPSBvcERhdGEub3A7XG4gICAgXG4gICAgLy8gVGhlIGNvbnRleHQgbmVlZHMgdG8gYmUgdG9sZCB3ZSdyZSBhYm91dCB0byBlZGl0LCBqdXN0IGluIGNhc2UgaXQgbmVlZHNcbiAgICAvLyB0byBzdG9yZSBhbnkgZXh0cmEgZGF0YS4gKHRleHQtdHAyIGhhcyB0aGlzIGNvbnN0cmFpbnQuKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lZGl0aW5nQ29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gdGhpcy5lZGl0aW5nQ29udGV4dHNbaV07XG4gICAgICBpZiAoYyAhPSBjb250ZXh0ICYmIGMuX2JlZm9yZU9wKSBjLl9iZWZvcmVPcChvcERhdGEub3ApO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlIG9wJywgb3AsIGNvbnRleHQpO1xuXG4gICAgLy8gVGhpcyBleGlzdHMgc28gY2xpZW50cyBjYW4gcHVsbCBhbnkgbmVjZXNzYXJ5IGRhdGEgb3V0IG9mIHRoZSBzbmFwc2hvdFxuICAgIC8vIGJlZm9yZSBpdCBnZXRzIGNoYW5nZWQuICBQcmV2aW91c2x5IHdlIGtlcHQgdGhlIG9sZCBzbmFwc2hvdCBvYmplY3QgYW5kXG4gICAgLy8gcGFzc2VkIGl0IHRvIHRoZSBvcCBldmVudCBoYW5kbGVyLiBIb3dldmVyLCBhcHBseSBubyBsb25nZXIgZ3VhcmFudGVlc1xuICAgIC8vIHRoZSBvbGQgb2JqZWN0IGlzIHN0aWxsIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gQmVjYXVzZSB0aGlzIGNvdWxkIGJlIHRvdGFsbHkgdW5uZWNlc3Nhcnkgd29yaywgaXRzIGJlaGluZCBhIGZsYWcuIHNldFxuICAgIC8vIGRvYy5pbmNyZW1lbnRhbCB0byBlbmFibGUuXG4gICAgaWYgKHRoaXMuaW5jcmVtZW50YWwgJiYgdHlwZS5pbmNyZW1lbnRhbEFwcGx5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdHlwZS5pbmNyZW1lbnRhbEFwcGx5KHRoaXMuc25hcHNob3QsIG9wLCBmdW5jdGlvbihvLCBzbmFwc2hvdCkge1xuICAgICAgICBfdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICBfdGhpcy5lbWl0KCdvcCcsIG8sIGNvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGNhc2UsIHNpbXBseSBhcHBseWluZyB0aGUgb3BlcmF0aW9uIHRvIHRoZSBsb2NhbCBzbmFwc2hvdC5cbiAgICAgIHRoaXMuc25hcHNob3QgPSB0eXBlLmFwcGx5KHRoaXMuc25hcHNob3QsIG9wKTtcbiAgICAgIHRoaXMuZW1pdCgnb3AnLCBvcCwgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8vIEl0cyBwb3NzaWJsZSBmb3Igbm9uZSBvZiB0aGUgYWJvdmUgY2FzZXMgdG8gbWF0Y2gsIGluIHdoaWNoIGNhc2UgdGhlIG9wIGlzXG4gIC8vIGEgbm8tb3AuIFRoaXMgd2lsbCBoYXBwZW4gd2hlbiBhIGRvY3VtZW50IGhhcyBiZWVuIGRlbGV0ZWQgbG9jYWxseSBhbmRcbiAgLy8gcmVtb3RlIG9wcyBlZGl0IHRoZSBkb2N1bWVudC5cbn07XG5cbi8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBfb3RBcHBseS5cbkRvYy5wcm90b3R5cGUuX2FmdGVyT3RBcHBseSA9IGZ1bmN0aW9uKG9wRGF0YSwgY29udGV4dCkge1xuICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ3VubG9jaycpO1xuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5lZGl0aW5nQ29udGV4dHM7XG4gICAgLy8gTm90aWZ5IGFsbCB0aGUgY29udGV4dHMgYWJvdXQgdGhlIG9wICh3ZWxsLCBhbGwgdGhlIGNvbnRleHRzIGV4Y2VwdFxuICAgIC8vIHRoZSBvbmUgd2hpY2ggaW5pdGlhdGVkIHRoZSBzdWJtaXQgaW4gdGhlIGZpcnN0IHBsYWNlKS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNvbnRleHRzW2ldO1xuICAgICAgaWYgKGMgIT0gY29udGV4dCAmJiBjLl9vbk9wKSBjLl9vbk9wKG9wRGF0YS5vcCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjb250ZXh0cy5yZW1vdmUpIGNvbnRleHRzLnNwbGljZShpLS0sIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoJ2FmdGVyIG9wJywgb3BEYXRhLm9wLCBjb250ZXh0KTtcbiAgfVxufTtcblxuXG5cbi8vICoqKioqIFNlbmRpbmcgb3BlcmF0aW9uc1xuXG5cbi8vIEFjdHVhbGx5IHNlbmQgb3AgZGF0YSB0byB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5fc2VuZE9wRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZCA9IHRoaXMuaW5mbGlnaHREYXRhO1xuXG4gIGlmICh0aGlzLmFjdGlvbikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlICcgKyB0aGlzLmFjdGlvbiArICcgZm9yIHNlbmRPcERhdGEnKTtcbiAgdGhpcy5hY3Rpb24gPSAnc3VibWl0JztcblxuICB2YXIgbXNnID0ge2E6J29wJywgdjp0aGlzLnZlcnNpb259O1xuICBpZiAoZC5zcmMpIHtcbiAgICBtc2cuc3JjID0gZC5zcmM7XG4gICAgbXNnLnNlcSA9IGQuc2VxO1xuICB9XG5cbiAgLy8gVGhlIHNlcnZlciBhdXRvZGV0ZWN0cyB0aGlzLlxuICAvL2lmICh0aGlzLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykgbXNnLmYgPSB0cnVlOyAvLyBmZXRjaCBpbnRlcm1lZGlhdGUgb3BzXG5cbiAgaWYgKGQub3ApIG1zZy5vcCA9IGQub3A7XG4gIGlmIChkLmNyZWF0ZSkgbXNnLmNyZWF0ZSA9IGQuY3JlYXRlO1xuICBpZiAoZC5kZWwpIG1zZy5kZWwgPSBkLmRlbDtcblxuICBtc2cuYyA9IHRoaXMuY29sbGVjdGlvbjtcbiAgbXNnLmQgPSB0aGlzLm5hbWU7XG5cbiAgdGhpcy5jb25uZWN0aW9uLnNlbmRPcChtc2cpO1xuICAgXG4gIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHNlbmQgYW4gb3AsIGl0cyBpZCBhbmQgc2VxdWVuY2UgbnVtYmVyIGlzIGltcGxpY2l0LlxuICBpZiAoIWQuc3JjKSB7XG4gICAgZC5zcmMgPSB0aGlzLmNvbm5lY3Rpb24uaWQ7XG4gICAgZC5zZXEgPSB0aGlzLmNvbm5lY3Rpb24uc2VxKys7XG4gIH1cbn07XG5cblxuLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCB0byBkbyB0aGUgYWN0dWFsIHdvcmsgZm9yIHN1Ym1pdE9wKCksIGNyZWF0ZSgpIGFuZCBkZWwoKS5cbi8vXG4vLyBjb250ZXh0IGlzIG9wdGlvbmFsLlxuRG9jLnByb3RvdHlwZS5fc3VibWl0T3BEYXRhID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAvL2NvbnNvbGUubG9nKCdzdWJtaXQnLCBKU09OLnN0cmluZ2lmeShvcERhdGEpLCAndj0nLCB0aGlzLnZlcnNpb24pO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gY29udGV4dDtcbiAgICBjb250ZXh0ID0gdHJ1ZTsgLy8gVGhlIGRlZmF1bHQgY29udGV4dCBpcyB0cnVlLlxuICB9XG4gIGlmIChjb250ZXh0ID09IG51bGwpIGNvbnRleHQgPSB0cnVlO1xuXG4gIHZhciBlcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICBlbHNlIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ0ZhaWxlZCBhdHRlbXB0IHRvIHN1Ym1pdE9wOicsIGVycik7XG4gIH07XG5cbiAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgcmV0dXJuIGVycm9yKFwiQ2Fubm90IGNhbGwgc3VibWl0T3AgZnJvbSBpbnNpZGUgYW4gJ29wJyBldmVudCBoYW5kbGVyXCIpO1xuICB9XG5cbiAgLy8gVGhlIG9wRGF0YSBjb250YWlucyBlaXRoZXIgb3AsIGNyZWF0ZSwgZGVsZXRlLCBvciBub25lIG9mIHRoZSBhYm92ZSAoYSBuby1vcCkuXG5cbiAgaWYgKG9wRGF0YS5vcCkge1xuICAgIGlmICghdGhpcy50eXBlKSByZXR1cm4gZXJyb3IoJ0RvY3VtZW50IGhhcyBub3QgYmVlbiBjcmVhdGVkJyk7XG5cbiAgICAvLyBUcnkgdG8gbm9ybWFsaXplIHRoZSBvcC4gVGhpcyByZW1vdmVzIHRyYWlsaW5nIHNraXA6MCdzIGFuZCB0aGluZ3MgbGlrZSB0aGF0LlxuICAgIGlmICh0aGlzLnR5cGUubm9ybWFsaXplKSBvcERhdGEub3AgPSB0aGlzLnR5cGUubm9ybWFsaXplKG9wRGF0YS5vcCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gJ2Zsb2F0aW5nJztcbiAgfVxuXG4gIC8vIEFjdHVhbGx5IGFwcGx5IHRoZSBvcGVyYXRpb24gbG9jYWxseS5cbiAgdGhpcy5fb3RBcHBseShvcERhdGEsIGNvbnRleHQpO1xuXG4gIC8vIElmIHRoZSB0eXBlIHN1cHBvcnRzIGNvbXBvc2VzLCB0cnkgdG8gY29tcG9zZSB0aGUgb3BlcmF0aW9uIG9udG8gdGhlIGVuZFxuICAvLyBvZiB0aGUgbGFzdCBwZW5kaW5nIG9wZXJhdGlvbi5cbiAgdmFyIGVudHJ5ID0gdGhpcy5wZW5kaW5nRGF0YVt0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAtIDFdO1xuXG4gIGlmICh0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJlxuICAgICAgKGVudHJ5ID0gdGhpcy5wZW5kaW5nRGF0YVt0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAtIDFdLFxuICAgICAgIHRyeUNvbXBvc2UodGhpcy50eXBlLCBlbnRyeSwgb3BEYXRhKSkpIHtcbiAgfSBlbHNlIHtcbiAgICBlbnRyeSA9IG9wRGF0YTtcbiAgICBvcERhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBvcERhdGEuY2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5wZW5kaW5nRGF0YS5wdXNoKG9wRGF0YSk7XG4gIH1cblxuICBpZiAoY2FsbGJhY2spIGVudHJ5LmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblxuICB0aGlzLl9hZnRlck90QXBwbHkob3BEYXRhLCBjb250ZXh0KTtcblxuICAvLyBUaGUgY2FsbCB0byBmbHVzaCBpcyBpbiBhIHRpbWVvdXQgc28gaWYgc3VibWl0T3AoKSBpcyBjYWxsZWQgbXVsdGlwbGVcbiAgLy8gdGltZXMgaW4gYSBjbG9zdXJlIGFsbCB0aGUgb3BzIGFyZSBjb21iaW5lZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGVcbiAgLy8gc2VydmVyLiBJdCBkb2Vzbid0IG1hdHRlciBpZiBmbHVzaCBpcyBjYWxsZWQgYSBidW5jaCBvZiB0aW1lcy5cbiAgdmFyIF90aGlzID0gdGhpcztcbiAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7IF90aGlzLmZsdXNoKCk7IH0pLCAwKTtcbn07XG5cblxuLy8gKioqIENsaWVudCBPVCBlbnRyeXBvaW50cy5cblxuLy8gU3VibWl0IGFuIG9wZXJhdGlvbiB0byB0aGUgZG9jdW1lbnQuIFRoZSBvcCBtdXN0IGJlIHZhbGlkIGdpdmVuIHRoZSBjdXJyZW50IE9UIHR5cGUuXG5Eb2MucHJvdG90eXBlLnN1Ym1pdE9wID0gZnVuY3Rpb24ob3AsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX3N1Ym1pdE9wRGF0YSh7b3A6IG9wfSwgY29udGV4dCwgY2FsbGJhY2spO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBkb2N1bWVudCwgd2hpY2ggaW4gU2hhcmVKUyBzZW1hbnRpY3MgbWVhbnMgdG8gc2V0IGl0cyB0eXBlLiBFdmVyeVxuLy8gb2JqZWN0IGltcGxpY2l0bHkgZXhpc3RzIGluIHRoZSBkYXRhYmFzZSBidXQgaGFzIG5vIGRhdGEgYW5kIG5vIHR5cGUuIENyZWF0ZVxuLy8gc2V0cyB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IGFuZCBjYW4gb3B0aW9uYWxseSBzZXQgc29tZSBpbml0aWFsIGRhdGEgb24gdGhlXG4vLyBvYmplY3QsIGRlcGVuZGluZyBvbiB0aGUgdHlwZS5cbkRvYy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24odHlwZSwgZGF0YSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gU2V0dGluZyB0aGUgY29udGV4dCB0byBiZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaW4gdGhpcyBjYXNlIHNvIF9zdWJtaXRPcERhdGFcbiAgICAvLyBjYW4gaGFuZGxlIHRoZSBkZWZhdWx0IHZhbHVlIHRoaW5nLlxuICAgIGNvbnRleHQgPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHRoaXMudHlwZSkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soJ0RvY3VtZW50IGFscmVhZHkgZXhpc3RzJyk7XG4gICAgcmV0dXJuIFxuICB9XG5cbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtjcmVhdGU6IHt0eXBlOnR5cGUsIGRhdGE6ZGF0YX19LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG4vLyBEZWxldGUgdGhlIGRvY3VtZW50LiBUaGlzIGNyZWF0ZXMgYW5kIHN1Ym1pdHMgYSBkZWxldGUgb3BlcmF0aW9uIHRvIHRoZVxuLy8gc2VydmVyLiBEZWxldGluZyByZXNldHMgdGhlIG9iamVjdCdzIHR5cGUgdG8gbnVsbCBhbmQgZGVsZXRlcyBpdHMgZGF0YS4gVGhlXG4vLyBkb2N1bWVudCBzdGlsbCBleGlzdHMsIGFuZCBzdGlsbCBoYXMgdGhlIHZlcnNpb24gaXQgdXNlZCB0byBoYXZlIGJlZm9yZSB5b3Vcbi8vIGRlbGV0ZWQgaXQgKHdlbGwsIG9sZCB2ZXJzaW9uICsxKS5cbkRvYy5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oY29udGV4dCwgY2FsbGJhY2spIHtcbiAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCdEb2N1bWVudCBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3N1Ym1pdE9wRGF0YSh7ZGVsOiB0cnVlfSwgY29udGV4dCwgY2FsbGJhY2spO1xufTtcblxuXG4vLyBQYXVzaW5nIHN0b3BzIHRoZSBkb2N1bWVudCBmcm9tIHNlbmRpbmcgYW55IG9wZXJhdGlvbnMgdG8gdGhlIHNlcnZlci5cbkRvYy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xufTtcblxuRG9jLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuXG4vLyAqKiogUmVjZWl2aW5nIG9wZXJhdGlvbnNcblxuXG4vLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHNlcnZlciByZWplY3RzIG91ciBvcGVyYXRpb25zIGZvciBzb21lIHJlYXNvbi5cbi8vIFRoZXJlJ3Mgbm90IG11Y2ggd2UgY2FuIGRvIGhlcmUgaWYgdGhlIE9UIHR5cGUgaXMgbm9uaW52ZXJ0YWJsZSwgYnV0IHRoYXRcbi8vIHNob3VsZG4ndCBoYXBwZW4gdG9vIG11Y2ggaW4gcmVhbCBsaWZlIGJlY2F1c2UgcmVhZG9ubHkgZG9jdW1lbnRzIHNob3VsZCBiZVxuLy8gZmxhZ2dlZCBhcyBzdWNoLiAoSSBzaG91bGQgcHJvYmFibHkgZmlndXJlIG91dCBhIGZsYWcgZm9yIHRoYXQpLlxuLy9cbi8vIFRoaXMgZG9lcyBOT1QgZ2V0IGNhbGxlZCBpZiBvdXIgb3AgZmFpbHMgdG8gcmVhY2ggdGhlIHNlcnZlciBmb3Igc29tZSByZWFzb25cbi8vIC0gd2Ugb3B0aW1pc3RpY2FsbHkgYXNzdW1lIGl0J2xsIG1ha2UgaXQgdGhlcmUgZXZlbnR1YWxseS5cbkRvYy5wcm90b3R5cGUuX3RyeVJvbGxiYWNrID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIC8vIFRoaXMgaXMgcHJvYmFibHkgaG9ycmlibHkgYnJva2VuLlxuICBpZiAob3BEYXRhLmNyZWF0ZSkge1xuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG5cbiAgICAvLyBJIGRvbid0IHRoaW5rIGl0cyBwb3NzaWJsZSB0byBnZXQgaGVyZSBpZiB3ZSBhcmVuJ3QgaW4gYSBmbG9hdGluZyBzdGF0ZS5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Zsb2F0aW5nJylcbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUud2FybignUm9sbGJhY2sgYSBjcmVhdGUgZnJvbSBzdGF0ZSAnICsgdGhpcy5zdGF0ZSk7XG5cbiAgfSBlbHNlIGlmIChvcERhdGEub3AgJiYgb3BEYXRhLnR5cGUuaW52ZXJ0KSB7XG4gICAgdmFyIHVuZG8gPSBvcERhdGEudHlwZS5pbnZlcnQob3BEYXRhLm9wKTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgdW5kbyBvcGVyYXRpb24gYnkgYW55IHBlbmRpbmcgb3BzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeGYodGhpcy5wZW5kaW5nRGF0YVtpXSwgdW5kbyk7XG4gICAgfVxuXG4gICAgLy8gLi4uIGFuZCBhcHBseSBpdCBsb2NhbGx5LCByZXZlcnRpbmcgdGhlIGNoYW5nZXMuXG4gICAgLy8gXG4gICAgLy8gVGhpcyBvcGVyYXRpb24gaXMgYXBwbGllZCB0byBsb29rIGxpa2UgaXQgY29tZXMgZnJvbSBhIHJlbW90ZSBjb250ZXh0LlxuICAgIC8vIEknbSBzdGlsbCBub3QgMTAwJSBzdXJlIGFib3V0IHRoaXMgZnVuY3Rpb25hbGl0eSwgYmVjYXVzZSBpdHMgcmVhbGx5IGFcbiAgICAvLyBsb2NhbCBvcC4gQmFzaWNhbGx5LCB0aGUgcHJvYmxlbSBpcyB0aGF0IGlmIHRoZSBjbGllbnQncyBvcCBpcyByZWplY3RlZFxuICAgIC8vIGJ5IHRoZSBzZXJ2ZXIsIHRoZSBlZGl0b3Igd2luZG93IHNob3VsZCB1cGRhdGUgdG8gcmVmbGVjdCB0aGUgdW5kby5cbiAgICB0aGlzLl9vdEFwcGx5KHVuZG8sIGZhbHNlKTtcbiAgICB0aGlzLl9hZnRlck90QXBwbHkodW5kbywgZmFsc2UpO1xuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCB8fCBvcERhdGEuZGVsKSB7XG4gICAgLy8gVGhpcyBpcyB3aGVyZSBhbiB1bmRvIHN0YWNrIHdvdWxkIGNvbWUgaW4gaGFuZHkuXG4gICAgdGhpcy5fc2V0VHlwZShudWxsKTtcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBcIk9wIGFwcGx5IGZhaWxlZCBhbmQgdGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcmV2ZXJ0ZWRcIik7XG5cbiAgICAvLyBUcmlnZ2VyIGEgZmV0Y2guIEluIG91ciBpbnZhbGlkIHN0YXRlLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmcuXG4gICAgdGhpcy5mZXRjaCgpO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuRG9jLnByb3RvdHlwZS5fY2xlYXJJbmZsaWdodE9wID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuaW5mbGlnaHREYXRhLmNhbGxiYWNrcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYWxsYmFja3NbaV0oZXJyb3IgfHwgdGhpcy5pbmZsaWdodERhdGEuZXJyb3IpO1xuICB9XG5cbiAgdGhpcy5pbmZsaWdodERhdGEgPSBudWxsO1xuICB0aGlzLl9jbGVhckFjdGlvbignc3VibWl0Jyk7XG5cbiAgaWYgKCF0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2QgbmFtZS5cbiAgICB0aGlzLmVtaXQoJ25vdGhpbmcgcGVuZGluZycpO1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIGFuIG9wZXJhdGlvbiBmcm9tIHRoZSBjbGllbnQuXG5Eb2MucHJvdG90eXBlLl9vcEFja25vd2xlZGdlZCA9IGZ1bmN0aW9uKG1zZykge1xuICAvLyBPdXIgaW5mbGlnaHQgb3AgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLCBzbyB3ZSBjYW4gdGhyb3cgYXdheSB0aGUgaW5mbGlnaHQgZGF0YS5cbiAgLy8gKFdlIHdlcmUgb25seSBob2xkaW5nIG9uIHRvIGl0IGluY2FzZSB3ZSBuZWVkZWQgdG8gcmVzZW5kIHRoZSBvcC4pXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3BBY2tub3dsZWRnZWQgY2FsbGVkIGZyb20gYSBudWxsIHN0YXRlLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgIGlmICghdGhpcy5pbmZsaWdodERhdGEuY3JlYXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2tub3dsZWRnZSBhbiBvcC4nKTtcblxuICAgIC8vIE91ciBjcmVhdGUgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGluamVzdGluZyBzb21lIGRhdGEuXG4gICAgdGhpcy52ZXJzaW9uID0gbXNnLnY7XG4gICAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBfdGhpcy5lbWl0KCdyZWFkeScpOyB9LCAwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYSBzbmFwc2hvdC4gVGhlIHNuYXBzaG90IHNob3VsZCBiZSBhdCB0aGUgYWNrbm93bGVkZ2VkXG4gICAgLy8gdmVyc2lvbiwgYmVjYXVzZSB0aGUgc2VydmVyIGhhcyBzZW50IHVzIGFsbCB0aGUgb3BzIHRoYXQgaGF2ZSBoYXBwZW5lZFxuICAgIC8vIGJlZm9yZSBhY2tub3dsZWRnaW5nIG91ciBvcC5cblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIHNvbWV0aGluZyBpcyBvdXQgb2Ygb3JkZXIuXG4gICAgaWYgKG1zZy52ICE9PSB0aGlzLnZlcnNpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiBmcm9tIHNlcnZlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUsIHRoaXMgaXMgYSBidWcuJyk7XG4gIH1cbiAgXG4gIC8vIFRoZSBvcCB3YXMgY29tbWl0dGVkIHN1Y2Nlc3NmdWxseS4gSW5jcmVtZW50IHRoZSB2ZXJzaW9uIG51bWJlclxuICB0aGlzLnZlcnNpb24rKztcblxuICB0aGlzLl9jbGVhckluZmxpZ2h0T3AoKTtcbn07XG5cblxuLy8gQVBJIENvbnRleHRzXG5cbi8vIFRoaXMgY3JlYXRlcyBhbmQgcmV0dXJucyBhbiBlZGl0aW5nIGNvbnRleHQgdXNpbmcgdGhlIGN1cnJlbnQgT1QgdHlwZS5cbkRvYy5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgaWYgKCF0eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZScpO1xuXG4gIC8vIEkgY291bGQgdXNlIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gZG8gdGhpcyBpbnN0ZWFkLCBidXQgT2JqZWN0LmNyZWF0ZVxuICAvLyBpc24ndCBkZWZpbmVkIG9uIG9sZCBicm93c2Vycy4gVGhpcyB3aWxsIGJlIGZpbmUuXG4gIHZhciBkb2MgPSB0aGlzO1xuICB2YXIgY29udGV4dCA9IHtcbiAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9jLnNuYXBzaG90O1xuICAgIH0sXG4gICAgc3VibWl0T3A6IGZ1bmN0aW9uKG9wLCBjYWxsYmFjaykge1xuICAgICAgZG9jLnN1Ym1pdE9wKG9wLCBjb250ZXh0LCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmRldGFjaCkge1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICAvLyBEb24ndCBkb3VibGUtZGV0YWNoLlxuICAgICAgICBkZWxldGUgdGhpcy5kZXRhY2g7XG4gICAgICB9XG4gICAgICAvLyBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYWN0dWFsIGVkaXRpbmdDb250ZXh0cyBsaXN0IG5leHQgdGltZVxuICAgICAgLy8gd2UgcmVjZWl2ZSBhbiBvcCBvbiB0aGUgZG9jdW1lbnQgKGFuZCB0aGUgbGlzdCBpcyBpdGVyYXRlZCB0aHJvdWdoKS5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGlzIHBvdGVudGlhbGx5IGRvZGd5LCBhbGxvd2luZyBhIG1lbW9yeSBsZWFrIGlmIHlvdSBjcmVhdGUgJlxuICAgICAgLy8gZGVzdHJveSBhIHdob2xlIGJ1bmNoIG9mIGNvbnRleHRzIHdpdGhvdXQgcmVjZWl2aW5nIG9yIHNlbmRpbmcgYW55IG9wc1xuICAgICAgLy8gdG8gdGhlIGRvY3VtZW50LlxuICAgICAgZGVsZXRlIHRoaXMuX29uT3A7XG4gICAgICB0aGlzLnJlbW92ZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgZGFuZ2Vyb3VzLCBidXQgcmVhbGx5IHJlYWxseSB1c2VmdWwgZm9yIGRlYnVnZ2luZy4gSSBob3BlIHBlb3BsZVxuICAgIC8vIGRvbid0IGRlcGVuZCBvbiBpdC5cbiAgICBfZG9jOiB0aGlzLFxuICB9O1xuXG4gIGlmICh0eXBlLmFwaSkge1xuICAgIC8vIENvcHkgZXZlcnl0aGluZyBlbHNlIGZyb20gdGhlIHR5cGUncyBBUEkgaW50byB0aGUgZWRpdGluZyBjb250ZXh0LlxuICAgIGZvciAodmFyIGsgaW4gdHlwZS5hcGkpIHtcbiAgICAgIGNvbnRleHRba10gPSB0eXBlLmFwaVtrXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5wcm92aWRlcyA9IHt9O1xuICB9XG5cbiAgdGhpcy5lZGl0aW5nQ29udGV4dHMucHVzaChjb250ZXh0KTtcblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbkRvYy5wcm90b3R5cGUucmVtb3ZlQ29udGV4dHMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuZWRpdGluZ0NvbnRleHRzW2ldLmRlc3Ryb3koKTtcbiAgfVxuICB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGggPSAwO1xufTtcblxuLy8gQSBDb25uZWN0aW9uIHdyYXBzIGEgcGVyc2lzdGFudCBCQyBjb25uZWN0aW9uIHRvIGEgc2hhcmVqcyBzZXJ2ZXIuXG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBjbGllbnQgc2lkZSBvZiB0aGUgcHJvdG9jb2wgZGVmaW5lZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvc2VwaGcvU2hhcmVKUy93aWtpL1dpcmUtUHJvdG9jb2xcbi8vXG4vLyBUaGUgZXF1aXZhbGVudCBzZXJ2ZXIgY29kZSBpcyBpbiBzcmMvc2VydmVyL3Nlc3Npb24uXG4vL1xuLy8gVGhpcyBmaWxlIGlzIGEgYml0IG9mIGEgbWVzcy4gSSdtIGRyZWFkZnVsbHkgc29ycnkgYWJvdXQgdGhhdC4gSXQgcGFzc2VzIGFsbCB0aGUgdGVzdHMsXG4vLyBzbyBJIGhhdmUgaG9wZSB0aGF0IGl0cyAqY29ycmVjdCogZXZlbiBpZiBpdHMgbm90IGNsZWFuLlxuLy9cbi8vIFRvIG1ha2UgYSBjb25uZWN0aW9uLCB1c2U6XG4vLyAgbmV3IHNoYXJlanMuQ29ubmVjdGlvbihzb2NrZXQpXG4vL1xuLy8gVGhlIHNvY2tldCBzaG91bGQgbG9vayBsaWtlIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24uIEl0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vICBzZW5kKG1zZyk6IFNlbmQgdGhlIGdpdmVuIG1lc3NhZ2UuIG1zZyBtYXkgYmUgYW4gb2JqZWN0IC0gaWYgc28sIHlvdSBtaWdodCBuZWVkIHRvIEpTT04uc3RyaW5naWZ5IGl0LlxuLy8gIGNsb3NlKCk6IERpc2Nvbm5lY3QgdGhlIHNlc3Npb25cbi8vXG4vLyAgb25tZXNzYWdlID0gZnVuY3Rpb24obXNnKXt9OiBFdmVudCBoYW5kbGVyIHdoaWNoIGlzIGNhbGxlZCB3aGVuZXZlciBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuIFRoZSBtZXNzYWdlXG4vLyAgICAgcGFzc2VkIGluIHNob3VsZCBhbHJlYWR5IGJlIGFuIG9iamVjdC4gKEl0IG1heSBuZWVkIHRvIGJlIEpTT04ucGFyc2VkKVxuLy8gIG9uY2xvc2Vcbi8vICBvbmVycm9yXG4vLyAgb25vcGVuXG4vLyAgb25jb25uZWN0aW5nXG4vL1xuLy8gVGhlIHNvY2tldCBzaG91bGQgcHJvYmFibHkgYXV0b21hdGljYWxseSByZWNvbm5lY3QuIElmIHNvLCBpdCBzaG91bGQgZW1pdCB0aGUgYXBwcm9wcmlhdGUgZXZlbnRzIGFzIGl0XG4vLyBkaXNjb25uZWN0cyAmIHJlY29ubmVjdHMuIChvbmNsb3NlKCksIG9uY29ubmVjdGluZygpLCBvbm9wZW4oKSkuXG5cbnZhciB0eXBlcywgRG9jO1xuaWYgKHR5cGVvZiBicmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHlwZXMgPSBicmVxdWlyZSgnb3R0eXBlcycpO1xuICBEb2MgPSBicmVxdWlyZSgnLi9kb2MnKS5Eb2M7XG4gIFF1ZXJ5ID0gYnJlcXVpcmUoJy4vcXVlcnknKS5RdWVyeTtcbn0gZWxzZSB7XG4gIHR5cGVzID0gd2luZG93Lm90dHlwZXM7XG4gIERvYyA9IGV4cG9ydHMuRG9jO1xufVxuXG52YXIgQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgLy8gTWFwIG9mIGNvbGxlY3Rpb24gLT4gZG9jTmFtZSAtPiBkb2Mgb2JqZWN0IGZvciBjcmVhdGVkIGRvY3VtZW50cy5cbiAgLy8gKGNyZWF0ZWQgZG9jdW1lbnRzIE1VU1QgQkUgVU5JUVVFKVxuICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG5cbiAgLy8gRWFjaCBxdWVyeSBpcyBjcmVhdGVkIHdpdGggYW4gaWQgdGhhdCB0aGUgc2VydmVyIHVzZXMgd2hlbiBpdCBzZW5kcyB1c1xuICAvLyBpbmZvIGFib3V0IHRoZSBxdWVyeSAodXBkYXRlcywgZXRjKS5cbiAgLy90aGlzLm5leHRRdWVyeUlkID0gKE1hdGgucmFuZG9tKCkgKiAxMDAwKSB8MDtcbiAgdGhpcy5uZXh0UXVlcnlJZCA9IDE7XG5cbiAgLy8gTWFwIGZyb20gcXVlcnkgSUQgLT4gcXVlcnkgb2JqZWN0LlxuICB0aGlzLnF1ZXJpZXMgPSB7fTtcblxuICAvLyBDb25uZWN0aW9uIHN0YXRlLlxuICAvLyBcbiAgLy8gU3RhdGVzOlxuICAvLyAtICdjb25uZWN0aW5nJzogVGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIGJ1dCB3ZSBkb24ndCBoYXZlIG91ciBjbGllbnQgSUQgeWV0XG4gIC8vIC0gJ2Nvbm5lY3RlZCc6IFdlIGhhdmUgY29ubmVjdGVkIGFuZCByZWNpZXZlZCBvdXIgY2xpZW50IElELiBSZWFkeSBmb3IgZGF0YS5cbiAgLy8gLSAnZGlzY29ubmVjdGVkJzogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLCBidXQgaXQgd2lsbCByZWNvbm5lY3QgYXV0b21hdGljYWxseS5cbiAgLy8gLSAnc3RvcHBlZCc6IFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCwgYW5kIHNob3VsZCBub3QgcmVjb25uZWN0LlxuICB0aGlzLnN0YXRlID0gKHNvY2tldC5yZWFkeVN0YXRlID09PSAwIHx8IHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSA/ICdjb25uZWN0aW5nJyA6ICdkaXNjb25uZWN0ZWQnO1xuXG4gIC8vIFRoaXMgaXMgYSBoZWxwZXIgdmFyaWFibGUgdGhlIGRvY3VtZW50IHVzZXMgdG8gc2VlIHdoZXRoZXIgd2UncmUgY3VycmVudGx5XG4gIC8vIGluIGEgJ2xpdmUnIHN0YXRlLiBJdCBpcyB0cnVlIGlmIHRoZSBzdGF0ZSBpcyAnY29ubmVjdGluZycgb3IgJ2Nvbm5lY3RlZCcuXG4gIHRoaXMuY2FuU2VuZCA9IHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJztcblxuICAvLyBSZXNldCBzb21lIG1vcmUgc3RhdGUgdmFyaWFibGVzLlxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAvLyBJJ2xsIHN0b3JlIHRoZSBtb3N0IHJlY2VudCAxMDAgbWVzc2FnZXMgc28gd2hlbiBlcnJvcnMgb2NjdXIgd2UgY2FuIHNlZSB3aGF0IGhhcHBlbmVkLlxuICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcblxuICB2YXIgY29ubmVjdGlvbiA9IHRoaXM7XG5cbiAgdmFyIGhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAvLyBTd2l0Y2ggb24gdGhlIG1lc3NhZ2UgYWN0aW9uLiBNb3N0IG1lc3NhZ2VzIGFyZSBmb3IgZG9jdW1lbnRzIGFuZCBhcmVcbiAgICAvLyBoYW5kbGVkIGluIHRoZSBkb2MgY2xhc3MuXG4gICAgc3dpdGNoIChtc2cuYSkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIC8vIENsaWVudCBpbml0aWFsaXphdGlvbiBwYWNrZXQuIFRoaXMgYnVuZGxlIG9mIGpveSBjb250YWlucyBvdXIgY2xpZW50XG4gICAgICAgIC8vIElELlxuICAgICAgICBpZiAobXNnLnByb3RvY29sICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpO1xuICAgICAgICBpZiAodHlwZW9mIG1zZy5pZCAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNsaWVudCBpZCcpO1xuXG4gICAgICAgIGNvbm5lY3Rpb24uaWQgPSBtc2cuaWQ7XG4gICAgICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3FmZXRjaCc6XG4gICAgICBjYXNlICdxc3ViJzpcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgY2FzZSAncXVuc3ViJzpcbiAgICAgICAgLy8gUXVlcnkgbWVzc2FnZS4gUGFzcyB0aGlzIHRvIHRoZSBhcHByb3ByaWF0ZSBxdWVyeSBvYmplY3QuXG4gICAgICAgIHZhciBxdWVyeSA9IGNvbm5lY3Rpb24ucXVlcmllc1ttc2cuaWRdO1xuICAgICAgICBpZiAocXVlcnkpIHF1ZXJ5Ll9vbk1lc3NhZ2UobXNnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvY3VtZW50IG1lc3NhZ2UuIFB1bGwgb3V0IHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IGFuZCBmb3J3YXJkIHRoZVxuICAgICAgICAvLyBtZXNzYWdlLlxuICAgICAgICB2YXIgY29sbGVjdGlvbiwgZG9jTmFtZSwgZG9jO1xuICAgICAgICBpZiAobXNnLmQpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gY29ubmVjdGlvbi5fbGFzdFJlY2VpdmVkQ29sbGVjdGlvbiA9IG1zZy5jO1xuICAgICAgICAgIGRvY05hbWUgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWREb2MgPSBtc2cuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gbXNnLmMgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWRDb2xsZWN0aW9uO1xuICAgICAgICAgIGRvY05hbWUgPSBtc2cuZCA9IGNvbm5lY3Rpb24uX2xhc3RSZWNlaXZlZERvYztcbiAgICAgICAgfVxuXG4gICAgICAgIGRvYyA9IGNvbm5lY3Rpb24uZ2V0KGNvbGxlY3Rpb24sIGRvY05hbWUpO1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKCdNZXNzYWdlIGZvciB1bmtub3duIGRvYy4gSWdub3JpbmcuJywgbXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkb2MuX29uTWVzc2FnZShtc2cpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBdHRhY2ggZXZlbnQgaGFuZGxlcnMgdG8gdGhlIHNvY2tldC5cbiAgc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGlmIChjb25uZWN0aW9uLmRlYnVnKSBjb25zb2xlLmxvZygnUkVDVicsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgIGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5wdXNoKHt0OihuZXcgRGF0ZSgpKS50b1RpbWVTdHJpbmcoKSwgcmVjdjpKU09OLnN0cmluZ2lmeShtc2cpfSk7XG4gICAgd2hpbGUgKGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAxMDApIHtcbiAgICAgIGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBoYW5kbGVNZXNzYWdlKG1zZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29ubmVjdGlvbi5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgLy8gV2UgY291bGQgYWxzbyByZXN0YXJ0IHRoZSBjb25uZWN0aW9uIGhlcmUsIGFsdGhvdWdoIHRoYXQgbWlnaHQgcmVzdWx0XG4gICAgICAvLyBpbiBpbmZpbml0ZSByZWNvbm5lY3Rpb24gYnVncy5cbiAgICB9XG4gIH1cblxuICBzb2NrZXQub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgfTtcblxuICBzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBUaGlzIGlzbid0IHRoZSBzYW1lIGFzIGEgcmVndWxhciBlcnJvciwgYmVjYXVzZSBpdCB3aWxsIGhhcHBlbiBub3JtYWxseVxuICAgIC8vIGZyb20gdGltZSB0byB0aW1lLiBZb3VyIGNvbm5lY3Rpb24gc2hvdWxkIHByb2JhYmx5IGF1dG9tYXRpY2FsbHlcbiAgICAvLyByZWNvbm5lY3QgYW55d2F5LCBidXQgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkIG9mZiBvbmNsb3NlIG5vdCBvbmVycm9yLlxuICAgIC8vIChvbmNsb3NlIGhhcHBlbnMgd2hlbiBvbmVycm9yIGdldHMgY2FsbGVkIGFueXdheSkuXG4gICAgY29ubmVjdGlvbi5lbWl0KCdjb25uZWN0aW9uIGVycm9yJywgZSk7XG4gIH07XG5cbiAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnZGlzY29ubmVjdGVkJywgcmVhc29uKTtcbiAgICBpZiAocmVhc29uID09PSAnQ2xvc2VkJyB8fCByZWFzb24gPT09ICdTdG9wcGVkIGJ5IHNlcnZlcicpIHtcbiAgICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdzdG9wcGVkJywgcmVhc29uKTtcbiAgICB9XG4gIH07XG59XG5cbi8qIFdoeSBkb2VzIHRoaXMgZnVuY3Rpb24gZXhpc3Q/IElzIGl0IGltcG9ydGFudD9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5fc2V0U3RhdGUoJ3N0b3BwZWQnLCBlKTtcbiAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdChlKTtcbn07XG4qL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlkID0gdGhpcy5sYXN0RXJyb3IgPVxuICAgIHRoaXMuX2xhc3RSZWNlaXZlZENvbGxlY3Rpb24gPSB0aGlzLl9sYXN0UmVjZWl2ZWREb2MgPVxuICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IHRoaXMuX2xhc3RTZW50RG9jID0gbnVsbDtcblxuICB0aGlzLnNlcSA9IDE7XG59O1xuXG4vLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBzdGF0ZS4gVGhlIGNvbm5lY3Rpb24gaXMgYmFzaWNhbGx5IGEgc3RhdGUgbWFjaGluZS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlLCBkYXRhKSB7XG4gIGlmICh0aGlzLnN0YXRlID09PSBuZXdTdGF0ZSkgcmV0dXJuO1xuXG4gIC8vIEkgbWFkZSBhIHN0YXRlIGRpYWdyYW0uIFRoZSBvbmx5IGludmFsaWQgdHJhbnNpdGlvbnMgYXJlIGdldHRpbmcgdG9cbiAgLy8gJ2Nvbm5lY3RpbmcnIGZyb20gYW55d2hlcmUgb3RoZXIgdGhhbiAnZGlzY29ubmVjdGVkJyBhbmQgZ2V0dGluZyB0b1xuICAvLyAnY29ubmVjdGVkJyBmcm9tIGFueXdoZXJlIG90aGVyIHRoYW4gJ2Nvbm5lY3RpbmcnLlxuICBpZiAoKG5ld1N0YXRlID09PSAnY29ubmVjdGluZycgJiYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09ICdzdG9wcGVkJykpXG4gICAgICB8fCAobmV3U3RhdGUgPT09ICdjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09ICdjb25uZWN0aW5nJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNpdGlvbiBkaXJlY3RseSBmcm9tIFwiICsgdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICB9XG5cbiAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICB0aGlzLmNhblNlbmQgPSBuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IG5ld1N0YXRlID09PSAnY29ubmVjdGVkJztcblxuICBpZiAobmV3U3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5lbWl0KG5ld1N0YXRlLCBkYXRhKTtcblxuICAvLyAmIEVtaXQgdGhlIGV2ZW50IHRvIGFsbCBkb2N1bWVudHMgJiBxdWVyaWVzLiBJdCBtaWdodCBtYWtlIHNlbnNlIGZvclxuICAvLyBkb2N1bWVudHMgdG8ganVzdCByZWdpc3RlciBmb3IgdGhpcyBzdHVmZiB1c2luZyBldmVudHMsIGJ1dCB0aGF0IGNvdXBsZXNcbiAgLy8gY29ubmVjdGlvbnMgYW5kIGRvY3VtZW50cyBhIGJpdCBtdWNoLiBJdHMgbm90IGEgYmlnIGRlYWwgZWl0aGVyIHdheS5cbiAgdGhpcy5vcFF1ZXVlID0gW107XG4gIGZvciAodmFyIGMgaW4gdGhpcy5jb2xsZWN0aW9ucykge1xuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uc1tjXTtcbiAgICBmb3IgKHZhciBkb2NOYW1lIGluIGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb25bZG9jTmFtZV0uX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZChuZXdTdGF0ZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vcFF1ZXVlLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5zZXEgLSBiLnNlcTsgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5zZW5kKHRoaXMub3BRdWV1ZVtpXSk7XG4gIH1cbiAgdGhpcy5vcFF1ZXVlID0gbnVsbDtcbiAgXG4gIGZvciAodmFyIGlkIGluIHRoaXMucXVlcmllcykge1xuICAgIHRoaXMucXVlcmllc1tpZF0uX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZChuZXdTdGF0ZSwgZGF0YSk7XG4gIH1cbn07XG5cbi8vIFNvLCB0aGVyZSdzIGFuIGF3ZnVsIGVycm9yIGNhc2Ugd2hlcmUgdGhlIGNsaWVudCBzZW5kcyB0d28gcmVxdWVzdHMgKHdoaWNoXG4vLyBmYWlsKSwgdGhlbiByZWNvbm5lY3RzLiBUaGUgZG9jdW1lbnRzIGNvdWxkIGhhdmUgX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuLy8gY2FsbGVkIGluIHRoZSB3cm9uZyBvcmRlciBhbmQgdGhlIG9wZXJhdGlvbnMgdGhlbiBnZXQgc2VudCB3aXRoIHJldmVyc2VkXG4vLyBzZXF1ZW5jZSBudW1iZXJzLiBUaGlzIGNhdXNlcyB0aGUgc2VydmVyIHRvIGluY29ycmVjdGx5IHJlamVjdCB0aGUgc2Vjb25kXG4vLyBzZW50IG9wLiBTbyB3ZSBuZWVkIHRvIHF1ZXVlIHRoZSBvcGVyYXRpb25zIHdoaWxlIHdlJ3JlIHJlY29ubmVjdGluZyBhbmRcbi8vIHJlc2VuZCB0aGVtIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZE9wID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5vcFF1ZXVlKSB7XG4gICAgdGhpcy5vcFF1ZXVlLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kKGRhdGEpO1xuICB9XG59O1xuXG4vLyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgY29ubmVjdGlvbi5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKHRoaXMuZGVidWcpIGNvbnNvbGUubG9nKFwiU0VORFwiLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgdGhpcy5tZXNzYWdlQnVmZmVyLnB1c2goe3Q6KG5ldyBEYXRlKCkpLnRvVGltZVN0cmluZygpLCBzZW5kOkpTT04uc3RyaW5naWZ5KG1zZyl9KTtcbiAgd2hpbGUgKHRoaXMubWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAxMDApIHtcbiAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuc2hpZnQoKTtcbiAgfVxuXG4gIGlmIChtc2cuZCkgeyAvLyBUaGUgZG9jdW1lbnQgdGhlIG1lc3NhZ2UgcmVmZXJzIHRvLiBOb3Qgc2V0IGZvciBxdWVyaWVzLlxuICAgIHZhciBjb2xsZWN0aW9uID0gbXNnLmM7XG4gICAgdmFyIGRvY05hbWUgPSBtc2cuZDtcbiAgICBpZiAoY29sbGVjdGlvbiA9PT0gdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uICYmIGRvY05hbWUgPT09IHRoaXMuX2xhc3RTZW50RG9jKSB7XG4gICAgICBkZWxldGUgbXNnLmM7XG4gICAgICBkZWxldGUgbXNnLmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB0aGlzLl9sYXN0U2VudERvYyA9IGRvY05hbWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zb2NrZXQuc2VuZChtc2cpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIHdpbGwgY2FsbCBAc29ja2V0Lm9uY2xvc2UoKSwgd2hpY2ggaW4gdHVybiB3aWxsIGVtaXQgdGhlICdkaXNjb25uZWN0ZWQnIGV2ZW50LlxuICB0aGlzLnNvY2tldC5jbG9zZSgpO1xufTtcblxuXG4vLyAqKioqKiBEb2N1bWVudCBtYW5hZ2VtZW50XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldEV4aXN0aW5nID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbmFtZSkge1xuICBpZiAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSkgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl1bbmFtZV07XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpIHtcbiAgY29uc29sZS50cmFjZSgnZ2V0T3JDcmVhdGUgaXMgZGVwcmVjYXRlZC4gVXNlIGdldCgpIGluc3RlYWQnKTtcbiAgcmV0dXJuIHRoaXMuZ2V0KGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpO1xufTtcblxuLy8gQ3JlYXRlIGEgZG9jdW1lbnQgaWYgaXQgZG9lc24ndCBleGlzdC4gUmV0dXJucyB0aGUgZG9jdW1lbnQgc3luY2hyb25vdXNseS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpIHtcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0RXhpc3RpbmcoY29sbGVjdGlvbiwgbmFtZSk7XG5cbiAgaWYgKCFkb2MpIHtcbiAgICAvLyBDcmVhdGUgaXQuXG4gICAgZG9jID0gbmV3IERvYyh0aGlzLCBjb2xsZWN0aW9uLCBuYW1lKTtcblxuICAgIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSA9XG4gICAgICAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSB8fCB7fSk7XG4gICAgY29sbGVjdGlvbk9iamVjdFtuYW1lXSA9IGRvYztcbiAgfVxuXG4gIC8vIEV2ZW4gaWYgdGhlIGRvY3VtZW50IGlzbid0IG5ldywgaXRzIHBvc3NpYmxlIHRoZSBkb2N1bWVudCB3YXMgY3JlYXRlZFxuICAvLyBtYW51YWxseSBhbmQgdGhlbiB0cmllZCB0byBiZSByZS1jcmVhdGVkIHdpdGggZGF0YSAoc3VwcG9zZSBhIHF1ZXJ5XG4gIC8vIHJldHVybnMgd2l0aCBkYXRhIGZvciB0aGUgZG9jdW1lbnQpLiBXZSBzaG91bGQgaHlkcmF0ZSB0aGUgZG9jdW1lbnRcbiAgLy8gaW1tZWRpYXRlbHkgaWYgd2UgY2FuIGJlY2F1c2UgdGhlIHF1ZXJ5IGNhbGxiYWNrIHdpbGwgZXhwZWN0IHRoZSBkb2N1bWVudFxuICAvLyB0byBoYXZlIGRhdGEuXG4gIGlmIChkYXRhICYmIGRhdGEuc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhZG9jLnN0YXRlKSB7XG4gICAgZG9jLmluamVzdERhdGEoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufTtcblxuLy8gQ2FsbCBkb2MuZGVzdHJveSgpXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveURvYyA9IGZ1bmN0aW9uKGRvYykge1xuICB2YXIgY29sbGVjdGlvbk9iamVjdCA9IHRoaXMuY29sbGVjdGlvbnNbZG9jLmNvbGxlY3Rpb25dO1xuICBpZiAoIWNvbGxlY3Rpb25PYmplY3QpIHJldHVybjtcblxuICBkZWxldGUgY29sbGVjdGlvbk9iamVjdFtkb2MubmFtZV07XG5cbiAgLy8gRGVsZXRlIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5lciBpZiBpdHMgZW1wdHkuIFRoaXMgY291bGQgYmUgYSBzb3VyY2Ugb2ZcbiAgLy8gbWVtb3J5IGxlYWtzIGlmIHlvdSBzbG93bHkgbWFrZSBhIGJpbGxpb24gY29sbGVjdGlvbnMsIHdoaWNoIHlvdSBwcm9iYWJseVxuICAvLyB3b24ndCBkbyBhbnl3YXksIGJ1dCB3aGF0ZXZlci5cbiAgaWYgKCFoYXNLZXlzKGNvbGxlY3Rpb25PYmplY3QpKVxuICAgIGRlbGV0ZSB0aGlzLmNvbGxlY3Rpb25zW2RvYy5jb2xsZWN0aW9uXTtcbn07XG4gXG5mdW5jdGlvbiBoYXNLZXlzKG9iamVjdCkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gKioqKiBRdWVyaWVzLlxuXG4vLyBIZWxwZXIgZm9yIGNyZWF0ZUZldGNoUXVlcnkgYW5kIGNyZWF0ZVN1YnNjcmliZVF1ZXJ5LCBiZWxvdy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVRdWVyeSA9IGZ1bmN0aW9uKHR5cGUsIGNvbGxlY3Rpb24sIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlICE9PSAnZmV0Y2gnICYmIHR5cGUgIT09ICdzdWInKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBxdWVyeSB0eXBlOiAnICsgdHlwZSk7XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBpZCA9IHRoaXMubmV4dFF1ZXJ5SWQrKztcbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHR5cGUsIHRoaXMsIGlkLCBjb2xsZWN0aW9uLCBxLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIHRoaXMucXVlcmllc1tpZF0gPSBxdWVyeTtcbiAgcXVlcnkuX2V4ZWN1dGUoKTtcbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb24uIFVzZSBxdWVyeS5kZXN0cm95KCkgdG8gcmVtb3ZlIHF1ZXJpZXMuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgZGVsZXRlIHRoaXMucXVlcmllc1txdWVyeS5pZF07XG59O1xuXG4vLyBUaGUgcXVlcnkgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4vL1xuLy8gZG9jTW9kZTogV2hhdCB0byBkbyB3aXRoIGRvY3VtZW50cyB0aGF0IGFyZSBpbiB0aGUgcmVzdWx0IHNldC4gQ2FuIGJlXG4vLyAgIG51bGwvdW5kZWZpbmVkIChkZWZhdWx0KSwgJ2ZldGNoJyBvciAnc3Vic2NyaWJlJy4gRmV0Y2ggbW9kZSBpbmRpY2F0ZXNcbi8vICAgdGhhdCB0aGUgc2VydmVyIHNob3VsZCBzZW5kIGRvY3VtZW50IHNuYXBzaG90cyB0byB0aGUgY2xpZW50IGZvciBhbGwgcXVlcnlcbi8vICAgcmVzdWx0cy4gVGhlc2Ugd2lsbCBiZSBoeWRyYXRlZCBpbnRvIHRoZSBkb2N1bWVudCBvYmplY3RzIGJlZm9yZSB0aGUgcXVlcnlcbi8vICAgcmVzdWx0IGNhbGxiYWNrcyBhcmUgcmV0dXJuZWQuIFN1YnNjcmliZSBtb2RlIGdldHMgZG9jdW1lbnQgc25hcHNob3RzIGFuZFxuLy8gICBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZXMgdGhlIGNsaWVudCB0byBhbGwgcmVzdWx0cy4gTm90ZSB0aGF0IHRoZVxuLy8gICBkb2N1bWVudHMgKldJTEwgTk9UKiBiZSBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlZCB3aGVuIHRoZSBxdWVyeSBpc1xuLy8gICBkZXN0cm95ZWQuIChTaGFyZUpTIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZG8gdGhhdCBzYWZlbHkpLlxuLy8gICBCZXdhcmUgb2YgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgdGhpcyBvcHRpb24uXG4vL1xuLy8gcG9sbDogRm9yY2FibHkgZW5hYmxlIG9yIGRpc2FibGUgcG9sbGluZyBtb2RlLiBQb2xsaW5nIG1vZGUgd2lsbCByZWlzc3VlIHRoZSBxdWVyeVxuLy8gICBldmVyeSB0aW1lIGFueXRoaW5nIGluIHRoZSBjb2xsZWN0aW9uIGNoYW5nZXMgKCEhKSBzbywgaXRzIHF1aXRlXG4vLyAgIGV4cGVuc2l2ZS4gIEl0IGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCBmb3IgcGFnaW5hdGVkIGFuZCBzb3J0ZWQgcXVlcmllcy5cbi8vICAgQnkgZGVmYXVsdCBxdWVyaWVzIHJ1biB3aXRoIHBvbGxpbmcgbW9kZSBkaXNhYmxlZDsgd2hpY2ggd2lsbCBvbmx5IGNoZWNrXG4vLyAgIGNoYW5nZWQgZG9jdW1lbnRzIHRvIHRlc3QgaWYgdGhleSBub3cgbWF0Y2ggdGhlIHNwZWNpZmllZCBxdWVyeS5cbi8vICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcG9sbGluZyBtb2RlLCBvciB0cnVlIHRvIGVuYWJsZSBpdC4gSWYgeW91IGRvbid0XG4vLyAgIHNwZWNpZnkgYSBwb2xsIG9wdGlvbiwgcG9sbGluZyBtb2RlIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQgYXV0b21hdGljYWxseVxuLy8gICBieSB0aGUgcXVlcnkncyBiYWNrZW5kLlxuLy9cbi8vIGJhY2tlbmQ6IFNldCB0aGUgYmFja2VuZCBzb3VyY2UgZm9yIHRoZSBxdWVyeS4gWW91IGNhbiBhdHRhY2ggZGlmZmVyZW50XG4vLyAgIHF1ZXJ5IGJhY2tlbmRzIHRvIGxpdmVkYiBhbmQgcGljayB3aGljaCBvbmUgdGhlIHF1ZXJ5IHNob3VsZCBoaXQgdXNpbmdcbi8vICAgdGhpcyBwYXJhbWV0ZXIuXG4vL1xuLy8gcmVzdWx0czogKGV4cGVyaW1lbnRhbCkgSW5pdGlhbCBsaXN0IG9mIHJlc3VsdGFudCBkb2N1bWVudHMuIFRoaXMgaXNcbi8vICAgdXNlZnVsIGZvciByZWh5ZHJhdGluZyBxdWVyaWVzIHdoZW4geW91J3JlIHVzaW5nIGF1dG9GZXRjaCAvIGF1dG9TdWJzY3JpYmVcbi8vICAgc28gdGhlIHNlcnZlciBkb2Vzbid0IGhhdmUgdG8gc2VuZCBvdmVyIHNuYXBzaG90cyBmb3IgZG9jdW1lbnRzIHRoZSBjbGllbnRcbi8vICAgYWxyZWFkeSBrbm93cyBhYm91dC4gVGhpcyBpcyBleHBlcmltZW50YWwgLSB0aGUgQVBJIG1heSBjaGFuZ2UgaW4gdXBjb21pbmdcbi8vICAgdmVyc2lvbnMuXG5cbi8vIENyZWF0ZSBhIGZldGNoIHF1ZXJ5LiBGZXRjaCBxdWVyaWVzIGFyZSBvbmx5IGlzc3VlZCBvbmNlLCByZXR1cm5pbmcgdGhlXG4vLyByZXN1bHRzIGRpcmVjdGx5IGludG8gdGhlIGNhbGxiYWNrLlxuLy9cbi8vIFRoZSBpbmRleCBpcyBzcGVjaWZpYyB0byB0aGUgc291cmNlLCBidXQgaWYgeW91J3JlIHVzaW5nIG1vbmdvZGIgaXQnbGwgYmVcbi8vIHRoZSBjb2xsZWN0aW9uIHRvIHdoaWNoIHRoZSBxdWVyeSBpcyBtYWRlLlxuLy8gVGhlIGNhbGxiYWNrIHNob3VsZCBoYXZlIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIGV4dHJhRGF0YSlcbi8vIHdoZXJlIHJlc3VsdHMgaXMgYSBsaXN0IG9mIERvYyBvYmplY3RzLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRmV0Y2hRdWVyeSA9IGZ1bmN0aW9uKGluZGV4LCBxLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlUXVlcnkoJ2ZldGNoJywgaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8vIENyZWF0ZSBhIHN1YnNjcmliZSBxdWVyeS4gU3Vic2NyaWJlIHF1ZXJpZXMgcmV0dXJuIHdpdGggdGhlIGluaXRpYWwgZGF0YVxuLy8gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHRoZW4gdXBkYXRlIHRoZW1zZWx2ZXMgd2hlbmV2ZXIgdGhlIHF1ZXJ5IHJlc3VsdCBzZXRcbi8vIGNoYW5nZXMgdmlhIHRoZWlyIG93biBldmVudCBlbWl0dGVyLlxuLy9cbi8vIElmIHByZXNlbnQsIHRoZSBjYWxsYmFjayBzaG91bGQgaGF2ZSB0aGUgc2lnbmF0dXJlIGZ1bmN0aW9uKGVycm9yLCByZXN1bHRzLCBleHRyYURhdGEpXG4vLyB3aGVyZSByZXN1bHRzIGlzIGEgbGlzdCBvZiBEb2Mgb2JqZWN0cy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmliZVF1ZXJ5ID0gZnVuY3Rpb24oaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVRdWVyeSgnc3ViJywgaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbmlmICh0eXBlb2YgYnJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIE1pY3JvRXZlbnQgPSBicmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59XG5cbk1pY3JvRXZlbnQubWl4aW4oQ29ubmVjdGlvbik7XG5cbi8qIFRoaXMgY29udGFpbnMgdGhlIHRleHRhcmVhIGJpbmRpbmcgZm9yIFNoYXJlSlMuIFRoaXMgYmluZGluZyBpcyByZWFsbHlcbiAqIHNpbXBsZSwgYW5kIGEgYml0IHNsb3cgb24gYmlnIGRvY3VtZW50cyAoSXRzIE8oTikuIEhvd2V2ZXIsIGl0IGJyZXF1aXJlcyBub1xuICogY2hhbmdlcyB0byB0aGUgRE9NIGFuZCBubyBoZWF2eSBsaWJyYXJpZXMgbGlrZSBhY2UuIEl0IHdvcmtzIGZvciBhbnkga2luZCBvZlxuICogdGV4dCBpbnB1dCBmaWVsZC5cbiAqXG4gKiBZb3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhpcyBiaW5kaW5nIGZvciBzbWFsbCBmaWVsZHMgb24gZm9ybXMgYW5kIHN1Y2guXG4gKiBGb3IgY29kZSBlZGl0b3JzIG9yIHJpY2ggdGV4dCBlZGl0b3JzIG9yIHdoYXRldmVyLCBJIHJlY29tbWVuZCBzb21ldGhpbmdcbiAqIGhlYXZpZXIuXG4gKi9cblxuXG4vKiBhcHBseUNoYW5nZSBjcmVhdGVzIHRoZSBlZGl0cyB0byBjb252ZXJ0IG9sZHZhbCAtPiBuZXd2YWwuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHRleHQgZWxlbWVudCBpcyBjaGFuZ2VkLlxuICogQmVjYXVzZSBjaGFuZ2VzIGFyZSBhbHdheXMgbG9jYWxpc2VkLCB0aGUgZGlmZmluZyBpcyBxdWl0ZSBlYXN5LiBXZSBzaW1wbHlcbiAqIHNjYW4gaW4gZnJvbSB0aGUgc3RhcnQgYW5kIHNjYW4gaW4gZnJvbSB0aGUgZW5kIHRvIGlzb2xhdGUgdGhlIGVkaXRlZCByYW5nZSxcbiAqIHRoZW4gZGVsZXRlIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgcmVtb3ZlZCAmIGFkZCBldmVyeXRoaW5nIHRoYXQgd2FzIGFkZGVkLlxuICogVGhpcyB3b3VsZG4ndCB3b3JrIGZvciBjb21wbGV4IGNoYW5nZXMsIGJ1dCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWRcbiAqIG9uIGtleXN0cm9rZSAtIHNvIHRoZSBlZGl0cyB3aWxsIG1vc3RseSBqdXN0IGJlIHNpbmdsZSBjaGFyYWN0ZXIgY2hhbmdlcy5cbiAqIFNvbWV0aW1lcyB0aGV5J2xsIHBhc3RlIHRleHQgb3ZlciBvdGhlciB0ZXh0LCBidXQgZXZlbiB0aGVuIHRoZSBkaWZmXG4gKiBnZW5lcmF0ZWQgYnkgdGhpcyBhbGdvcml0aG0gaXMgY29ycmVjdC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyBPKE4pLiBJIHN1c3BlY3QgeW91IGNvdWxkIHNwZWVkIGl0IHVwIHNvbWVob3cgdXNpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xudmFyIGFwcGx5Q2hhbmdlID0gZnVuY3Rpb24oY3R4LCBvbGR2YWwsIG5ld3ZhbCkge1xuICAvLyBTdHJpbmdzIGFyZSBpbW11dGFibGUgYW5kIGhhdmUgcmVmZXJlbmNlIGVxdWFsaXR5LiBJIHRoaW5rIHRoaXMgdGVzdCBpcyBPKDEpLCBzbyBpdHMgd29ydGggZG9pbmcuXG4gIGlmIChvbGR2YWwgPT09IG5ld3ZhbCkgcmV0dXJuO1xuXG4gIHZhciBjb21tb25TdGFydCA9IDA7XG4gIHdoaWxlIChvbGR2YWwuY2hhckF0KGNvbW1vblN0YXJ0KSA9PT0gbmV3dmFsLmNoYXJBdChjb21tb25TdGFydCkpIHtcbiAgICBjb21tb25TdGFydCsrO1xuICB9XG5cbiAgdmFyIGNvbW1vbkVuZCA9IDA7XG4gIHdoaWxlIChvbGR2YWwuY2hhckF0KG9sZHZhbC5sZW5ndGggLSAxIC0gY29tbW9uRW5kKSA9PT0gbmV3dmFsLmNoYXJBdChuZXd2YWwubGVuZ3RoIC0gMSAtIGNvbW1vbkVuZCkgJiZcbiAgICAgIGNvbW1vbkVuZCArIGNvbW1vblN0YXJ0IDwgb2xkdmFsLmxlbmd0aCAmJiBjb21tb25FbmQgKyBjb21tb25TdGFydCA8IG5ld3ZhbC5sZW5ndGgpIHtcbiAgICBjb21tb25FbmQrKztcbiAgfVxuXG4gIGlmIChvbGR2YWwubGVuZ3RoICE9PSBjb21tb25TdGFydCArIGNvbW1vbkVuZCkge1xuICAgIGN0eC5yZW1vdmUoY29tbW9uU3RhcnQsIG9sZHZhbC5sZW5ndGggLSBjb21tb25TdGFydCAtIGNvbW1vbkVuZCk7XG4gIH1cbiAgaWYgKG5ld3ZhbC5sZW5ndGggIT09IGNvbW1vblN0YXJ0ICsgY29tbW9uRW5kKSB7XG4gICAgY3R4Lmluc2VydChjb21tb25TdGFydCwgbmV3dmFsLnNsaWNlKGNvbW1vblN0YXJ0LCBuZXd2YWwubGVuZ3RoIC0gY29tbW9uRW5kKSk7XG4gIH1cbn07XG5cbi8vIEF0dGFjaCBhIHRleHRhcmVhIHRvIGEgZG9jdW1lbnQncyBlZGl0aW5nIGNvbnRleHQuXG4vL1xuLy8gVGhlIGNvbnRleHQgaXMgb3B0aW9uYWwsIGFuZCB3aWxsIGJlIGNyZWF0ZWQgZnJvbSB0aGUgZG9jdW1lbnQgaWYgaXRzIG5vdFxuLy8gc3BlY2lmaWVkLlxud2luZG93LnNoYXJlanMuRG9jLnByb3RvdHlwZS5hdHRhY2hUZXh0YXJlYSA9IGZ1bmN0aW9uKGVsZW0sIGN0eCkge1xuICBpZiAoIWN0eCkgY3R4ID0gdGhpcy5jcmVhdGVDb250ZXh0KCk7XG5cbiAgaWYgKCFjdHgucHJvdmlkZXMudGV4dCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXR0YWNoIHRvIG5vbi10ZXh0IGRvY3VtZW50Jyk7XG5cbiAgZWxlbS52YWx1ZSA9IGN0eC5nZXRUZXh0KCk7XG5cbiAgLy8gVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyB0ZXh0IGlzIHN0b3JlZCBzbyB3ZSBjYW4gcXVpY2tseSBjaGVja1xuICAvLyBpZiBpdHMgYmVlbiBjaGFuZ2VkIGluIHRoZSBldmVudCBoYW5kbGVycy4gVGhpcyBpcyBtb3N0bHkgZm9yIGJyb3dzZXJzIG9uXG4gIC8vIHdpbmRvd3MsIHdoZXJlIHRoZSBjb250ZW50IGNvbnRhaW5zIFxcclxcbiBuZXdsaW5lcy4gYXBwbHlDaGFuZ2UoKSBpcyBvbmx5XG4gIC8vIGNhbGxlZCBhZnRlciB0aGUgXFxyXFxuIG5ld2xpbmVzIGFyZSBjb252ZXJ0ZWQsIGFuZCB0aGF0IGNoZWNrIGlzIHF1aXRlXG4gIC8vIHNsb3cuIFNvIHdlIGFsc28gY2FjaGUgdGhlIHN0cmluZyBiZWZvcmUgY29udmVyc2lvbiBzbyB3ZSBjYW4gZG8gYSBxdWlja1xuICAvLyBjaGVjayBpbmNhc2UgdGhlIGNvbnZlcnNpb24gaXNuJ3QgbmVlZGVkLlxuICB2YXIgcHJldnZhbHVlO1xuXG4gIC8vIFJlcGxhY2UgdGhlIGNvbnRlbnQgb2YgdGhlIHRleHQgYXJlYSB3aXRoIG5ld1RleHQsIGFuZCB0cmFuc2Zvcm0gdGhlXG4gIC8vIGN1cnJlbnQgY3Vyc29yIGJ5IHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gIHZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uKG5ld1RleHQsIHRyYW5zZm9ybUN1cnNvcikge1xuICAgIGlmICh0cmFuc2Zvcm1DdXJzb3IpIHtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBbdHJhbnNmb3JtQ3Vyc29yKGVsZW0uc2VsZWN0aW9uU3RhcnQpLCB0cmFuc2Zvcm1DdXJzb3IoZWxlbS5zZWxlY3Rpb25FbmQpXTtcbiAgICB9XG5cbiAgICAvLyBGaXhhdGUgdGhlIHdpbmRvdydzIHNjcm9sbCB3aGlsZSB3ZSBzZXQgdGhlIGVsZW1lbnQncyB2YWx1ZS4gT3RoZXJ3aXNlXG4gICAgLy8gdGhlIGJyb3dzZXIgc2Nyb2xscyB0byB0aGUgZWxlbWVudC5cbiAgICB2YXIgc2Nyb2xsVG9wID0gZWxlbS5zY3JvbGxUb3A7XG4gICAgZWxlbS52YWx1ZSA9IG5ld1RleHQ7XG4gICAgcHJldnZhbHVlID0gZWxlbS52YWx1ZTsgLy8gTm90IGRvbmUgb24gb25lIGxpbmUgc28gdGhlIGJyb3dzZXIgY2FuIGRvIG5ld2xpbmUgY29udmVyc2lvbi5cbiAgICBpZiAoZWxlbS5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcCkgZWxlbS5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG5cbiAgICAvLyBTZXR0aW5nIHRoZSBzZWxlY3Rpb24gbW92ZXMgdGhlIGN1cnNvci4gV2UnbGwganVzdCBoYXZlIHRvIGxldCB5b3VyXG4gICAgLy8gY3Vyc29yIGRyaWZ0IGlmIHRoZSBlbGVtZW50IGlzbid0IGFjdGl2ZSwgdGhvdWdoIHVzdWFsbHkgdXNlcnMgZG9uJ3RcbiAgICAvLyBjYXJlLlxuICAgIGlmIChuZXdTZWxlY3Rpb24gJiYgd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW0pIHtcbiAgICAgIGVsZW0uc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25bMF07XG4gICAgICBlbGVtLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvblsxXTtcbiAgICB9XG4gIH07XG5cbiAgcmVwbGFjZVRleHQoY3R4LmdldFRleHQoKSk7XG5cblxuICAvLyAqKiogcmVtb3RlIC0+IGxvY2FsIGNoYW5nZXNcblxuICBjdHgub25JbnNlcnQgPSBmdW5jdGlvbihwb3MsIHRleHQpIHtcbiAgICB2YXIgdHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgICByZXR1cm4gcG9zIDwgY3Vyc29yID8gY3Vyc29yICsgdGV4dC5sZW5ndGggOiBjdXJzb3I7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBhbnkgd2luZG93LXN0eWxlIG5ld2xpbmUgY2hhcmFjdGVycy4gV2luZG93cyBpbnNlcnRzIHRoZXNlLCBhbmRcbiAgICAvLyB0aGV5IG1lc3MgdXAgdGhlIGdlbmVyYXRlZCBkaWZmLlxuICAgIHZhciBwcmV2ID0gZWxlbS52YWx1ZS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgIHJlcGxhY2VUZXh0KHByZXYuc2xpY2UoMCwgcG9zKSArIHRleHQgKyBwcmV2LnNsaWNlKHBvcyksIHRyYW5zZm9ybUN1cnNvcik7XG4gIH07XG5cbiAgY3R4Lm9uUmVtb3ZlID0gZnVuY3Rpb24ocG9zLCBsZW5ndGgpIHtcbiAgICB2YXIgdHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yKSB7XG4gICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGluc2lkZSB0aGUgZGVsZXRlZCByZWdpb24sIHdlIG9ubHkgd2FudCB0byBtb3ZlIGJhY2sgdG8gdGhlIHN0YXJ0XG4gICAgICAvLyBvZiB0aGUgcmVnaW9uLiBIZW5jZSB0aGUgTWF0aC5taW4uXG4gICAgICByZXR1cm4gcG9zIDwgY3Vyc29yID8gY3Vyc29yIC0gTWF0aC5taW4obGVuZ3RoLCBjdXJzb3IgLSBwb3MpIDogY3Vyc29yO1xuICAgIH07XG5cbiAgICB2YXIgcHJldiA9IGVsZW0udmFsdWUucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbiAgICByZXBsYWNlVGV4dChwcmV2LnNsaWNlKDAsIHBvcykgKyBwcmV2LnNsaWNlKHBvcyArIGxlbmd0aCksIHRyYW5zZm9ybUN1cnNvcik7XG4gIH07XG5cblxuICAvLyAqKiogbG9jYWwgLT4gcmVtb3RlIGNoYW5nZXNcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBvcGVyYXRpb25zIGZyb20gdGhlIGNoYW5nZWQgY29udGVudCBpbiB0aGUgdGV4dGFyZWEuXG4gIHZhciBnZW5PcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gSW4gYSB0aW1lb3V0IHNvIHRoZSBicm93c2VyIGhhcyB0aW1lIHRvIHByb3BvZ2F0ZSB0aGUgZXZlbnQncyBjaGFuZ2VzIHRvIHRoZSBET00uXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChlbGVtLnZhbHVlICE9PSBwcmV2dmFsdWUpIHtcbiAgICAgICAgcHJldnZhbHVlID0gZWxlbS52YWx1ZTtcbiAgICAgICAgYXBwbHlDaGFuZ2UoY3R4LCBjdHguZ2V0VGV4dCgpLCBlbGVtLnZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuXG4gIHZhciBldmVudE5hbWVzID0gWyd0ZXh0SW5wdXQnLCAna2V5ZG93bicsICdrZXl1cCcsICdzZWxlY3QnLCAnY3V0JywgJ3Bhc3RlJ107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZXZlbnROYW1lc1tpXTtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZSwgZ2VuT3AsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZSwgZ2VuT3ApO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5kZXRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlID0gZXZlbnROYW1lc1tpXTtcbiAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGdlbk9wLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBlLCBnZW5PcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuXG52YXIgRG9jO1xuaWYgKHR5cGVvZiBicmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgRG9jID0gYnJlcXVpcmUoJy4vZG9jJykuRG9jO1xufVxuXG4vLyBRdWVyaWVzIGFyZSBsaXZlIHJlcXVlc3RzIHRvIHRoZSBkYXRhYmFzZSBmb3IgcGFydGljdWxhciBzZXRzIG9mIGZpZWxkcy5cbi8vXG4vLyBUaGUgc2VydmVyIGFjdGl2ZWx5IHRlbGxzIHRoZSBjbGllbnQgd2hlbiB0aGVyZSdzIG5ldyBkYXRhIHRoYXQgbWF0Y2hlc1xuLy8gYSBzZXQgb2YgY29uZGl0aW9ucy5cbnZhciBRdWVyeSA9IGV4cG9ydHMuUXVlcnkgPSBmdW5jdGlvbih0eXBlLCBjb25uZWN0aW9uLCBpZCwgY29sbGVjdGlvbiwgcXVlcnksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vICdmZXRjaCcgb3IgJ3N1YidcbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgLy8gVGhlIHF1ZXJ5IGl0c2VsZi4gRm9yIG1vbmdvLCB0aGlzIHNob3VsZCBsb29rIHNvbWV0aGluZyBsaWtlIHtcImRhdGEueFwiOjV9XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcblxuICAvLyBSZXN1bHRhbnQgZG9jdW1lbnQgYWN0aW9uIGZvciB0aGUgc2VydmVyLiBGZXRjaCBtb2RlIHdpbGwgYXV0b21hdGljYWxseVxuICAvLyBmZXRjaCBhbGwgcmVzdWx0cy4gU3Vic2NyaWJlIG1vZGUgd2lsbCBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZSBhbGxcbiAgLy8gcmVzdWx0cy4gUmVzdWx0cyBhcmUgbmV2ZXIgdW5zdWJzY3JpYmVkLlxuICB0aGlzLmRvY01vZGUgPSBvcHRpb25zLmRvY01vZGU7IC8vIHVuZGVmaW5lZCwgJ2ZldGNoJyBvciAnc3ViJy5cbiAgaWYgKHRoaXMuZG9jTW9kZSA9PT0gJ3N1YnNjcmliZScpIHRoaXMuZG9jTW9kZSA9ICdzdWInO1xuXG4gIC8vIERvIHdlIHJlcG9sbCB0aGUgZW50aXJlIHF1ZXJ5IHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXM/IChBcyBvcHBvc2VkIHRvXG4gIC8vIGp1c3QgcG9sbGluZyB0aGUgY2hhbmdlZCBpdGVtKS4gVGhpcyBuZWVkcyB0byBiZSBlbmFibGVkIHRvIGJlIGFibGUgdG8gdXNlXG4gIC8vIG9yZGVyZWQgcXVlcmllcyAoc29ydGJ5OikgYW5kIHBhZ2luYXRlZCBxdWVyaWVzLiBTZXQgdG8gdW5kZWZpbmVkLCBpdCB3aWxsXG4gIC8vIGJlIGVuYWJsZWQgLyBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBxdWVyeSdzIHByb3BlcnRpZXMuXG4gIHRoaXMucG9sbCA9IG9wdGlvbnMucG9sbDtcblxuICAvLyBUaGUgYmFja2VuZCB3ZSBhY3R1YWxseSBoaXQuIElmIHRoaXMgaXNuJ3QgZGVmaW5lZCwgaXQgaGl0cyB0aGUgc25hcHNob3RcbiAgLy8gZGF0YWJhc2UuIE90aGVyd2lzZSB0aGlzIGNhbiBiZSB1c2VkIHRvIGhpdCBhbm90aGVyIGNvbmZpZ3VyZWQgcXVlcnlcbiAgLy8gaW5kZXguXG4gIHRoaXMuYmFja2VuZCA9IG9wdGlvbnMuYmFja2VuZCB8fCBvcHRpb25zLnNvdXJjZTtcblxuICAvLyBBIGxpc3Qgb2YgcmVzdWx0aW5nIGRvY3VtZW50cy4gVGhlc2UgYXJlIGFjdHVhbCBkb2N1bWVudHMsIGNvbXBsZXRlIHdpdGhcbiAgLy8gZGF0YSBhbmQgYWxsIHRoZSByZXN0LiBJZiBmZXRjaCBpcyBmYWxzZSwgdGhlc2UgZG9jdW1lbnRzIHdpbGwgbm90XG4gIC8vIGhhdmUgYW55IGRhdGEuIFlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCBmZXRjaCgpIG9yIHN1YnNjcmliZSgpIG9uIHRoZW0uXG4gIC8vXG4gIC8vIENhbGxpbmcgc3Vic2NyaWJlKCkgbWlnaHQgYmUgYSBnb29kIGlkZWEgYW55d2F5LCBhcyB5b3Ugd29uJ3QgYmVcbiAgLy8gc3Vic2NyaWJlZCB0byB0aGUgZG9jdW1lbnRzIGJ5IGRlZmF1bHQuXG4gIHRoaXMua25vd25Eb2NzID0gb3B0aW9ucy5rbm93bkRvY3MgfHwgW107XG4gIHRoaXMucmVzdWx0cyA9IFtdO1xuXG4gIC8vIERvIHdlIGhhdmUgc29tZSBpbml0aWFsIGRhdGE/XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcblxuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG59O1xuUXVlcnkucHJvdG90eXBlLmFjdGlvbiA9ICdxc3ViJztcblxuLy8gSGVscGVyIGZvciBzdWJzY3JpYmUgJiBmZXRjaCwgc2luY2UgdGhleSBzaGFyZSB0aGUgc2FtZSBtZXNzYWdlIGZvcm1hdC5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGFjdHVhbGx5IGlzc3VlcyB0aGUgcXVlcnkuXG5RdWVyeS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCkgcmV0dXJuO1xuXG4gIGlmICh0aGlzLmRvY01vZGUpIHtcbiAgICB2YXIgY29sbGVjdGlvblZlcnNpb25zID0ge307XG4gICAgLy8gQ29sbGVjdCB0aGUgdmVyc2lvbiBvZiBhbGwgdGhlIGRvY3VtZW50cyBpbiB0aGUgY3VycmVudCByZXN1bHQgc2V0IHNvIHdlXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBiZSBzZW50IHRoZWlyIHNuYXBzaG90cyBhZ2Fpbi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua25vd25Eb2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5rbm93bkRvY3NbaV07XG4gICAgICB2YXIgYyA9IGNvbGxlY3Rpb25WZXJzaW9uc1tkb2MuY29sbGVjdGlvbl0gPSBjb2xsZWN0aW9uVmVyc2lvbnNbZG9jLmNvbGxlY3Rpb25dIHx8IHt9O1xuICAgICAgY1tkb2MubmFtZV0gPSBkb2MudmVyc2lvbjtcbiAgICB9XG4gIH1cblxuICB2YXIgbXNnID0ge1xuICAgIGE6ICdxJyArIHRoaXMudHlwZSxcbiAgICBpZDogdGhpcy5pZCxcbiAgICBjOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgbzoge30sXG4gICAgcTogdGhpcy5xdWVyeSxcbiAgfTtcblxuICBpZiAodGhpcy5kb2NNb2RlKSB7XG4gICAgbXNnLm8ubSA9IHRoaXMuZG9jTW9kZTtcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvbWl0dGVkIGlmIGVtcHR5LCBidXQgd2hhdGV2ZXIuXG4gICAgbXNnLm8udnMgPSBjb2xsZWN0aW9uVmVyc2lvbnM7XG4gIH1cbiAgaWYgKHRoaXMuYmFja2VuZCAhPSBudWxsKSBtc2cuby5iID0gdGhpcy5iYWNrZW5kO1xuICBpZiAodGhpcy5wb2xsICE9PSB1bmRlZmluZWQpIG1zZy5vLnAgPSB0aGlzLnBvbGw7XG5cbiAgdGhpcy5jb25uZWN0aW9uLnNlbmQobXNnKTtcbn07XG5cbi8vIE1ha2UgYSBsaXN0IG9mIGRvY3VtZW50cyBmcm9tIHRoZSBsaXN0IG9mIHNlcnZlci1yZXR1cm5lZCBkYXRhIG9iamVjdHNcblF1ZXJ5LnByb3RvdHlwZS5fZGF0YVRvRG9jcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIGxhc3RUeXBlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZG9jRGF0YSA9IGRhdGFbaV07XG5cbiAgICAvLyBUeXBlcyBhcmUgb25seSBwdXQgaW4gZm9yIHRoZSBmaXJzdCByZXN1bHQgaW4gdGhlIHNldCBhbmQgZXZlcnkgdGltZSB0aGUgdHlwZSBjaGFuZ2VzIGluIHRoZSBsaXN0LlxuICAgIGlmIChkb2NEYXRhLnR5cGUpIHtcbiAgICAgIGxhc3RUeXBlID0gZG9jRGF0YS50eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2NEYXRhLnR5cGUgPSBsYXN0VHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGhpcy5jb25uZWN0aW9uLmdldChkb2NEYXRhLmMgfHwgdGhpcy5jb2xsZWN0aW9uLCBkb2NEYXRhLmQsIGRvY0RhdGEpO1xuICAgIC8vIEZvcmNlIHRoZSBkb2N1bWVudCB0byBrbm93IGl0cyBzdWJzY3JpYmVkIGlmIHdlJ3JlIGluIGRvY21vZGU6c3Vic2NyaWJlLlxuICAgIGlmICh0aGlzLmRvY01vZGUgPT09ICdzdWInKSB7XG4gICAgICBkb2Muc3Vic2NyaWJlZCA9IHRydWU7IC8vIFNldCBiZWZvcmUgc2V0V2FudFN1YnNjcmliZSgpIHNvIGZsdXNoIGRvZXNuJ3Qgc2VuZCBhIHN1YnNjcmliZSByZXF1ZXN0LlxuICAgICAgZG9jLl9zZXRXYW50U3Vic2NyaWJlKHRydWUpOyAvLyB0aGlzIHdpbGwgY2FsbCBhbnkgc3Vic2NyaWJlIGNhbGxiYWNrcyBvciB3aGF0ZXZlci5cbiAgICAgIGRvYy5lbWl0KCdzdWJzY3JpYmUnKTtcbiAgICAgIGRvYy5fZmluaXNoU3ViKHRydWUpOyAvLyB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgZG8gYW55dGhpbmcgaGVyZSwgYnV0IGl0cyBtb3JlIGNvcnJlY3QgdG8gaGF2ZSBpdC5cbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBEZXN0cm95IHRoZSBxdWVyeSBvYmplY3QuIEFueSBzdWJzZXF1ZW50IG1lc3NhZ2VzIGZvciB0aGUgcXVlcnkgd2lsbCBiZVxuLy8gaWdub3JlZCBieSB0aGUgY29ubmVjdGlvbi4gWW91IHNob3VsZCB1bnN1YnNjcmliZSBmcm9tIHRoZSBxdWVyeSBiZWZvcmVcbi8vIGRlc3Ryb3lpbmcgaXQuXG5RdWVyeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb25uZWN0aW9uLmNhblNlbmQgJiYgdGhpcy50eXBlID09PSAnc3ViJykge1xuICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKHthOidxdW5zdWInLCBpZDp0aGlzLmlkfSk7XG4gIH1cblxuICB0aGlzLmNvbm5lY3Rpb24uX2Rlc3Ryb3lRdWVyeSh0aGlzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuICBpZiAodGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICB0aGlzLl9leGVjdXRlKCk7XG4gIH1cbn07XG5cbi8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZnJvbSBjb25uZWN0aW9uIHRvIHBhc3Mgc2VydmVyIG1lc3NhZ2VzIHRvIHRoZSBxdWVyeS5cblF1ZXJ5LnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICgobXNnLmEgPT09ICdxZmV0Y2gnKSAhPT0gKHRoaXMudHlwZSA9PT0gJ2ZldGNoJykpIHtcbiAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdJbnZhbGlkIG1lc3NhZ2Ugc2VudCB0byBxdWVyeScsIG1zZywgdGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG1zZy5lcnJvcikgdGhpcy5lbWl0KCdlcnJvcicsIG1zZy5lcnJvcik7XG5cbiAgc3dpdGNoIChtc2cuYSkge1xuICAgIGNhc2UgJ3FmZXRjaCc6XG4gICAgICB2YXIgcmVzdWx0cyA9IG1zZy5kYXRhID8gdGhpcy5fZGF0YVRvRG9jcyhtc2cuZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5jYWxsYmFjaykgdGhpcy5jYWxsYmFjayhtc2cuZXJyb3IsIHJlc3VsdHMsIG1zZy5leHRyYSk7XG4gICAgICAvLyBPbmNlIGEgZmV0Y2ggcXVlcnkgZ2V0cyBpdHMgZGF0YSwgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgdGhpcy5jb25uZWN0aW9uLl9kZXN0cm95UXVlcnkodGhpcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3EnOlxuICAgICAgLy8gUXVlcnkgZGlmZiBkYXRhIChpbnNlcnRzIGFuZCByZW1vdmVzKVxuICAgICAgaWYgKG1zZy5kaWZmKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgbGlzdCB0d2ljZS4gRmlyc3QsIHdlJ2xsIGluamVzdCBhbGwgdGhlXG4gICAgICAgIC8vIG5ldyBkb2N1bWVudHMgYW5kIHNldCB0aGVtIGFzIHN1YnNjcmliZWQuICBBZnRlciB0aGF0IHdlJ2xsIGVtaXRcbiAgICAgICAgLy8gZXZlbnRzIGFuZCBhY3R1YWxseSB1cGRhdGUgb3VyIGxpc3QuIFRoaXMgYXZvaWRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAvLyBhcm91bmQgc2V0dGluZyBkb2N1bWVudHMgdG8gYmUgc3Vic2NyaWJlZCAmIHVuc3Vic2NyaWJpbmcgZG9jdW1lbnRzXG4gICAgICAgIC8vIGluIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cuZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkID0gbXNnLmRpZmZbaV07XG4gICAgICAgICAgaWYgKGQudHlwZSA9PT0gJ2luc2VydCcpIGQudmFsdWVzID0gdGhpcy5fZGF0YVRvRG9jcyhkLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5kaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGQgPSBtc2cuZGlmZltpXTtcbiAgICAgICAgICBzd2l0Y2ggKGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgdmFyIG5ld0RvY3MgPSBkLnZhbHVlcztcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLnJlc3VsdHMsIFtkLmluZGV4LCAwXS5jb25jYXQobmV3RG9jcykpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2luc2VydCcsIG5ld0RvY3MsIGQuaW5kZXgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgIHZhciBob3dNYW55ID0gZC5ob3dNYW55IHx8IDE7XG4gICAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yZXN1bHRzLnNwbGljZShkLmluZGV4LCBob3dNYW55KTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmUnLCByZW1vdmVkLCBkLmluZGV4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBkLmhvd01hbnkgfHwgMTtcbiAgICAgICAgICAgICAgdmFyIGRvY3MgPSB0aGlzLnJlc3VsdHMuc3BsaWNlKGQuZnJvbSwgaG93TWFueSk7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5yZXN1bHRzLCBbZC50bywgMF0uY29uY2F0KGRvY3MpKTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtb3ZlJywgZG9jcywgZC5mcm9tLCBkLnRvKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cuZXh0cmEpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdleHRyYScsIG1zZy5leHRyYSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdxc3ViJzpcbiAgICAgIC8vIFRoaXMgbWVzc2FnZSByZXBsYWNlcyB0aGUgZW50aXJlIHJlc3VsdCBzZXQgd2l0aCB0aGUgc2V0IHBhc3NlZC5cbiAgICAgIGlmICghbXNnLmVycm9yKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMucmVzdWx0cztcblxuICAgICAgICAvLyBUaGVuIGFkZCBldmVyeXRoaW5nIGluIHRoZSBuZXcgcmVzdWx0IHNldC5cbiAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5rbm93bkRvY3MgPSB0aGlzLl9kYXRhVG9Eb2NzKG1zZy5kYXRhKTtcbiAgICAgICAgdGhpcy5leHRyYSA9IG1zZy5leHRyYTtcblxuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB0aGlzLnJlc3VsdHMsIHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sobXNnLmVycm9yLCB0aGlzLnJlc3VsdHMsIHRoaXMuZXh0cmEpO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaGFuZ2UgdGhlIHRoaW5nIHdlJ3JlIHNlYXJjaGluZyBmb3IuIFRoaXMgaXNuJ3QgZnVsbHkgc3VwcG9ydGVkIG9uIHRoZVxuLy8gYmFja2VuZCAoaXQgZGVzdHJveXMgdGhlIG9sZCBxdWVyeSBhbmQgbWFrZXMgYSBuZXcgb25lKSAtIGJ1dCBpdHNcbi8vIHByb2dyYW1hdGljYWxseSB1c2VmdWwgYW5kIEkgbWlnaHQgYWRkIGJhY2tlbmQgc3VwcG9ydCBhdCBzb21lIHBvaW50LlxuUXVlcnkucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24ocSkge1xuICBpZiAodGhpcy50eXBlICE9PSAnc3ViJykgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2hhbmdlIGEgZmV0Y2ggcXVlcnknKTtcblxuICB0aGlzLnF1ZXJ5ID0gcTtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5jYW5TZW5kKSB7XG4gICAgLy8gVGhlcmUncyBubyAnY2hhbmdlJyBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gSnVzdCByZXN1YnNjcmliZS5cbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZCh7YToncXVuc3ViJywgaWQ6dGhpcy5pZH0pO1xuICAgIHRoaXMuX2V4ZWN1dGUoKTtcbiAgfVxufTtcblxudmFyIE1pY3JvRXZlbnQ7XG5pZiAodHlwZW9mIGJyZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBNaWNyb0V2ZW50ID0gYnJlcXVpcmUoJy4vbWljcm9ldmVudCcpO1xufVxuXG5NaWNyb0V2ZW50Lm1peGluKFF1ZXJ5KTtcblxufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuaWQobGVuLCBwcmVmaXgsIGtleXNwYWNlKSB7XHJcbiAgaWYgKGxlbiA9PSBudWxsKSB7XHJcbiAgICBsZW4gPSAzMjtcclxuICB9XHJcbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XHJcbiAgICBwcmVmaXggPSBcIlwiO1xyXG4gIH1cclxuICBpZiAoa2V5c3BhY2UgPT0gbnVsbCkge1xyXG4gICAga2V5c3BhY2UgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XHJcbiAgfVxyXG4gIHdoaWxlIChsZW4tLSA+IDApIHtcclxuICAgIHByZWZpeCArPSBrZXlzcGFjZS5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICoga2V5c3BhY2UubGVuZ3RoKSk7XHJcbiAgfVxyXG4gIHJldHVybiBwcmVmaXg7XHJcbn07IiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjAuMCA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHA6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnbG9kYXNoLmlzZnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC5pc29iamVjdCcpLFxuICAgIHJlTmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9yZW5hdGl2ZScpO1xuXG4vKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xudmFyIHVuZGVmaW5lZDtcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzICovXG52YXIgbm93ID0gcmVOYXRpdmUudGVzdChub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gK25ldyBEYXRlOyB9O1xuXG4vKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuXG4gKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAqIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAqXG4gKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gKlxuICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSk7XG4gKlxuICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7XG4gKiAgICdtYXhXYWl0JzogMTAwMFxuICogfSwgZmFsc2UpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBhcmdzLFxuICAgICAgbWF4VGltZW91dElkLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhbXAsXG4gICAgICB0aGlzQXJnLFxuICAgICAgdGltZW91dElkLFxuICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgfVxuICB3YWl0ID0gbmF0aXZlTWF4KDAsIHdhaXQpIHx8IDA7XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAobmF0aXZlTWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzdGFtcCA9IG5vdygpO1xuICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgIH1cbiAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgIH1cbiAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuMC4wIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG52YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgU3RyaW5nKG9iamVjdFByb3RvLnZhbHVlT2YpXG4gICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvdmFsdWVPZnxmb3IgW15cXF1dKy9nLCAnLis/JykgKyAnJCdcbik7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVOYXRpdmU7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuMC4wIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RzXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMi4wLjAgPGh0dHA6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgb2JqZWN0VHlwZXMgPSByZXF1aXJlKCdsb2Rhc2guX29iamVjdHR5cGVzJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RzXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgdGhlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3RcbiAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMi4wLjAgPGh0dHA6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIE9iamVjdCAqL1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAnYm9vbGVhbic6IGZhbHNlLFxuICAnZnVuY3Rpb24nOiB0cnVlLFxuICAnb2JqZWN0JzogdHJ1ZSxcbiAgJ251bWJlcic6IGZhbHNlLFxuICAnc3RyaW5nJzogZmFsc2UsXG4gICd1bmRlZmluZWQnOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUeXBlcztcbiIsIihmdW5jdGlvbigpe1xuKGZ1bmN0aW9uKCl7dmFyIHI9e2V4cG9ydHM6e319LGU9ci5leHBvcnRzO2UubmFtZT1cInRleHRcIixlLnVyaT1cImh0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0djFcIixlLmNyZWF0ZT1mdW5jdGlvbihyKXtpZihudWxsIT1yJiZcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBFcnJvcihcIkluaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nXCIpO3JldHVybiByfHxcIlwifTt2YXIgdD1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihyKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocil9LG49ZnVuY3Rpb24ocil7aWYoIXQocikpdGhyb3cgRXJyb3IoXCJPcCBtdXN0IGJlIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcIik7Zm9yKHZhciBlPW51bGwsbj0wO3IubGVuZ3RoPm47bisrKXt2YXIgbz1yW25dO3N3aXRjaCh0eXBlb2Ygbyl7Y2FzZVwib2JqZWN0XCI6aWYoIShcIm51bWJlclwiPT10eXBlb2Ygby5kJiZvLmQ+MCkpdGhyb3cgRXJyb3IoXCJPYmplY3QgY29tcG9uZW50cyBtdXN0IGJlIGRlbGV0ZXMgb2Ygc2l6ZSA+IDBcIik7YnJlYWs7Y2FzZVwic3RyaW5nXCI6aWYoIShvLmxlbmd0aD4wKSl0aHJvdyBFcnJvcihcIkluc2VydHMgY2Fubm90IGJlIGVtcHR5XCIpO2JyZWFrO2Nhc2VcIm51bWJlclwiOmlmKCEobz4wKSl0aHJvdyBFcnJvcihcIlNraXAgY29tcG9uZW50cyBtdXN0IGJlID4wXCIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IEVycm9yKFwiQWRqYWNlbnQgc2tpcCBjb21wb25lbnRzIHNob3VsZCBiZSBjb21iaW5lZFwiKX1lPW99aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpdGhyb3cgRXJyb3IoXCJPcCBoYXMgYSB0cmFpbGluZyBza2lwXCIpfSxvPWZ1bmN0aW9uKHIpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZSYmMCE9PWUuZD8wPT09ci5sZW5ndGg/ci5wdXNoKGUpOnR5cGVvZiBlPT10eXBlb2YgcltyLmxlbmd0aC0xXT9cIm9iamVjdFwiPT10eXBlb2YgZT9yW3IubGVuZ3RoLTFdLmQrPWUuZDpyW3IubGVuZ3RoLTFdKz1lOnIucHVzaChlKTp2b2lkIDB9fSxzPWZ1bmN0aW9uKHIpe3ZhciBlPTAsdD0wLG49ZnVuY3Rpb24obixvKXtpZihlPT09ci5sZW5ndGgpcmV0dXJuLTE9PT1uP251bGw6bjt2YXIgcyxpPXJbZV07cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGk/LTE9PT1ufHxuPj1pLXQ/KHM9aS10LCsrZSx0PTAscyk6KHQrPW4sbik6XCJzdHJpbmdcIj09dHlwZW9mIGk/LTE9PT1ufHxcImlcIj09PW98fG4+PWkubGVuZ3RoLXQ/KHM9aS5zbGljZSh0KSwrK2UsdD0wLHMpOihzPWkuc2xpY2UodCx0K24pLHQrPW4scyk6LTE9PT1ufHxcImRcIj09PW98fG4+PWkuZC10PyhzPXtkOmkuZC10fSwrK2UsdD0wLHMpOih0Kz1uLHtkOm59KX0sbz1mdW5jdGlvbigpe3JldHVybiByW2VdfTtyZXR1cm5bbixvXX0saT1mdW5jdGlvbihyKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2Ygcj9yOnIubGVuZ3RofHxyLmR9LGE9ZnVuY3Rpb24ocil7cmV0dXJuIHIubGVuZ3RoPjAmJlwibnVtYmVyXCI9PXR5cGVvZiByW3IubGVuZ3RoLTFdJiZyLnBvcCgpLHJ9O2Uubm9ybWFsaXplPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1bXSx0PW8oZSksbj0wO3IubGVuZ3RoPm47bisrKXQocltuXSk7cmV0dXJuIGEoZSl9LGUuYXBwbHk9ZnVuY3Rpb24ocixlKXtpZihcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBFcnJvcihcIlNuYXBzaG90IHNob3VsZCBiZSBhIHN0cmluZ1wiKTtuKGUpO2Zvcih2YXIgdD1bXSxvPTA7ZS5sZW5ndGg+bztvKyspe3ZhciBzPWVbb107c3dpdGNoKHR5cGVvZiBzKXtjYXNlXCJudW1iZXJcIjppZihzPnIubGVuZ3RoKXRocm93IEVycm9yKFwiVGhlIG9wIGlzIHRvbyBsb25nIGZvciB0aGlzIGRvY3VtZW50XCIpO3QucHVzaChyLnNsaWNlKDAscykpLHI9ci5zbGljZShzKTticmVhaztjYXNlXCJzdHJpbmdcIjp0LnB1c2gocyk7YnJlYWs7Y2FzZVwib2JqZWN0XCI6cj1yLnNsaWNlKHMuZCl9fXJldHVybiB0LmpvaW4oXCJcIikrcn0sZS50cmFuc2Zvcm09ZnVuY3Rpb24ocixlLHQpe2lmKFwibGVmdFwiIT10JiZcInJpZ2h0XCIhPXQpdGhyb3cgRXJyb3IoXCJzaWRlIChcIit0K1wiKSBtdXN0IGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO24ociksbihlKTtmb3IodmFyIGM9W10sZj1vKGMpLHU9cyhyKSxoPXVbMF0scD11WzFdLGI9MDtlLmxlbmd0aD5iO2IrKyl7dmFyIGwsZyxtPWVbYl07c3dpdGNoKHR5cGVvZiBtKXtjYXNlXCJudW1iZXJcIjpmb3IobD1tO2w+MDspZz1oKGwsXCJpXCIpLGYoZyksXCJzdHJpbmdcIiE9dHlwZW9mIGcmJihsLT1pKGcpKTticmVhaztjYXNlXCJzdHJpbmdcIjpcImxlZnRcIj09PXQmJlwic3RyaW5nXCI9PXR5cGVvZiBwKCkmJmYoaCgtMSkpLGYobS5sZW5ndGgpO2JyZWFrO2Nhc2VcIm9iamVjdFwiOmZvcihsPW0uZDtsPjA7KXN3aXRjaChnPWgobCxcImlcIiksdHlwZW9mIGcpe2Nhc2VcIm51bWJlclwiOmwtPWc7YnJlYWs7Y2FzZVwic3RyaW5nXCI6ZihnKTticmVhaztjYXNlXCJvYmplY3RcIjpsLT1nLmR9fX1mb3IoO209aCgtMSk7KWYobSk7cmV0dXJuIGEoYyl9LGUuY29tcG9zZT1mdW5jdGlvbihyLGUpe24ociksbihlKTtmb3IodmFyIHQ9W10sYz1vKHQpLGY9cyhyKVswXSx1PTA7ZS5sZW5ndGg+dTt1Kyspe3ZhciBoLHAsYj1lW3VdO3N3aXRjaCh0eXBlb2YgYil7Y2FzZVwibnVtYmVyXCI6Zm9yKGg9YjtoPjA7KXA9ZihoLFwiZFwiKSxjKHApLFwib2JqZWN0XCIhPXR5cGVvZiBwJiYoaC09aShwKSk7YnJlYWs7Y2FzZVwic3RyaW5nXCI6YyhiKTticmVhaztjYXNlXCJvYmplY3RcIjpmb3IoaD1iLmQ7aD4wOylzd2l0Y2gocD1mKGgsXCJkXCIpLHR5cGVvZiBwKXtjYXNlXCJudW1iZXJcIjpjKHtkOnB9KSxoLT1wO2JyZWFrO2Nhc2VcInN0cmluZ1wiOmgtPXAubGVuZ3RoO2JyZWFrO2Nhc2VcIm9iamVjdFwiOmMocCl9fX1mb3IoO2I9ZigtMSk7KWMoYik7cmV0dXJuIGEodCl9O3ZhciBjPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB0PTAsbj0wO2UubGVuZ3RoPm47bisrKXt2YXIgbz1lW25dO2lmKHQ+PXIpYnJlYWs7c3dpdGNoKHR5cGVvZiBvKXtjYXNlXCJudW1iZXJcIjppZih0K28+PXIpcmV0dXJuIHI7dCs9bzticmVhaztjYXNlXCJzdHJpbmdcIjp0Kz1vLmxlbmd0aCxyKz1vLmxlbmd0aDticmVhaztjYXNlXCJvYmplY3RcIjpyLT1NYXRoLm1pbihvLmQsci10KX19cmV0dXJuIHJ9O2UudHJhbnNmb3JtQ3Vyc29yPWZ1bmN0aW9uKHIsZSx0KXt2YXIgbj0wO2lmKHQpe2Zvcih2YXIgbz0wO2UubGVuZ3RoPm87bysrKXt2YXIgcz1lW29dO3N3aXRjaCh0eXBlb2Ygcyl7Y2FzZVwibnVtYmVyXCI6bis9czticmVhaztjYXNlXCJzdHJpbmdcIjpuKz1zLmxlbmd0aH19cmV0dXJuW24sbl19cmV0dXJuW2MoclswXSxlKSxjKHJbMV0sZSldfTt2YXIgZj13aW5kb3cub3R0eXBlcz13aW5kb3cub3R0eXBlc3x8e30sdT1yLmV4cG9ydHM7Zlt1Lm5hbWVdPXUsdS51cmkmJihmW3UudXJpXT11KX0pKCk7Ly8gVGV4dCBkb2N1bWVudCBBUEkgZm9yIHRoZSAndGV4dCcgdHlwZS5cblxuLy8gVGhlIEFQSSBpbXBsZW1lbnRzIHRoZSBzdGFuZGFyZCB0ZXh0IEFQSSBtZXRob2RzLiBJbiBwYXJ0aWN1bGFyOlxuLy9cbi8vIC0gZ2V0TGVuZ3RoKCkgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBpbiBjaGFyYWN0ZXJzXG4vLyAtIGdldFRleHQoKSByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBkb2N1bWVudFxuLy8gLSBpbnNlcnQocG9zLCB0ZXh0LCBbY2FsbGJhY2tdKSBpbnNlcnRzIHRleHQgYXQgcG9zaXRpb24gcG9zIGluIHRoZSBkb2N1bWVudFxuLy8gLSByZW1vdmUocG9zLCBsZW5ndGgsIFtjYWxsYmFja10pIHJlbW92ZXMgbGVuZ3RoIGNoYXJhY3RlcnMgYXQgcG9zaXRpb24gcG9zXG4vL1xuLy8gRXZlbnRzIGFyZSBpbXBsZW1lbnRlZCBieSBqdXN0IGFkZGluZyB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kcyB0byB5b3VyXG4vLyBjb250ZXh0IG9iamVjdC5cbi8vIG9uSW5zZXJ0KHBvcywgdGV4dCk6IENhbGxlZCB3aGVuIHRleHQgaXMgaW5zZXJ0ZWQuXG4vLyBvblJlbW92ZShwb3MsIGxlbmd0aCk6IENhbGxlZCB3aGVuIHRleHQgaXMgcmVtb3ZlZC5cblxudmFyIF90eXBlcyA9ICh0eXBlb2YgYnJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSA/XG4gIGJyZXF1aXJlKCdvdHR5cGVzJykgOiB3aW5kb3cub3R0eXBlcztcblxuX3R5cGVzWydodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dHYxJ10uYXBpID0ge1xuICBwcm92aWRlczoge3RleHQ6IHRydWV9LFxuICBcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZ1xuICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nZXRTbmFwc2hvdCgpLmxlbmd0aDsgfSxcblxuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50XG4gIGdldFRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nZXRTbmFwc2hvdCgpOyB9LFxuXG4gIC8vIEluc2VydCB0aGUgc3BlY2lmaWVkIHRleHQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuICBpbnNlcnQ6IGZ1bmN0aW9uKHBvcywgdGV4dCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5zdWJtaXRPcChbcG9zLCB0ZXh0XSwgY2FsbGJhY2spO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24ocG9zLCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VibWl0T3AoW3Bvcywge2Q6bGVuZ3RofV0sIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvLyBXaGVuIHlvdSB1c2UgdGhpcyBBUEksIHlvdSBzaG91bGQgaW1wbGVtZW50IHRoZXNlIHR3byBtZXRob2RzXG4gIC8vIGluIHlvdXIgZWRpdGluZyBjb250ZXh0LlxuICAvL29uSW5zZXJ0OiBmdW5jdGlvbihwb3MsIHRleHQpIHt9LFxuICAvL29uUmVtb3ZlOiBmdW5jdGlvbihwb3MsIHJlbW92ZWRMZW5ndGgpIHt9LFxuXG4gIF9vbk9wOiBmdW5jdGlvbihvcCkge1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBzcG9zID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gb3BbaV07XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBwb3MgKz0gY29tcG9uZW50O1xuICAgICAgICAgIHNwb3MgKz0gY29tcG9uZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGlmICh0aGlzLm9uSW5zZXJ0KSB0aGlzLm9uSW5zZXJ0KHBvcywgY29tcG9uZW50KTtcbiAgICAgICAgICBwb3MgKz0gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAodGhpcy5vblJlbW92ZSkgdGhpcy5vblJlbW92ZShwb3MsIGNvbXBvbmVudC5kKTtcbiAgICAgICAgICBzcG9zICs9IGNvbXBvbmVudC5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8vIFRoaXMgaXMgYSBwcmVsdWRlIHdoaWNoIGNvbWVzIGJlZm9yZSB0aGUgSlMgYmxvYiBvZiBlYWNoIEpTIHR5cGUgZm9yIHRoZSB3ZWIuXG4oZnVuY3Rpb24oKXtcbiAgdmFyIG1vZHVsZSA9IHtleHBvcnRzOnt9fTtcbiAgdmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8gVGhlc2UgbWV0aG9kcyBsZXQgeW91IGJ1aWxkIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIGZyb20gYSB0cmFuc2Zvcm1Db21wb25lbnRcbi8vIGZ1bmN0aW9uIGZvciBPVCB0eXBlcyBsaWtlIEpTT04wIGluIHdoaWNoIG9wZXJhdGlvbnMgYXJlIGxpc3RzIG9mIGNvbXBvbmVudHNcbi8vIGFuZCB0cmFuc2Zvcm1pbmcgdGhlbSByZXFyZXVpcmVzIE5eMiB3b3JrLiBJIGZpbmQgaXQga2luZCBvZiBuYXN0eSB0aGF0IEkgbmVlZFxuLy8gdGhpcywgYnV0IEknbSBub3QgcmVhbGx5IHN1cmUgd2hhdCBhIGJldHRlciBzb2x1dGlvbiBpcy4gTWF5YmUgSSBzaG91bGQgZG9cbi8vIHRoaXMgYXV0b21hdGljYWxseSB0byB0eXBlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wb3NlIGZ1bmN0aW9uIGRlZmluZWQuXG5cbi8vIEFkZCB0cmFuc2Zvcm0gYW5kIHRyYW5zZm9ybVggZnVuY3Rpb25zIGZvciBhbiBPVCB0eXBlIHdoaWNoIGhhc1xuLy8gdHJhbnNmb3JtQ29tcG9uZW50IGRlZmluZWQuICB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdGluYXRpb24gYXJyYXksXG4vLyBjb21wb25lbnQsIG90aGVyIGNvbXBvbmVudCwgc2lkZSlcbmV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHR5cGUsIHRyYW5zZm9ybUNvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBhcHBlbmQpIHtcbiAgdmFyIHRyYW5zZm9ybUNvbXBvbmVudFggPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgZGVzdExlZnQsIGRlc3RSaWdodCkge1xuICAgIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0TGVmdCwgbGVmdCwgcmlnaHQsICdsZWZ0Jyk7XG4gICAgdHJhbnNmb3JtQ29tcG9uZW50KGRlc3RSaWdodCwgcmlnaHQsIGxlZnQsICdyaWdodCcpO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm1YID0gdHlwZS50cmFuc2Zvcm1YID0gZnVuY3Rpb24obGVmdE9wLCByaWdodE9wKSB7XG4gICAgY2hlY2tWYWxpZE9wKGxlZnRPcCk7XG4gICAgY2hlY2tWYWxpZE9wKHJpZ2h0T3ApO1xuICAgIHZhciBuZXdSaWdodE9wID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0T3AubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByaWdodENvbXBvbmVudCA9IHJpZ2h0T3BbaV07XG5cbiAgICAgIC8vIEdlbmVyYXRlIG5ld0xlZnRPcCBieSBjb21wb3NpbmcgbGVmdE9wIGJ5IHJpZ2h0Q29tcG9uZW50XG4gICAgICB2YXIgbmV3TGVmdE9wID0gW107XG4gICAgICB2YXIgayA9IDA7XG4gICAgICB3aGlsZSAoayA8IGxlZnRPcC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDID0gW107XG4gICAgICAgIHRyYW5zZm9ybUNvbXBvbmVudFgobGVmdE9wW2tdLCByaWdodENvbXBvbmVudCwgbmV3TGVmdE9wLCBuZXh0Qyk7XG4gICAgICAgIGsrKztcblxuICAgICAgICBpZiAobmV4dEMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBuZXh0Q1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Qy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gazsgaiA8IGxlZnRPcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgYXBwZW5kKG5ld0xlZnRPcCwgbGVmdE9wW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlY3Vyc2UuXG4gICAgICAgICAgdmFyIHBhaXIgPSB0cmFuc2Zvcm1YKGxlZnRPcC5zbGljZShrKSwgbmV4dEMpO1xuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcGFpclswXS5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgYXBwZW5kKG5ld0xlZnRPcCwgcGFpclswXVtsXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcGFpclsxXS5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgYXBwZW5kKG5ld1JpZ2h0T3AsIHBhaXJbMV1bcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJpZ2h0Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgICAgYXBwZW5kKG5ld1JpZ2h0T3AsIHJpZ2h0Q29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIGxlZnRPcCA9IG5ld0xlZnRPcDtcbiAgICB9XG4gICAgcmV0dXJuIFtsZWZ0T3AsIG5ld1JpZ2h0T3BdO1xuICB9O1xuXG4gIC8vIFRyYW5zZm9ybXMgb3Agd2l0aCBzcGVjaWZpZWQgdHlwZSAoJ2xlZnQnIG9yICdyaWdodCcpIGJ5IG90aGVyT3AuXG4gIHR5cGUudHJhbnNmb3JtID0gdHlwZVsndHJhbnNmb3JtJ10gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgdHlwZSkge1xuICAgIGlmICghKHR5cGUgPT09ICdsZWZ0JyB8fCB0eXBlID09PSAncmlnaHQnKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtcblxuICAgIGlmIChvdGhlck9wLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9wO1xuXG4gICAgaWYgKG9wLmxlbmd0aCA9PT0gMSAmJiBvdGhlck9wLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Db21wb25lbnQoW10sIG9wWzBdLCBvdGhlck9wWzBdLCB0eXBlKTtcblxuICAgIGlmICh0eXBlID09PSAnbGVmdCcpXG4gICAgICByZXR1cm4gdHJhbnNmb3JtWChvcCwgb3RoZXJPcClbMF07XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybVgob3RoZXJPcCwgb3ApWzFdO1xuICB9O1xufTtcbi8vIERFUFJFQ0FURUQhXG4vL1xuLy8gVGhpcyB0eXBlIHdvcmtzLCBidXQgaXMgbm90IGV4cG9ydGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgdGhpcyBsaWJyYXJ5LlxuXG5cbi8vIEEgc2ltcGxlIHRleHQgaW1wbGVtZW50YXRpb25cbi8vXG4vLyBPcGVyYXRpb25zIGFyZSBsaXN0cyBvZiBjb21wb25lbnRzLlxuLy8gRWFjaCBjb21wb25lbnQgZWl0aGVyIGluc2VydHMgb3IgZGVsZXRlcyBhdCBhIHNwZWNpZmllZCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXG4vL1xuLy8gQ29tcG9uZW50cyBhcmUgZWl0aGVyOlxuLy8gIHtpOidzdHInLCBwOjEwMH06IEluc2VydCAnc3RyJyBhdCBwb3NpdGlvbiAxMDAgaW4gdGhlIGRvY3VtZW50XG4vLyAge2Q6J3N0cicsIHA6MTAwfTogRGVsZXRlICdzdHInIGF0IHBvc2l0aW9uIDEwMCBpbiB0aGUgZG9jdW1lbnRcbi8vXG4vLyBDb21wb25lbnRzIGluIGFuIG9wZXJhdGlvbiBhcmUgZXhlY3V0ZWQgc2VxdWVudGlhbGx5LCBzbyB0aGUgcG9zaXRpb24gb2YgY29tcG9uZW50c1xuLy8gYXNzdW1lcyBwcmV2aW91cyBjb21wb25lbnRzIGhhdmUgYWxyZWFkeSBleGVjdXRlZC5cbi8vXG4vLyBFZzogVGhpcyBvcDpcbi8vICAgW3tpOidhYmMnLCBwOjB9XVxuLy8gaXMgZXF1aXZhbGVudCB0byB0aGlzIG9wOlxuLy8gICBbe2k6J2EnLCBwOjB9LCB7aTonYicsIHA6MX0sIHtpOidjJywgcDoyfV1cblxuLy8gTk9URTogVGhlIGdsb2JhbCBzY29wZSBoZXJlIGlzIHNoYXJlZCB3aXRoIG90aGVyIHNoYXJlanMgZmlsZXMgd2hlbiBidWlsdCB3aXRoIGNsb3N1cmUuXG4vLyBCZSBjYXJlZnVsIHdoYXQgZW5kcyB1cCBpbiB5b3VyIG5hbWVzcGFjZS5cblxudmFyIHRleHQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3RleHQwJyxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3RleHR2MCcsXG4gIGNyZWF0ZTogZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgIGlmICgoaW5pdGlhbCAhPSBudWxsKSAmJiB0eXBlb2YgaW5pdGlhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbCBkYXRhIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWwgfHwgJyc7XG4gIH1cbn07XG5cbi8qKiBJbnNlcnQgczIgaW50byBzMSBhdCBwb3MuICovXG52YXIgc3RySW5qZWN0ID0gZnVuY3Rpb24oczEsIHBvcywgczIpIHtcbiAgcmV0dXJuIHMxLnNsaWNlKDAsIHBvcykgKyBzMiArIHMxLnNsaWNlKHBvcyk7XG59O1xuXG4vKiogQ2hlY2sgdGhhdCBhbiBvcGVyYXRpb24gY29tcG9uZW50IGlzIHZhbGlkLiBUaHJvd3MgaWYgaXRzIGludmFsaWQuICovXG52YXIgY2hlY2tWYWxpZENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgaWYgKHR5cGVvZiBjLnAgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50IG1pc3NpbmcgcG9zaXRpb24gZmllbGQnKTtcblxuICBpZiAoKHR5cGVvZiBjLmkgPT09ICdzdHJpbmcnKSA9PT0gKHR5cGVvZiBjLmQgPT09ICdzdHJpbmcnKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudCBuZWVkcyBhbiBpIG9yIGQgZmllbGQnKTtcblxuICBpZiAoYy5wIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aW9uIGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xufTtcblxuLyoqIENoZWNrIHRoYXQgYW4gb3BlcmF0aW9uIGlzIHZhbGlkICovXG52YXIgY2hlY2tWYWxpZE9wID0gZnVuY3Rpb24ob3ApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIGNoZWNrVmFsaWRDb21wb25lbnQob3BbaV0pO1xuICB9XG59O1xuXG4vKiogQXBwbHkgb3AgdG8gc25hcHNob3QgKi9cbnRleHQuYXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcbiAgdmFyIGRlbGV0ZWQ7XG5cbiAgY2hlY2tWYWxpZE9wKG9wKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvcFtpXTtcbiAgICBpZiAoY29tcG9uZW50LmkgIT0gbnVsbCkge1xuICAgICAgc25hcHNob3QgPSBzdHJJbmplY3Qoc25hcHNob3QsIGNvbXBvbmVudC5wLCBjb21wb25lbnQuaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZWQgPSBzbmFwc2hvdC5zbGljZShjb21wb25lbnQucCwgY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xuICAgICAgaWYgKGNvbXBvbmVudC5kICE9PSBkZWxldGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWxldGUgY29tcG9uZW50ICdcIiArIGNvbXBvbmVudC5kICsgXCInIGRvZXMgbm90IG1hdGNoIGRlbGV0ZWQgdGV4dCAnXCIgKyBkZWxldGVkICsgXCInXCIpO1xuXG4gICAgICBzbmFwc2hvdCA9IHNuYXBzaG90LnNsaWNlKDAsIGNvbXBvbmVudC5wKSArIHNuYXBzaG90LnNsaWNlKGNvbXBvbmVudC5wICsgY29tcG9uZW50LmQubGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNuYXBzaG90O1xufTtcblxuLyoqXG4gKiBBcHBlbmQgYSBjb21wb25lbnQgdG8gdGhlIGVuZCBvZiBuZXdPcC4gRXhwb3J0ZWQgZm9yIHVzZSBieSB0aGUgcmFuZG9tIG9wXG4gKiBnZW5lcmF0b3IgYW5kIHRoZSBKU09OMCB0eXBlLlxuICovXG52YXIgYXBwZW5kID0gdGV4dC5fYXBwZW5kID0gZnVuY3Rpb24obmV3T3AsIGMpIHtcbiAgaWYgKGMuaSA9PT0gJycgfHwgYy5kID09PSAnJykgcmV0dXJuO1xuXG4gIGlmIChuZXdPcC5sZW5ndGggPT09IDApIHtcbiAgICBuZXdPcC5wdXNoKGMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0ID0gbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdC5pICE9IG51bGwgJiYgYy5pICE9IG51bGwgJiYgbGFzdC5wIDw9IGMucCAmJiBjLnAgPD0gbGFzdC5wICsgbGFzdC5pLmxlbmd0aCkge1xuICAgICAgLy8gQ29tcG9zZSB0aGUgaW5zZXJ0IGludG8gdGhlIHByZXZpb3VzIGluc2VydFxuICAgICAgbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7aTpzdHJJbmplY3QobGFzdC5pLCBjLnAgLSBsYXN0LnAsIGMuaSksIHA6bGFzdC5wfTtcblxuICAgIH0gZWxzZSBpZiAobGFzdC5kICE9IG51bGwgJiYgYy5kICE9IG51bGwgJiYgYy5wIDw9IGxhc3QucCAmJiBsYXN0LnAgPD0gYy5wICsgYy5kLmxlbmd0aCkge1xuICAgICAgLy8gQ29tcG9zZSB0aGUgZGVsZXRlcyB0b2dldGhlclxuICAgICAgbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7ZDpzdHJJbmplY3QoYy5kLCBsYXN0LnAgLSBjLnAsIGxhc3QuZCksIHA6Yy5wfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdPcC5wdXNoKGMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqIENvbXBvc2Ugb3AxIGFuZCBvcDIgdG9nZXRoZXIgKi9cbnRleHQuY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSwgb3AyKSB7XG4gIGNoZWNrVmFsaWRPcChvcDEpO1xuICBjaGVja1ZhbGlkT3Aob3AyKTtcbiAgdmFyIG5ld09wID0gb3AxLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kKG5ld09wLCBvcDJbaV0pO1xuICB9XG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8qKiBDbGVhbiB1cCBhbiBvcCAqL1xudGV4dC5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcblxuICAvLyBOb3JtYWxpemUgc2hvdWxkIGFsbG93IG9wcyB3aGljaCBhcmUgYSBzaW5nbGUgKHVud3JhcHBlZCkgY29tcG9uZW50OlxuICAvLyB7aTonYXNkZicsIHA6MjN9LlxuICAvLyBUaGVyZSdzIG5vIGdvb2Qgd2F5IHRvIHRlc3QgaWYgc29tZXRoaW5nIGlzIGFuIGFycmF5OlxuICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cbiAgLy8gc28gdGhpcyBpcyBwcm9iYWJseSB0aGUgbGVhc3QgYmFkIHNvbHV0aW9uLlxuICBpZiAob3AuaSAhPSBudWxsIHx8IG9wLnAgIT0gbnVsbCkgb3AgPSBbb3BdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmIChjLnAgPT0gbnVsbCkgYy5wID0gMDtcblxuICAgIGFwcGVuZChuZXdPcCwgYyk7XG4gIH1cblxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vLyBUaGlzIGhlbHBlciBtZXRob2QgdHJhbnNmb3JtcyBhIHBvc2l0aW9uIGJ5IGFuIG9wIGNvbXBvbmVudC5cbi8vXG4vLyBJZiBjIGlzIGFuIGluc2VydCwgaW5zZXJ0QWZ0ZXIgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHRyYW5zZm9ybVxuLy8gaXMgcHVzaGVkIGFmdGVyIHRoZSBpbnNlcnQgKHRydWUpIG9yIGJlZm9yZSBpdCAoZmFsc2UpLlxuLy9cbi8vIGluc2VydEFmdGVyIGlzIG9wdGlvbmFsIGZvciBkZWxldGVzLlxudmFyIHRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCBjLCBpbnNlcnRBZnRlcikge1xuICAvLyBUaGlzIHdpbGwgZ2V0IGNvbGxhcHNlZCBpbnRvIGEgZ2lhbnQgdGVybmFyeSBieSB1Z2xpZnkuXG4gIGlmIChjLmkgIT0gbnVsbCkge1xuICAgIGlmIChjLnAgPCBwb3MgfHwgKGMucCA9PT0gcG9zICYmIGluc2VydEFmdGVyKSkge1xuICAgICAgcmV0dXJuIHBvcyArIGMuaS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEkgdGhpbmsgdGhpcyBjb3VsZCBhbHNvIGJlIHdyaXR0ZW4gYXM6IE1hdGgubWluKGMucCwgTWF0aC5taW4oYy5wIC1cbiAgICAvLyBvdGhlckMucCwgb3RoZXJDLmQubGVuZ3RoKSkgYnV0IEkgdGhpbmsgaXRzIGhhcmRlciB0byByZWFkIHRoYXQgd2F5LCBhbmRcbiAgICAvLyBpdCBjb21waWxlcyB1c2luZyB0ZXJuYXJ5IG9wZXJhdG9ycyBhbnl3YXkgc28gaXRzIG5vIHNsb3dlciB3cml0dGVuIGxpa2VcbiAgICAvLyB0aGlzLlxuICAgIGlmIChwb3MgPD0gYy5wKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH0gZWxzZSBpZiAocG9zIDw9IGMucCArIGMuZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjLnA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3MgLSBjLmQubGVuZ3RoO1xuICAgIH1cbiAgfVxufTtcblxuLy8gSGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gYSBjdXJzb3IgcG9zaXRpb24gYXMgYSByZXN1bHQgb2YgYW4gb3AuXG4vL1xuLy8gTGlrZSB0cmFuc2Zvcm1Qb3NpdGlvbiBhYm92ZSwgaWYgYyBpcyBhbiBpbnNlcnQsIGluc2VydEFmdGVyIHNwZWNpZmllc1xuLy8gd2hldGhlciB0aGUgY3Vyc29yIHBvc2l0aW9uIGlzIHB1c2hlZCBhZnRlciBhbiBpbnNlcnQgKHRydWUpIG9yIGJlZm9yZSBpdFxuLy8gKGZhbHNlKS5cbnRleHQudHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24ocG9zaXRpb24sIG9wLCBzaWRlKSB7XG4gIHZhciBpbnNlcnRBZnRlciA9IHNpZGUgPT09ICdyaWdodCc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICBwb3NpdGlvbiA9IHRyYW5zZm9ybVBvc2l0aW9uKHBvc2l0aW9uLCBvcFtpXSwgaW5zZXJ0QWZ0ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufTtcblxuLy8gVHJhbnNmb3JtIGFuIG9wIGNvbXBvbmVudCBieSBhbm90aGVyIG9wIGNvbXBvbmVudC4gQXN5bW1ldHJpYy5cbi8vIFRoZSByZXN1bHQgd2lsbCBiZSBhcHBlbmRlZCB0byBkZXN0aW5hdGlvbi5cbi8vXG4vLyBleHBvcnRlZCBmb3IgdXNlIGluIEpTT04gdHlwZVxudmFyIHRyYW5zZm9ybUNvbXBvbmVudCA9IHRleHQuX3RjID0gZnVuY3Rpb24oZGVzdCwgYywgb3RoZXJDLCBzaWRlKSB7XG4gIC8vdmFyIGNJbnRlcnNlY3QsIGludGVyc2VjdEVuZCwgaW50ZXJzZWN0U3RhcnQsIG5ld0MsIG90aGVySW50ZXJzZWN0LCBzO1xuXG4gIGNoZWNrVmFsaWRDb21wb25lbnQoYyk7XG4gIGNoZWNrVmFsaWRDb21wb25lbnQob3RoZXJDKTtcblxuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICAvLyBJbnNlcnQuXG4gICAgYXBwZW5kKGRlc3QsIHtpOmMuaSwgcDp0cmFuc2Zvcm1Qb3NpdGlvbihjLnAsIG90aGVyQywgc2lkZSA9PT0gJ3JpZ2h0Jyl9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWxldGVcbiAgICBpZiAob3RoZXJDLmkgIT0gbnVsbCkge1xuICAgICAgLy8gRGVsZXRlIHZzIGluc2VydFxuICAgICAgdmFyIHMgPSBjLmQ7XG4gICAgICBpZiAoYy5wIDwgb3RoZXJDLnApIHtcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtkOnMuc2xpY2UoMCwgb3RoZXJDLnAgLSBjLnApLCBwOmMucH0pO1xuICAgICAgICBzID0gcy5zbGljZShvdGhlckMucCAtIGMucCk7XG4gICAgICB9XG4gICAgICBpZiAocyAhPT0gJycpXG4gICAgICAgIGFwcGVuZChkZXN0LCB7ZDogcywgcDogYy5wICsgb3RoZXJDLmkubGVuZ3RofSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVsZXRlIHZzIGRlbGV0ZVxuICAgICAgaWYgKGMucCA+PSBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aClcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtkOiBjLmQsIHA6IGMucCAtIG90aGVyQy5kLmxlbmd0aH0pO1xuICAgICAgZWxzZSBpZiAoYy5wICsgYy5kLmxlbmd0aCA8PSBvdGhlckMucClcbiAgICAgICAgYXBwZW5kKGRlc3QsIGMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZXkgb3ZlcmxhcCBzb21ld2hlcmUuXG4gICAgICAgIHZhciBuZXdDID0ge2Q6ICcnLCBwOiBjLnB9O1xuXG4gICAgICAgIGlmIChjLnAgPCBvdGhlckMucClcbiAgICAgICAgICBuZXdDLmQgPSBjLmQuc2xpY2UoMCwgb3RoZXJDLnAgLSBjLnApO1xuXG4gICAgICAgIGlmIChjLnAgKyBjLmQubGVuZ3RoID4gb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpXG4gICAgICAgICAgbmV3Qy5kICs9IGMuZC5zbGljZShvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCAtIGMucCk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBlbnRpcmVseSBvcHRpb25hbCAtIEknbSBqdXN0IGNoZWNraW5nIHRoZSBkZWxldGVkIHRleHQgaW5cbiAgICAgICAgLy8gdGhlIHR3byBvcHMgbWF0Y2hlc1xuICAgICAgICB2YXIgaW50ZXJzZWN0U3RhcnQgPSBNYXRoLm1heChjLnAsIG90aGVyQy5wKTtcbiAgICAgICAgdmFyIGludGVyc2VjdEVuZCA9IE1hdGgubWluKGMucCArIGMuZC5sZW5ndGgsIG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKTtcbiAgICAgICAgdmFyIGNJbnRlcnNlY3QgPSBjLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBjLnAsIGludGVyc2VjdEVuZCAtIGMucCk7XG4gICAgICAgIHZhciBvdGhlckludGVyc2VjdCA9IG90aGVyQy5kLnNsaWNlKGludGVyc2VjdFN0YXJ0IC0gb3RoZXJDLnAsIGludGVyc2VjdEVuZCAtIG90aGVyQy5wKTtcbiAgICAgICAgaWYgKGNJbnRlcnNlY3QgIT09IG90aGVySW50ZXJzZWN0KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlIG9wcyBkZWxldGUgZGlmZmVyZW50IHRleHQgaW4gdGhlIHNhbWUgcmVnaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuXG4gICAgICAgIGlmIChuZXdDLmQgIT09ICcnKSB7XG4gICAgICAgICAgbmV3Qy5wID0gdHJhbnNmb3JtUG9zaXRpb24obmV3Qy5wLCBvdGhlckMpO1xuICAgICAgICAgIGFwcGVuZChkZXN0LCBuZXdDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxudmFyIGludmVydENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgcmV0dXJuIChjLmkgIT0gbnVsbCkgPyB7ZDpjLmksIHA6Yy5wfSA6IHtpOmMuZCwgcDpjLnB9O1xufTtcblxuLy8gTm8gbmVlZCB0byB1c2UgYXBwZW5kIGZvciBpbnZlcnQsIGJlY2F1c2UgdGhlIGNvbXBvbmVudHMgd29uJ3QgYmUgYWJsZSB0b1xuLy8gY2FuY2VsIG9uZSBhbm90aGVyLlxudGV4dC5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICAvLyBTaGFsbG93IGNvcHkgJiByZXZlcnNlIHRoYXQgc3Vja2EuXG4gIG9wID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICBvcFtpXSA9IGludmVydENvbXBvbmVudChvcFtpXSk7XG4gIH1cbiAgcmV0dXJuIG9wO1xufTtcblxuZXhwb3J0cy5fYm9vdHN0cmFwVHJhbnNmb3JtKHRleHQsIHRyYW5zZm9ybUNvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBhcHBlbmQpO1xuXG4vKlxuIFRoaXMgaXMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBKU09OIE9UIHR5cGUuXG5cbiBTcGVjIGlzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NlcGhnL1NoYXJlSlMvd2lraS9KU09OLU9wZXJhdGlvbnNcblxuIE5vdGU6IFRoaXMgaXMgYmVpbmcgbWFkZSBvYnNvbGV0ZS4gSXQgd2lsbCBzb29uIGJlIHJlcGxhY2VkIGJ5IHRoZSBKU09OMiB0eXBlLlxuKi9cblxuLyoqXG4gKiBVVElMSVRZIEZVTkNUSU9OU1xuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgb2JqZWN0IGlzIGFuIEFycmF5IGluc3RhbmNlLiBDYW4ndCB1c2UgQXJyYXkuaXNBcnJheVxuICogeWV0IGJlY2F1c2UgaXRzIG5vdCBzdXBwb3J0ZWQgb24gSUU4LlxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBwYXNzZWQgb2JqZWN0IHVzaW5nIEpTT04gc2VyaWFsaXphdGlvbiAod2hpY2ggaXMgc2xvdykuXG4gKlxuICogaGF4LCBjb3BpZWQgZnJvbSB0ZXN0L3R5cGVzL2pzb24uIEFwcGFyZW50bHkgdGhpcyBpcyBzdGlsbCB0aGUgZmFzdGVzdCB3YXlcbiAqIHRvIGRlZXAgY2xvbmUgYW4gb2JqZWN0LCBhc3N1bWluZyB3ZSBoYXZlIGJyb3dzZXIgc3VwcG9ydCBmb3IgSlNPTi4gIEBzZWVcbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb25pbmctYW4tb2JqZWN0LzEyXG4gKi9cbnZhciBjbG9uZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xufTtcblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIFRleHQgT1QgdHlwZS4gVGhpcyBpcyB1c2VkIGZvciB0aGUgSlNPTiBTdHJpbmcgb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHsqfVxuICovXG5pZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKVxuICB2YXIgdGV4dCA9IHdpbmRvdy5vdHR5cGVzLnRleHQ7XG5cbi8qKlxuICogSlNPTiBPVCBUeXBlXG4gKiBAdHlwZSB7Kn1cbiAqL1xudmFyIGpzb24gPSB7IFxuICBuYW1lOiAnanNvbjAnLFxuICB1cmk6ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvSlNPTnYwJ1xufTtcblxuanNvbi5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vIE51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQgaWYgeW91IGRvbid0IHBhc3MgYW4gYXJndW1lbnQuXG4gIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogZGF0YTtcbn07XG5cbmpzb24uaW52ZXJ0Q29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xuICB2YXIgY18gPSB7cDogYy5wfTtcblxuICBpZiAoYy5zaSAhPT0gdm9pZCAwKSBjXy5zZCA9IGMuc2k7XG4gIGlmIChjLnNkICE9PSB2b2lkIDApIGNfLnNpID0gYy5zZDtcbiAgaWYgKGMub2kgIT09IHZvaWQgMCkgY18ub2QgPSBjLm9pO1xuICBpZiAoYy5vZCAhPT0gdm9pZCAwKSBjXy5vaSA9IGMub2Q7XG4gIGlmIChjLmxpICE9PSB2b2lkIDApIGNfLmxkID0gYy5saTtcbiAgaWYgKGMubGQgIT09IHZvaWQgMCkgY18ubGkgPSBjLmxkO1xuICBpZiAoYy5uYSAhPT0gdm9pZCAwKSBjXy5uYSA9IC1jLm5hO1xuXG4gIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICBjXy5sbSA9IGMucFtjLnAubGVuZ3RoLTFdO1xuICAgIGNfLnAgPSBjLnAuc2xpY2UoMCxjLnAubGVuZ3RoLTEpLmNvbmNhdChbYy5sbV0pO1xuICB9XG5cbiAgcmV0dXJuIGNfO1xufTtcblxuanNvbi5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgb3BfID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XG4gIHZhciBpb3AgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcF8ubGVuZ3RoOyBpKyspIHtcbiAgICBpb3AucHVzaChqc29uLmludmVydENvbXBvbmVudChvcF9baV0pKTtcbiAgfVxuICByZXR1cm4gaW9wO1xufTtcblxuanNvbi5jaGVja1ZhbGlkT3AgPSBmdW5jdGlvbihvcCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gIGlmICghaXNBcnJheShvcFtpXS5wKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGF0aCcpO1xuICB9XG59O1xuXG5qc29uLmNoZWNrTGlzdCA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgaWYgKCFpc0FycmF5KGVsZW0pKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIGxpc3QnKTtcbn07XG5cbmpzb24uY2hlY2tPYmogPSBmdW5jdGlvbihlbGVtKSB7XG4gIGlmIChlbGVtLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGFuIG9iamVjdCAoaXQgd2FzIFwiICsgSlNPTi5zdHJpbmdpZnkoZWxlbSkgKyBcIilcIik7XG4gIH1cbn07XG5cbmpzb24uYXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcbiAganNvbi5jaGVja1ZhbGlkT3Aob3ApO1xuXG4gIG9wID0gY2xvbmUob3ApO1xuXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgZGF0YTogc25hcHNob3RcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcblxuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBwYXJlbnRLZXkgPSBudWxsO1xuICAgIHZhciBlbGVtID0gY29udGFpbmVyO1xuICAgIHZhciBrZXkgPSAnZGF0YSc7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMucC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHAgPSBjLnBbal07XG5cbiAgICAgIHBhcmVudCA9IGVsZW07XG4gICAgICBwYXJlbnRLZXkgPSBrZXk7XG4gICAgICBlbGVtID0gZWxlbVtrZXldO1xuICAgICAga2V5ID0gcDtcblxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8vIE51bWJlciBhZGRcbiAgICBpZiAoYy5uYSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1ba2V5XSAhPSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgbnVtYmVyJyk7XG5cbiAgICAgIGVsZW1ba2V5XSArPSBjLm5hO1xuICAgIH1cblxuICAgIC8vIFN0cmluZyBpbnNlcnRcbiAgICBlbHNlIGlmIChjLnNpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbSAhPSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgc3RyaW5nIChpdCB3YXMgJytKU09OLnN0cmluZ2lmeShlbGVtKSsnKScpO1xuXG4gICAgICBwYXJlbnRbcGFyZW50S2V5XSA9IGVsZW0uc2xpY2UoMCxrZXkpICsgYy5zaSArIGVsZW0uc2xpY2Uoa2V5KTtcbiAgICB9XG5cbiAgICAvLyBTdHJpbmcgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5zZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW0gIT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIHN0cmluZycpO1xuXG4gICAgICBpZiAoZWxlbS5zbGljZShrZXksa2V5ICsgYy5zZC5sZW5ndGgpICE9PSBjLnNkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZWQgc3RyaW5nIGRvZXMgbm90IG1hdGNoJyk7XG5cbiAgICAgIHBhcmVudFtwYXJlbnRLZXldID0gZWxlbS5zbGljZSgwLGtleSkgKyBlbGVtLnNsaWNlKGtleSArIGMuc2QubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IHJlcGxhY2VcbiAgICBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGUgbGlzdCBlbGVtZW50IG1hdGNoZXMgYy5sZFxuICAgICAgZWxlbVtrZXldID0gYy5saTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IGluc2VydFxuICAgIGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICBlbGVtLnNwbGljZShrZXksMCwgYy5saSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBkZWxldGVcbiAgICBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoZSBsaXN0IGVsZW1lbnQgbWF0Y2hlcyBjLmxkIGhlcmUgdG9vLlxuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDEpO1xuICAgIH1cblxuICAgIC8vIExpc3QgbW92ZVxuICAgIGVsc2UgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICBpZiAoYy5sbSAhPSBrZXkpIHtcbiAgICAgICAgdmFyIGUgPSBlbGVtW2tleV07XG4gICAgICAgIC8vIFJlbW92ZSBpdC4uLlxuICAgICAgICBlbGVtLnNwbGljZShrZXksMSk7XG4gICAgICAgIC8vIEFuZCBpbnNlcnQgaXQgYmFjay5cbiAgICAgICAgZWxlbS5zcGxpY2UoYy5sbSwwLGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9iamVjdCBpbnNlcnQgLyByZXBsYWNlXG4gICAgZWxzZSBpZiAoYy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrT2JqKGVsZW0pO1xuXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxuICAgICAgZWxlbVtrZXldID0gYy5vaTtcbiAgICB9XG5cbiAgICAvLyBPYmplY3QgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrT2JqKGVsZW0pO1xuXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxuICAgICAgZGVsZXRlIGVsZW1ba2V5XTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCAvIG1pc3NpbmcgaW5zdHJ1Y3Rpb24gaW4gb3AnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmRhdGE7XG59O1xuXG4vLyBIZWxwZXIgZm9yIGluY3JlbWVudGFsbHkgYXBwbHlpbmcgYW4gb3BlcmF0aW9uIHRvIGEgc25hcHNob3QuIENhbGxzIHlpZWxkXG4vLyBhZnRlciBlYWNoIG9wIGNvbXBvbmVudCBoYXMgYmVlbiBhcHBsaWVkLlxuanNvbi5pbmNyZW1lbnRhbEFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wLCBfeWllbGQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbWFsbE9wID0gW29wW2ldXTtcbiAgICBzbmFwc2hvdCA9IGpzb24uYXBwbHkoc25hcHNob3QsIHNtYWxsT3ApO1xuICAgIC8vIEknZCBqdXN0IGNhbGwgdGhpcyB5aWVsZCwgYnV0IHRoYXRzIGEgcmVzZXJ2ZWQga2V5d29yZC4gQmFoIVxuICAgIF95aWVsZChzbWFsbE9wLCBzbmFwc2hvdCk7XG4gIH1cbiAgXG4gIHJldHVybiBzbmFwc2hvdDtcbn07XG5cbi8vIENoZWNrcyBpZiB0d28gcGF0aHMsIHAxIGFuZCBwMiBtYXRjaC5cbnZhciBwYXRoTWF0Y2hlcyA9IGpzb24ucGF0aE1hdGNoZXMgPSBmdW5jdGlvbihwMSwgcDIsIGlnbm9yZUxhc3QpIHtcbiAgaWYgKHAxLmxlbmd0aCAhPSBwMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocDFbaV0gIT09IHAyW2ldICYmICghaWdub3JlTGFzdCB8fCBpICE9PSBwMS5sZW5ndGggLSAxKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gIHZhciBuZXdDID0ge3A6IGNvbXBvbmVudC5wW2NvbXBvbmVudC5wLmxlbmd0aCAtIDFdfTtcbiAgaWYgKGNvbXBvbmVudC5zaSAhPSBudWxsKSB7XG4gICAgbmV3Qy5pID0gY29tcG9uZW50LnNpO1xuICB9IGVsc2Uge1xuICAgIG5ld0MuZCA9IGNvbXBvbmVudC5zZDtcbiAgfVxuICByZXR1cm4gbmV3Qztcbn07XG5cbmpzb24uYXBwZW5kID0gZnVuY3Rpb24oZGVzdCxjKSB7XG4gIGMgPSBjbG9uZShjKTtcblxuICB2YXIgbGFzdDtcblxuICBpZiAoZGVzdC5sZW5ndGggIT0gMCAmJiBwYXRoTWF0Y2hlcyhjLnAsIChsYXN0ID0gZGVzdFtkZXN0Lmxlbmd0aCAtIDFdKS5wKSkge1xuICAgIGlmIChsYXN0Lm5hICE9IG51bGwgJiYgYy5uYSAhPSBudWxsKSB7XG4gICAgICBkZXN0W2Rlc3QubGVuZ3RoIC0gMV0gPSB7cDogbGFzdC5wLCBuYTogbGFzdC5uYSArIGMubmF9O1xuICAgIH0gZWxzZSBpZiAobGFzdC5saSAhPT0gdW5kZWZpbmVkICYmIGMubGkgPT09IHVuZGVmaW5lZCAmJiBjLmxkID09PSBsYXN0LmxpKSB7XG4gICAgICAvLyBpbnNlcnQgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgZGVsZXRlIGJlY29tZXMgYSBub29wLlxuICAgICAgaWYgKGxhc3QubGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBsZWF2ZSB0aGUgZGVsZXRlIHBhcnQgb2YgdGhlIHJlcGxhY2VcbiAgICAgICAgZGVsZXRlIGxhc3QubGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGFzdC5vZCAhPT0gdW5kZWZpbmVkICYmIGxhc3Qub2kgPT09IHVuZGVmaW5lZCAmJiBjLm9pICE9PSB1bmRlZmluZWQgJiYgYy5vZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXN0Lm9pID0gYy5vaTtcbiAgICB9IGVsc2UgaWYgKGxhc3Qub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoZSBsYXN0IHBhdGggY29tcG9uZW50IGluc2VydGVkIHNvbWV0aGluZyB0aGF0IHRoZSBuZXcgY29tcG9uZW50IGRlbGV0ZXMgKG9yIHJlcGxhY2VzKS5cbiAgICAgIC8vIEp1c3QgbWVyZ2UgdGhlbS5cbiAgICAgIGlmIChjLm9pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFzdC5vaSA9IGMub2k7XG4gICAgICB9IGVsc2UgaWYgKGxhc3Qub2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgbGFzdC5vaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIGluc2VydCBkaXJlY3RseSBmb2xsb3dlZCBieSBhIGRlbGV0ZSB0dXJucyBpbnRvIGEgbm8tb3AgYW5kIGNhbiBiZSByZW1vdmVkLlxuICAgICAgICBkZXN0LnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYy5sbSAhPT0gdW5kZWZpbmVkICYmIGMucFtjLnAubGVuZ3RoIC0gMV0gPT09IGMubG0pIHtcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3QucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVzdC5sZW5ndGggIT0gMCAmJiBwYXRoTWF0Y2hlcyhjLnAsIGxhc3QucCwgdHJ1ZSkpIHtcbiAgICBpZiAoKGMuc2kgIT0gbnVsbCB8fCBjLnNkICE9IG51bGwpICYmIChsYXN0LnNpICE9IG51bGwgfHwgbGFzdC5zZCAhPSBudWxsKSkge1xuICAgICAgLy8gVHJ5IHRvIGNvbXBvc2UgdGhlIHN0cmluZyBvcHMgdG9nZXRoZXIgdXNpbmcgdGV4dCdzIGVxdWl2YWxlbnQgbWV0aG9kc1xuICAgICAgdmFyIHRleHRPcCA9IFtfY29udmVydFRvVGV4dENvbXBvbmVudChsYXN0KV07XG4gICAgICB0ZXh0Ll9hcHBlbmQodGV4dE9wLCBfY29udmVydFRvVGV4dENvbXBvbmVudChjKSk7XG4gICAgICBcbiAgICAgIC8vIFRoZW4gY29udmVydCBiYWNrLlxuICAgICAgaWYgKHRleHRPcC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgZGVzdC5wdXNoKGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHRDID0gdGV4dE9wWzBdO1xuICAgICAgICBsYXN0LnBbbGFzdC5wLmxlbmd0aCAtIDFdID0gdGV4dEMucDtcbiAgICAgICAgaWYgKHRleHRDLmkgIT0gbnVsbClcbiAgICAgICAgICBsYXN0LnNpID0gdGV4dEMuaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxhc3Quc2QgPSB0ZXh0Qy5kO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0LnB1c2goYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlc3QucHVzaChjKTtcbiAgfVxufTtcblxuanNvbi5jb21wb3NlID0gZnVuY3Rpb24ob3AxLG9wMikge1xuICBqc29uLmNoZWNrVmFsaWRPcChvcDEpO1xuICBqc29uLmNoZWNrVmFsaWRPcChvcDIpO1xuXG4gIHZhciBuZXdPcCA9IGNsb25lKG9wMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICBqc29uLmFwcGVuZChuZXdPcCxvcDJbaV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuanNvbi5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcblxuICBvcCA9IGlzQXJyYXkob3ApID8gb3AgOiBbb3BdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmIChjLnAgPT0gbnVsbCkgYy5wID0gW107XG5cbiAgICBqc29uLmFwcGVuZChuZXdPcCxjKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBhbiBvcCBhdCBvdGhlclBhdGggbWF5IGFmZmVjdCBhbiBvcCBhdCBwYXRoXG5qc29uLmNhbk9wQWZmZWN0T3AgPSBmdW5jdGlvbihvdGhlclBhdGgscGF0aCkge1xuICBpZiAob3RoZXJQYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIHBhdGggPSBwYXRoLnNsaWNlKDAscGF0aC5sZW5ndGggLSAxKTtcbiAgb3RoZXJQYXRoID0gb3RoZXJQYXRoLnNsaWNlKDAsb3RoZXJQYXRoLmxlbmd0aCAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBvdGhlclBhdGhbaV07XG4gICAgaWYgKGkgPj0gcGF0aC5sZW5ndGggfHwgcCAhPSBwYXRoW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBTYW1lXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gdHJhbnNmb3JtIGMgc28gaXQgYXBwbGllcyB0byBhIGRvY3VtZW50IHdpdGggb3RoZXJDIGFwcGxpZWQuXG5qc29uLnRyYW5zZm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uKGRlc3QsIGMsIG90aGVyQywgdHlwZSkge1xuICBjID0gY2xvbmUoYyk7XG5cbiAgaWYgKGMubmEgIT09IHZvaWQgMClcbiAgICBjLnAucHVzaCgwKTtcblxuICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApXG4gICAgb3RoZXJDLnAucHVzaCgwKTtcblxuICB2YXIgY29tbW9uO1xuICBpZiAoanNvbi5jYW5PcEFmZmVjdE9wKG90aGVyQy5wLCBjLnApKVxuICAgIGNvbW1vbiA9IG90aGVyQy5wLmxlbmd0aCAtIDE7XG5cbiAgdmFyIGNvbW1vbjI7XG4gIGlmIChqc29uLmNhbk9wQWZmZWN0T3AoYy5wLG90aGVyQy5wKSlcbiAgICBjb21tb24yID0gYy5wLmxlbmd0aCAtIDE7XG5cbiAgdmFyIGNwbGVuZ3RoID0gYy5wLmxlbmd0aDtcbiAgdmFyIG90aGVyQ3BsZW5ndGggPSBvdGhlckMucC5sZW5ndGg7XG5cbiAgaWYgKGMubmEgIT09IHZvaWQgMCkgLy8gaGF4XG4gICAgYy5wLnBvcCgpO1xuXG4gIGlmIChvdGhlckMubmEgIT09IHZvaWQgMClcbiAgICBvdGhlckMucC5wb3AoKTtcblxuICBpZiAob3RoZXJDLm5hKSB7XG4gICAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID49IGNwbGVuZ3RoICYmIG90aGVyQy5wW2NvbW1vbjJdID09IGMucFtjb21tb24yXSkge1xuICAgICAgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICAgIGMubGQgPSBqc29uLmFwcGx5KGNsb25lKGMubGQpLFtvY10pO1xuICAgICAgfSBlbHNlIGlmIChjLm9kICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgICBjLm9kID0ganNvbi5hcHBseShjbG9uZShjLm9kKSxbb2NdKTtcbiAgICAgIH1cbiAgICB9XG4gICAganNvbi5hcHBlbmQoZGVzdCxjKTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8vIGlmIGMgaXMgZGVsZXRpbmcgc29tZXRoaW5nLCBhbmQgdGhhdCB0aGluZyBpcyBjaGFuZ2VkIGJ5IG90aGVyQywgd2UgbmVlZCB0b1xuICAvLyB1cGRhdGUgYyB0byByZWZsZWN0IHRoYXQgY2hhbmdlIGZvciBpbnZlcnRpYmlsaXR5LlxuICAvLyBUT0RPIHRoaXMgaXMgcHJvYmFibHkgbm90IG5lZWRlZCBzaW5jZSB3ZSBkb24ndCBoYXZlIGludmVydGliaWxpdHlcbiAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID4gY3BsZW5ndGggJiYgYy5wW2NvbW1vbjJdID09IG90aGVyQy5wW2NvbW1vbjJdKSB7XG4gICAgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgIGMubGQgPSBqc29uLmFwcGx5KGNsb25lKGMubGQpLFtvY10pO1xuICAgIH0gZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgYy5vZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5vZCksW29jXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbW1vbiAhPSBudWxsKSB7XG4gICAgdmFyIGNvbW1vbk9wZXJhbmQgPSBjcGxlbmd0aCA9PSBvdGhlckNwbGVuZ3RoO1xuXG4gICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIG90aGVyQ1xuICAgIGlmIChvdGhlckMubmEgIT09IHZvaWQgMCkge1xuICAgICAgLy8gdGhpcyBjYXNlIGlzIGhhbmRsZWQgYWJvdmUgZHVlIHRvIGlja3kgcGF0aCBoYXhcbiAgICB9IGVsc2UgaWYgKG90aGVyQy5zaSAhPT0gdm9pZCAwIHx8IG90aGVyQy5zZCAhPT0gdm9pZCAwKSB7XG4gICAgICAvLyBTdHJpbmcgb3AgdnMgc3RyaW5nIG9wIC0gcGFzcyB0aHJvdWdoIHRvIHRleHQgdHlwZVxuICAgICAgaWYgKGMuc2kgIT09IHZvaWQgMCB8fCBjLnNkICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKSB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgYSBzdHJpbmc/Jyk7XG5cbiAgICAgICAgLy8gQ29udmVydCBhbiBvcCBjb21wb25lbnQgdG8gYSB0ZXh0IG9wIGNvbXBvbmVudCBzbyB3ZSBjYW4gdXNlIHRoZVxuICAgICAgICAvLyB0ZXh0IHR5cGUncyB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgICAgICAgdmFyIHRjMSA9IF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGMpO1xuICAgICAgICB2YXIgdGMyID0gX2NvbnZlcnRUb1RleHRDb21wb25lbnQob3RoZXJDKTtcblxuICAgICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgICAgLy8gYWN0dWFsbHkgdHJhbnNmb3JtXG4gICAgICAgIHRleHQuX3RjKHJlcywgdGMxLCB0YzIsIHR5cGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gLi4uLiB0aGVuIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIGludG8gYSBKU09OIG9wIGFnYWluLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIFRleHQgY29tcG9uZW50XG4gICAgICAgICAgdmFyIHRjID0gcmVzW2ldO1xuICAgICAgICAgIC8vIEpTT04gY29tcG9uZW50XG4gICAgICAgICAgdmFyIGpjID0ge3A6IGMucC5zbGljZSgwLCBjb21tb24pfTtcbiAgICAgICAgICBqYy5wLnB1c2godGMucCk7XG5cbiAgICAgICAgICBpZiAodGMuaSAhPSBudWxsKSBqYy5zaSA9IHRjLmk7XG4gICAgICAgICAgaWYgKHRjLmQgIT0gbnVsbCkgamMuc2QgPSB0Yy5kO1xuICAgICAgICAgIGpzb24uYXBwZW5kKGRlc3QsIGpjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5saSAhPT0gdm9pZCAwICYmIG90aGVyQy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gbm9vcFxuXG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIC8vIHdlJ3JlIHRyeWluZyB0byBkZWxldGUgdGhlIHNhbWUgZWxlbWVudCwgLT4gbm9vcFxuICAgICAgICAgIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgdHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBib3RoIHJlcGxhY2luZyBvbmUgZWxlbWVudCB3aXRoIGFub3RoZXIuIG9ubHkgb25lIGNhbiBzdXJ2aXZlXG4gICAgICAgICAgICBjLmxkID0gY2xvbmUob3RoZXJDLmxpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkID09PSB1bmRlZmluZWQgJiYgY29tbW9uT3BlcmFuZCAmJiBjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBpbiBsaSB2cy4gbGksIGxlZnQgd2lucy5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpXG4gICAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJDLnBbY29tbW9uXSA8PSBjLnBbY29tbW9uXSkge1xuICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgLy8gb3RoZXJDIGVkaXRzIHRoZSBzYW1lIGxpc3Qgd2UgZWRpdFxuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dIDw9IGMubG0pXG4gICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgLy8gY2hhbmdpbmcgYy5mcm9tIGlzIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgICAgICAvLyB0aGV5IGRlbGV0ZWQgdGhlIHRoaW5nIHdlJ3JlIHRyeWluZyB0byBtb3ZlXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3RoZXJDIGVkaXRzIHRoZSBzYW1lIGxpc3Qgd2UgZWRpdFxuICAgICAgICAgIHZhciBwID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgICB2YXIgZnJvbSA9IGMucFtjb21tb25dO1xuICAgICAgICAgIHZhciB0byA9IGMubG07XG4gICAgICAgICAgaWYgKHAgPCB0byB8fCAocCA9PT0gdG8gJiYgZnJvbSA8IHRvKSlcbiAgICAgICAgICAgIGMubG0tLTtcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlckMucFtjb21tb25dIDwgYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgYy5wW2NvbW1vbl0tLTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgaWYgKG90aGVyQ3BsZW5ndGggPCBjcGxlbmd0aCkge1xuICAgICAgICAgIC8vIHdlJ3JlIGJlbG93IHRoZSBkZWxldGVkIGVsZW1lbnQsIHNvIC0+IG5vb3BcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfSBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoYy5saSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSByZXBsYWNpbmcsIHRoZXkncmUgZGVsZXRpbmcuIHdlIGJlY29tZSBhbiBpbnNlcnQuXG4gICAgICAgICAgICBkZWxldGUgYy5sZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UncmUgdHJ5aW5nIHRvIGRlbGV0ZSB0aGUgc2FtZSBlbGVtZW50LCAtPiBub29wXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxtICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxtICE9PSB2b2lkIDAgJiYgY3BsZW5ndGggPT09IG90aGVyQ3BsZW5ndGgpIHtcbiAgICAgICAgLy8gbG0gdnMgbG0sIGhlcmUgd2UgZ28hXG4gICAgICAgIHZhciBmcm9tID0gYy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IGMubG07XG4gICAgICAgIHZhciBvdGhlckZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgb3RoZXJUbyA9IG90aGVyQy5sbTtcbiAgICAgICAgaWYgKG90aGVyRnJvbSAhPT0gb3RoZXJUbykge1xuICAgICAgICAgIC8vIGlmIG90aGVyRnJvbSA9PSBvdGhlclRvLCB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSBvdXIgb3AuXG5cbiAgICAgICAgICAvLyB3aGVyZSBkaWQgbXkgdGhpbmcgZ28/XG4gICAgICAgICAgaWYgKGZyb20gPT09IG90aGVyRnJvbSkge1xuICAgICAgICAgICAgLy8gdGhleSBtb3ZlZCBpdCEgdGllIGJyZWFrLlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICBjLnBbY29tbW9uXSA9IG90aGVyVG87XG4gICAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgLy8gdWdoXG4gICAgICAgICAgICAgICAgYy5sbSA9IG90aGVyVG87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhleSBtb3ZlZCBhcm91bmQgaXRcbiAgICAgICAgICAgIGlmIChmcm9tID4gb3RoZXJGcm9tKSBjLnBbY29tbW9uXS0tO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvdGhlclRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gb3RoZXJUbykge1xuICAgICAgICAgICAgICBpZiAob3RoZXJGcm9tID4gb3RoZXJUbykge1xuICAgICAgICAgICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSAvLyB1Z2gsIGFnYWluXG4gICAgICAgICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RlcCAyOiB3aGVyZSBhbSBpIGdvaW5nIHRvIHB1dCBpdD9cbiAgICAgICAgICAgIGlmICh0byA+IG90aGVyRnJvbSkge1xuICAgICAgICAgICAgICBjLmxtLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSBvdGhlckZyb20pIHtcbiAgICAgICAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgICAgICBjLmxtLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG8gPiBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIGMubG0rKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG8gPT09IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYm90aCBtb3ZpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uLCB0aWUgYnJlYWtcbiAgICAgICAgICAgICAgaWYgKChvdGhlclRvID4gb3RoZXJGcm9tICYmIHRvID4gZnJvbSkgfHxcbiAgICAgICAgICAgICAgICAgIChvdGhlclRvIDwgb3RoZXJGcm9tICYmIHRvIDwgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0JykgYy5sbSsrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGZyb20pIGMubG0rKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSBjLmxtLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgPT09IHVuZGVmaW5lZCAmJiBjb21tb25PcGVyYW5kKSB7XG4gICAgICAgIC8vIGxpXG4gICAgICAgIHZhciBmcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIHRvID0gb3RoZXJDLmxtO1xuICAgICAgICBwID0gYy5wW2NvbW1vbl07XG4gICAgICAgIGlmIChwID4gZnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgaWYgKHAgPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxkLCBsZCtsaSwgc2ksIHNkLCBuYSwgb2ksIG9kLCBvaStvZCwgYW55IGxpIG9uIGFuIGVsZW1lbnQgYmVuZWF0aFxuICAgICAgICAvLyB0aGUgbG1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaS5lLiB0aGluZ3MgY2FyZSBhYm91dCB3aGVyZSB0aGVpciBpdGVtIGlzIGFmdGVyIHRoZSBtb3ZlLlxuICAgICAgICB2YXIgZnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcbiAgICAgICAgcCA9IGMucFtjb21tb25dO1xuICAgICAgICBpZiAocCA9PT0gZnJvbSkge1xuICAgICAgICAgIGMucFtjb21tb25dID0gdG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHAgPiBmcm9tKSBjLnBbY29tbW9uXS0tO1xuICAgICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICAgICAgZWxzZSBpZiAocCA9PT0gdG8gJiYgZnJvbSA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG90aGVyQy5vaSAhPT0gdm9pZCAwICYmIG90aGVyQy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCAmJiBjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgLy8gd2UgaW5zZXJ0ZWQgd2hlcmUgc29tZW9uZSBlbHNlIHJlcGxhY2VkXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIGxlZnQgd2luc1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlIHdpbiwgbWFrZSBvdXIgb3AgcmVwbGFjZSB3aGF0IHRoZXkgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGMub2QgPSBvdGhlckMub2k7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIC0+IG5vb3AgaWYgdGhlIG90aGVyIGNvbXBvbmVudCBpcyBkZWxldGluZyB0aGUgc2FtZSBvYmplY3QgKG9yIGFueSBwYXJlbnQpXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwICYmIGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIGxlZnQgd2lucyBpZiB3ZSB0cnkgdG8gaW5zZXJ0IGF0IHRoZSBzYW1lIHBsYWNlXG4gICAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBqc29uLmFwcGVuZChkZXN0LHtwOiBjLnAsIG9kOm90aGVyQy5vaX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMub2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMucFtjb21tb25dID09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKVxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVsZXRlIGMub2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBqc29uLmFwcGVuZChkZXN0LGMpO1xuICByZXR1cm4gZGVzdDtcbn07XG5cbmV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybShqc29uLCBqc29uLnRyYW5zZm9ybUNvbXBvbmVudCwganNvbi5jaGVja1ZhbGlkT3AsIGpzb24uYXBwZW5kKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb247XG4vLyBUaGlzIGlzIGluY2x1ZGVkIGFmdGVyIHRoZSBKUyBmb3IgZWFjaCB0eXBlIHdoZW4gd2UgYnVpbGQgZm9yIHRoZSB3ZWIuXG5cbiAgdmFyIF90eXBlcyA9IHdpbmRvdy5vdHR5cGVzID0gd2luZG93Lm90dHlwZXMgfHwge307XG4gIHZhciBfdCA9IG1vZHVsZS5leHBvcnRzO1xuICBfdHlwZXNbX3QubmFtZV0gPSBfdDtcblxuICBpZiAoX3QudXJpKSBfdHlwZXNbX3QudXJpXSA9IF90O1xufSkoKTtcbi8vIEpTT04gZG9jdW1lbnQgQVBJIGZvciB0aGUgJ2pzb24wJyB0eXBlLlxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfX3NsaWNlID0gW10uc2xpY2U7XG4gIHZhciBfdHlwZXMgPSB0eXBlb2YgYnJlcXVpcmUgIT09ICd1bmRlZmluZWQnID8gYnJlcXVpcmUoJ290dHlwZXMnKSA6IHdpbmRvdy5vdHR5cGVzO1xuICB2YXIgX3R5cGUgPSBfdHlwZXNbJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy9KU09OdjAnXTtcblxuICAvLyBIZWxwZXJzXG5cbiAgZnVuY3Rpb24gZGVwYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDEgJiYgcGF0aFswXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgIHJldHVybiBwYXRoWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmF2ZXJzZShzbmFwc2hvdCwgcGF0aCkge1xuICAgIHZhciBrZXkgPSAnZGF0YSc7XG4gICAgdmFyIGVsZW0gPSB7IGRhdGE6IHNuYXBzaG90IH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW0gPSBlbGVtW2tleV07XG4gICAgICBpZiAodHlwZW9mIGVsZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBhdGgnKTtcbiAgICAgIH1cbiAgICAgIGtleSA9IHBhdGhbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW06IGVsZW0sXG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoRXF1YWxzKHAxLCBwMikge1xuICAgIGlmIChwMS5sZW5ndGggIT09IHAyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAxLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocDFbaV0gIT09IHAyW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb250YWluc1BhdGgocDEsIHAyKSB7XG4gICAgaWYgKHAxLmxlbmd0aCA8IHAyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBwYXRoRXF1YWxzKCBwMS5zbGljZSgwLHAyLmxlbmd0aCksIHAyKTtcbiAgfVxuXG4gIC8vIGRvZXMgbm90aGluZywgdXNlZCBhcyBhIGRlZmF1bHQgY2FsbGJhY2tcbiAgZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCl7fVxuXG4gIC8vIGhlbHBlciBmb3IgY3JlYXRpbmcgZnVuY3Rpb25zIHdpdGggdGhlIG1ldGhvZCBzaWduYXR1cmUgZnVuYyhbcGF0aF0sYXJnMSxhcmcyLC4uLixbY2JdKVxuICAvLyBwb3B1bGF0ZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIHdpdGggYSBkZWZhdWx0IHBhdGggYW5kIGNhbGxiYWNrXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3Mob2JqLGFyZ3MsZnVuYyl7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIHZhciBwYXRoX3ByZWZpeCA9IG9iai5wYXRoIHx8IFtdO1xuXG4gICAgaWYgKGZ1bmMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJncy5wdXNoKG51bGxGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgZnVuYy5sZW5ndGgpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChwYXRoX3ByZWZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NbMF0gPSBwYXRoX3ByZWZpeC5jb25jYXQoYXJnc1swXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqLGFyZ3MpO1xuICB9O1xuXG5cbiAgLy8gU3ViRG9jXG4gIC8vIHRoaXMgb2JqZWN0IGlzIHJldHVybmVkIGZyb20gY29udGV4dC5jcmVhdGVDb250ZXh0QXQoKVxuXG4gIHZhciBTdWJEb2MgPSBmdW5jdGlvbihjb250ZXh0LCBwYXRoKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8IFtdO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUuX3VwZGF0ZVBhdGggPSBmdW5jdGlvbihvcCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBvcFtpXTtcbiAgICAgIGlmKGMubG0gIT09IHVuZGVmaW5lZCAmJiBjb250YWluc1BhdGgodGhpcy5wYXRoLGMucCkpe1xuICAgICAgICB2YXIgbmV3X3BhdGhfcHJlZml4ID0gYy5wLnNsaWNlKDAsYy5wLmxlbmd0aC0xKTtcbiAgICAgICAgbmV3X3BhdGhfcHJlZml4LnB1c2goYy5sbSk7XG4gICAgICAgIHRoaXMucGF0aCA9IG5ld19wYXRoX3ByZWZpeC5jb25jYXQodGhpcy5wYXRoLnNsaWNlKG5ld19wYXRoX3ByZWZpeC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0QXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5jcmVhdGVDb250ZXh0QXQodGhpcy5wYXRoLmNvbmNhdChkZXBhdGgocGF0aCkpKTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoKXtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0KHBhdGgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ocGF0aCx2YWx1ZSxjYikge1xuICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsdmFsdWUsY2Ipe1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zZXQocGF0aCwgdmFsdWUsIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHBhdGgsIHBvcywgdmFsdWUsIGNiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgcG9zLCB2YWx1ZSwgY2Ipe1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pbnNlcnQocGF0aCwgcG9zLCB2YWx1ZSwgY2IpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocGF0aCwgY2IpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZW1vdmUocGF0aCwgY2IpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBjYikge1xuICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5pbnNlcnQocGF0aCwgdGhpcy5nZXQoKS5sZW5ndGgsIHZhbHVlLCBjYik7XG4gICAgfSk7XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24ocGF0aCwgZnJvbSwgdG8sIGNiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgZnJvbSwgdG8sIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm1vdmUocGF0aCwgZnJvbSwgdG8sIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhdGgsIGFtb3VudCwgY2IpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCBhbW91bnQsIGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmFkZChwYXRoLCBhbW91bnQsIGNiKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdWJEb2MucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5hZGRMaXN0ZW5lcih0aGlzLnBhdGgsIGV2ZW50LCBjYik7XG4gIH07XG5cbiAgU3ViRG9jLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJlbW92ZUxpc3RlbmVyKGwpO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0TGVuZ3RoKHBhdGgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldFRleHQocGF0aCk7XG4gICAgfSk7XG4gIH07XG4gIFxuICBTdWJEb2MucHJvdG90eXBlLmRlbGV0ZVRleHQgPSBmdW5jdGlvbihwYXRoLCBwb3MsIGxlbmd0aCwgY2IpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCBwb3MsIGxlbmd0aCwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZGVsZXRlVGV4dChwYXRoLCBsZW5ndGgsIHBvcywgY2IpO1xuICAgIH0pO1xuICB9O1xuXG4gIFN1YkRvYy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5fcmVtb3ZlU3ViRG9jKHRoaXMpO1xuICB9O1xuXG5cbiAgLy8gSlNPTiBBUEkgbWV0aG9kc1xuICAvLyB0aGVzZSBtZXRob2RzIGFyZSBtaXhlZCBpbiB0byB0aGUgY29udGV4dCByZXR1cm4gZnJvbSBkb2MuY3JlYXRlQ29udGV4dCgpXG5cbiAgX3R5cGUuYXBpID0ge1xuXG4gICAgcHJvdmlkZXM6IHtcbiAgICAgIGpzb246IHRydWVcbiAgICB9LFxuXG4gICAgX2ZpeENvbXBvbmVudFBhdGhzOiBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYy5uYSAhPT0gdW5kZWZpbmVkIHx8IGMuc2kgIT09IHVuZGVmaW5lZCB8fCBjLnNkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9fcmVtb3ZlID0gW107XG4gICAgICB2YXIgX3JlZiA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsID0gX3JlZltpXTtcbiAgICAgICAgdmFyIGR1bW15ID0ge1xuICAgICAgICAgIHA6IGwucGF0aCxcbiAgICAgICAgICBuYTogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgeGZvcm1lZCA9IF90eXBlLnRyYW5zZm9ybUNvbXBvbmVudChbXSwgZHVtbXksIGMsICdsZWZ0Jyk7XG4gICAgICAgIGlmICh4Zm9ybWVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRvX3JlbW92ZS5wdXNoKGkpO1xuICAgICAgICB9IGVsc2UgaWYgKHhmb3JtZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbC5wYXRoID0geGZvcm1lZFswXS5wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBhc3N1bXB0aW9uIGluIGpzb24tYXBpOiB4Zm9ybWluZyBhbiAnbmEnIG9wIHdpbGwgYWx3YXlzIHJlc3VsdCBpbiAwIG9yIDEgY29tcG9uZW50cy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9fcmVtb3ZlLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYiAtIGE7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRvX3JlbW92ZS5sZW5ndGg7IGorKykge1xuICAgICAgICBpID0gdG9fcmVtb3ZlW2pdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfSxcblxuICAgIF9maXhQYXRoczogZnVuY3Rpb24ob3ApIHtcbiAgICAgIHZhciBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG9wW2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuX2ZpeENvbXBvbmVudFBhdGhzKGMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9LFxuXG4gICAgX3N1Ym1pdDogZnVuY3Rpb24ob3AsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9maXhQYXRocyhvcCk7XG4gICAgICByZXR1cm4gdGhpcy5zdWJtaXRPcChvcCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBfYWRkU3ViRG9jOiBmdW5jdGlvbihzdWJkb2Mpe1xuICAgICAgdGhpcy5fc3ViZG9jcyB8fCAodGhpcy5fc3ViZG9jcyA9IFtdKTtcbiAgICAgIHRoaXMuX3N1YmRvY3MucHVzaChzdWJkb2MpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlU3ViRG9jOiBmdW5jdGlvbihzdWJkb2Mpe1xuICAgICAgdGhpcy5fc3ViZG9jcyB8fCAodGhpcy5fc3ViZG9jcyA9IFtdKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJkb2NzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYodGhpcy5fc3ViZG9jc1tpXSA9PT0gc3ViZG9jKSB0aGlzLl9zdWJkb2NzLnNwbGljZShpLDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSxcblxuICAgIF91cGRhdGVTdWJkb2NQYXRoczogZnVuY3Rpb24ob3Ape1xuICAgICAgdGhpcy5fc3ViZG9jcyB8fCAodGhpcy5fc3ViZG9jcyA9IFtdKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJkb2NzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5fc3ViZG9jc1tpXS5fdXBkYXRlUGF0aChvcCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbnRleHRBdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICB2YXIgc3ViZG9jID0gIG5ldyBTdWJEb2ModGhpcywgZGVwYXRoKHBhdGgpKTtcbiAgICAgIHRoaXMuX2FkZFN1YkRvYyhzdWJkb2MpO1xuICAgICAgcmV0dXJuIHN1YmRvYztcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBpZiAoIXBhdGgpIHJldHVybiB0aGlzLmdldFNuYXBzaG90KCk7ICBcbiAgICAgIFxuICAgICAgdmFyIF9yZWYgPSB0cmF2ZXJzZSh0aGlzLmdldFNuYXBzaG90KCksIHBhdGgpO1xuICAgICAgcmV0dXJuIF9yZWYuZWxlbVtfcmVmLmtleV07XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24ocGF0aCwgdmFsdWUsIGNiKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCB2YWx1ZSwgY2IpIHtcbiAgICAgICAgdmFyIF9yZWYgPSB0cmF2ZXJzZSh0aGlzLmdldFNuYXBzaG90KCksIHBhdGgpO1xuICAgICAgICB2YXIgZWxlbSA9IF9yZWYuZWxlbTtcbiAgICAgICAgdmFyIGtleSA9IF9yZWYua2V5O1xuICAgICAgICB2YXIgb3AgPSB7XG4gICAgICAgICAgcDogcGF0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlbGVtLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgIG9wLmxpID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGVtW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcC5sZCA9IGVsZW1ba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb3Aub2kgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGVsZW1ba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wLm9kID0gZWxlbVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwYXRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VibWl0KFtvcF0sIGNiKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHBhdGgsIGNiKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCBjYikge1xuICAgICAgICB2YXIgX3JlZiA9IHRyYXZlcnNlKHRoaXMuZ2V0U25hcHNob3QoKSwgcGF0aCk7XG4gICAgICAgIHZhciBlbGVtID0gX3JlZi5lbGVtO1xuICAgICAgICB2YXIga2V5ID0gX3JlZi5rZXk7XG4gICAgICAgIHZhciBvcCA9IHtcbiAgICAgICAgICBwOiBwYXRoXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBlbGVtZW50IGF0IHRoYXQgcGF0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW0uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgb3AubGQgPSBlbGVtW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb3Aub2QgPSBlbGVtW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcGF0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdChbb3BdLCBjYik7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihwYXRoLCBwb3MsIHZhbHVlLCBjYikge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgcG9zLCB2YWx1ZSwgY2IpIHtcbiAgICAgICAgdmFyIF9yZWYgPSB0cmF2ZXJzZSh0aGlzLmdldFNuYXBzaG90KCksIHBhdGgpO1xuICAgICAgICB2YXIgZWxlbSA9IF9yZWYuZWxlbTtcbiAgICAgICAgdmFyIGtleSA9IF9yZWYua2V5O1xuICAgICAgICB2YXIgb3AgPSB7XG4gICAgICAgICAgcDogcGF0aC5jb25jYXQocG9zKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlbGVtW2tleV0uY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgb3AubGkgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbVtrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG9wLnNpID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VibWl0KFtvcF0sIGNiKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtb3ZlOiBmdW5jdGlvbihwYXRoLCBmcm9tLCB0bywgY2IpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIGZyb20sIHRvLCBjYikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvcCA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwOiBwYXRoLmNvbmNhdChmcm9tKSxcbiAgICAgICAgICAgIGxtOiB0b1xuICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fc3VibWl0KG9wLCBmdW5jdGlvbigpe1xuICAgICAgICAgIHNlbGYuX3VwZGF0ZVN1YmRvY1BhdGhzKG9wKTtcbiAgICAgICAgICBpZihjYikgY2IuYXBwbHkoY2IsYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24ocGF0aCwgdmFsdWUsIGNiKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoLCB2YWx1ZSwgY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHBhdGgsIHRoaXMuZ2V0KCkubGVuZ3RoLCB2YWx1ZSwgY2IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24ocGF0aCwgYW1vdW50LCBjYikge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgdmFsdWUsIGNiKSB7XG4gICAgICAgIHZhciBvcCA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwOiBwYXRoLFxuICAgICAgICAgICAgbmE6IGFtb3VudFxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdChvcCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplQXJncyh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHBhdGgpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldFRleHQ6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHBhdGgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRlbGV0ZVRleHQ6IGZ1bmN0aW9uKHBhdGgsIGxlbmd0aCwgcG9zLCBjYikge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZUFyZ3ModGhpcyxhcmd1bWVudHMsZnVuY3Rpb24ocGF0aCwgbGVuZ3RoLCBwb3MsIGNiKSB7XG4gICAgICAgIHZhciBfcmVmID0gdHJhdmVyc2UodGhpcy5nZXRTbmFwc2hvdCgpLCBwYXRoKTtcbiAgICAgICAgdmFyIG9wID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHA6IHBhdGguY29uY2F0KHBvcyksXG4gICAgICAgICAgICBzZDogX3JlZi5lbGVtW19yZWYua2V5XS5zbGljZShwb3MsIHBvcyArIGxlbmd0aClcbiAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1Ym1pdChvcCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbihwYXRoLCBldmVudCwgY2IpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVBcmdzKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKHBhdGgsIHZhbHVlLCBjYikge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgY2I6IGNiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0gW10pO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX29uT3A6IGZ1bmN0aW9uKG9wKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gb3BbaV07XG4gICAgICAgIHRoaXMuX2ZpeENvbXBvbmVudFBhdGhzKGMpO1xuXG4gICAgICAgIGlmKGMubG0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVN1YmRvY1BhdGhzKFtjXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hfcGF0aCA9IGMubmEgPT09IHVuZGVmaW5lZCA/IGMucC5zbGljZSgwLCBjLnAubGVuZ3RoIC0gMSkgOiBjLnA7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnNbbF07XG4gICAgICAgICAgdmFyIGNiID0gbGlzdGVuZXIuY2I7XG5cbiAgICAgICAgICBpZiAocGF0aEVxdWFscyhsaXN0ZW5lci5wYXRoLCBtYXRjaF9wYXRoKSkge1xuICAgICAgICAgICAgc3dpdGNoIChsaXN0ZW5lci5ldmVudCkge1xuICAgICAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgICAgIGlmIChjLmxpICE9PSB1bmRlZmluZWQgJiYgYy5sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLmxpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMucFtjLnAubGVuZ3RoIC0gMV0sIGMub2kpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5zaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLnNpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKGMubGkgPT09IHVuZGVmaW5lZCAmJiBjLmxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMucFtjLnAubGVuZ3RoIC0gMV0sIGMubGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5vaSA9PT0gdW5kZWZpbmVkICYmIGMub2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2IoYy5wW2MucC5sZW5ndGggLSAxXSwgYy5vZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjLnNkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMucFtjLnAubGVuZ3RoIC0gMV0sIGMuc2QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgaWYgKGMubGkgIT09IHVuZGVmaW5lZCAmJiBjLmxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNiKGMucFtjLnAubGVuZ3RoIC0gMV0sIGMubGQsIGMubGkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5vaSAhPT0gdW5kZWZpbmVkICYmIGMub2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2IoYy5wW2MucC5sZW5ndGggLSAxXSwgYy5vZCwgYy5vaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgICBpZiAoYy5sbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBjYihjLnBbYy5wLmxlbmd0aCAtIDFdLCBjLmxtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgaWYgKGMubmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgY2IoYy5uYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGUuY2FuT3BBZmZlY3RPcChsaXN0ZW5lci5wYXRoLCBtYXRjaF9wYXRoKVxuICAgICAgICAgICAgICAmJiBsaXN0ZW5lci5ldmVudCA9PT0gJ2NoaWxkIG9wJykge1xuICAgICAgICAgICAgdmFyIGNoaWxkX3BhdGggPSBjLnAuc2xpY2UobGlzdGVuZXIucGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgY2IoY2hpbGRfcGF0aCwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuLy8gVGhpcyBmaWxlIGlzIGluY2x1ZGVkIGF0IHRoZSB0b3Agb2YgdGhlIGNvbXBpbGVkIGNsaWVudCBKUy5cblxuLy8gQWxsIHRoZSBtb2R1bGVzIHdpbGwganVzdCBhZGQgc3R1ZmYgdG8gZXhwb3J0cywgYW5kIGl0J2xsIGFsbCBnZXQgZXhwb3J0ZWQuXG52YXIgZXhwb3J0cyA9IHdpbmRvdy5zaGFyZWpzID0ge3ZlcnNpb246ICcwLjcuMCd9O1xuXG4vLyBUaGlzIGlzIGEgc2ltcGxlIHJld3JpdGUgb2YgbWljcm9ldmVudC5qcy4gSSd2ZSBjaGFuZ2VkIHRoZVxuLy8gZnVuY3Rpb24gbmFtZXMgdG8gYmUgY29uc2lzdGVudCB3aXRoIG5vZGUuanMgRXZlbnRFbWl0dGVyLlxuLy9cbi8vIG1pY3JvZXZlbnQuanMgaXMgY29weXJpZ2h0IEplcm9tZSBFdGllbm5lLCBhbmQgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2plcm9tZWV0aWVubmUvbWljcm9ldmVudC5qc1xuXG52YXIgTWljcm9FdmVudCA9IGZ1bmN0aW9uKCkge307XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIChldmVudHNbZXZlbnRdID0gZXZlbnRzW2V2ZW50XSB8fCBbXSkucHVzaChmbik7XG59O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50XSA9IGV2ZW50c1tldmVudF0gfHwgW107XG5cbiAgLy8gU2FkbHksIG5vIElFOCBzdXBwb3J0IGZvciBpbmRleE9mLlxuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIC8vIENvbXBhY3QgdGhlIGxpc3Qgd2hlbiBubyBldmVudCBoYW5kbGVyIGlzIGFjdHVhbGx5IHJ1bm5pbmcuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZXZlbnRzW2V2ZW50XSA9IFtdO1xuICAgIHZhciBmbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gT25seSBhZGQgYmFjayBldmVudCBoYW5kbGVycyB3aGljaCBleGlzdC5cbiAgICAgIGlmICgoZm4gPSBsaXN0ZW5lcnNbaV0pKSBldmVudHNbZXZlbnRdLnB1c2goZm4pO1xuICAgIH1cbiAgfSwgMCk7XG59O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpZiAoIWV2ZW50cyB8fCAhZXZlbnRzW2V2ZW50XSkge1xuICAgIGlmIChldmVudCA9PSAnZXJyb3InKSB7XG4gICAgICBpZiAoY29uc29sZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50XTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGlzdGVuZXJzW2ldKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gIHZhciBsaXN0ZW5lciwgX3RoaXMgPSB0aGlzO1xuICB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgIF90aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgZm4uYXBwbHkoX3RoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xufTtcblxuTWljcm9FdmVudC5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcHJvdG8gPSBvYmoucHJvdG90eXBlIHx8IG9iajtcbiAgcHJvdG8ub24gPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5vbjtcbiAgcHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiAgcHJvdG8uZW1pdCA9IE1pY3JvRXZlbnQucHJvdG90eXBlLmVtaXQ7XG4gIHByb3RvLm9uY2UgPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5vbmNlO1xuICByZXR1cm4gb2JqO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gTWljcm9FdmVudDtcblxudmFyIHR5cGVzLCBNaWNyb0V2ZW50O1xuXG5pZiAodHlwZW9mIGJyZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHR5cGVzID0gYnJlcXVpcmUoJ290dHlwZXMnKTtcbiAgTWljcm9FdmVudCA9IGJyZXF1aXJlKCcuL21pY3JvZXZlbnQnKTtcbn0gZWxzZSB7XG4gIHR5cGVzID0gd2luZG93Lm90dHlwZXM7XG59XG5cbi8qXG4gKiBBIERvYyBpcyBhIGNsaWVudCdzIHZpZXcgb24gYSBzaGFyZWpzIGRvY3VtZW50LlxuICpcbiAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIGNyZWF0ZWQgZGlyZWN0bHkuIENyZWF0ZSB0aGVtIGJ5IGNhbGxpbmcgdGhlXG4gKiBkb2N1bWVudCBnZXR0aW5nIGZ1bmN0aW9ucyBpbiBjb25uZWN0aW9uLlxuICpcbiAqIERvY3VtZW50cyBhcmUgZXZlbnQgZW1pdHRlcnMuIFVzZSBkb2Mub24oZXZlbnRuYW1lLCBmbikgdG8gc3Vic2NyaWJlLlxuICpcbiAqIERvY3VtZW50cyBjdXJyZW50bHkgZ2V0IG1peGVkIGluIHdpdGggdGhlaXIgdHlwZSdzIEFQSSBtZXRob2RzLiBTbywgeW91IGNhblxuICogLmluc2VydCgnZm9vJywgMCkgaW50byBhIHRleHQgZG9jdW1lbnQgYW5kIHN0dWZmIGxpa2UgdGhhdC5cbiAqXG4gKiBFdmVudHM6XG4gKiAtIGJlZm9yZSBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIGJlZm9yZSBhbiBvcGVyYXRpb24gaXMgYXBwbGllZCB0byB0aGVcbiAqICAgZG9jdW1lbnQuXG4gKiAtIG9wIChvcCwgbG9jYWxTaXRlKTogRmlyZWQgcmlnaHQgYWZ0ZXIgYW4gb3BlcmF0aW9uIChvciBwYXJ0IG9mIGFuXG4gKiAgIG9wZXJhdGlvbikgaGFzIGJlZW4gYXBwbGllZCB0byB0aGUgZG9jdW1lbnQuIFN1Ym1pdHRpbmcgYW5vdGhlciBvcCBoZXJlIGlzXG4gKiAgIGludmFsaWQgLSB3YWl0IHVudGlsICdhZnRlciBvcCcgaWYgeW91IHdhbnQgdG8gc3VibWl0IG1vcmUgb3BlcmF0aW9ucy4gIC1cbiAqICAgY2hhbmdlZCAob3ApXG4gKiAtIGFmdGVyIG9wIChvcCwgbG9jYWxTaXRlKTogRmlyZWQgYWZ0ZXIgYW4gb3BlcmF0aW9uIGhhcyBiZWVuIGFwcGxpZWQuIFlvdVxuICogICBjYW4gc3VibWl0IG1vcmUgb3BzIGhlcmUuXG4gKiAtIHN1YnNjcmliZWQgKGVycm9yKTogVGhlIGRvY3VtZW50IHdhcyBzdWJzY3JpYmVkXG4gKiAtIHVuc3Vic2NyaWJlZCAoZXJyb3IpOiBUaGUgZG9jdW1lbnQgd2FzIHVuc3Vic2NyaWJlZFxuICogLSBjcmVhdGVkOiBUaGUgZG9jdW1lbnQgd2FzIGNyZWF0ZWQuIFRoYXQgbWVhbnMgaXRzIHR5cGUgd2FzIHNldCBhbmQgaXQgaGFzXG4gKiAgIHNvbWUgaW5pdGlhbCBkYXRhLlxuICogLSBlcnJvclxuICovXG52YXIgRG9jID0gZXhwb3J0cy5Eb2MgPSBmdW5jdGlvbihjb25uZWN0aW9uLCBjb2xsZWN0aW9uLCBuYW1lKSB7XG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG5cbiAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgdGhpcy5uYW1lID0gbmFtZTtcblxuICB0aGlzLnZlcnNpb24gPSB0aGlzLnR5cGUgPSBudWxsO1xuXG4gIC8vICoqKiogU3RhdGUgaW4gZG9jdW1lbnQ6XG4gXG4gIC8vIEFjdGlvbi4gVGhpcyBpcyBlaXRoZXIgbnVsbCwgb3Igb25lIG9mIHRoZSBhY3Rpb25zIChzdWJzY3JpYmUsXG4gIC8vIHVuc3Vic2NyaWJlLCBmZXRjaCwgc3VibWl0KS4gT25seSBvbmUgYWN0aW9uIGNhbiBiZSBoYXBwZW5pbmcgYXQgYSB0aW1lIHRvXG4gIC8vIHByZXZlbnQgbWUgZnJvbSBnb2luZyBtYWQuXG4gIC8vXG4gIC8vIFBvc3NpYmxlIHZhbHVlczpcbiAgLy8gLSBzdWJzY3JpYmVcbiAgLy8gLSB1bnN1YnNjcmliZVxuICAvLyAtIGZldGNoXG4gIC8vIC0gc3VibWl0XG4gIHRoaXMuYWN0aW9uID0gbnVsbDtcbiBcbiAgLy8gVGhlIGRhdGEgdGhlIGRvY3VtZW50IG9iamVjdCBzdG9yZXMgY2FuIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRocmVlIHN0YXRlczpcbiAgLy8gICAtIE5vIGRhdGEuIChudWxsKSBXZSBob25lc3RseSBkb24ndCBrbm93IHdoYXRzIGdvaW5nIG9uLlxuICAvLyAgIC0gRmxvYXRpbmcgKCdmbG9hdGluZycpOiB3ZSBoYXZlIGEgbG9jYWxseSBjcmVhdGVkIGRvY3VtZW50IHRoYXQgaGFzbid0XG4gIC8vICAgICBiZWVuIGNyZWF0ZWQgb24gdGhlIHNlcnZlciB5ZXQpXG4gIC8vICAgLSBMaXZlICgncmVhZHknKSAod2UgaGF2ZSBkYXRhIHRoYXRzIGN1cnJlbnQgb24gdGhlIHNlcnZlciBhdCBzb21lIHZlcnNpb24pLlxuICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAvLyBPdXIgc3Vic2NyaXB0aW9uIHN0YXR1cy4gRWl0aGVyIHdlJ3JlIHN1YnNjcmliZWQgb24gdGhlIHNlcnZlciwgb3Igd2UgYXJlbid0LlxuICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgLy8gRWl0aGVyIHdlIHdhbnQgdG8gYmUgc3Vic2NyaWJlZCAodHJ1ZSksIHdlIHdhbnQgYSBuZXcgc25hcHNob3QgZnJvbSB0aGVcbiAgLy8gc2VydmVyICgnZmV0Y2gnKSwgb3Igd2UgZG9uJ3QgY2FyZSAoZmFsc2UpLiAgVGhpcyBpcyBhbHNvIHVzZWQgd2hlbiB3ZVxuICAvLyBkaXNjb25uZWN0ICYgcmVjb25uZWN0IHRvIGRlY2lkZSB3aGF0IHRvIGRvLlxuICB0aGlzLndhbnRTdWJzY3JpYmUgPSBmYWxzZTtcbiAgLy8gVGhpcyBsaXN0IGlzIHVzZWQgZm9yIHN1YnNjcmliZSBhbmQgdW5zdWJzY3JpYmUsIHNpbmNlIHdlJ2xsIG9ubHkgd2FudCB0b1xuICAvLyBkbyBvbmUgdGhpbmcgYXQgYSB0aW1lLlxuICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MgPSBbXTtcblxuXG4gIC8vICoqKiBlbmQgc3RhdGUgc3R1ZmYuXG5cbiAgLy8gVGhpcyBkb2Vzbid0IHByb3ZpZGUgYW55IHN0YW5kYXJkIEFQSSBhY2Nlc3MgcmlnaHQgbm93LlxuICB0aGlzLnByb3ZpZGVzID0ge307XG5cbiAgLy8gVGhlIGVkaXRpbmcgY29udGV4dHMuIFRoZXNlIGFyZSB1c3VhbGx5IGluc3RhbmNlcyBvZiB0aGUgdHlwZSBBUEkgd2hlbiB0aGVcbiAgLy8gZG9jdW1lbnQgaXMgcmVhZHkgZm9yIGVkaXRzLlxuICB0aGlzLmVkaXRpbmdDb250ZXh0cyA9IFtdO1xuICBcbiAgLy8gVGhlIG9wIHRoYXQgaXMgY3VycmVudGx5IHJvdW5kdHJpcHBpbmcgdG8gdGhlIHNlcnZlciwgb3IgbnVsbC5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgY29ubmVjdGlvbiByZWNvbm5lY3RzLCB0aGUgaW5mbGlnaHQgb3AgaXMgcmVzdWJtaXR0ZWQuXG4gIC8vXG4gIC8vIFRoaXMgaGFzIHRoZSBzYW1lIGZvcm1hdCBhcyBhbiBlbnRyeSBpbiBwZW5kaW5nRGF0YSwgd2hpY2ggaXM6XG4gIC8vIHtbY3JlYXRlOnsuLi59XSwgW2RlbDp0cnVlXSwgW29wOi4uLl0sIGNhbGxiYWNrczpbLi4uXSwgc3JjOiwgc2VxOn1cbiAgdGhpcy5pbmZsaWdodERhdGEgPSBudWxsO1xuXG4gIC8vIEFsbCBvcHMgdGhhdCBhcmUgd2FpdGluZyBmb3IgdGhlIHNlcnZlciB0byBhY2tub3dsZWRnZSBAaW5mbGlnaHREYXRhXG4gIC8vIFRoaXMgdXNlZCB0byBqdXN0IGJlIGEgc2luZ2xlIG9wZXJhdGlvbiwgYnV0IGNyZWF0ZXMgJiBkZWxldGVzIGNhbid0IGJlIGNvbXBvc2VkIHdpdGhcbiAgLy8gcmVndWxhciBvcGVyYXRpb25zLlxuICAvL1xuICAvLyBUaGlzIGlzIGEgbGlzdCBvZiB7W2NyZWF0ZTp7Li4ufV0sIFtkZWw6dHJ1ZV0sIFtvcDouLi5dLCBjYWxsYmFja3M6Wy4uLl19XG4gIHRoaXMucGVuZGluZ0RhdGEgPSBbXTtcbn07XG5cbk1pY3JvRXZlbnQubWl4aW4oRG9jKTtcblxuRG9jLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGRvYyA9IHRoaXM7XG4gIHRoaXMudW5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XG4gICAgLy8gRG9uJ3QgY2FyZSBpZiB0aGVyZSdzIGFuIGVycm9yIHVuc3Vic2NyaWJpbmcuXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVGhlcmUnbGwgcHJvYmFibHkgYmUgbm90aGluZyBoZXJlIHNlZWluZyBhcyBob3cgd2UganVzdCB1bnN1YnNjcmliZWQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRvYy5fc3Vic2NyaWJlQ2FsbGJhY2tzW2ldKCdEb2N1bWVudCBkZXN0cm95ZWQnKTtcbiAgICAgIH1cbiAgICAgIGRvYy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgfSwgMCk7XG5cbiAgICBkb2MuY29ubmVjdGlvbi5fZGVzdHJveURvYyhkb2MpO1xuICAgIGRvYy5yZW1vdmVDb250ZXh0cygpO1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgfSk7XG59O1xuXG5cbi8vICoqKioqKiBNYW5pcHVsYXRpbmcgdGhlIGRvY3VtZW50IHNuYXBzaG90LCB2ZXJzaW9uIGFuZCB0eXBlLlxuXG4vLyBTZXQgdGhlIGRvY3VtZW50J3MgdHlwZSwgYW5kIGFzc29jaWF0ZWQgcHJvcGVydGllcy4gTW9zdCBvZiB0aGUgbG9naWMgaW5cbi8vIHRoaXMgZnVuY3Rpb24gZXhpc3RzIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQgYmFzZWQgb24gYW55IGFkZGVkICYgcmVtb3ZlZCBBUElcbi8vIG1ldGhvZHMuXG5Eb2MucHJvdG90eXBlLl9zZXRUeXBlID0gZnVuY3Rpb24obmV3VHlwZSkge1xuICBpZiAodHlwZW9mIG5ld1R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF0eXBlc1tuZXdUeXBlXSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0eXBlIFwiICsgbmV3VHlwZSk7XG4gICAgbmV3VHlwZSA9IHR5cGVzW25ld1R5cGVdO1xuICB9XG4gIHRoaXMucmVtb3ZlQ29udGV4dHMoKTtcblxuICAvLyBTZXQgdGhlIG5ldyB0eXBlXG4gIHRoaXMudHlwZSA9IG5ld1R5cGU7XG5cbiAgLy8gSWYgd2UgcmVtb3ZlZCB0aGUgdHlwZSBmcm9tIHRoZSBvYmplY3QsIGFsc28gcmVtb3ZlIGl0cyBzbmFwc2hvdC5cbiAgaWYgKCFuZXdUeXBlKSB7XG4gICAgdGhpcy5wcm92aWRlcyA9IHt9O1xuICB9IGVsc2UgaWYgKG5ld1R5cGUuYXBpKSB7XG4gICAgLy8gUmVnaXN0ZXIgdGhlIG5ldyB0eXBlJ3MgQVBJLlxuICAgIHRoaXMucHJvdmlkZXMgPSBuZXdUeXBlLmFwaS5wcm92aWRlcztcbiAgfVxufTtcblxuLy8gSW5qZXN0IHNuYXBzaG90IGRhdGEuIFRoaXMgZGF0YSBtdXN0IGluY2x1ZGUgYSB2ZXJzaW9uLCBzbmFwc2hvdCBhbmQgdHlwZS5cbi8vIFRoaXMgaXMgdXNlZCBib3RoIHRvIGluamVzdCBkYXRhIHRoYXQgd2FzIGV4cG9ydGVkIHdpdGggYSB3ZWJwYWdlIGFuZCBkYXRhXG4vLyB0aGF0IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgZHVyaW5nIGEgZmV0Y2guXG5Eb2MucHJvdG90eXBlLmluamVzdERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4oJ0lnbm9yaW5nIGF0dGVtcHQgdG8gaW5qZXN0IGRhdGEgaW4gc3RhdGUnLCB0aGlzLnN0YXRlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhLnYgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmVyc2lvbiBpbiBpbmplc3RlZCBkYXRhJyk7XG5cblxuICB0aGlzLnZlcnNpb24gPSBkYXRhLnY7XG4gIHRoaXMuc25hcHNob3QgPSBkYXRhLnNuYXBzaG90O1xuICB0aGlzLl9zZXRUeXBlKGRhdGEudHlwZSk7XG5cbiAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gIHRoaXMuZW1pdCgncmVhZHknKTtcbn07XG5cbi8vIEdldCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IGRvY3VtZW50IHNuYXBzaG90LlxuRG9jLnByb3RvdHlwZS5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zbmFwc2hvdDtcbn07XG5cbi8vIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhdCBhIHRpbWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGEgc25hcHNob3QgYW5kXG4vLyB5b3UgY2FuIHN0YXJ0IGFwcGx5aW5nIG9wZXJhdGlvbnMuIFRoaXMgbWF5IGJlIGltbWVkaWF0ZWx5LlxuRG9jLnByb3RvdHlwZS53aGVuUmVhZHkgPSBmdW5jdGlvbihmbikge1xuICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5Jykge1xuICAgIGZuKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gIH1cbn07XG5cbkRvYy5wcm90b3R5cGUuaGFzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbmZsaWdodERhdGEgIT0gbnVsbCB8fCAhIXRoaXMucGVuZGluZ0RhdGEubGVuZ3RoO1xufTtcblxuXG4vLyAqKioqIEhlbHBlcnMgZm9yIG5ldHdvcmsgbWVzc2FnZXNcblxuLy8gU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGNvbm5lY3Rpb24gZnJvbSB0aGlzIGRvY3VtZW50LlxuRG9jLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgbWVzc2FnZS5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtZXNzYWdlLmQgPSB0aGlzLm5hbWU7XG4gIHRoaXMuY29ubmVjdGlvbi5zZW5kKG1lc3NhZ2UpO1xufTtcblxuLy8gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIGNvbm5lY3Rpb24gd2hlbiBpdCByZWNlaXZlcyBhIG1lc3NhZ2UgZm9yIHRoZSBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAoIShtc2cuYyA9PT0gdGhpcy5jb2xsZWN0aW9uICYmIG1zZy5kID09PSB0aGlzLm5hbWUpKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIC0gaXRzIGEgc2FuaXR5IGNoZWNrIGZvciBidWdzIGluIHRoZSBjb25uZWN0aW9uIGNvZGUuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiR290IG1lc3NhZ2UgZm9yIHdyb25nIGRvY3VtZW50LlwiKTtcbiAgfVxuXG4gIC8vIG1zZy5hID0gdGhlIGFjdGlvbi5cbiAgc3dpdGNoIChtc2cuYSkge1xuICAgIGNhc2UgJ2ZldGNoJzpcbiAgICAgIC8vIFdlJ3JlIGRvbmUgZmV0Y2hpbmcuIFRoaXMgbWVzc2FnZSBoYXMgbm8gb3RoZXIgaW5mb3JtYXRpb24uXG4gICAgICBpZiAobXNnLmRhdGEpIHRoaXMuaW5qZXN0RGF0YShtc2cuZGF0YSk7XG4gICAgICB0aGlzLl9maW5pc2hTdWIoJ2ZldGNoJywgbXNnLmVycm9yKTtcbiAgICAgIGlmICh0aGlzLndhbnRTdWJzY3JpYmUgPT09ICdmZXRjaCcpIHRoaXMud2FudFN1YnNjcmliZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fY2xlYXJBY3Rpb24oJ2ZldGNoJyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3N1Yic6XG4gICAgICAvLyBTdWJzY3JpYmUgcmVwbHkuXG4gICAgICBpZiAobXNnLmVycm9yICYmIG1zZy5lcnJvciAhPT0gJ0FscmVhZHkgc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3Qgc3Vic2NyaWJlOiBcIiArIG1zZy5lcnJvcik7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBtc2cuZXJyb3IpO1xuICAgICAgICAvLyBUaGVyZSdzIHByb2JhYmx5IGEgcmVhc29uIHdlIGNvdWxkbid0IHN1YnNjcmliZS4gRG9uJ3QgcmV0cnkuXG4gICAgICAgIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUoZmFsc2UsIG51bGwsIG1zZy5lcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtc2cuZGF0YSkgdGhpcy5pbmplc3REYXRhKG1zZy5kYXRhKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdWJzY3JpYmUnKTtcbiAgICAgICAgdGhpcy5fZmluaXNoU3ViKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhckFjdGlvbignc3Vic2NyaWJlJyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Vuc3ViJzpcbiAgICAgIC8vIFVuc3Vic2NyaWJlIHJlcGx5XG4gICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmUnKTtcblxuICAgICAgdGhpcy5fZmluaXNoU3ViKGZhbHNlLCBtc2cuZXJyb3IpO1xuICAgICAgdGhpcy5fY2xlYXJBY3Rpb24oJ3Vuc3Vic2NyaWJlJyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Fjayc6XG4gICAgICAvLyBBY2tub3dsZWRnZSBhIGxvY2FsbHkgc3VibWl0dGVkIG9wZXJhdGlvbi5cbiAgICAgIC8vXG4gICAgICAvLyBVc3VhbGx5IHdlIGRvIG5vdGhpbmcgaGVyZSAtIGFsbCB0aGUgaW50ZXJlc3RpbmcgbG9naWMgaGFwcGVucyB3aGVuIHdlXG4gICAgICAvLyBnZXQgc2VudCBvdXIgb3AgYmFjayBpbiB0aGUgb3Agc3RyZWFtICh3aGljaCBoYXBwZW5zIGV2ZW4gaWYgd2UgYXJlbid0XG4gICAgICAvLyBzdWJzY3JpYmVkKS4gSG93ZXZlciwgaWYgdGhlIG9wIGRvZXNuJ3QgZ2V0IGFjY2VwdGVkLCB3ZSBzdGlsbCBuZWVkIHRvXG4gICAgICAvLyBjbGVhciBzb21lIHN0YXRlLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBtZXNzYWdlIGVycm9yIGlzICdPcCBhbHJlYWR5IHN1Ym1pdHRlZCcsIHRoYXQgbWVhbnMgd2UndmVcbiAgICAgIC8vIHJlc2VudCBhbiBvcCB0aGF0IHRoZSBzZXJ2ZXIgYWxyZWFkeSBnb3QuIEl0IHdpbGwgYWxzbyBiZSBjb25maXJtZWRcbiAgICAgIC8vIG5vcm1hbGx5LlxuICAgICAgaWYgKG1zZy5lcnJvciAmJiBtc2cuZXJyb3IgIT09ICdPcCBhbHJlYWR5IHN1Ym1pdHRlZCcpIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBoYXMgcmVqZWN0ZWQgYW4gb3AgZnJvbSB0aGUgY2xpZW50IGZvciBzb21lIHJlYXNvbi5cbiAgICAgICAgLy8gV2UnbGwgc2VuZCB0aGUgZXJyb3IgbWVzc2FnZSB0byB0aGUgdXNlciBhbmQgdHJ5IHRvIHJvbGwgYmFjayB0aGUgY2hhbmdlLlxuICAgICAgICBpZiAodGhpcy5pbmZsaWdodERhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ09wZXJhdGlvbiB3YXMgcmVqZWN0ZWQgKCcgKyBtc2cuZXJyb3IgKyAnKS4gVHJ5aW5nIHRvIHJvbGxiYWNrIGNoYW5nZSBsb2NhbGx5LicpO1xuICAgICAgICAgIHRoaXMuX3RyeVJvbGxiYWNrKHRoaXMuaW5mbGlnaHREYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJIG1hbmFnZWQgdG8gZ2V0IGludG8gdGhpcyBzdGF0ZSBvbmNlLiBJJ20gbm90IHN1cmUgaG93IGl0IGhhcHBlbmVkLlxuICAgICAgICAgIC8vIFRoZSBvcCB3YXMgbWF5YmUgZG91YmxlLWFja25vd2xlZGdlZD9cbiAgICAgICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdTZWNvbmQgYWNrbm93bGVkZ2VtZW50IG1lc3NhZ2UgKGVycm9yKSByZWNlaXZlZCcsIG1zZywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgdGhpcy5fY2xlYXJJbmZsaWdodE9wKG1zZy5lcnJvcik7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wJzpcbiAgICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSAmJlxuICAgICAgICAgIG1zZy5zcmMgPT09IHRoaXMuaW5mbGlnaHREYXRhLnNyYyAmJlxuICAgICAgICAgIG1zZy5zZXEgPT09IHRoaXMuaW5mbGlnaHREYXRhLnNlcSkge1xuICAgICAgICAvLyBUaGlzIG9uZSBpcyBtaW5lLiBBY2NlcHQgaXQgYXMgYWNrbm93bGVkZ2VkLlxuICAgICAgICB0aGlzLl9vcEFja25vd2xlZGdlZChtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy52ICE9PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgLy8gSSBzaG91bGQgYWRkIHRoZSBuYW1lIG9mIHRoZSBkb2N1bWVudCB0byBhbGwgZXJyb3JzIC0gbW9zdGx5IHRoaXMgaXNcbiAgICAgICAgLy8gdG8gdHJhY2sgZG93biBvbmUgcGFydGljdWxhciBidWcuXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCAnSW4gZG9jdW1lbnQgJyArIHRoaXMubmFtZSArICcgZXhwZWN0ZWQgdmVyc2lvbiAnICsgdGhpcy52ZXJzaW9uICsgJyBidXQgZ290ICcgKyBtc2cudik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbmZsaWdodERhdGEpIHhmKHRoaXMuaW5mbGlnaHREYXRhLCBtc2cpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeGYodGhpcy5wZW5kaW5nRGF0YVtpXSwgbXNnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52ZXJzaW9uKys7XG4gICAgICB0aGlzLl9vdEFwcGx5KG1zZywgZmFsc2UpO1xuICAgICAgdGhpcy5fYWZ0ZXJPdEFwcGx5KG1zZywgZmFsc2UpO1xuICAgICAgLy9jb25zb2xlLmxvZygnYXBwbGllZCcsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtZXRhJzpcbiAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ1VuaGFuZGxlZCBtZXRhIG9wOicsIG1zZyk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgZG9jdW1lbnQgbWVzc2FnZTonLCBtc2cpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIENhbGxlZCB3aGVuZXZlciAoeW91IGd1ZXNzZWQgaXQhKSB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzLiBUaGlzIHdpbGxcbi8vIGhhcHBlbiB3aGVuIHdlIGdldCBkaXNjb25uZWN0ZWQgJiByZWNvbm5lY3QuXG5Eb2MucHJvdG90eXBlLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uKSB7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB7XG4gICAgICB0aGlzLl9zZW5kT3BEYXRhKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgLy8gV2UgZ28gaW50byB0aGUgY29ubmVjdGVkIHN0YXRlIG9uY2Ugd2UgaGF2ZSBhIHNlc3Npb25JRC4gV2UgY2FuJ3Qgc2VuZFxuICAgIC8vIG5ldyBvcHMgdW50aWwgdGhlbiwgc28gd2UgbmVlZCB0byBmbHVzaCBhZ2Fpbi5cbiAgICB0aGlzLmZsdXNoKCk7XG4gIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQpIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVkJyk7XG4gIH1cbn07XG5cblxuXG5cbi8vICoqKioqKiBEZWFsaW5nIHdpdGggYWN0aW9uc1xuXG5Eb2MucHJvdG90eXBlLl9jbGVhckFjdGlvbiA9IGZ1bmN0aW9uKGV4cGVjdGVkQWN0aW9uKSB7XG4gIGlmICh0aGlzLmFjdGlvbiAhPT0gZXhwZWN0ZWRBY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgYWN0aW9uICcgKyB0aGlzLmFjdGlvbiArICcgZXhwZWN0ZWQ6ICcgKyBleHBlY3RlZEFjdGlvbik7XG4gIH1cbiAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG5cblxuLy8gU2VuZCB0aGUgbmV4dCBwZW5kaW5nIG9wIHRvIHRoZSBzZXJ2ZXIsIGlmIHdlIGNhbi5cbi8vXG4vLyBPbmx5IG9uZSBvcGVyYXRpb24gY2FuIGJlIGluLWZsaWdodCBhdCBhIHRpbWUuIElmIGFuIG9wZXJhdGlvbiBpcyBhbHJlYWR5IG9uXG4vLyBpdHMgd2F5LCBvciB3ZSdyZSBub3QgY3VycmVudGx5IGNvbm5lY3RlZCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuRG9jLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY29ubmVjdGlvbi5jYW5TZW5kIHx8IHRoaXMuYWN0aW9uKSByZXR1cm47XG5cbiAgdmFyIG9wRGF0YTtcbiAgLy8gUHVtcCBhbmQgZHVtcCBhbnkgbm8tb3BzIGZyb20gdGhlIGZyb250IG9mIHRoZSBwZW5kaW5nIG9wIGxpc3QuXG4gIHdoaWxlICh0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJiBpc05vT3Aob3BEYXRhID0gdGhpcy5wZW5kaW5nRGF0YVswXSkpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gb3BEYXRhLmNhbGxiYWNrcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2tzW2ldKG9wRGF0YS5lcnJvcik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0RhdGEuc2hpZnQoKTtcbiAgfVxuXG4gIC8vIEZpcnN0IGNvbnNpZGVyIGNoYW5naW5nIHN0YXRlXG4gIGlmICh0aGlzLnN1YnNjcmliZWQgJiYgIXRoaXMud2FudFN1YnNjcmliZSkge1xuICAgIHRoaXMuYWN0aW9uID0gJ3Vuc3Vic2NyaWJlJztcbiAgICB0aGlzLl9zZW5kKHthOid1bnN1Yid9KTtcbiAgfSBlbHNlIGlmICghdGhpcy5zdWJzY3JpYmVkICYmIHRoaXMud2FudFN1YnNjcmliZSA9PT0gJ2ZldGNoJykge1xuICAgIHRoaXMuYWN0aW9uID0gJ2ZldGNoJztcbiAgICB0aGlzLl9zZW5kKHRoaXMuc3RhdGUgPT09ICdyZWFkeScgPyB7YTonZmV0Y2gnLCB2OnRoaXMudmVyc2lvbn0gOiB7YTonZmV0Y2gnfSk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuc3Vic2NyaWJlZCAmJiB0aGlzLndhbnRTdWJzY3JpYmUpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICdzdWJzY3JpYmUnO1xuICAgIHRoaXMuX3NlbmQodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5JyA/IHthOidzdWInLCB2OnRoaXMudmVyc2lvbn0gOiB7YTonc3ViJ30pO1xuICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgLy8gVHJ5IGFuZCBzZW5kIGFueSBwZW5kaW5nIG9wcy4gV2UgY2FuJ3Qgc2VuZCBvcHMgd2hpbGUgaW4gXG4gICAgdGhpcy5pbmZsaWdodERhdGEgPSB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG5cbiAgICAvLyBEZWxheSBmb3IgZGVidWdnaW5nLlxuICAgIC8vdmFyIHRoYXQgPSB0aGlzO1xuICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5fc2VuZE9wRGF0YSgpOyB9LCAxMDAwKTtcblxuICAgIC8vIFRoaXMgYWxzbyBzZXRzIGFjdGlvbiB0byAnc3VibWl0Jy5cbiAgICB0aGlzLl9zZW5kT3BEYXRhKCk7XG4gIH1cbn07XG5cblxuLy8gKioqKioqIFN1YnNjcmliaW5nLCB1bnN1YnNjcmliaW5nIGFuZCBmZXRjaGluZ1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgaWFyZSBjb3BpZWQgaW50byB0aGUgcXVlcnkgY2xhc3MgYXMgd2VsbCwgc28gYmUgY2FyZWZ1bCBtYWtpbmdcbi8vIGNoYW5nZXMgaGVyZS5cblxuLy8gVmFsdWUgaXMgdHJ1ZSwgZmFsc2Ugb3IgJ2ZldGNoJy5cbkRvYy5wcm90b3R5cGUuX3NldFdhbnRTdWJzY3JpYmUgPSBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2ssIGVycikge1xuICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSB0aGlzLndhbnRTdWJzY3JpYmUgJiZcbiAgICAgICh0aGlzLnN1YnNjcmliZWQgPT09IHZhbHVlIHx8IHZhbHVlID09PSAnZmV0Y2gnICYmIHRoaXMuc3Vic2NyaWJlZCkpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBpZiAoIXRoaXMud2FudFN1YnNjcmliZSAhPT0gIXZhbHVlKSB7XG4gICAgLy8gQ2FsbCBhbGwgdGhlIGN1cnJlbnQgc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGNhbGxiYWNrcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gU2hvdWxkIEkgcmV0dXJuIGFuIGVycm9yIGhlcmU/IFdoYXQgaGFwcGVuZWQgaXMgdGhlIHVzZXIgdW5zdWJjcmliZWRcbiAgICAgIC8vIHdpdGggYSBjYWxsYmFjayB0aGVuIHJlc3Vic2NyaWJlZCBzdHJhaWdodCBhZnRlci4gRG9lcyB0aGF0IG1lYW4gdGhlXG4gICAgICAvLyB1bnN1YnNjcmliZSBmYWlsZWQ/XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvLyBJZiB3ZSB3YW50IHRvIHN1YnNjcmliZSwgZG9uJ3Qgd2Vha2VuIGl0IHRvIGEgZmV0Y2guXG4gIGlmICh2YWx1ZSAhPT0gJ2ZldGNoJyB8fCB0aGlzLndhbnRTdWJzY3JpYmUgIT09IHRydWUpXG4gICAgdGhpcy53YW50U3Vic2NyaWJlID0gdmFsdWU7XG5cbiAgaWYgKGNhbGxiYWNrKSB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8vIE9wZW4gdGhlIGRvY3VtZW50LiBUaGVyZSBpcyBubyBjYWxsYmFjayBhbmQgbm8gZXJyb3IgaGFuZGxpbmcgaWYgeW91J3JlXG4vLyBhbHJlYWR5IGNvbm5lY3RlZC5cbi8vXG4vLyBPbmx5IGNhbGwgdGhpcyBvbmNlIHBlciBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSh0cnVlLCBjYWxsYmFjayk7XG59O1xuXG4vLyBVbnN1YnNjcmliZS4gVGhlIGRhdGEgd2lsbCBzdGF5IGFyb3VuZCBpbiBsb2NhbCBtZW1vcnksIGJ1dCB3ZSdsbCBzdG9wXG4vLyByZWNlaXZpbmcgdXBkYXRlcy5cbkRvYy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl9zZXRXYW50U3Vic2NyaWJlKGZhbHNlLCBjYWxsYmFjayk7XG59O1xuXG4vLyBDYWxsIHRvIHJlcXVlc3QgZnJlc2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSgnZmV0Y2gnLCBjYWxsYmFjayk7XG59O1xuXG4vLyBDYWxsZWQgd2hlbiBvdXIgc3Vic2NyaWJlLCBmZXRjaCBvciB1bnN1YnNjcmliZSBtZXNzYWdlcyBhcmUgYWNrbm93bGVkZ2VkLlxuRG9jLnByb3RvdHlwZS5fZmluaXNoU3ViID0gZnVuY3Rpb24odmFsdWUsIGVycm9yKSB7XG4gIGlmICh2YWx1ZSA9PT0gdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrc1tpXShlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICB9XG59O1xuXG5cbi8vIE9wZXJhdGlvbnNcblxuXG4vLyAqKioqKioqKioqKiogRGVhbGluZyB3aXRoIG9wZXJhdGlvbnMuXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgb3BEYXRhIHRvIGNvbnRhaW4gYSBuby1vcC5cbnZhciBzZXROb09wID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIGRlbGV0ZSBvcERhdGEub3A7XG4gIGRlbGV0ZSBvcERhdGEuY3JlYXRlO1xuICBkZWxldGUgb3BEYXRhLmRlbDtcbn07XG5cbnZhciBpc05vT3AgPSBmdW5jdGlvbihvcERhdGEpIHtcbiAgcmV0dXJuICFvcERhdGEub3AgJiYgIW9wRGF0YS5jcmVhdGUgJiYgIW9wRGF0YS5kZWw7XG59XG5cbi8vIFRyeSB0byBjb21wb3NlIGRhdGEyIGludG8gZGF0YTEuIFJldHVybnMgdHJ1dGh5IGlmIGl0IHN1Y2NlZWRzLCBvdGhlcndpc2UgZmFsc3kuXG52YXIgdHJ5Q29tcG9zZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGExLCBkYXRhMikge1xuICBpZiAoZGF0YTEuY3JlYXRlICYmIGRhdGEyLmRlbCkge1xuICAgIHNldE5vT3AoZGF0YTEpO1xuICB9IGVsc2UgaWYgKGRhdGExLmNyZWF0ZSAmJiBkYXRhMi5vcCkge1xuICAgIC8vIENvbXBvc2UgdGhlIGRhdGEgaW50byB0aGUgY3JlYXRlIGRhdGEuXG4gICAgdmFyIGRhdGEgPSAoZGF0YTEuY3JlYXRlLmRhdGEgPT09IHVuZGVmaW5lZCkgPyB0eXBlLmNyZWF0ZSgpIDogZGF0YTEuY3JlYXRlLmRhdGE7XG4gICAgZGF0YTEuY3JlYXRlLmRhdGEgPSB0eXBlLmFwcGx5KGRhdGEsIGRhdGEyLm9wKTtcbiAgfSBlbHNlIGlmIChpc05vT3AoZGF0YTEpKSB7XG4gICAgZGF0YTEuY3JlYXRlID0gZGF0YTIuY3JlYXRlO1xuICAgIGRhdGExLmRlbCA9IGRhdGEyLmRlbDtcbiAgICBkYXRhMS5vcCA9IGRhdGEyLm9wO1xuICB9IGVsc2UgaWYgKGRhdGExLm9wICYmIGRhdGEyLm9wICYmIHR5cGUuY29tcG9zZSkge1xuICAgIGRhdGExLm9wID0gdHlwZS5jb21wb3NlKGRhdGExLm9wLCBkYXRhMi5vcCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gVHJhbnNmb3JtIHNlcnZlciBvcCBkYXRhIGJ5IGEgY2xpZW50IG9wLCBhbmQgdmljZSB2ZXJzYS4gT3BzIGFyZSBlZGl0ZWQgaW4gcGxhY2UuXG52YXIgeGYgPSBmdW5jdGlvbihjbGllbnQsIHNlcnZlcikge1xuICAvLyBJbiB0aGlzIGNhc2UsIHdlJ3JlIGluIGZvciBzb21lIGZ1bi4gVGhlcmUgYXJlIHNvbWUgbG9jYWwgb3BlcmF0aW9uc1xuICAvLyB3aGljaCBhcmUgdG90YWxseSBpbnZhbGlkIC0gZWl0aGVyIHRoZSBjbGllbnQgY29udGludWVkIGVkaXRpbmcgYVxuICAvLyBkb2N1bWVudCB0aGF0IHNvbWVvbmUgZWxzZSBkZWxldGVkIG9yIGEgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYm90aCBvbiB0aGVcbiAgLy8gY2xpZW50IGFuZCBvbiB0aGUgc2VydmVyLiBJbiBlaXRoZXIgY2FzZSwgdGhlIGxvY2FsIGRvY3VtZW50IGlzIHdheVxuICAvLyBpbnZhbGlkIGFuZCB0aGUgY2xpZW50J3Mgb3BzIGFyZSB1c2VsZXNzLlxuICAvL1xuICAvLyBUaGUgY2xpZW50IGJlY29tZXMgYSBuby1vcCwgYW5kIHdlIGtlZXAgdGhlIHNlcnZlciBvcCBlbnRpcmVseS5cbiAgaWYgKHNlcnZlci5jcmVhdGUgfHwgc2VydmVyLmRlbCkgcmV0dXJuIHNldE5vT3AoY2xpZW50KTtcbiAgaWYgKGNsaWVudC5jcmVhdGUpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZS4gVGhpcyBpcyBhIGJ1Zy4nKTtcblxuICAvLyBUaGUgY2xpZW50IGhhcyBkZWxldGVkIHRoZSBkb2N1bWVudCB3aGlsZSB0aGUgc2VydmVyIGVkaXRlZCBpdC4gS2lsbCB0aGVcbiAgLy8gc2VydmVyJ3Mgb3AuXG4gIGlmIChjbGllbnQuZGVsKSByZXR1cm4gc2V0Tm9PcChzZXJ2ZXIpO1xuXG4gIC8vIFdlIG9ubHkgZ2V0IGhlcmUgaWYgZWl0aGVyIHRoZSBzZXJ2ZXIgb3IgY2xpZW50IG9wcyBhcmUgbm8tb3AuIENhcnJ5IG9uLFxuICAvLyBub3RoaW5nIHRvIHNlZSBoZXJlLlxuICBpZiAoIXNlcnZlci5vcCB8fCAhY2xpZW50Lm9wKSByZXR1cm47XG5cbiAgLy8gVGhleSBib3RoIGVkaXRlZCB0aGUgZG9jdW1lbnQuIFRoaXMgaXMgdGhlIG5vcm1hbCBjYXNlIGZvciB0aGlzIGZ1bmN0aW9uIC1cbiAgLy8gYXMgaW4sIG1vc3Qgb2YgdGhlIHRpbWUgd2UnbGwgZW5kIHVwIGRvd24gaGVyZS5cbiAgLy9cbiAgLy8gWW91IHNob3VsZCBiZSB3b25kZXJpbmcgd2h5IEknbSB1c2luZyBjbGllbnQudHlwZSBpbnN0ZWFkIG9mIHRoaXMudHlwZS5cbiAgLy8gVGhlIHJlYXNvbiBpcywgaWYgd2UgZ2V0IG9wcyBhdCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQsIHRoaXMudHlwZVxuICAvLyBtaWdodCBiZSB1bmRlZmluZWQgb3IgYSB0b3RhbGx5IGRpZmZlcmVudCB0eXBlLiBCeSBwaW5uaW5nIHRoZSB0eXBlIHRvIHRoZVxuICAvLyBvcCBkYXRhLCB3ZSBtYWtlIHN1cmUgdGhlIHJpZ2h0IHR5cGUgaGFzIGl0cyB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FsbGVkLlxuICBpZiAoY2xpZW50LnR5cGUudHJhbnNmb3JtWCkge1xuICAgIHZhciByZXN1bHQgPSBjbGllbnQudHlwZS50cmFuc2Zvcm1YKGNsaWVudC5vcCwgc2VydmVyLm9wKTtcbiAgICBjbGllbnQub3AgPSByZXN1bHRbMF07XG4gICAgc2VydmVyLm9wID0gcmVzdWx0WzFdO1xuICB9IGVsc2Uge1xuICAgIC8vY29uc29sZS5sb2coJ3hmJywgSlNPTi5zdHJpbmdpZnkoY2xpZW50Lm9wKSwgSlNPTi5zdHJpbmdpZnkoc2VydmVyLm9wKSk7XG4gICAgdmFyIF9jID0gY2xpZW50LnR5cGUudHJhbnNmb3JtKGNsaWVudC5vcCwgc2VydmVyLm9wLCAnbGVmdCcpO1xuICAgIHZhciBfcyA9IGNsaWVudC50eXBlLnRyYW5zZm9ybShzZXJ2ZXIub3AsIGNsaWVudC5vcCwgJ3JpZ2h0Jyk7XG4gICAgY2xpZW50Lm9wID0gX2M7IHNlcnZlci5vcCA9IF9zO1xuICAgIC8vY29uc29sZS5sb2coJy0+JywgSlNPTi5zdHJpbmdpZnkoY2xpZW50Lm9wKSwgSlNPTi5zdHJpbmdpZnkoc2VydmVyLm9wKSk7XG4gIH1cbn07XG5cbi8vIEludGVybmFsIG1ldGhvZCB0byBhY3R1YWxseSBhcHBseSB0aGUgZ2l2ZW4gb3AgZGF0YSB0byBvdXIgbG9jYWwgbW9kZWwuXG4vL1xuLy8gX2FmdGVyT3RBcHBseSgpIHNob3VsZCBhbHdheXMgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXJ3YXJkcy5cbkRvYy5wcm90b3R5cGUuX290QXBwbHkgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQpIHtcbiAgLy8gTG9jayB0aGUgZG9jdW1lbnQuIE5vYm9keSBpcyBhbGxvd2VkIHRvIGNhbGwgc3VibWl0T3AoKSB1bnRpbCBfYWZ0ZXJPdEFwcGx5IGlzIGNhbGxlZC5cbiAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuXG4gIGlmIChvcERhdGEuY3JlYXRlKSB7XG4gICAgLy8gSWYgdGhlIHR5cGUgaXMgY3VycmVudGx5IHNldCwgaXQgbWVhbnMgd2UgdHJpZWQgY3JlYXRpbmcgdGhlIGRvY3VtZW50XG4gICAgLy8gYW5kIHNvbWVvbmUgZWxzZSB3b24uIGNsaWVudCBjcmVhdGUgeCBzZXJ2ZXIgY3JlYXRlID0gc2VydmVyIGNyZWF0ZS5cbiAgICB2YXIgY3JlYXRlID0gb3BEYXRhLmNyZWF0ZTtcbiAgICB0aGlzLl9zZXRUeXBlKGNyZWF0ZS50eXBlKTtcbiAgICB0aGlzLnNuYXBzaG90ID0gdGhpcy50eXBlLmNyZWF0ZShjcmVhdGUuZGF0YSk7XG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IGhlYXZ5d2VpZ2h0LCBidXQgSSB3YW50IHRoZSBjcmVhdGVkIGV2ZW50IHRvIGZpcmUgb3V0c2lkZSBvZiB0aGUgbG9jay5cbiAgICB0aGlzLm9uY2UoJ3VubG9jaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcERhdGEuZGVsKSB7XG4gICAgLy8gVGhlIHR5cGUgc2hvdWxkIGFsd2F5cyBleGlzdCBpbiB0aGlzIGNhc2UuIGRlbCB4IF8gPSBkZWxcbiAgICB2YXIgb2xkU25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG4gICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnZGVsJywgY29udGV4dCwgb2xkU25hcHNob3QpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCkge1xuICAgIGlmICghdGhpcy50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciBvcCA9IG9wRGF0YS5vcDtcbiAgICBcbiAgICAvLyBUaGUgY29udGV4dCBuZWVkcyB0byBiZSB0b2xkIHdlJ3JlIGFib3V0IHRvIGVkaXQsIGp1c3QgaW4gY2FzZSBpdCBuZWVkc1xuICAgIC8vIHRvIHN0b3JlIGFueSBleHRyYSBkYXRhLiAodGV4dC10cDIgaGFzIHRoaXMgY29uc3RyYWludC4pXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSB0aGlzLmVkaXRpbmdDb250ZXh0c1tpXTtcbiAgICAgIGlmIChjICE9IGNvbnRleHQgJiYgYy5fYmVmb3JlT3ApIGMuX2JlZm9yZU9wKG9wRGF0YS5vcCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdiZWZvcmUgb3AnLCBvcCwgY29udGV4dCk7XG5cbiAgICAvLyBUaGlzIGV4aXN0cyBzbyBjbGllbnRzIGNhbiBwdWxsIGFueSBuZWNlc3NhcnkgZGF0YSBvdXQgb2YgdGhlIHNuYXBzaG90XG4gICAgLy8gYmVmb3JlIGl0IGdldHMgY2hhbmdlZC4gIFByZXZpb3VzbHkgd2Uga2VwdCB0aGUgb2xkIHNuYXBzaG90IG9iamVjdCBhbmRcbiAgICAvLyBwYXNzZWQgaXQgdG8gdGhlIG9wIGV2ZW50IGhhbmRsZXIuIEhvd2V2ZXIsIGFwcGx5IG5vIGxvbmdlciBndWFyYW50ZWVzXG4gICAgLy8gdGhlIG9sZCBvYmplY3QgaXMgc3RpbGwgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBCZWNhdXNlIHRoaXMgY291bGQgYmUgdG90YWxseSB1bm5lY2Vzc2FyeSB3b3JrLCBpdHMgYmVoaW5kIGEgZmxhZy4gc2V0XG4gICAgLy8gZG9jLmluY3JlbWVudGFsIHRvIGVuYWJsZS5cbiAgICBpZiAodGhpcy5pbmNyZW1lbnRhbCAmJiB0eXBlLmluY3JlbWVudGFsQXBwbHkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0eXBlLmluY3JlbWVudGFsQXBwbHkodGhpcy5zbmFwc2hvdCwgb3AsIGZ1bmN0aW9uKG8sIHNuYXBzaG90KSB7XG4gICAgICAgIF90aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIF90aGlzLmVtaXQoJ29wJywgbywgY29udGV4dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSwgc2ltcGx5IGFwcGx5aW5nIHRoZSBvcGVyYXRpb24gdG8gdGhlIGxvY2FsIHNuYXBzaG90LlxuICAgICAgdGhpcy5zbmFwc2hvdCA9IHR5cGUuYXBwbHkodGhpcy5zbmFwc2hvdCwgb3ApO1xuICAgICAgdGhpcy5lbWl0KCdvcCcsIG9wLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgLy8gSXRzIHBvc3NpYmxlIGZvciBub25lIG9mIHRoZSBhYm92ZSBjYXNlcyB0byBtYXRjaCwgaW4gd2hpY2ggY2FzZSB0aGUgb3AgaXNcbiAgLy8gYSBuby1vcC4gVGhpcyB3aWxsIGhhcHBlbiB3aGVuIGEgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBsb2NhbGx5IGFuZFxuICAvLyByZW1vdGUgb3BzIGVkaXQgdGhlIGRvY3VtZW50LlxufTtcblxuLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIF9vdEFwcGx5LlxuRG9jLnByb3RvdHlwZS5fYWZ0ZXJPdEFwcGx5ID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0KSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgndW5sb2NrJyk7XG4gIGlmIChvcERhdGEub3ApIHtcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLmVkaXRpbmdDb250ZXh0cztcbiAgICAvLyBOb3RpZnkgYWxsIHRoZSBjb250ZXh0cyBhYm91dCB0aGUgb3AgKHdlbGwsIGFsbCB0aGUgY29udGV4dHMgZXhjZXB0XG4gICAgLy8gdGhlIG9uZSB3aGljaCBpbml0aWF0ZWQgdGhlIHN1Ym1pdCBpbiB0aGUgZmlyc3QgcGxhY2UpLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY29udGV4dHNbaV07XG4gICAgICBpZiAoYyAhPSBjb250ZXh0ICYmIGMuX29uT3ApIGMuX29uT3Aob3BEYXRhLm9wKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvbnRleHRzLnJlbW92ZSkgY29udGV4dHMuc3BsaWNlKGktLSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnYWZ0ZXIgb3AnLCBvcERhdGEub3AsIGNvbnRleHQpO1xuICB9XG59O1xuXG5cblxuLy8gKioqKiogU2VuZGluZyBvcGVyYXRpb25zXG5cblxuLy8gQWN0dWFsbHkgc2VuZCBvcCBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLl9zZW5kT3BEYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gdGhpcy5pbmZsaWdodERhdGE7XG5cbiAgaWYgKHRoaXMuYWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUgJyArIHRoaXMuYWN0aW9uICsgJyBmb3Igc2VuZE9wRGF0YScpO1xuICB0aGlzLmFjdGlvbiA9ICdzdWJtaXQnO1xuXG4gIHZhciBtc2cgPSB7YTonb3AnLCB2OnRoaXMudmVyc2lvbn07XG4gIGlmIChkLnNyYykge1xuICAgIG1zZy5zcmMgPSBkLnNyYztcbiAgICBtc2cuc2VxID0gZC5zZXE7XG4gIH1cblxuICAvLyBUaGUgc2VydmVyIGF1dG9kZXRlY3RzIHRoaXMuXG4gIC8vaWYgKHRoaXMuc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSBtc2cuZiA9IHRydWU7IC8vIGZldGNoIGludGVybWVkaWF0ZSBvcHNcblxuICBpZiAoZC5vcCkgbXNnLm9wID0gZC5vcDtcbiAgaWYgKGQuY3JlYXRlKSBtc2cuY3JlYXRlID0gZC5jcmVhdGU7XG4gIGlmIChkLmRlbCkgbXNnLmRlbCA9IGQuZGVsO1xuXG4gIG1zZy5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtc2cuZCA9IHRoaXMubmFtZTtcblxuICB0aGlzLmNvbm5lY3Rpb24uc2VuZE9wKG1zZyk7XG4gICBcbiAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugc2VuZCBhbiBvcCwgaXRzIGlkIGFuZCBzZXF1ZW5jZSBudW1iZXIgaXMgaW1wbGljaXQuXG4gIGlmICghZC5zcmMpIHtcbiAgICBkLnNyYyA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICBkLnNlcSA9IHRoaXMuY29ubmVjdGlvbi5zZXErKztcbiAgfVxufTtcblxuXG4vLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIHRvIGRvIHRoZSBhY3R1YWwgd29yayBmb3Igc3VibWl0T3AoKSwgY3JlYXRlKCkgYW5kIGRlbCgpLlxuLy9cbi8vIGNvbnRleHQgaXMgb3B0aW9uYWwuXG5Eb2MucHJvdG90eXBlLl9zdWJtaXRPcERhdGEgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIC8vY29uc29sZS5sb2coJ3N1Ym1pdCcsIEpTT04uc3RyaW5naWZ5KG9wRGF0YSksICd2PScsIHRoaXMudmVyc2lvbik7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb250ZXh0O1xuICAgIGNvbnRleHQgPSB0cnVlOyAvLyBUaGUgZGVmYXVsdCBjb250ZXh0IGlzIHRydWUuXG4gIH1cbiAgaWYgKGNvbnRleHQgPT0gbnVsbCkgY29udGV4dCA9IHRydWU7XG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIGVsc2UgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignRmFpbGVkIGF0dGVtcHQgdG8gc3VibWl0T3A6JywgZXJyKTtcbiAgfTtcblxuICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICByZXR1cm4gZXJyb3IoXCJDYW5ub3QgY2FsbCBzdWJtaXRPcCBmcm9tIGluc2lkZSBhbiAnb3AnIGV2ZW50IGhhbmRsZXJcIik7XG4gIH1cblxuICAvLyBUaGUgb3BEYXRhIGNvbnRhaW5zIGVpdGhlciBvcCwgY3JlYXRlLCBkZWxldGUsIG9yIG5vbmUgb2YgdGhlIGFib3ZlIChhIG5vLW9wKS5cblxuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBlcnJvcignRG9jdW1lbnQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQnKTtcblxuICAgIC8vIFRyeSB0byBub3JtYWxpemUgdGhlIG9wLiBUaGlzIHJlbW92ZXMgdHJhaWxpbmcgc2tpcDowJ3MgYW5kIHRoaW5ncyBsaWtlIHRoYXQuXG4gICAgaWYgKHRoaXMudHlwZS5ub3JtYWxpemUpIG9wRGF0YS5vcCA9IHRoaXMudHlwZS5ub3JtYWxpemUob3BEYXRhLm9wKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSAnZmxvYXRpbmcnO1xuICB9XG5cbiAgLy8gQWN0dWFsbHkgYXBwbHkgdGhlIG9wZXJhdGlvbiBsb2NhbGx5LlxuICB0aGlzLl9vdEFwcGx5KG9wRGF0YSwgY29udGV4dCk7XG5cbiAgLy8gSWYgdGhlIHR5cGUgc3VwcG9ydHMgY29tcG9zZXMsIHRyeSB0byBjb21wb3NlIHRoZSBvcGVyYXRpb24gb250byB0aGUgZW5kXG4gIC8vIG9mIHRoZSBsYXN0IHBlbmRpbmcgb3BlcmF0aW9uLlxuICB2YXIgZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoICYmXG4gICAgICAoZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV0sXG4gICAgICAgdHJ5Q29tcG9zZSh0aGlzLnR5cGUsIGVudHJ5LCBvcERhdGEpKSkge1xuICB9IGVsc2Uge1xuICAgIGVudHJ5ID0gb3BEYXRhO1xuICAgIG9wRGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIG9wRGF0YS5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdEYXRhLnB1c2gob3BEYXRhKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjaykgZW50cnkuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gIHRoaXMuX2FmdGVyT3RBcHBseShvcERhdGEsIGNvbnRleHQpO1xuXG4gIC8vIFRoZSBjYWxsIHRvIGZsdXNoIGlzIGluIGEgdGltZW91dCBzbyBpZiBzdWJtaXRPcCgpIGlzIGNhbGxlZCBtdWx0aXBsZVxuICAvLyB0aW1lcyBpbiBhIGNsb3N1cmUgYWxsIHRoZSBvcHMgYXJlIGNvbWJpbmVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZVxuICAvLyBzZXJ2ZXIuIEl0IGRvZXNuJ3QgbWF0dGVyIGlmIGZsdXNoIGlzIGNhbGxlZCBhIGJ1bmNoIG9mIHRpbWVzLlxuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHsgX3RoaXMuZmx1c2goKTsgfSksIDApO1xufTtcblxuXG4vLyAqKiogQ2xpZW50IE9UIGVudHJ5cG9pbnRzLlxuXG4vLyBTdWJtaXQgYW4gb3BlcmF0aW9uIHRvIHRoZSBkb2N1bWVudC4gVGhlIG9wIG11c3QgYmUgdmFsaWQgZ2l2ZW4gdGhlIGN1cnJlbnQgT1QgdHlwZS5cbkRvYy5wcm90b3R5cGUuc3VibWl0T3AgPSBmdW5jdGlvbihvcCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtvcDogb3B9LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIGRvY3VtZW50LCB3aGljaCBpbiBTaGFyZUpTIHNlbWFudGljcyBtZWFucyB0byBzZXQgaXRzIHR5cGUuIEV2ZXJ5XG4vLyBvYmplY3QgaW1wbGljaXRseSBleGlzdHMgaW4gdGhlIGRhdGFiYXNlIGJ1dCBoYXMgbm8gZGF0YSBhbmQgbm8gdHlwZS4gQ3JlYXRlXG4vLyBzZXRzIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYW5kIGNhbiBvcHRpb25hbGx5IHNldCBzb21lIGluaXRpYWwgZGF0YSBvbiB0aGVcbi8vIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlLlxuRG9jLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBjb250ZXh0IHRvIGJlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpbiB0aGlzIGNhc2Ugc28gX3N1Ym1pdE9wRGF0YVxuICAgIC8vIGNhbiBoYW5kbGUgdGhlIGRlZmF1bHQgdmFsdWUgdGhpbmcuXG4gICAgY29udGV4dCA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodGhpcy50eXBlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygnRG9jdW1lbnQgYWxyZWFkeSBleGlzdHMnKTtcbiAgICByZXR1cm4gXG4gIH1cblxuICB0aGlzLl9zdWJtaXRPcERhdGEoe2NyZWF0ZToge3R5cGU6dHlwZSwgZGF0YTpkYXRhfX0sIGNvbnRleHQsIGNhbGxiYWNrKTtcbn07XG5cbi8vIERlbGV0ZSB0aGUgZG9jdW1lbnQuIFRoaXMgY3JlYXRlcyBhbmQgc3VibWl0cyBhIGRlbGV0ZSBvcGVyYXRpb24gdG8gdGhlXG4vLyBzZXJ2ZXIuIERlbGV0aW5nIHJlc2V0cyB0aGUgb2JqZWN0J3MgdHlwZSB0byBudWxsIGFuZCBkZWxldGVzIGl0cyBkYXRhLiBUaGVcbi8vIGRvY3VtZW50IHN0aWxsIGV4aXN0cywgYW5kIHN0aWxsIGhhcyB0aGUgdmVyc2lvbiBpdCB1c2VkIHRvIGhhdmUgYmVmb3JlIHlvdVxuLy8gZGVsZXRlZCBpdCAod2VsbCwgb2xkIHZlcnNpb24gKzEpLlxuRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xuICBpZiAoIXRoaXMudHlwZSkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soJ0RvY3VtZW50IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtkZWw6IHRydWV9LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG5cbi8vIFBhdXNpbmcgc3RvcHMgdGhlIGRvY3VtZW50IGZyb20gc2VuZGluZyBhbnkgb3BlcmF0aW9ucyB0byB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdXNlZCA9IHRydWU7XG59O1xuXG5Eb2MucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG5cbi8vICoqKiBSZWNlaXZpbmcgb3BlcmF0aW9uc1xuXG5cbi8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlamVjdHMgb3VyIG9wZXJhdGlvbnMgZm9yIHNvbWUgcmVhc29uLlxuLy8gVGhlcmUncyBub3QgbXVjaCB3ZSBjYW4gZG8gaGVyZSBpZiB0aGUgT1QgdHlwZSBpcyBub25pbnZlcnRhYmxlLCBidXQgdGhhdFxuLy8gc2hvdWxkbid0IGhhcHBlbiB0b28gbXVjaCBpbiByZWFsIGxpZmUgYmVjYXVzZSByZWFkb25seSBkb2N1bWVudHMgc2hvdWxkIGJlXG4vLyBmbGFnZ2VkIGFzIHN1Y2guIChJIHNob3VsZCBwcm9iYWJseSBmaWd1cmUgb3V0IGEgZmxhZyBmb3IgdGhhdCkuXG4vL1xuLy8gVGhpcyBkb2VzIE5PVCBnZXQgY2FsbGVkIGlmIG91ciBvcCBmYWlscyB0byByZWFjaCB0aGUgc2VydmVyIGZvciBzb21lIHJlYXNvblxuLy8gLSB3ZSBvcHRpbWlzdGljYWxseSBhc3N1bWUgaXQnbGwgbWFrZSBpdCB0aGVyZSBldmVudHVhbGx5LlxuRG9jLnByb3RvdHlwZS5fdHJ5Um9sbGJhY2sgPSBmdW5jdGlvbihvcERhdGEpIHtcbiAgLy8gVGhpcyBpcyBwcm9iYWJseSBob3JyaWJseSBicm9rZW4uXG4gIGlmIChvcERhdGEuY3JlYXRlKSB7XG4gICAgdGhpcy5fc2V0VHlwZShudWxsKTtcblxuICAgIC8vIEkgZG9uJ3QgdGhpbmsgaXRzIHBvc3NpYmxlIHRvIGdldCBoZXJlIGlmIHdlIGFyZW4ndCBpbiBhIGZsb2F0aW5nIHN0YXRlLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnZmxvYXRpbmcnKVxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgZWxzZVxuICAgICAgY29uc29sZS53YXJuKCdSb2xsYmFjayBhIGNyZWF0ZSBmcm9tIHN0YXRlICcgKyB0aGlzLnN0YXRlKTtcblxuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCAmJiBvcERhdGEudHlwZS5pbnZlcnQpIHtcbiAgICB2YXIgdW5kbyA9IG9wRGF0YS50eXBlLmludmVydChvcERhdGEub3ApO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSB1bmRvIG9wZXJhdGlvbiBieSBhbnkgcGVuZGluZyBvcHMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4Zih0aGlzLnBlbmRpbmdEYXRhW2ldLCB1bmRvKTtcbiAgICB9XG5cbiAgICAvLyAuLi4gYW5kIGFwcGx5IGl0IGxvY2FsbHksIHJldmVydGluZyB0aGUgY2hhbmdlcy5cbiAgICAvLyBcbiAgICAvLyBUaGlzIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIGxvb2sgbGlrZSBpdCBjb21lcyBmcm9tIGEgcmVtb3RlIGNvbnRleHQuXG4gICAgLy8gSSdtIHN0aWxsIG5vdCAxMDAlIHN1cmUgYWJvdXQgdGhpcyBmdW5jdGlvbmFsaXR5LCBiZWNhdXNlIGl0cyByZWFsbHkgYVxuICAgIC8vIGxvY2FsIG9wLiBCYXNpY2FsbHksIHRoZSBwcm9ibGVtIGlzIHRoYXQgaWYgdGhlIGNsaWVudCdzIG9wIGlzIHJlamVjdGVkXG4gICAgLy8gYnkgdGhlIHNlcnZlciwgdGhlIGVkaXRvciB3aW5kb3cgc2hvdWxkIHVwZGF0ZSB0byByZWZsZWN0IHRoZSB1bmRvLlxuICAgIHRoaXMuX290QXBwbHkodW5kbywgZmFsc2UpO1xuICAgIHRoaXMuX2FmdGVyT3RBcHBseSh1bmRvLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAob3BEYXRhLm9wIHx8IG9wRGF0YS5kZWwpIHtcbiAgICAvLyBUaGlzIGlzIHdoZXJlIGFuIHVuZG8gc3RhY2sgd291bGQgY29tZSBpbiBoYW5keS5cbiAgICB0aGlzLl9zZXRUeXBlKG51bGwpO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIFwiT3AgYXBwbHkgZmFpbGVkIGFuZCB0aGUgb3BlcmF0aW9uIGNvdWxkIG5vdCBiZSByZXZlcnRlZFwiKTtcblxuICAgIC8vIFRyaWdnZXIgYSBmZXRjaC4gSW4gb3VyIGludmFsaWQgc3RhdGUsIHdlIGNhbid0IHJlYWxseSBkbyBhbnl0aGluZy5cbiAgICB0aGlzLmZldGNoKCk7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG5Eb2MucHJvdG90eXBlLl9jbGVhckluZmxpZ2h0T3AgPSBmdW5jdGlvbihlcnJvcikge1xuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5pbmZsaWdodERhdGEuY2FsbGJhY2tzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNhbGxiYWNrc1tpXShlcnJvciB8fCB0aGlzLmluZmxpZ2h0RGF0YS5lcnJvcik7XG4gIH1cblxuICB0aGlzLmluZmxpZ2h0RGF0YSA9IG51bGw7XG4gIHRoaXMuX2NsZWFyQWN0aW9uKCdzdWJtaXQnKTtcblxuICBpZiAoIXRoaXMucGVuZGluZ0RhdGEubGVuZ3RoKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHZlcnkgZ29vZCBuYW1lLlxuICAgIHRoaXMuZW1pdCgnbm90aGluZyBwZW5kaW5nJyk7XG4gIH1cbn07XG5cbi8vIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNlcnZlciBhY2tub3dsZWRnZXMgYW4gb3BlcmF0aW9uIGZyb20gdGhlIGNsaWVudC5cbkRvYy5wcm90b3R5cGUuX29wQWNrbm93bGVkZ2VkID0gZnVuY3Rpb24obXNnKSB7XG4gIC8vIE91ciBpbmZsaWdodCBvcCBoYXMgYmVlbiBhY2tub3dsZWRnZWQsIHNvIHdlIGNhbiB0aHJvdyBhd2F5IHRoZSBpbmZsaWdodCBkYXRhLlxuICAvLyAoV2Ugd2VyZSBvbmx5IGhvbGRpbmcgb24gdG8gaXQgaW5jYXNlIHdlIG5lZWRlZCB0byByZXNlbmQgdGhlIG9wLilcbiAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvcEFja25vd2xlZGdlZCBjYWxsZWQgZnJvbSBhIG51bGwgc3RhdGUuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4nKTtcbiAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnZmxvYXRpbmcnKSB7XG4gICAgaWYgKCF0aGlzLmluZmxpZ2h0RGF0YS5jcmVhdGUpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFja25vd2xlZGdlIGFuIG9wLicpO1xuXG4gICAgLy8gT3VyIGNyZWF0ZSBoYXMgYmVlbiBhY2tub3dsZWRnZWQuIFRoaXMgaXMgdGhlIHNhbWUgYXMgaW5qZXN0aW5nIHNvbWUgZGF0YS5cbiAgICB0aGlzLnZlcnNpb24gPSBtc2cudjtcbiAgICB0aGlzLnN0YXRlID0gJ3JlYWR5JztcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLmVtaXQoJ3JlYWR5Jyk7IH0sIDApO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhIHNuYXBzaG90LiBUaGUgc25hcHNob3Qgc2hvdWxkIGJlIGF0IHRoZSBhY2tub3dsZWRnZWRcbiAgICAvLyB2ZXJzaW9uLCBiZWNhdXNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdXMgYWxsIHRoZSBvcHMgdGhhdCBoYXZlIGhhcHBlbmVkXG4gICAgLy8gYmVmb3JlIGFja25vd2xlZGdpbmcgb3VyIG9wLlxuXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIC0gc29tZXRoaW5nIGlzIG91dCBvZiBvcmRlci5cbiAgICBpZiAobXNnLnYgIT09IHRoaXMudmVyc2lvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2ZXJzaW9uIGZyb20gc2VydmVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSwgdGhpcyBpcyBhIGJ1Zy4nKTtcbiAgfVxuICBcbiAgLy8gVGhlIG9wIHdhcyBjb21taXR0ZWQgc3VjY2Vzc2Z1bGx5LiBJbmNyZW1lbnQgdGhlIHZlcnNpb24gbnVtYmVyXG4gIHRoaXMudmVyc2lvbisrO1xuXG4gIHRoaXMuX2NsZWFySW5mbGlnaHRPcCgpO1xufTtcblxuXG4vLyBBUEkgQ29udGV4dHNcblxuLy8gVGhpcyBjcmVhdGVzIGFuZCByZXR1cm5zIGFuIGVkaXRpbmcgY29udGV4dCB1c2luZyB0aGUgY3VycmVudCBPVCB0eXBlLlxuRG9jLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlJyk7XG5cbiAgLy8gSSBjb3VsZCB1c2UgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBkbyB0aGlzIGluc3RlYWQsIGJ1dCBPYmplY3QuY3JlYXRlXG4gIC8vIGlzbid0IGRlZmluZWQgb24gb2xkIGJyb3dzZXJzLiBUaGlzIHdpbGwgYmUgZmluZS5cbiAgdmFyIGRvYyA9IHRoaXM7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2Muc25hcHNob3Q7XG4gICAgfSxcbiAgICBzdWJtaXRPcDogZnVuY3Rpb24ob3AsIGNhbGxiYWNrKSB7XG4gICAgICBkb2Muc3VibWl0T3Aob3AsIGNvbnRleHQsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGV0YWNoKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIC8vIERvbid0IGRvdWJsZS1kZXRhY2guXG4gICAgICAgIGRlbGV0ZSB0aGlzLmRldGFjaDtcbiAgICAgIH1cbiAgICAgIC8vIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhY3R1YWwgZWRpdGluZ0NvbnRleHRzIGxpc3QgbmV4dCB0aW1lXG4gICAgICAvLyB3ZSByZWNlaXZlIGFuIG9wIG9uIHRoZSBkb2N1bWVudCAoYW5kIHRoZSBsaXN0IGlzIGl0ZXJhdGVkIHRocm91Z2gpLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgcG90ZW50aWFsbHkgZG9kZ3ksIGFsbG93aW5nIGEgbWVtb3J5IGxlYWsgaWYgeW91IGNyZWF0ZSAmXG4gICAgICAvLyBkZXN0cm95IGEgd2hvbGUgYnVuY2ggb2YgY29udGV4dHMgd2l0aG91dCByZWNlaXZpbmcgb3Igc2VuZGluZyBhbnkgb3BzXG4gICAgICAvLyB0byB0aGUgZG9jdW1lbnQuXG4gICAgICBkZWxldGUgdGhpcy5fb25PcDtcbiAgICAgIHRoaXMucmVtb3ZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBpcyBkYW5nZXJvdXMsIGJ1dCByZWFsbHkgcmVhbGx5IHVzZWZ1bCBmb3IgZGVidWdnaW5nLiBJIGhvcGUgcGVvcGxlXG4gICAgLy8gZG9uJ3QgZGVwZW5kIG9uIGl0LlxuICAgIF9kb2M6IHRoaXMsXG4gIH07XG5cbiAgaWYgKHR5cGUuYXBpKSB7XG4gICAgLy8gQ29weSBldmVyeXRoaW5nIGVsc2UgZnJvbSB0aGUgdHlwZSdzIEFQSSBpbnRvIHRoZSBlZGl0aW5nIGNvbnRleHQuXG4gICAgZm9yICh2YXIgayBpbiB0eXBlLmFwaSkge1xuICAgICAgY29udGV4dFtrXSA9IHR5cGUuYXBpW2tdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnByb3ZpZGVzID0ge307XG4gIH1cblxuICB0aGlzLmVkaXRpbmdDb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuRG9jLnByb3RvdHlwZS5yZW1vdmVDb250ZXh0cyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWRpdGluZ0NvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5lZGl0aW5nQ29udGV4dHNbaV0uZGVzdHJveSgpO1xuICB9XG4gIHRoaXMuZWRpdGluZ0NvbnRleHRzLmxlbmd0aCA9IDA7XG59O1xuXG4vLyBBIENvbm5lY3Rpb24gd3JhcHMgYSBwZXJzaXN0YW50IEJDIGNvbm5lY3Rpb24gdG8gYSBzaGFyZWpzIHNlcnZlci5cbi8vXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIGNsaWVudCBzaWRlIG9mIHRoZSBwcm90b2NvbCBkZWZpbmVkIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9TaGFyZUpTL3dpa2kvV2lyZS1Qcm90b2NvbFxuLy9cbi8vIFRoZSBlcXVpdmFsZW50IHNlcnZlciBjb2RlIGlzIGluIHNyYy9zZXJ2ZXIvc2Vzc2lvbi5cbi8vXG4vLyBUaGlzIGZpbGUgaXMgYSBiaXQgb2YgYSBtZXNzLiBJJ20gZHJlYWRmdWxseSBzb3JyeSBhYm91dCB0aGF0LiBJdCBwYXNzZXMgYWxsIHRoZSB0ZXN0cyxcbi8vIHNvIEkgaGF2ZSBob3BlIHRoYXQgaXRzICpjb3JyZWN0KiBldmVuIGlmIGl0cyBub3QgY2xlYW4uXG4vL1xuLy8gVG8gbWFrZSBhIGNvbm5lY3Rpb24sIHVzZTpcbi8vICBuZXcgc2hhcmVqcy5Db25uZWN0aW9uKHNvY2tldClcbi8vXG4vLyBUaGUgc29ja2V0IHNob3VsZCBsb29rIGxpa2UgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbi4gSXQgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy8gIHNlbmQobXNnKTogU2VuZCB0aGUgZ2l2ZW4gbWVzc2FnZS4gbXNnIG1heSBiZSBhbiBvYmplY3QgLSBpZiBzbywgeW91IG1pZ2h0IG5lZWQgdG8gSlNPTi5zdHJpbmdpZnkgaXQuXG4vLyAgY2xvc2UoKTogRGlzY29ubmVjdCB0aGUgc2Vzc2lvblxuLy9cbi8vICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpe306IEV2ZW50IGhhbmRsZXIgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIGEgbWVzc2FnZSBpcyByZWNlaXZlZC4gVGhlIG1lc3NhZ2Vcbi8vICAgICBwYXNzZWQgaW4gc2hvdWxkIGFscmVhZHkgYmUgYW4gb2JqZWN0LiAoSXQgbWF5IG5lZWQgdG8gYmUgSlNPTi5wYXJzZWQpXG4vLyAgb25jbG9zZVxuLy8gIG9uZXJyb3Jcbi8vICBvbm9wZW5cbi8vICBvbmNvbm5lY3Rpbmdcbi8vXG4vLyBUaGUgc29ja2V0IHNob3VsZCBwcm9iYWJseSBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdC4gSWYgc28sIGl0IHNob3VsZCBlbWl0IHRoZSBhcHByb3ByaWF0ZSBldmVudHMgYXMgaXRcbi8vIGRpc2Nvbm5lY3RzICYgcmVjb25uZWN0cy4gKG9uY2xvc2UoKSwgb25jb25uZWN0aW5nKCksIG9ub3BlbigpKS5cblxudmFyIHR5cGVzLCBEb2M7XG5pZiAodHlwZW9mIGJyZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICB0eXBlcyA9IGJyZXF1aXJlKCdvdHR5cGVzJyk7XG4gIERvYyA9IGJyZXF1aXJlKCcuL2RvYycpLkRvYztcbiAgUXVlcnkgPSBicmVxdWlyZSgnLi9xdWVyeScpLlF1ZXJ5O1xufSBlbHNlIHtcbiAgdHlwZXMgPSB3aW5kb3cub3R0eXBlcztcbiAgRG9jID0gZXhwb3J0cy5Eb2M7XG59XG5cbnZhciBDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICB0aGlzLnNvY2tldCA9IHNvY2tldDtcblxuICAvLyBNYXAgb2YgY29sbGVjdGlvbiAtPiBkb2NOYW1lIC0+IGRvYyBvYmplY3QgZm9yIGNyZWF0ZWQgZG9jdW1lbnRzLlxuICAvLyAoY3JlYXRlZCBkb2N1bWVudHMgTVVTVCBCRSBVTklRVUUpXG4gIHRoaXMuY29sbGVjdGlvbnMgPSB7fTtcblxuICAvLyBFYWNoIHF1ZXJ5IGlzIGNyZWF0ZWQgd2l0aCBhbiBpZCB0aGF0IHRoZSBzZXJ2ZXIgdXNlcyB3aGVuIGl0IHNlbmRzIHVzXG4gIC8vIGluZm8gYWJvdXQgdGhlIHF1ZXJ5ICh1cGRhdGVzLCBldGMpLlxuICAvL3RoaXMubmV4dFF1ZXJ5SWQgPSAoTWF0aC5yYW5kb20oKSAqIDEwMDApIHwwO1xuICB0aGlzLm5leHRRdWVyeUlkID0gMTtcblxuICAvLyBNYXAgZnJvbSBxdWVyeSBJRCAtPiBxdWVyeSBvYmplY3QuXG4gIHRoaXMucXVlcmllcyA9IHt9O1xuXG4gIC8vIENvbm5lY3Rpb24gc3RhdGUuXG4gIC8vIFxuICAvLyBTdGF0ZXM6XG4gIC8vIC0gJ2Nvbm5lY3RpbmcnOiBUaGUgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCwgYnV0IHdlIGRvbid0IGhhdmUgb3VyIGNsaWVudCBJRCB5ZXRcbiAgLy8gLSAnY29ubmVjdGVkJzogV2UgaGF2ZSBjb25uZWN0ZWQgYW5kIHJlY2lldmVkIG91ciBjbGllbnQgSUQuIFJlYWR5IGZvciBkYXRhLlxuICAvLyAtICdkaXNjb25uZWN0ZWQnOiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQsIGJ1dCBpdCB3aWxsIHJlY29ubmVjdCBhdXRvbWF0aWNhbGx5LlxuICAvLyAtICdzdG9wcGVkJzogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLCBhbmQgc2hvdWxkIG5vdCByZWNvbm5lY3QuXG4gIHRoaXMuc3RhdGUgPSAoc29ja2V0LnJlYWR5U3RhdGUgPT09IDAgfHwgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpID8gJ2Nvbm5lY3RpbmcnIDogJ2Rpc2Nvbm5lY3RlZCc7XG5cbiAgLy8gVGhpcyBpcyBhIGhlbHBlciB2YXJpYWJsZSB0aGUgZG9jdW1lbnQgdXNlcyB0byBzZWUgd2hldGhlciB3ZSdyZSBjdXJyZW50bHlcbiAgLy8gaW4gYSAnbGl2ZScgc3RhdGUuIEl0IGlzIHRydWUgaWYgdGhlIHN0YXRlIGlzICdjb25uZWN0aW5nJyBvciAnY29ubmVjdGVkJy5cbiAgdGhpcy5jYW5TZW5kID0gdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnO1xuXG4gIC8vIFJlc2V0IHNvbWUgbW9yZSBzdGF0ZSB2YXJpYWJsZXMuXG4gIHRoaXMucmVzZXQoKTtcblxuICB0aGlzLmRlYnVnID0gZmFsc2U7XG4gIC8vIEknbGwgc3RvcmUgdGhlIG1vc3QgcmVjZW50IDEwMCBtZXNzYWdlcyBzbyB3aGVuIGVycm9ycyBvY2N1ciB3ZSBjYW4gc2VlIHdoYXQgaGFwcGVuZWQuXG4gIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuXG4gIHZhciBjb25uZWN0aW9uID0gdGhpcztcblxuICB2YXIgaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIC8vIFN3aXRjaCBvbiB0aGUgbWVzc2FnZSBhY3Rpb24uIE1vc3QgbWVzc2FnZXMgYXJlIGZvciBkb2N1bWVudHMgYW5kIGFyZVxuICAgIC8vIGhhbmRsZWQgaW4gdGhlIGRvYyBjbGFzcy5cbiAgICBzd2l0Y2ggKG1zZy5hKSB7XG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgLy8gQ2xpZW50IGluaXRpYWxpemF0aW9uIHBhY2tldC4gVGhpcyBidW5kbGUgb2Ygam95IGNvbnRhaW5zIG91ciBjbGllbnRcbiAgICAgICAgLy8gSUQuXG4gICAgICAgIGlmIChtc2cucHJvdG9jb2wgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbCB2ZXJzaW9uJyk7XG4gICAgICAgIGlmICh0eXBlb2YgbXNnLmlkICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2xpZW50IGlkJyk7XG5cbiAgICAgICAgY29ubmVjdGlvbi5pZCA9IG1zZy5pZDtcbiAgICAgICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncWZldGNoJzpcbiAgICAgIGNhc2UgJ3FzdWInOlxuICAgICAgY2FzZSAncSc6XG4gICAgICBjYXNlICdxdW5zdWInOlxuICAgICAgICAvLyBRdWVyeSBtZXNzYWdlLiBQYXNzIHRoaXMgdG8gdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IG9iamVjdC5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gY29ubmVjdGlvbi5xdWVyaWVzW21zZy5pZF07XG4gICAgICAgIGlmIChxdWVyeSkgcXVlcnkuX29uTWVzc2FnZShtc2cpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG9jdW1lbnQgbWVzc2FnZS4gUHVsbCBvdXQgdGhlIHJlZmVyZW5jZWQgZG9jdW1lbnQgYW5kIGZvcndhcmQgdGhlXG4gICAgICAgIC8vIG1lc3NhZ2UuXG4gICAgICAgIHZhciBjb2xsZWN0aW9uLCBkb2NOYW1lLCBkb2M7XG4gICAgICAgIGlmIChtc2cuZCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWRDb2xsZWN0aW9uID0gbXNnLmM7XG4gICAgICAgICAgZG9jTmFtZSA9IGNvbm5lY3Rpb24uX2xhc3RSZWNlaXZlZERvYyA9IG1zZy5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBtc2cuYyA9IGNvbm5lY3Rpb24uX2xhc3RSZWNlaXZlZENvbGxlY3Rpb247XG4gICAgICAgICAgZG9jTmFtZSA9IG1zZy5kID0gY29ubmVjdGlvbi5fbGFzdFJlY2VpdmVkRG9jO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jID0gY29ubmVjdGlvbi5nZXQoY29sbGVjdGlvbiwgZG9jTmFtZSk7XG4gICAgICAgIGlmICghZG9jKSB7XG4gICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoJ01lc3NhZ2UgZm9yIHVua25vd24gZG9jLiBJZ25vcmluZy4nLCBtc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5fb25NZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEF0dGFjaCBldmVudCBoYW5kbGVycyB0byB0aGUgc29ja2V0LlxuICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uZGVidWcpIGNvbnNvbGUubG9nKCdSRUNWJywgSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgY29ubmVjdGlvbi5tZXNzYWdlQnVmZmVyLnB1c2goe3Q6KG5ldyBEYXRlKCkpLnRvVGltZVN0cmluZygpLCByZWN2OkpTT04uc3RyaW5naWZ5KG1zZyl9KTtcbiAgICB3aGlsZSAoY29ubmVjdGlvbi5tZXNzYWdlQnVmZmVyLmxlbmd0aCA+IDEwMCkge1xuICAgICAgY29ubmVjdGlvbi5tZXNzYWdlQnVmZmVyLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAvLyBXZSBjb3VsZCBhbHNvIHJlc3RhcnQgdGhlIGNvbm5lY3Rpb24gaGVyZSwgYWx0aG91Z2ggdGhhdCBtaWdodCByZXN1bHRcbiAgICAgIC8vIGluIGluZmluaXRlIHJlY29ubmVjdGlvbiBidWdzLlxuICAgIH1cbiAgfVxuXG4gIHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnY29ubmVjdGluZycpO1xuICB9O1xuXG4gIHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIC8vIFRoaXMgaXNuJ3QgdGhlIHNhbWUgYXMgYSByZWd1bGFyIGVycm9yLCBiZWNhdXNlIGl0IHdpbGwgaGFwcGVuIG5vcm1hbGx5XG4gICAgLy8gZnJvbSB0aW1lIHRvIHRpbWUuIFlvdXIgY29ubmVjdGlvbiBzaG91bGQgcHJvYmFibHkgYXV0b21hdGljYWxseVxuICAgIC8vIHJlY29ubmVjdCBhbnl3YXksIGJ1dCB0aGF0IHNob3VsZCBiZSB0cmlnZ2VyZWQgb2ZmIG9uY2xvc2Ugbm90IG9uZXJyb3IuXG4gICAgLy8gKG9uY2xvc2UgaGFwcGVucyB3aGVuIG9uZXJyb3IgZ2V0cyBjYWxsZWQgYW55d2F5KS5cbiAgICBjb25uZWN0aW9uLmVtaXQoJ2Nvbm5lY3Rpb24gZXJyb3InLCBlKTtcbiAgfTtcblxuICBzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdkaXNjb25uZWN0ZWQnLCByZWFzb24pO1xuICAgIGlmIChyZWFzb24gPT09ICdDbG9zZWQnIHx8IHJlYXNvbiA9PT0gJ1N0b3BwZWQgYnkgc2VydmVyJykge1xuICAgICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ3N0b3BwZWQnLCByZWFzb24pO1xuICAgIH1cbiAgfTtcbn1cblxuLyogV2h5IGRvZXMgdGhpcyBmdW5jdGlvbiBleGlzdD8gSXMgaXQgaW1wb3J0YW50P1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLl9zZXRTdGF0ZSgnc3RvcHBlZCcsIGUpO1xuICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KGUpO1xufTtcbiovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaWQgPSB0aGlzLmxhc3RFcnJvciA9XG4gICAgdGhpcy5fbGFzdFJlY2VpdmVkQ29sbGVjdGlvbiA9IHRoaXMuX2xhc3RSZWNlaXZlZERvYyA9XG4gICAgdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uID0gdGhpcy5fbGFzdFNlbnREb2MgPSBudWxsO1xuXG4gIHRoaXMuc2VxID0gMTtcbn07XG5cbi8vIFNldCB0aGUgY29ubmVjdGlvbidzIHN0YXRlLiBUaGUgY29ubmVjdGlvbiBpcyBiYXNpY2FsbHkgYSBzdGF0ZSBtYWNoaW5lLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldFN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUsIGRhdGEpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT09IG5ld1N0YXRlKSByZXR1cm47XG5cbiAgLy8gSSBtYWRlIGEgc3RhdGUgZGlhZ3JhbS4gVGhlIG9ubHkgaW52YWxpZCB0cmFuc2l0aW9ucyBhcmUgZ2V0dGluZyB0b1xuICAvLyAnY29ubmVjdGluZycgZnJvbSBhbnl3aGVyZSBvdGhlciB0aGFuICdkaXNjb25uZWN0ZWQnIGFuZCBnZXR0aW5nIHRvXG4gIC8vICdjb25uZWN0ZWQnIGZyb20gYW55d2hlcmUgb3RoZXIgdGhhbiAnY29ubmVjdGluZycuXG4gIGlmICgobmV3U3RhdGUgPT09ICdjb25uZWN0aW5nJyAmJiAodGhpcy5zdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgdGhpcy5zdGF0ZSAhPT0gJ3N0b3BwZWQnKSlcbiAgICAgIHx8IChuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgJiYgdGhpcy5zdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFuc2l0aW9uIGRpcmVjdGx5IGZyb20gXCIgKyB0aGlzLnN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gIH1cblxuICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gIHRoaXMuY2FuU2VuZCA9IG5ld1N0YXRlID09PSAnY29ubmVjdGluZycgfHwgbmV3U3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuXG4gIGlmIChuZXdTdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHRoaXMucmVzZXQoKTtcblxuICB0aGlzLmVtaXQobmV3U3RhdGUsIGRhdGEpO1xuXG4gIC8vICYgRW1pdCB0aGUgZXZlbnQgdG8gYWxsIGRvY3VtZW50cyAmIHF1ZXJpZXMuIEl0IG1pZ2h0IG1ha2Ugc2Vuc2UgZm9yXG4gIC8vIGRvY3VtZW50cyB0byBqdXN0IHJlZ2lzdGVyIGZvciB0aGlzIHN0dWZmIHVzaW5nIGV2ZW50cywgYnV0IHRoYXQgY291cGxlc1xuICAvLyBjb25uZWN0aW9ucyBhbmQgZG9jdW1lbnRzIGEgYml0IG11Y2guIEl0cyBub3QgYSBiaWcgZGVhbCBlaXRoZXIgd2F5LlxuICB0aGlzLm9wUXVldWUgPSBbXTtcbiAgZm9yICh2YXIgYyBpbiB0aGlzLmNvbGxlY3Rpb25zKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb25zW2NdO1xuICAgIGZvciAodmFyIGRvY05hbWUgaW4gY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbltkb2NOYW1lXS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKG5ld1N0YXRlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wUXVldWUuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnNlcSAtIGIuc2VxOyB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnNlbmQodGhpcy5vcFF1ZXVlW2ldKTtcbiAgfVxuICB0aGlzLm9wUXVldWUgPSBudWxsO1xuICBcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgdGhpcy5xdWVyaWVzW2lkXS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKG5ld1N0YXRlLCBkYXRhKTtcbiAgfVxufTtcblxuLy8gU28sIHRoZXJlJ3MgYW4gYXdmdWwgZXJyb3IgY2FzZSB3aGVyZSB0aGUgY2xpZW50IHNlbmRzIHR3byByZXF1ZXN0cyAod2hpY2hcbi8vIGZhaWwpLCB0aGVuIHJlY29ubmVjdHMuIFRoZSBkb2N1bWVudHMgY291bGQgaGF2ZSBfb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4vLyBjYWxsZWQgaW4gdGhlIHdyb25nIG9yZGVyIGFuZCB0aGUgb3BlcmF0aW9ucyB0aGVuIGdldCBzZW50IHdpdGggcmV2ZXJzZWRcbi8vIHNlcXVlbmNlIG51bWJlcnMuIFRoaXMgY2F1c2VzIHRoZSBzZXJ2ZXIgdG8gaW5jb3JyZWN0bHkgcmVqZWN0IHRoZSBzZWNvbmRcbi8vIHNlbnQgb3AuIFNvIHdlIG5lZWQgdG8gcXVldWUgdGhlIG9wZXJhdGlvbnMgd2hpbGUgd2UncmUgcmVjb25uZWN0aW5nIGFuZFxuLy8gcmVzZW5kIHRoZW0gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZW5kT3AgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICh0aGlzLm9wUXVldWUpIHtcbiAgICB0aGlzLm9wUXVldWUucHVzaChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmQoZGF0YSk7XG4gIH1cbn07XG5cbi8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjb25uZWN0aW9uLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAodGhpcy5kZWJ1ZykgY29uc29sZS5sb2coXCJTRU5EXCIsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaCh7dDoobmV3IERhdGUoKSkudG9UaW1lU3RyaW5nKCksIHNlbmQ6SlNPTi5zdHJpbmdpZnkobXNnKX0pO1xuICB3aGlsZSAodGhpcy5tZXNzYWdlQnVmZmVyLmxlbmd0aCA+IDEwMCkge1xuICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xuICB9XG5cbiAgaWYgKG1zZy5kKSB7IC8vIFRoZSBkb2N1bWVudCB0aGUgbWVzc2FnZSByZWZlcnMgdG8uIE5vdCBzZXQgZm9yIHF1ZXJpZXMuXG4gICAgdmFyIGNvbGxlY3Rpb24gPSBtc2cuYztcbiAgICB2YXIgZG9jTmFtZSA9IG1zZy5kO1xuICAgIGlmIChjb2xsZWN0aW9uID09PSB0aGlzLl9sYXN0U2VudENvbGxlY3Rpb24gJiYgZG9jTmFtZSA9PT0gdGhpcy5fbGFzdFNlbnREb2MpIHtcbiAgICAgIGRlbGV0ZSBtc2cuYztcbiAgICAgIGRlbGV0ZSBtc2cuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIHRoaXMuX2xhc3RTZW50RG9jID0gZG9jTmFtZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnNvY2tldC5zZW5kKG1zZyk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgd2lsbCBjYWxsIEBzb2NrZXQub25jbG9zZSgpLCB3aGljaCBpbiB0dXJuIHdpbGwgZW1pdCB0aGUgJ2Rpc2Nvbm5lY3RlZCcgZXZlbnQuXG4gIHRoaXMuc29ja2V0LmNsb3NlKCk7XG59O1xuXG5cbi8vICoqKioqIERvY3VtZW50IG1hbmFnZW1lbnRcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0RXhpc3RpbmcgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBuYW1lKSB7XG4gIGlmICh0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25dKSByZXR1cm4gdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXVtuYW1lXTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldE9yQ3JlYXRlID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbmFtZSwgZGF0YSkge1xuICBjb25zb2xlLnRyYWNlKCdnZXRPckNyZWF0ZSBpcyBkZXByZWNhdGVkLiBVc2UgZ2V0KCkgaW5zdGVhZCcpO1xuICByZXR1cm4gdGhpcy5nZXQoY29sbGVjdGlvbiwgbmFtZSwgZGF0YSk7XG59O1xuXG4vLyBDcmVhdGUgYSBkb2N1bWVudCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBSZXR1cm5zIHRoZSBkb2N1bWVudCBzeW5jaHJvbm91c2x5LlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbmFtZSwgZGF0YSkge1xuICB2YXIgZG9jID0gdGhpcy5nZXRFeGlzdGluZyhjb2xsZWN0aW9uLCBuYW1lKTtcblxuICBpZiAoIWRvYykge1xuICAgIC8vIENyZWF0ZSBpdC5cbiAgICBkb2MgPSBuZXcgRG9jKHRoaXMsIGNvbGxlY3Rpb24sIG5hbWUpO1xuXG4gICAgdmFyIGNvbGxlY3Rpb25PYmplY3QgPSB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25dID1cbiAgICAgICh0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25dIHx8IHt9KTtcbiAgICBjb2xsZWN0aW9uT2JqZWN0W25hbWVdID0gZG9jO1xuICB9XG5cbiAgLy8gRXZlbiBpZiB0aGUgZG9jdW1lbnQgaXNuJ3QgbmV3LCBpdHMgcG9zc2libGUgdGhlIGRvY3VtZW50IHdhcyBjcmVhdGVkXG4gIC8vIG1hbnVhbGx5IGFuZCB0aGVuIHRyaWVkIHRvIGJlIHJlLWNyZWF0ZWQgd2l0aCBkYXRhIChzdXBwb3NlIGEgcXVlcnlcbiAgLy8gcmV0dXJucyB3aXRoIGRhdGEgZm9yIHRoZSBkb2N1bWVudCkuIFdlIHNob3VsZCBoeWRyYXRlIHRoZSBkb2N1bWVudFxuICAvLyBpbW1lZGlhdGVseSBpZiB3ZSBjYW4gYmVjYXVzZSB0aGUgcXVlcnkgY2FsbGJhY2sgd2lsbCBleHBlY3QgdGhlIGRvY3VtZW50XG4gIC8vIHRvIGhhdmUgZGF0YS5cbiAgaWYgKGRhdGEgJiYgZGF0YS5zbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFkb2Muc3RhdGUpIHtcbiAgICBkb2MuaW5qZXN0RGF0YShkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkb2M7XG59O1xuXG4vLyBDYWxsIGRvYy5kZXN0cm95KClcbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95RG9jID0gZnVuY3Rpb24oZG9jKSB7XG4gIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tkb2MuY29sbGVjdGlvbl07XG4gIGlmICghY29sbGVjdGlvbk9iamVjdCkgcmV0dXJuO1xuXG4gIGRlbGV0ZSBjb2xsZWN0aW9uT2JqZWN0W2RvYy5uYW1lXTtcblxuICAvLyBEZWxldGUgdGhlIGNvbGxlY3Rpb24gY29udGFpbmVyIGlmIGl0cyBlbXB0eS4gVGhpcyBjb3VsZCBiZSBhIHNvdXJjZSBvZlxuICAvLyBtZW1vcnkgbGVha3MgaWYgeW91IHNsb3dseSBtYWtlIGEgYmlsbGlvbiBjb2xsZWN0aW9ucywgd2hpY2ggeW91IHByb2JhYmx5XG4gIC8vIHdvbid0IGRvIGFueXdheSwgYnV0IHdoYXRldmVyLlxuICBpZiAoIWhhc0tleXMoY29sbGVjdGlvbk9iamVjdCkpXG4gICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNbZG9jLmNvbGxlY3Rpb25dO1xufTtcbiBcbmZ1bmN0aW9uIGhhc0tleXMob2JqZWN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAqKioqIFF1ZXJpZXMuXG5cbi8vIEhlbHBlciBmb3IgY3JlYXRlRmV0Y2hRdWVyeSBhbmQgY3JlYXRlU3Vic2NyaWJlUXVlcnksIGJlbG93LlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZVF1ZXJ5ID0gZnVuY3Rpb24odHlwZSwgY29sbGVjdGlvbiwgcSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGUgIT09ICdmZXRjaCcgJiYgdHlwZSAhPT0gJ3N1YicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1ZXJ5IHR5cGU6ICcgKyB0eXBlKTtcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGlkID0gdGhpcy5uZXh0UXVlcnlJZCsrO1xuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodHlwZSwgdGhpcywgaWQsIGNvbGxlY3Rpb24sIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgdGhpcy5xdWVyaWVzW2lkXSA9IHF1ZXJ5O1xuICBxdWVyeS5fZXhlY3V0ZSgpO1xuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vLyBJbnRlcm5hbCBmdW5jdGlvbi4gVXNlIHF1ZXJ5LmRlc3Ryb3koKSB0byByZW1vdmUgcXVlcmllcy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95UXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBkZWxldGUgdGhpcy5xdWVyaWVzW3F1ZXJ5LmlkXTtcbn07XG5cbi8vIFRoZSBxdWVyeSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczpcbi8vXG4vLyBkb2NNb2RlOiBXaGF0IHRvIGRvIHdpdGggZG9jdW1lbnRzIHRoYXQgYXJlIGluIHRoZSByZXN1bHQgc2V0LiBDYW4gYmVcbi8vICAgbnVsbC91bmRlZmluZWQgKGRlZmF1bHQpLCAnZmV0Y2gnIG9yICdzdWJzY3JpYmUnLiBGZXRjaCBtb2RlIGluZGljYXRlc1xuLy8gICB0aGF0IHRoZSBzZXJ2ZXIgc2hvdWxkIHNlbmQgZG9jdW1lbnQgc25hcHNob3RzIHRvIHRoZSBjbGllbnQgZm9yIGFsbCBxdWVyeVxuLy8gICByZXN1bHRzLiBUaGVzZSB3aWxsIGJlIGh5ZHJhdGVkIGludG8gdGhlIGRvY3VtZW50IG9iamVjdHMgYmVmb3JlIHRoZSBxdWVyeVxuLy8gICByZXN1bHQgY2FsbGJhY2tzIGFyZSByZXR1cm5lZC4gU3Vic2NyaWJlIG1vZGUgZ2V0cyBkb2N1bWVudCBzbmFwc2hvdHMgYW5kXG4vLyAgIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlcyB0aGUgY2xpZW50IHRvIGFsbCByZXN1bHRzLiBOb3RlIHRoYXQgdGhlXG4vLyAgIGRvY3VtZW50cyAqV0lMTCBOT1QqIGJlIGF1dG9tYXRpY2FsbHkgdW5zdWJzY3JpYmVkIHdoZW4gdGhlIHF1ZXJ5IGlzXG4vLyAgIGRlc3Ryb3llZC4gKFNoYXJlSlMgZG9lc24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBkbyB0aGF0IHNhZmVseSkuXG4vLyAgIEJld2FyZSBvZiBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyB0aGlzIG9wdGlvbi5cbi8vXG4vLyBwb2xsOiBGb3JjYWJseSBlbmFibGUgb3IgZGlzYWJsZSBwb2xsaW5nIG1vZGUuIFBvbGxpbmcgbW9kZSB3aWxsIHJlaXNzdWUgdGhlIHF1ZXJ5XG4vLyAgIGV2ZXJ5IHRpbWUgYW55dGhpbmcgaW4gdGhlIGNvbGxlY3Rpb24gY2hhbmdlcyAoISEpIHNvLCBpdHMgcXVpdGVcbi8vICAgZXhwZW5zaXZlLiAgSXQgaXMgYXV0b21hdGljYWxseSBlbmFibGVkIGZvciBwYWdpbmF0ZWQgYW5kIHNvcnRlZCBxdWVyaWVzLlxuLy8gICBCeSBkZWZhdWx0IHF1ZXJpZXMgcnVuIHdpdGggcG9sbGluZyBtb2RlIGRpc2FibGVkOyB3aGljaCB3aWxsIG9ubHkgY2hlY2tcbi8vICAgY2hhbmdlZCBkb2N1bWVudHMgdG8gdGVzdCBpZiB0aGV5IG5vdyBtYXRjaCB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxuLy8gICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwb2xsaW5nIG1vZGUsIG9yIHRydWUgdG8gZW5hYmxlIGl0LiBJZiB5b3UgZG9uJ3Rcbi8vICAgc3BlY2lmeSBhIHBvbGwgb3B0aW9uLCBwb2xsaW5nIG1vZGUgaXMgZW5hYmxlZCBvciBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5XG4vLyAgIGJ5IHRoZSBxdWVyeSdzIGJhY2tlbmQuXG4vL1xuLy8gYmFja2VuZDogU2V0IHRoZSBiYWNrZW5kIHNvdXJjZSBmb3IgdGhlIHF1ZXJ5LiBZb3UgY2FuIGF0dGFjaCBkaWZmZXJlbnRcbi8vICAgcXVlcnkgYmFja2VuZHMgdG8gbGl2ZWRiIGFuZCBwaWNrIHdoaWNoIG9uZSB0aGUgcXVlcnkgc2hvdWxkIGhpdCB1c2luZ1xuLy8gICB0aGlzIHBhcmFtZXRlci5cbi8vXG4vLyByZXN1bHRzOiAoZXhwZXJpbWVudGFsKSBJbml0aWFsIGxpc3Qgb2YgcmVzdWx0YW50IGRvY3VtZW50cy4gVGhpcyBpc1xuLy8gICB1c2VmdWwgZm9yIHJlaHlkcmF0aW5nIHF1ZXJpZXMgd2hlbiB5b3UncmUgdXNpbmcgYXV0b0ZldGNoIC8gYXV0b1N1YnNjcmliZVxuLy8gICBzbyB0aGUgc2VydmVyIGRvZXNuJ3QgaGF2ZSB0byBzZW5kIG92ZXIgc25hcHNob3RzIGZvciBkb2N1bWVudHMgdGhlIGNsaWVudFxuLy8gICBhbHJlYWR5IGtub3dzIGFib3V0LiBUaGlzIGlzIGV4cGVyaW1lbnRhbCAtIHRoZSBBUEkgbWF5IGNoYW5nZSBpbiB1cGNvbWluZ1xuLy8gICB2ZXJzaW9ucy5cblxuLy8gQ3JlYXRlIGEgZmV0Y2ggcXVlcnkuIEZldGNoIHF1ZXJpZXMgYXJlIG9ubHkgaXNzdWVkIG9uY2UsIHJldHVybmluZyB0aGVcbi8vIHJlc3VsdHMgZGlyZWN0bHkgaW50byB0aGUgY2FsbGJhY2suXG4vL1xuLy8gVGhlIGluZGV4IGlzIHNwZWNpZmljIHRvIHRoZSBzb3VyY2UsIGJ1dCBpZiB5b3UncmUgdXNpbmcgbW9uZ29kYiBpdCdsbCBiZVxuLy8gdGhlIGNvbGxlY3Rpb24gdG8gd2hpY2ggdGhlIHF1ZXJ5IGlzIG1hZGUuXG4vLyBUaGUgY2FsbGJhY2sgc2hvdWxkIGhhdmUgdGhlIHNpZ25hdHVyZSBmdW5jdGlvbihlcnJvciwgcmVzdWx0cywgZXh0cmFEYXRhKVxuLy8gd2hlcmUgcmVzdWx0cyBpcyBhIGxpc3Qgb2YgRG9jIG9iamVjdHMuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVGZXRjaFF1ZXJ5ID0gZnVuY3Rpb24oaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVRdWVyeSgnZmV0Y2gnLCBpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLy8gQ3JlYXRlIGEgc3Vic2NyaWJlIHF1ZXJ5LiBTdWJzY3JpYmUgcXVlcmllcyByZXR1cm4gd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4vLyB0aHJvdWdoIHRoZSBjYWxsYmFjaywgdGhlbiB1cGRhdGUgdGhlbXNlbHZlcyB3aGVuZXZlciB0aGUgcXVlcnkgcmVzdWx0IHNldFxuLy8gY2hhbmdlcyB2aWEgdGhlaXIgb3duIGV2ZW50IGVtaXR0ZXIuXG4vL1xuLy8gSWYgcHJlc2VudCwgdGhlIGNhbGxiYWNrIHNob3VsZCBoYXZlIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIGV4dHJhRGF0YSlcbi8vIHdoZXJlIHJlc3VsdHMgaXMgYSBsaXN0IG9mIERvYyBvYmplY3RzLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaWJlUXVlcnkgPSBmdW5jdGlvbihpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVF1ZXJ5KCdzdWInLCBpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuaWYgKHR5cGVvZiBicmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgTWljcm9FdmVudCA9IGJyZXF1aXJlKCcuL21pY3JvZXZlbnQnKTtcbn1cblxuTWljcm9FdmVudC5taXhpbihDb25uZWN0aW9uKTtcblxuLyogVGhpcyBjb250YWlucyB0aGUgdGV4dGFyZWEgYmluZGluZyBmb3IgU2hhcmVKUy4gVGhpcyBiaW5kaW5nIGlzIHJlYWxseVxuICogc2ltcGxlLCBhbmQgYSBiaXQgc2xvdyBvbiBiaWcgZG9jdW1lbnRzIChJdHMgTyhOKS4gSG93ZXZlciwgaXQgYnJlcXVpcmVzIG5vXG4gKiBjaGFuZ2VzIHRvIHRoZSBET00gYW5kIG5vIGhlYXZ5IGxpYnJhcmllcyBsaWtlIGFjZS4gSXQgd29ya3MgZm9yIGFueSBraW5kIG9mXG4gKiB0ZXh0IGlucHV0IGZpZWxkLlxuICpcbiAqIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSB0aGlzIGJpbmRpbmcgZm9yIHNtYWxsIGZpZWxkcyBvbiBmb3JtcyBhbmQgc3VjaC5cbiAqIEZvciBjb2RlIGVkaXRvcnMgb3IgcmljaCB0ZXh0IGVkaXRvcnMgb3Igd2hhdGV2ZXIsIEkgcmVjb21tZW5kIHNvbWV0aGluZ1xuICogaGVhdmllci5cbiAqL1xuXG5cbi8qIGFwcGx5Q2hhbmdlIGNyZWF0ZXMgdGhlIGVkaXRzIHRvIGNvbnZlcnQgb2xkdmFsIC0+IG5ld3ZhbC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgdGV4dCBlbGVtZW50IGlzIGNoYW5nZWQuXG4gKiBCZWNhdXNlIGNoYW5nZXMgYXJlIGFsd2F5cyBsb2NhbGlzZWQsIHRoZSBkaWZmaW5nIGlzIHF1aXRlIGVhc3kuIFdlIHNpbXBseVxuICogc2NhbiBpbiBmcm9tIHRoZSBzdGFydCBhbmQgc2NhbiBpbiBmcm9tIHRoZSBlbmQgdG8gaXNvbGF0ZSB0aGUgZWRpdGVkIHJhbmdlLFxuICogdGhlbiBkZWxldGUgZXZlcnl0aGluZyB0aGF0IHdhcyByZW1vdmVkICYgYWRkIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgYWRkZWQuXG4gKiBUaGlzIHdvdWxkbid0IHdvcmsgZm9yIGNvbXBsZXggY2hhbmdlcywgYnV0IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZFxuICogb24ga2V5c3Ryb2tlIC0gc28gdGhlIGVkaXRzIHdpbGwgbW9zdGx5IGp1c3QgYmUgc2luZ2xlIGNoYXJhY3RlciBjaGFuZ2VzLlxuICogU29tZXRpbWVzIHRoZXknbGwgcGFzdGUgdGV4dCBvdmVyIG90aGVyIHRleHQsIGJ1dCBldmVuIHRoZW4gdGhlIGRpZmZcbiAqIGdlbmVyYXRlZCBieSB0aGlzIGFsZ29yaXRobSBpcyBjb3JyZWN0LlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIE8oTikuIEkgc3VzcGVjdCB5b3UgY291bGQgc3BlZWQgaXQgdXAgc29tZWhvdyB1c2luZyByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG52YXIgYXBwbHlDaGFuZ2UgPSBmdW5jdGlvbihjdHgsIG9sZHZhbCwgbmV3dmFsKSB7XG4gIC8vIFN0cmluZ3MgYXJlIGltbXV0YWJsZSBhbmQgaGF2ZSByZWZlcmVuY2UgZXF1YWxpdHkuIEkgdGhpbmsgdGhpcyB0ZXN0IGlzIE8oMSksIHNvIGl0cyB3b3J0aCBkb2luZy5cbiAgaWYgKG9sZHZhbCA9PT0gbmV3dmFsKSByZXR1cm47XG5cbiAgdmFyIGNvbW1vblN0YXJ0ID0gMDtcbiAgd2hpbGUgKG9sZHZhbC5jaGFyQXQoY29tbW9uU3RhcnQpID09PSBuZXd2YWwuY2hhckF0KGNvbW1vblN0YXJ0KSkge1xuICAgIGNvbW1vblN0YXJ0Kys7XG4gIH1cblxuICB2YXIgY29tbW9uRW5kID0gMDtcbiAgd2hpbGUgKG9sZHZhbC5jaGFyQXQob2xkdmFsLmxlbmd0aCAtIDEgLSBjb21tb25FbmQpID09PSBuZXd2YWwuY2hhckF0KG5ld3ZhbC5sZW5ndGggLSAxIC0gY29tbW9uRW5kKSAmJlxuICAgICAgY29tbW9uRW5kICsgY29tbW9uU3RhcnQgPCBvbGR2YWwubGVuZ3RoICYmIGNvbW1vbkVuZCArIGNvbW1vblN0YXJ0IDwgbmV3dmFsLmxlbmd0aCkge1xuICAgIGNvbW1vbkVuZCsrO1xuICB9XG5cbiAgaWYgKG9sZHZhbC5sZW5ndGggIT09IGNvbW1vblN0YXJ0ICsgY29tbW9uRW5kKSB7XG4gICAgY3R4LnJlbW92ZShjb21tb25TdGFydCwgb2xkdmFsLmxlbmd0aCAtIGNvbW1vblN0YXJ0IC0gY29tbW9uRW5kKTtcbiAgfVxuICBpZiAobmV3dmFsLmxlbmd0aCAhPT0gY29tbW9uU3RhcnQgKyBjb21tb25FbmQpIHtcbiAgICBjdHguaW5zZXJ0KGNvbW1vblN0YXJ0LCBuZXd2YWwuc2xpY2UoY29tbW9uU3RhcnQsIG5ld3ZhbC5sZW5ndGggLSBjb21tb25FbmQpKTtcbiAgfVxufTtcblxuLy8gQXR0YWNoIGEgdGV4dGFyZWEgdG8gYSBkb2N1bWVudCdzIGVkaXRpbmcgY29udGV4dC5cbi8vXG4vLyBUaGUgY29udGV4dCBpcyBvcHRpb25hbCwgYW5kIHdpbGwgYmUgY3JlYXRlZCBmcm9tIHRoZSBkb2N1bWVudCBpZiBpdHMgbm90XG4vLyBzcGVjaWZpZWQuXG53aW5kb3cuc2hhcmVqcy5Eb2MucHJvdG90eXBlLmF0dGFjaFRleHRhcmVhID0gZnVuY3Rpb24oZWxlbSwgY3R4KSB7XG4gIGlmICghY3R4KSBjdHggPSB0aGlzLmNyZWF0ZUNvbnRleHQoKTtcblxuICBpZiAoIWN0eC5wcm92aWRlcy50ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhdHRhY2ggdG8gbm9uLXRleHQgZG9jdW1lbnQnKTtcblxuICBlbGVtLnZhbHVlID0gY3R4LmdldFRleHQoKTtcblxuICAvLyBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIHRleHQgaXMgc3RvcmVkIHNvIHdlIGNhbiBxdWlja2x5IGNoZWNrXG4gIC8vIGlmIGl0cyBiZWVuIGNoYW5nZWQgaW4gdGhlIGV2ZW50IGhhbmRsZXJzLiBUaGlzIGlzIG1vc3RseSBmb3IgYnJvd3NlcnMgb25cbiAgLy8gd2luZG93cywgd2hlcmUgdGhlIGNvbnRlbnQgY29udGFpbnMgXFxyXFxuIG5ld2xpbmVzLiBhcHBseUNoYW5nZSgpIGlzIG9ubHlcbiAgLy8gY2FsbGVkIGFmdGVyIHRoZSBcXHJcXG4gbmV3bGluZXMgYXJlIGNvbnZlcnRlZCwgYW5kIHRoYXQgY2hlY2sgaXMgcXVpdGVcbiAgLy8gc2xvdy4gU28gd2UgYWxzbyBjYWNoZSB0aGUgc3RyaW5nIGJlZm9yZSBjb252ZXJzaW9uIHNvIHdlIGNhbiBkbyBhIHF1aWNrXG4gIC8vIGNoZWNrIGluY2FzZSB0aGUgY29udmVyc2lvbiBpc24ndCBuZWVkZWQuXG4gIHZhciBwcmV2dmFsdWU7XG5cbiAgLy8gUmVwbGFjZSB0aGUgY29udGVudCBvZiB0aGUgdGV4dCBhcmVhIHdpdGggbmV3VGV4dCwgYW5kIHRyYW5zZm9ybSB0aGVcbiAgLy8gY3VycmVudCBjdXJzb3IgYnkgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgdmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24obmV3VGV4dCwgdHJhbnNmb3JtQ3Vyc29yKSB7XG4gICAgaWYgKHRyYW5zZm9ybUN1cnNvcikge1xuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IFt0cmFuc2Zvcm1DdXJzb3IoZWxlbS5zZWxlY3Rpb25TdGFydCksIHRyYW5zZm9ybUN1cnNvcihlbGVtLnNlbGVjdGlvbkVuZCldO1xuICAgIH1cblxuICAgIC8vIEZpeGF0ZSB0aGUgd2luZG93J3Mgc2Nyb2xsIHdoaWxlIHdlIHNldCB0aGUgZWxlbWVudCdzIHZhbHVlLiBPdGhlcndpc2VcbiAgICAvLyB0aGUgYnJvd3NlciBzY3JvbGxzIHRvIHRoZSBlbGVtZW50LlxuICAgIHZhciBzY3JvbGxUb3AgPSBlbGVtLnNjcm9sbFRvcDtcbiAgICBlbGVtLnZhbHVlID0gbmV3VGV4dDtcbiAgICBwcmV2dmFsdWUgPSBlbGVtLnZhbHVlOyAvLyBOb3QgZG9uZSBvbiBvbmUgbGluZSBzbyB0aGUgYnJvd3NlciBjYW4gZG8gbmV3bGluZSBjb252ZXJzaW9uLlxuICAgIGlmIChlbGVtLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wKSBlbGVtLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcblxuICAgIC8vIFNldHRpbmcgdGhlIHNlbGVjdGlvbiBtb3ZlcyB0aGUgY3Vyc29yLiBXZSdsbCBqdXN0IGhhdmUgdG8gbGV0IHlvdXJcbiAgICAvLyBjdXJzb3IgZHJpZnQgaWYgdGhlIGVsZW1lbnQgaXNuJ3QgYWN0aXZlLCB0aG91Z2ggdXN1YWxseSB1c2VycyBkb24ndFxuICAgIC8vIGNhcmUuXG4gICAgaWYgKG5ld1NlbGVjdGlvbiAmJiB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbSkge1xuICAgICAgZWxlbS5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblswXTtcbiAgICAgIGVsZW0uc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uWzFdO1xuICAgIH1cbiAgfTtcblxuICByZXBsYWNlVGV4dChjdHguZ2V0VGV4dCgpKTtcblxuXG4gIC8vICoqKiByZW1vdGUgLT4gbG9jYWwgY2hhbmdlc1xuXG4gIGN0eC5vbkluc2VydCA9IGZ1bmN0aW9uKHBvcywgdGV4dCkge1xuICAgIHZhciB0cmFuc2Zvcm1DdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgIHJldHVybiBwb3MgPCBjdXJzb3IgPyBjdXJzb3IgKyB0ZXh0Lmxlbmd0aCA6IGN1cnNvcjtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIGFueSB3aW5kb3ctc3R5bGUgbmV3bGluZSBjaGFyYWN0ZXJzLiBXaW5kb3dzIGluc2VydHMgdGhlc2UsIGFuZFxuICAgIC8vIHRoZXkgbWVzcyB1cCB0aGUgZ2VuZXJhdGVkIGRpZmYuXG4gICAgdmFyIHByZXYgPSBlbGVtLnZhbHVlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgcmVwbGFjZVRleHQocHJldi5zbGljZSgwLCBwb3MpICsgdGV4dCArIHByZXYuc2xpY2UocG9zKSwgdHJhbnNmb3JtQ3Vyc29yKTtcbiAgfTtcblxuICBjdHgub25SZW1vdmUgPSBmdW5jdGlvbihwb3MsIGxlbmd0aCkge1xuICAgIHZhciB0cmFuc2Zvcm1DdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIHRoZSBkZWxldGVkIHJlZ2lvbiwgd2Ugb25seSB3YW50IHRvIG1vdmUgYmFjayB0byB0aGUgc3RhcnRcbiAgICAgIC8vIG9mIHRoZSByZWdpb24uIEhlbmNlIHRoZSBNYXRoLm1pbi5cbiAgICAgIHJldHVybiBwb3MgPCBjdXJzb3IgPyBjdXJzb3IgLSBNYXRoLm1pbihsZW5ndGgsIGN1cnNvciAtIHBvcykgOiBjdXJzb3I7XG4gICAgfTtcblxuICAgIHZhciBwcmV2ID0gZWxlbS52YWx1ZS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgIHJlcGxhY2VUZXh0KHByZXYuc2xpY2UoMCwgcG9zKSArIHByZXYuc2xpY2UocG9zICsgbGVuZ3RoKSwgdHJhbnNmb3JtQ3Vyc29yKTtcbiAgfTtcblxuXG4gIC8vICoqKiBsb2NhbCAtPiByZW1vdGUgY2hhbmdlc1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIG9wZXJhdGlvbnMgZnJvbSB0aGUgY2hhbmdlZCBjb250ZW50IGluIHRoZSB0ZXh0YXJlYS5cbiAgdmFyIGdlbk9wID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBJbiBhIHRpbWVvdXQgc28gdGhlIGJyb3dzZXIgaGFzIHRpbWUgdG8gcHJvcG9nYXRlIHRoZSBldmVudCdzIGNoYW5nZXMgdG8gdGhlIERPTS5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVsZW0udmFsdWUgIT09IHByZXZ2YWx1ZSkge1xuICAgICAgICBwcmV2dmFsdWUgPSBlbGVtLnZhbHVlO1xuICAgICAgICBhcHBseUNoYW5nZShjdHgsIGN0eC5nZXRUZXh0KCksIGVsZW0udmFsdWUucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG5cbiAgdmFyIGV2ZW50TmFtZXMgPSBbJ3RleHRJbnB1dCcsICdrZXlkb3duJywgJ2tleXVwJywgJ3NlbGVjdCcsICdjdXQnLCAncGFzdGUnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBldmVudE5hbWVzW2ldO1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihlLCBnZW5PcCwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBlLCBnZW5PcCk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmRldGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGUgPSBldmVudE5hbWVzW2ldO1xuICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgZ2VuT3AsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGUsIGdlbk9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGN0eDtcbn07XG5cbnZhciBEb2M7XG5pZiAodHlwZW9mIGJyZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBEb2MgPSBicmVxdWlyZSgnLi9kb2MnKS5Eb2M7XG59XG5cbi8vIFF1ZXJpZXMgYXJlIGxpdmUgcmVxdWVzdHMgdG8gdGhlIGRhdGFiYXNlIGZvciBwYXJ0aWN1bGFyIHNldHMgb2YgZmllbGRzLlxuLy9cbi8vIFRoZSBzZXJ2ZXIgYWN0aXZlbHkgdGVsbHMgdGhlIGNsaWVudCB3aGVuIHRoZXJlJ3MgbmV3IGRhdGEgdGhhdCBtYXRjaGVzXG4vLyBhIHNldCBvZiBjb25kaXRpb25zLlxudmFyIFF1ZXJ5ID0gZXhwb3J0cy5RdWVyeSA9IGZ1bmN0aW9uKHR5cGUsIGNvbm5lY3Rpb24sIGlkLCBjb2xsZWN0aW9uLCBxdWVyeSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gJ2ZldGNoJyBvciAnc3ViJ1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcblxuICAvLyBUaGUgcXVlcnkgaXRzZWxmLiBGb3IgbW9uZ28sIHRoaXMgc2hvdWxkIGxvb2sgc29tZXRoaW5nIGxpa2Uge1wiZGF0YS54XCI6NX1cbiAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuXG4gIC8vIFJlc3VsdGFudCBkb2N1bWVudCBhY3Rpb24gZm9yIHRoZSBzZXJ2ZXIuIEZldGNoIG1vZGUgd2lsbCBhdXRvbWF0aWNhbGx5XG4gIC8vIGZldGNoIGFsbCByZXN1bHRzLiBTdWJzY3JpYmUgbW9kZSB3aWxsIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlIGFsbFxuICAvLyByZXN1bHRzLiBSZXN1bHRzIGFyZSBuZXZlciB1bnN1YnNjcmliZWQuXG4gIHRoaXMuZG9jTW9kZSA9IG9wdGlvbnMuZG9jTW9kZTsgLy8gdW5kZWZpbmVkLCAnZmV0Y2gnIG9yICdzdWInLlxuICBpZiAodGhpcy5kb2NNb2RlID09PSAnc3Vic2NyaWJlJykgdGhpcy5kb2NNb2RlID0gJ3N1Yic7XG5cbiAgLy8gRG8gd2UgcmVwb2xsIHRoZSBlbnRpcmUgcXVlcnkgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcz8gKEFzIG9wcG9zZWQgdG9cbiAgLy8ganVzdCBwb2xsaW5nIHRoZSBjaGFuZ2VkIGl0ZW0pLiBUaGlzIG5lZWRzIHRvIGJlIGVuYWJsZWQgdG8gYmUgYWJsZSB0byB1c2VcbiAgLy8gb3JkZXJlZCBxdWVyaWVzIChzb3J0Ynk6KSBhbmQgcGFnaW5hdGVkIHF1ZXJpZXMuIFNldCB0byB1bmRlZmluZWQsIGl0IHdpbGxcbiAgLy8gYmUgZW5hYmxlZCAvIGRpc2FibGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlIHF1ZXJ5J3MgcHJvcGVydGllcy5cbiAgdGhpcy5wb2xsID0gb3B0aW9ucy5wb2xsO1xuXG4gIC8vIFRoZSBiYWNrZW5kIHdlIGFjdHVhbGx5IGhpdC4gSWYgdGhpcyBpc24ndCBkZWZpbmVkLCBpdCBoaXRzIHRoZSBzbmFwc2hvdFxuICAvLyBkYXRhYmFzZS4gT3RoZXJ3aXNlIHRoaXMgY2FuIGJlIHVzZWQgdG8gaGl0IGFub3RoZXIgY29uZmlndXJlZCBxdWVyeVxuICAvLyBpbmRleC5cbiAgdGhpcy5iYWNrZW5kID0gb3B0aW9ucy5iYWNrZW5kIHx8IG9wdGlvbnMuc291cmNlO1xuXG4gIC8vIEEgbGlzdCBvZiByZXN1bHRpbmcgZG9jdW1lbnRzLiBUaGVzZSBhcmUgYWN0dWFsIGRvY3VtZW50cywgY29tcGxldGUgd2l0aFxuICAvLyBkYXRhIGFuZCBhbGwgdGhlIHJlc3QuIElmIGZldGNoIGlzIGZhbHNlLCB0aGVzZSBkb2N1bWVudHMgd2lsbCBub3RcbiAgLy8gaGF2ZSBhbnkgZGF0YS4gWW91IHNob3VsZCBtYW51YWxseSBjYWxsIGZldGNoKCkgb3Igc3Vic2NyaWJlKCkgb24gdGhlbS5cbiAgLy9cbiAgLy8gQ2FsbGluZyBzdWJzY3JpYmUoKSBtaWdodCBiZSBhIGdvb2QgaWRlYSBhbnl3YXksIGFzIHlvdSB3b24ndCBiZVxuICAvLyBzdWJzY3JpYmVkIHRvIHRoZSBkb2N1bWVudHMgYnkgZGVmYXVsdC5cbiAgdGhpcy5rbm93bkRvY3MgPSBvcHRpb25zLmtub3duRG9jcyB8fCBbXTtcbiAgdGhpcy5yZXN1bHRzID0gW107XG5cbiAgLy8gRG8gd2UgaGF2ZSBzb21lIGluaXRpYWwgZGF0YT9cbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuXG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbn07XG5RdWVyeS5wcm90b3R5cGUuYWN0aW9uID0gJ3FzdWInO1xuXG4vLyBIZWxwZXIgZm9yIHN1YnNjcmliZSAmIGZldGNoLCBzaW5jZSB0aGV5IHNoYXJlIHRoZSBzYW1lIG1lc3NhZ2UgZm9ybWF0LlxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gYWN0dWFsbHkgaXNzdWVzIHRoZSBxdWVyeS5cblF1ZXJ5LnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY29ubmVjdGlvbi5jYW5TZW5kKSByZXR1cm47XG5cbiAgaWYgKHRoaXMuZG9jTW9kZSkge1xuICAgIHZhciBjb2xsZWN0aW9uVmVyc2lvbnMgPSB7fTtcbiAgICAvLyBDb2xsZWN0IHRoZSB2ZXJzaW9uIG9mIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBjdXJyZW50IHJlc3VsdCBzZXQgc28gd2VcbiAgICAvLyBkb24ndCBuZWVkIHRvIGJlIHNlbnQgdGhlaXIgc25hcHNob3RzIGFnYWluLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rbm93bkRvY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmtub3duRG9jc1tpXTtcbiAgICAgIHZhciBjID0gY29sbGVjdGlvblZlcnNpb25zW2RvYy5jb2xsZWN0aW9uXSA9IGNvbGxlY3Rpb25WZXJzaW9uc1tkb2MuY29sbGVjdGlvbl0gfHwge307XG4gICAgICBjW2RvYy5uYW1lXSA9IGRvYy52ZXJzaW9uO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtc2cgPSB7XG4gICAgYTogJ3EnICsgdGhpcy50eXBlLFxuICAgIGlkOiB0aGlzLmlkLFxuICAgIGM6IHRoaXMuY29sbGVjdGlvbixcbiAgICBvOiB7fSxcbiAgICBxOiB0aGlzLnF1ZXJ5LFxuICB9O1xuXG4gIGlmICh0aGlzLmRvY01vZGUpIHtcbiAgICBtc2cuby5tID0gdGhpcy5kb2NNb2RlO1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIG9taXR0ZWQgaWYgZW1wdHksIGJ1dCB3aGF0ZXZlci5cbiAgICBtc2cuby52cyA9IGNvbGxlY3Rpb25WZXJzaW9ucztcbiAgfVxuICBpZiAodGhpcy5iYWNrZW5kICE9IG51bGwpIG1zZy5vLmIgPSB0aGlzLmJhY2tlbmQ7XG4gIGlmICh0aGlzLnBvbGwgIT09IHVuZGVmaW5lZCkgbXNnLm8ucCA9IHRoaXMucG9sbDtcblxuICB0aGlzLmNvbm5lY3Rpb24uc2VuZChtc2cpO1xufTtcblxuLy8gTWFrZSBhIGxpc3Qgb2YgZG9jdW1lbnRzIGZyb20gdGhlIGxpc3Qgb2Ygc2VydmVyLXJldHVybmVkIGRhdGEgb2JqZWN0c1xuUXVlcnkucHJvdG90eXBlLl9kYXRhVG9Eb2NzID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgbGFzdFR5cGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkb2NEYXRhID0gZGF0YVtpXTtcblxuICAgIC8vIFR5cGVzIGFyZSBvbmx5IHB1dCBpbiBmb3IgdGhlIGZpcnN0IHJlc3VsdCBpbiB0aGUgc2V0IGFuZCBldmVyeSB0aW1lIHRoZSB0eXBlIGNoYW5nZXMgaW4gdGhlIGxpc3QuXG4gICAgaWYgKGRvY0RhdGEudHlwZSkge1xuICAgICAgbGFzdFR5cGUgPSBkb2NEYXRhLnR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY0RhdGEudHlwZSA9IGxhc3RUeXBlO1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0KGRvY0RhdGEuYyB8fCB0aGlzLmNvbGxlY3Rpb24sIGRvY0RhdGEuZCwgZG9jRGF0YSk7XG4gICAgLy8gRm9yY2UgdGhlIGRvY3VtZW50IHRvIGtub3cgaXRzIHN1YnNjcmliZWQgaWYgd2UncmUgaW4gZG9jbW9kZTpzdWJzY3JpYmUuXG4gICAgaWYgKHRoaXMuZG9jTW9kZSA9PT0gJ3N1YicpIHtcbiAgICAgIGRvYy5zdWJzY3JpYmVkID0gdHJ1ZTsgLy8gU2V0IGJlZm9yZSBzZXRXYW50U3Vic2NyaWJlKCkgc28gZmx1c2ggZG9lc24ndCBzZW5kIGEgc3Vic2NyaWJlIHJlcXVlc3QuXG4gICAgICBkb2MuX3NldFdhbnRTdWJzY3JpYmUodHJ1ZSk7IC8vIHRoaXMgd2lsbCBjYWxsIGFueSBzdWJzY3JpYmUgY2FsbGJhY2tzIG9yIHdoYXRldmVyLlxuICAgICAgZG9jLmVtaXQoJ3N1YnNjcmliZScpO1xuICAgICAgZG9jLl9maW5pc2hTdWIodHJ1ZSk7IC8vIHRoaXMgZG9lc24ndCBhY3R1YWxseSBkbyBhbnl0aGluZyBoZXJlLCBidXQgaXRzIG1vcmUgY29ycmVjdCB0byBoYXZlIGl0LlxuICAgIH1cbiAgICByZXN1bHRzLnB1c2goZG9jKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIERlc3Ryb3kgdGhlIHF1ZXJ5IG9iamVjdC4gQW55IHN1YnNlcXVlbnQgbWVzc2FnZXMgZm9yIHRoZSBxdWVyeSB3aWxsIGJlXG4vLyBpZ25vcmVkIGJ5IHRoZSBjb25uZWN0aW9uLiBZb3Ugc2hvdWxkIHVuc3Vic2NyaWJlIGZyb20gdGhlIHF1ZXJ5IGJlZm9yZVxuLy8gZGVzdHJveWluZyBpdC5cblF1ZXJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCAmJiB0aGlzLnR5cGUgPT09ICdzdWInKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoe2E6J3F1bnN1YicsIGlkOnRoaXMuaWR9KTtcbiAgfVxuXG4gIHRoaXMuY29ubmVjdGlvbi5fZGVzdHJveVF1ZXJ5KHRoaXMpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uKSB7XG4gIGlmICh0aGlzLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgIHRoaXMuX2V4ZWN1dGUoKTtcbiAgfVxufTtcblxuLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBmcm9tIGNvbm5lY3Rpb24gdG8gcGFzcyBzZXJ2ZXIgbWVzc2FnZXMgdG8gdGhlIHF1ZXJ5LlxuUXVlcnkucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKChtc2cuYSA9PT0gJ3FmZXRjaCcpICE9PSAodGhpcy50eXBlID09PSAnZmV0Y2gnKSkge1xuICAgIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ0ludmFsaWQgbWVzc2FnZSBzZW50IHRvIHF1ZXJ5JywgbXNnLCB0aGlzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobXNnLmVycm9yKSB0aGlzLmVtaXQoJ2Vycm9yJywgbXNnLmVycm9yKTtcblxuICBzd2l0Y2ggKG1zZy5hKSB7XG4gICAgY2FzZSAncWZldGNoJzpcbiAgICAgIHZhciByZXN1bHRzID0gbXNnLmRhdGEgPyB0aGlzLl9kYXRhVG9Eb2NzKG1zZy5kYXRhKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB0aGlzLmNhbGxiYWNrKG1zZy5lcnJvciwgcmVzdWx0cywgbXNnLmV4dHJhKTtcbiAgICAgIC8vIE9uY2UgYSBmZXRjaCBxdWVyeSBnZXRzIGl0cyBkYXRhLCBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICB0aGlzLmNvbm5lY3Rpb24uX2Rlc3Ryb3lRdWVyeSh0aGlzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncSc6XG4gICAgICAvLyBRdWVyeSBkaWZmIGRhdGEgKGluc2VydHMgYW5kIHJlbW92ZXMpXG4gICAgICBpZiAobXNnLmRpZmYpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSBsaXN0IHR3aWNlLiBGaXJzdCwgd2UnbGwgaW5qZXN0IGFsbCB0aGVcbiAgICAgICAgLy8gbmV3IGRvY3VtZW50cyBhbmQgc2V0IHRoZW0gYXMgc3Vic2NyaWJlZC4gIEFmdGVyIHRoYXQgd2UnbGwgZW1pdFxuICAgICAgICAvLyBldmVudHMgYW5kIGFjdHVhbGx5IHVwZGF0ZSBvdXIgbGlzdC4gVGhpcyBhdm9pZHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgIC8vIGFyb3VuZCBzZXR0aW5nIGRvY3VtZW50cyB0byBiZSBzdWJzY3JpYmVkICYgdW5zdWJzY3JpYmluZyBkb2N1bWVudHNcbiAgICAgICAgLy8gaW4gZXZlbnQgY2FsbGJhY2tzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5kaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGQgPSBtc2cuZGlmZltpXTtcbiAgICAgICAgICBpZiAoZC50eXBlID09PSAnaW5zZXJ0JykgZC52YWx1ZXMgPSB0aGlzLl9kYXRhVG9Eb2NzKGQudmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZCA9IG1zZy5kaWZmW2ldO1xuICAgICAgICAgIHN3aXRjaCAoZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgICB2YXIgbmV3RG9jcyA9IGQudmFsdWVzO1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMucmVzdWx0cywgW2QuaW5kZXgsIDBdLmNvbmNhdChuZXdEb2NzKSk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnaW5zZXJ0JywgbmV3RG9jcywgZC5pbmRleCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBkLmhvd01hbnkgfHwgMTtcbiAgICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLnJlc3VsdHMuc3BsaWNlKGQuaW5kZXgsIGhvd01hbnkpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZScsIHJlbW92ZWQsIGQuaW5kZXgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICB2YXIgaG93TWFueSA9IGQuaG93TWFueSB8fCAxO1xuICAgICAgICAgICAgICB2YXIgZG9jcyA9IHRoaXMucmVzdWx0cy5zcGxpY2UoZC5mcm9tLCBob3dNYW55KTtcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLnJlc3VsdHMsIFtkLnRvLCAwXS5jb25jYXQoZG9jcykpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21vdmUnLCBkb2NzLCBkLmZyb20sIGQudG8pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5leHRyYSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2V4dHJhJywgbXNnLmV4dHJhKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3FzdWInOlxuICAgICAgLy8gVGhpcyBtZXNzYWdlIHJlcGxhY2VzIHRoZSBlbnRpcmUgcmVzdWx0IHNldCB3aXRoIHRoZSBzZXQgcGFzc2VkLlxuICAgICAgaWYgKCFtc2cuZXJyb3IpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5yZXN1bHRzO1xuXG4gICAgICAgIC8vIFRoZW4gYWRkIGV2ZXJ5dGhpbmcgaW4gdGhlIG5ldyByZXN1bHQgc2V0LlxuICAgICAgICB0aGlzLnJlc3VsdHMgPSB0aGlzLmtub3duRG9jcyA9IHRoaXMuX2RhdGFUb0RvY3MobXNnLmRhdGEpO1xuICAgICAgICB0aGlzLmV4dHJhID0gbXNnLmV4dHJhO1xuXG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHRoaXMucmVzdWx0cywgcHJldmlvdXMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhtc2cuZXJyb3IsIHRoaXMucmVzdWx0cywgdGhpcy5leHRyYSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIENoYW5nZSB0aGUgdGhpbmcgd2UncmUgc2VhcmNoaW5nIGZvci4gVGhpcyBpc24ndCBmdWxseSBzdXBwb3J0ZWQgb24gdGhlXG4vLyBiYWNrZW5kIChpdCBkZXN0cm95cyB0aGUgb2xkIHF1ZXJ5IGFuZCBtYWtlcyBhIG5ldyBvbmUpIC0gYnV0IGl0c1xuLy8gcHJvZ3JhbWF0aWNhbGx5IHVzZWZ1bCBhbmQgSSBtaWdodCBhZGQgYmFja2VuZCBzdXBwb3J0IGF0IHNvbWUgcG9pbnQuXG5RdWVyeS5wcm90b3R5cGUuc2V0UXVlcnkgPSBmdW5jdGlvbihxKSB7XG4gIGlmICh0aGlzLnR5cGUgIT09ICdzdWInKSB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjaGFuZ2UgYSBmZXRjaCBxdWVyeScpO1xuXG4gIHRoaXMucXVlcnkgPSBxO1xuICBpZiAodGhpcy5jb25uZWN0aW9uLmNhblNlbmQpIHtcbiAgICAvLyBUaGVyZSdzIG5vICdjaGFuZ2UnIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgc2VydmVyLiBKdXN0IHJlc3Vic2NyaWJlLlxuICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKHthOidxdW5zdWInLCBpZDp0aGlzLmlkfSk7XG4gICAgdGhpcy5fZXhlY3V0ZSgpO1xuICB9XG59O1xuXG52YXIgTWljcm9FdmVudDtcbmlmICh0eXBlb2YgYnJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIE1pY3JvRXZlbnQgPSBicmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59XG5cbk1pY3JvRXZlbnQubWl4aW4oUXVlcnkpO1xuXG59KSgpO1xuIl19
;